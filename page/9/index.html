<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge" >
  <title>建均笔记</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="建均笔记">
<meta property="og:url" content="http://www.uto.ink/page/9/index.html">
<meta property="og:site_name" content="建均笔记">
<meta property="og:locale">
<meta property="article:author" content="建均笔记">
<meta name="twitter:card" content="summary">
  
  <meta name="keywords" content="建均笔记">
  
  
    <link rel="alternative" href="/atom.xml" title="建均笔记" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
<link rel="stylesheet" href="/css/style.css">

<script>
(function(){
    var bp = document.createElement('script');
    bp.src = '//push.zhanzhang.baidu.com/push.js';
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>

<!-- baidu Analytics -->
<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?b5a8646d4b9e56cf6ef835a8e416f147";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
})();
</script>
<!-- End baidu Analytics -->


<link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.3.0/css/font-awesome.min.css" />
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<meta name="generator" content="Hexo 5.4.0"></head>

<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="/img/avatar.jpg" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">建均笔记</a></h1>
		</hgroup>

		
		<p class="header-subtitle">不积跬步 无以至千里</p>
		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						<div class="icon-wrap icon-link hide" data-idx="2">
							<div class="loopback_l"></div>
							<div class="loopback_r"></div>
						</div>
						
						
					</div>

				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>菜单</li>
						<li>标签</li>
						
						<li>友情链接</li>
						
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives">所有文章</a></li>
				        
							<li><a href="/about">关于我</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="https://github.com/stotem" title="github">github</a>
					        
								<a class="rss" target="_blank" href="/atom.xml" title="rss">rss</a>
					        
								<a class="mail" target="_blank" href="mailto:china.wujianjun@icloud.com" title="mail">mail</a>
					        
						</div>
						<div>
							<i class="fa fa-line-chart"></i>
							本站访问量<span id=“busuanzi_container_site_pv”><span id="busuanzi_value_site_pv"><i class="fa fa-spinner fa-spin"></i></span></span> 次
						</div>
					</nav>
				</section>

				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						<a href="/tags/Docker/" style="font-size: 15.71px;">Docker</a> <a href="/tags/Java/" style="font-size: 10px;">Java</a> <a href="/tags/Maven/" style="font-size: 11.43px;">Maven</a> <a href="/tags/MySQL/" style="font-size: 10px;">MySQL</a> <a href="/tags/Nginx/" style="font-size: 15.71px;">Nginx</a> <a href="/tags/OpenVPN/" style="font-size: 12.86px;">OpenVPN</a> <a href="/tags/Podman/" style="font-size: 11.43px;">Podman</a> <a href="/tags/Redis/" style="font-size: 11.43px;">Redis</a> <a href="/tags/Transaction/" style="font-size: 10px;">Transaction</a> <a href="/tags/cdt/" style="font-size: 10px;">cdt</a> <a href="/tags/https/" style="font-size: 10px;">https</a> <a href="/tags/iOS/" style="font-size: 17.14px;">iOS</a> <a href="/tags/linux/" style="font-size: 10px;">linux</a> <a href="/tags/nginx-obs/" style="font-size: 10px;">nginx + obs</a> <a href="/tags/php-fpm/" style="font-size: 10px;">php-fpm</a> <a href="/tags/podman/" style="font-size: 14.29px;">podman</a> <a href="/tags/redis/" style="font-size: 10px;">redis</a> <a href="/tags/rocketmq/" style="font-size: 10px;">rocketmq</a> <a href="/tags/shiro/" style="font-size: 11.43px;">shiro</a> <a href="/tags/spring/" style="font-size: 11.43px;">spring</a> <a href="/tags/springcloud/" style="font-size: 10px;">springcloud</a> <a href="/tags/tomcat/" style="font-size: 10px;">tomcat</a> <a href="/tags/transaction/" style="font-size: 10px;">transaction</a> <a href="/tags/%E5%85%B3%E9%94%AE%E7%AC%94%E8%AE%B0/" style="font-size: 10px;">关键笔记</a> <a href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F/" style="font-size: 10px;">分布式</a> <a href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/" style="font-size: 10px;">分布式事务</a> <a href="/tags/%E5%8E%9F%E5%88%9B/" style="font-size: 20px;">原创</a> <a href="/tags/%E5%A4%9A%E8%BF%9B%E7%A8%8B/" style="font-size: 10px;">多进程</a> <a href="/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/" style="font-size: 11.43px;">大数据</a> <a href="/tags/%E5%B9%B6%E5%8F%91/" style="font-size: 10px;">并发</a> <a href="/tags/%E6%80%BB%E7%BB%93/" style="font-size: 10px;">总结</a> <a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" style="font-size: 10px;">操作系统</a> <a href="/tags/%E6%9E%B6%E6%9E%84/" style="font-size: 10px;">架构</a> <a href="/tags/%E7%94%B5%E5%95%86/" style="font-size: 10px;">电商</a> <a href="/tags/%E7%AC%94%E8%AE%B0/" style="font-size: 10px;">笔记</a> <a href="/tags/%E8%BD%AC%E8%BD%BD/" style="font-size: 18.57px;">转载</a> <a href="/tags/%E9%9A%8F%E7%AC%94/" style="font-size: 10px;">随笔</a>
					</div>
				</section>
				

				
				<section class="switch-part switch-part3">
					<div id="js-friends">
					
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://andylee1988.github.io">andylee1988的博客</a><br />
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://devtll.github.io">devtll的博客</a><br />
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://esnake0.github.io">esnake0的博客</a><br />
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://www.shaofan.org">少凡的独立博客</a><br />
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://blog.csdn.net/liuguofeng719?viewmode=list">guofeng的博客</a><br />
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://witchan.com">WitChan的技术博客</a><br />
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://blog.csdn.net/kelanq">kelanQ的博客</a><br />
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://chenxinyu.work">IT古书</a><br />
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://8tool.club">KnowledgeBase</a><br />
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://cherrycheng.top">cherrycheng</a><br />
			        
			        </div>
				</section>
				

				
			</div>
		</div>

	</header>
</div>

    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">建均笔记</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
			
				<img lazy-src="/img/avatar.jpg" class="js-avatar">
			
			</div>
			<hgroup>
			  <h1 class="header-author">建均笔记</h1>
			</hgroup>
			
			<p class="header-subtitle">不积跬步 无以至千里</p>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">所有文章</a></li>
		        
					<li><a href="/about">关于我</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/stotem" title="github">github</a>
			        
						<a class="rss" target="_blank" href="/atom.xml" title="rss">rss</a>
			        
						<a class="mail" target="_blank" href="mailto:china.wujianjun@icloud.com" title="mail">mail</a>
			        
				</div>
				<div style="text-align: center;">
					<i class="fa fa-line-chart"></i>
					本站访问量<span id=“busuanzi_container_site_pv”><span id="busuanzi_value_site_pv"><i class="fa fa-spinner fa-spin"></i></span></span> 次
				</div>
			</nav>
		</header>
	</div>
</nav>

      <div class="body-wrap">
  
    <article id="post-ios-mvvm" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/04/07/ios-mvvm/" class="article-date">
  	<time datetime="2016-04-07T10:14:40.000Z" itemprop="datePublished">2016-04-07</time>
</a>
      <div class="analysis-container">
	<i class="fa fa-line-chart"></i>
	已阅读<span id=“busuanzi_container_page_pv”><span id="busuanzi_value_page_pv"><i class="fa fa-spinner fa-spin"></i></span></span> 次
</div>

    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/04/07/ios-mvvm/">iOS开发MVVM理解与总结</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
              
        <h2 id="MVC存在的问题"><a href="#MVC存在的问题" class="headerlink" title="MVC存在的问题"></a>MVC存在的问题</h2><p><img src="/images/ios-mvc.png"></p>
<h3 id="iOS概念对应"><a href="#iOS概念对应" class="headerlink" title="iOS概念对应"></a>iOS概念对应</h3><p><code>M（model）:</code> 普通Class，用于对基础数据类型的对象封装，不包含界面逻辑、业务逻辑与数据转换等功能。<br><code>V（view）:</code>  xib或storyboard，用于显示给用户的界面。<br><code>C（controller）:</code> ViewController，用户下行数据输入与上线数据显示，view跳转，数据校验等功能。</p>
<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><ol>
<li>所有的逻辑代码，数据校验，UI控制，对象转换，数据缓存等服务都存在到Controller中，造成代码过于臃肿，可读性低。</li>
<li>Controller中处理所有的任务，基本上很难多人协作完成，分工性差。</li>
<li>Controller依赖到UIKit库，让单元测试无法覆盖，功能可靠性不可预测。</li>
<li>试想，iphone程序更换成macosx程序哪些能重用？功能的重用性低。</li>
</ol>
<p>分析MVC的问题，主要还是由于Controller完成的任务过多造成，为了解决以上问题，必须让Controller进行减肥。</p>
<h2 id="MVVM"><a href="#MVVM" class="headerlink" title="MVVM"></a>MVVM</h2><p><img src="/images/ios-mvvm.png"></p>
<h3 id="iOS概念对应-1"><a href="#iOS概念对应-1" class="headerlink" title="iOS概念对应"></a>iOS概念对应</h3><p><code>M（model）:</code> 与MVC中概念一致之外，将View分为数据model与界面model。<br><code>V（view）:</code>  与MVC中概念一致之外，另外将与view连接紧密的viewcontroller划分到一起。viewcontroller只负责界面跳转、用户下行数据获取、用户上行数据绑定以及vm层的调用。<br><code>VM（view-model）:</code> 用于连接view与model层，完成界面逻辑，业务逻辑，接口调用，数据model与界面model数据转换，数据校验上行数据处理与下行数据转换，数据缓存等功能。</p>
<h2 id="另外的建议"><a href="#另外的建议" class="headerlink" title="另外的建议"></a>另外的建议</h2><p>使用<a target="_blank" rel="noopener" href="https://cocoapods.org/">CocoaPods</a>将各层分开成不同的project，由workspace融合，最终通过静态库的形式进行相互的引用。<br>这样做的好处有以下几点：</p>
<ol>
<li>代码清晰，分工明确。</li>
<li>对于代码修改后的编译为分段进行，提高了编译速度。</li>
<li>对各层的代码都可以进行版本化管理，调用者的各层代码固化调用版本，对于重构代码等过程有很大的好处。</li>
<li>由于静态库可由其它程序平台重用（iOS与MacOSX），一次编译，多次使用。</li>
</ol>
<hr>
<p><em>观点仅代表自己，期待你的留言。</em></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/iOS/" rel="tag">iOS</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%8E%9F%E5%88%9B/" rel="tag">原创</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>











  
    <article id="post-docker-install-issue" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/04/06/docker-install-issue/" class="article-date">
  	<time datetime="2016-04-06T01:55:49.000Z" itemprop="datePublished">2016-04-06</time>
</a>
      <div class="analysis-container">
	<i class="fa fa-line-chart"></i>
	已阅读<span id=“busuanzi_container_page_pv”><span id="busuanzi_value_page_pv"><i class="fa fa-spinner fa-spin"></i></span></span> 次
</div>

    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/04/06/docker-install-issue/">Docker安装问题汇总</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
              
        <h3 id="测试环境"><a href="#测试环境" class="headerlink" title="测试环境"></a>测试环境</h3><p>Centos7_x86_64</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># uname -a</span></span><br><span class="line">Linux localhost.localdomain 3.10.0-123.el7.x86_64 <span class="comment">#1 SMP Mon Jun 30 12:09:22 UTC 2014 x86_64 x86_64 x86_64 GNU/Linux</span></span><br></pre></td></tr></table></figure>
<h3 id="增加yum源"><a href="#增加yum源" class="headerlink" title="增加yum源"></a>增加yum源</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># sudo tee /etc/yum.repos.d/docker.repo &lt;&lt;-&#x27;EOF&#x27;</span></span><br><span class="line">[dockerrepo]</span><br><span class="line">name=Docker Repository</span><br><span class="line">baseurl=https://yum.dockerproject.org/repo/main/centos/<span class="variable">$releasever</span>/</span><br><span class="line">enabled=1</span><br><span class="line">gpgcheck=1</span><br><span class="line">gpgkey=https://yum.dockerproject.org/gpg</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure>
<h3 id="文件冲突"><a href="#文件冲突" class="headerlink" title="文件冲突"></a>文件冲突</h3><p>Transaction check error:<br>  file /usr/lib/systemd/system/blk-availability.service from install of device-mapper-7:1.02.107-5.el7_2.1.x86_64 conflicts with file from package lvm2-7:2.02.105-14.el7.x86_64<br>  file /usr/sbin/blkdeactivate from install of device-mapper-7:1.02.107-5.el7_2.1.x86_64 conflicts with file from package lvm2-7:2.02.105-14.el7.x86_64<br>  file /usr/share/man/man8/blkdeactivate.8.gz from install of device-mapper-7:1.02.107-5.el7_2.1.x86_64 conflicts with file from package lvm2-7:2.02.105-14.el7.x86_64</p>
<p><code>解决方法:</code> 先安装lvm2</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># sudo yum install lvm2 -y</span></span><br><span class="line">[root@localhost ~]<span class="comment"># sudo yum install docker -y</span></span><br><span class="line">[root@localhost ~]<span class="comment"># docker -v</span></span><br><span class="line">Docker version 1.10.3, build 20f81d</span><br></pre></td></tr></table></figure>
<h3 id="Docker-daemon未运行"><a href="#Docker-daemon未运行" class="headerlink" title="Docker daemon未运行"></a>Docker daemon未运行</h3><p>[root@localhost ~]# docker pull ubuntu<br>Using default tag: latest<br>Warning: failed to get default registry endpoint from daemon (Cannot connect to the Docker daemon. Is the docker daemon running on this host?). Using system default: <a target="_blank" rel="noopener" href="https://index.docker.io/v1/">https://index.docker.io/v1/</a><br>Cannot connect to the Docker daemon. Is the docker daemon running on this host?<br><code>解决方法:</code> 重启docker服务</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># service docker restart</span></span><br><span class="line">Redirecting to /bin/systemctl restart  docker.service</span><br></pre></td></tr></table></figure>
<h3 id="Docker被墙"><a href="#Docker被墙" class="headerlink" title="Docker被墙"></a>Docker被墙</h3><p>[root@localhost ~]# docker pull centos<br>Using default tag: latest<br>Pulling repository docker.io/library/centos<br>Error while pulling image: Get <a target="_blank" rel="noopener" href="https://index.docker.io/v1/repositories/library/centos/images">https://index.docker.io/v1/repositories/library/centos/images</a>: dial tcp: lookup index.docker.io on 10.28.10.166:53: no such host</p>
<p>由于docker镜像站被墙，推荐使用<a target="_blank" rel="noopener" href="https://hub.alauda.cn/">灵雀云镜像</a><br><code>解决方法:</code> pull的时候使用国内镜像地址</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># docker pull index.alauda.cn/tutum/centos</span></span><br><span class="line">Using default tag: latest</span><br><span class="line">latest: Pulling from tutum/centos</span><br><span class="line">a3ed95caeb02: Pull complete </span><br><span class="line">196355c4b639: Pull complete </span><br><span class="line">edd0a8ebcd9d: Pull complete </span><br><span class="line">8ba44ed17115: Pull complete </span><br><span class="line">69f7e70c0063: Pull complete </span><br><span class="line">54abd94c9217: Pull complete </span><br><span class="line">Digest: sha256:11bc5863ca1643f1de49962c2741c3d1feca37ef258d5dd91baa2cca9a82b5b5</span><br><span class="line">Status: Downloaded newer image <span class="keyword">for</span> index.alauda.cn/tutum/centos:latest</span><br><span class="line">[root@localhost ~]<span class="comment"># docker images</span></span><br><span class="line">REPOSITORY                     TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">index.alauda.cn/tutum/centos   latest              e90ef4c35b09        2 weeks ago         297.3 MB</span><br></pre></td></tr></table></figure>

<hr>
<p><em>观点仅代表自己，期待你的留言。</em></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Docker/" rel="tag">Docker</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%8E%9F%E5%88%9B/" rel="tag">原创</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>











  
    <article id="post-ios-local-notification" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/04/05/ios-local-notification/" class="article-date">
  	<time datetime="2016-04-05T07:16:53.000Z" itemprop="datePublished">2016-04-05</time>
</a>
      <div class="analysis-container">
	<i class="fa fa-line-chart"></i>
	已阅读<span id=“busuanzi_container_page_pv”><span id="busuanzi_value_page_pv"><i class="fa fa-spinner fa-spin"></i></span></span> 次
</div>

    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/04/05/ios-local-notification/">iOS 本地通知</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
              
        <p>为了提高用户的关注度，我们经常会推送一些新的内容给用户。ios中主要有两种推送，一种是远程通知，一种是本地通知，远程通知是和服务器端配合完成的，这里暂不说明，这篇文章主要说下本地通知。<br>本地通知是在ios4.0之后添加的，但是在ios8之后，在设置通知之前，需要先对通知进行注册，注册需要的通知类型，否则收不到响应类型的通知消息。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ios8需要注册推送</span></span><br><span class="line"><span class="keyword">if</span> ([<span class="built_in">UIApplication</span> instancesRespondToSelector:<span class="keyword">@selector</span>(registerUserNotificationSettings:)])&#123;</span><br><span class="line">    <span class="comment">//通知类型</span></span><br><span class="line">    <span class="built_in">UIUserNotificationType</span> types = <span class="built_in">UIUserNotificationTypeBadge</span> |</span><br><span class="line">    <span class="built_in">UIUserNotificationTypeSound</span> | <span class="built_in">UIUserNotificationTypeAlert</span>;</span><br><span class="line">    <span class="comment">//设置通知类型和动画</span></span><br><span class="line">    <span class="built_in">UIUserNotificationSettings</span> *mySettings =</span><br><span class="line">    [<span class="built_in">UIUserNotificationSettings</span> settingsForTypes:types categories:<span class="literal">nil</span>];</span><br><span class="line">    <span class="comment">//注册</span></span><br><span class="line">    [[<span class="built_in">UIApplication</span> sharedApplication] registerUserNotificationSettings:mySettings];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上边注册了Icon角标，声音，和警告通知，当程序第一次调用<code>registerUserNotificationSettings</code>的时候，程序会询问用户是否允许程序发送通知，在用户选择之后(不管是同意与否)，程序会异步调用<code>- (void)application:(UIApplication *)application didRegisterUserNotificationSettings:(UIUserNotificationSettings *)</code>函数。所有的注册类型都会可通过<code>currentUserNotificationSettings</code>变量获得。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UILocalNotification</span> *notification = [[<span class="built_in">UILocalNotification</span> alloc] init];</span><br><span class="line"><span class="keyword">if</span> (notification) &#123;</span><br><span class="line">    <span class="comment">//设置时区</span></span><br><span class="line">    notification.timeZone=[<span class="built_in">NSTimeZone</span> defaultTimeZone];</span><br><span class="line">    <span class="comment">//设置推送的时间点</span></span><br><span class="line">    <span class="built_in">NSDateFormatter</span> *formatter = [[<span class="built_in">NSDateFormatter</span> alloc] init];</span><br><span class="line">    [formatter setDateFormat:<span class="string">@&quot;HH:mm:ss&quot;</span>];</span><br><span class="line">    <span class="built_in">NSDate</span> *date = [formatter dateFromString:<span class="string">@&quot;09:00:00&quot;</span>];</span><br><span class="line">    notification.fireDate=date;</span><br><span class="line">    <span class="comment">//通知重复提示的单位，可以是天、周、月</span></span><br><span class="line">    notification.repeatInterval = kCFCalendarUnitDay;</span><br><span class="line">    <span class="comment">//推送的内容</span></span><br><span class="line">    notification.alertBody = <span class="string">@&quot;this is a notificaiton&quot;</span>;</span><br><span class="line">    <span class="comment">//推送声音</span></span><br><span class="line">    notification.soundName = <span class="built_in">UILocalNotificationDefaultSoundName</span>;</span><br><span class="line">    <span class="comment">//应用右上角红色图标数字</span></span><br><span class="line">    notification.applicationIconBadgeNumber = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//自定义信息</span></span><br><span class="line">    <span class="built_in">NSDictionary</span> *infoDict = [<span class="built_in">NSDictionary</span> dictionaryWithObject:<span class="string">@&quot;two&quot;</span> forKey:<span class="string">@&quot;one&quot;</span>];</span><br><span class="line">    notification.userInfo = infoDict;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">UIApplication</span> *app = [<span class="built_in">UIApplication</span> sharedApplication];</span><br><span class="line">[app scheduleLocalNotification:notification];</span><br></pre></td></tr></table></figure>
<p>本地通知是通过<code>UILocalNotification</code>类来完成的，首先需要通过fireDate设置通知的时间点，还可设置通知的内容，声音，角标数等。除此之外，用户还可通过userInfo设置自定义数据。具体可参考<a target="_blank" rel="noopener" href="https://developer.apple.com/library/ios/documentation/iPhone/Reference/UILocalNotification_Class/index.html#//apple_ref/occ/cl/UILocalNotification">UILocalNotification官方文档</a><br>当程序正在运行时，收到通知时，会调用<code>application:didReceiveLocalNotification</code>方法。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)application:(<span class="built_in">UIApplication</span> *)application didReceiveLocalNotification:(<span class="built_in">UILocalNotification</span> *)notification</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSDictionary</span> *infoDict = notification.userInfo;</span><br><span class="line">    <span class="built_in">NSString</span> *str = [infoDict objectForKey:<span class="string">@&quot;one&quot;</span>];</span><br><span class="line">    <span class="keyword">if</span> ([str isEqualToString:<span class="string">@&quot;two&quot;</span>]) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;--------yes  equal&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;--------no &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>取消通知时，可以使用<code>cancelLocalNotification</code>取消具体某个通知或者通过<code>cancelAllLocalNotifications</code>取消全部通知。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[<span class="built_in">UIApplication</span> sharedApplication] cancelAllLocalNotifications];</span><br></pre></td></tr></table></figure>
<p>如果我们添加了角标，在通知之后，角标会一直存在，当需要取消角标时，可利用下边语句</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[<span class="built_in">UIApplication</span> sharedApplication] setApplicationIconBadgeNumber:<span class="number">0</span>];</span><br></pre></td></tr></table></figure>
<p>从ios8开始，通知添加了通知动作事件，如果有注意到，我们上边的进行注册的时候categories赋值为nil，此变量就是用来添加动作事件的。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ios8需要注册推送</span></span><br><span class="line"><span class="keyword">if</span> ([<span class="built_in">UIApplication</span> instancesRespondToSelector:<span class="keyword">@selector</span>(registerUserNotificationSettings:)])&#123;</span><br><span class="line">    <span class="built_in">UIMutableUserNotificationAction</span> *acceptAction =</span><br><span class="line">    [[<span class="built_in">UIMutableUserNotificationAction</span> alloc] init];</span><br><span class="line">    acceptAction.identifier = <span class="string">@&quot;accept_action&quot;</span>; <span class="comment">//ID</span></span><br><span class="line">    acceptAction.title = <span class="string">@&quot;Accept&quot;</span>;             <span class="comment">//按钮内容</span></span><br><span class="line">    acceptAction.activationMode = <span class="built_in">UIUserNotificationActivationModeBackground</span>;</span><br><span class="line">    acceptAction.destructive = <span class="literal">NO</span>;</span><br><span class="line">    acceptAction.authenticationRequired = <span class="literal">NO</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">UIMutableUserNotificationAction</span> *cancelAction =</span><br><span class="line">    [[<span class="built_in">UIMutableUserNotificationAction</span> alloc] init];</span><br><span class="line">    cancelAction.identifier = <span class="string">@&quot;cancel_action&quot;</span>;</span><br><span class="line">    cancelAction.title=<span class="string">@&quot;Cancel&quot;</span>;</span><br><span class="line">    cancelAction.activationMode = <span class="built_in">UIUserNotificationActivationModeBackground</span>;</span><br><span class="line">    cancelAction.destructive = <span class="literal">NO</span>;</span><br><span class="line">    cancelAction.authenticationRequired = <span class="literal">NO</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// First create the category</span></span><br><span class="line">    <span class="built_in">UIMutableUserNotificationCategory</span> *inviteCategory =</span><br><span class="line">    [[<span class="built_in">UIMutableUserNotificationCategory</span> alloc] init];</span><br><span class="line">    inviteCategory.identifier = <span class="string">@&quot;INVITE_CATEGORY&quot;</span>;</span><br><span class="line">    [inviteCategory setActions:@[acceptAction, cancelAction]</span><br><span class="line">                    forContext:<span class="built_in">UIUserNotificationActionContextDefault</span>];</span><br><span class="line">    <span class="built_in">NSSet</span> *categories = [<span class="built_in">NSSet</span> setWithObject:inviteCategory];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通知类型</span></span><br><span class="line">    <span class="built_in">UIUserNotificationType</span> types = <span class="built_in">UIUserNotificationTypeBadge</span> |</span><br><span class="line">    <span class="built_in">UIUserNotificationTypeSound</span> | <span class="built_in">UIUserNotificationTypeAlert</span>;</span><br><span class="line">    <span class="built_in">UIUserNotificationSettings</span> *mySettings =</span><br><span class="line">    [<span class="built_in">UIUserNotificationSettings</span> settingsForTypes:types categories:categories];</span><br><span class="line">    <span class="comment">//注册</span></span><br><span class="line">    [[<span class="built_in">UIApplication</span> sharedApplication] registerUserNotificationSettings:mySettings];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">UILocalNotification</span> *notification = [[<span class="built_in">UILocalNotification</span> alloc] init];</span><br><span class="line"><span class="keyword">if</span> (notification) &#123;</span><br><span class="line">    <span class="comment">//时区</span></span><br><span class="line">    notification.timeZone=[<span class="built_in">NSTimeZone</span> defaultTimeZone];</span><br><span class="line">    <span class="built_in">NSDateFormatter</span> *formatter = [[<span class="built_in">NSDateFormatter</span> alloc] init];</span><br><span class="line">    [formatter setDateFormat:<span class="string">@&quot;ss&quot;</span>];</span><br><span class="line">    <span class="built_in">NSDate</span> *date = [formatter dateFromString:<span class="string">@&quot;10&quot;</span>];</span><br><span class="line">    notification.alertBody = <span class="string">@&quot;haha&quot;</span>;</span><br><span class="line">    notification.fireDate=date;</span><br><span class="line">    <span class="comment">//通知重复提示的单位，可以是天、周、月</span></span><br><span class="line">    notification.repeatInterval = kCFCalendarUnitMinute;</span><br><span class="line">    <span class="comment">//推送声音</span></span><br><span class="line">    notification.soundName = <span class="built_in">UILocalNotificationDefaultSoundName</span>;</span><br><span class="line">    <span class="comment">//应用右上角红色图标数字</span></span><br><span class="line">    notification.applicationIconBadgeNumber = <span class="number">1</span>;</span><br><span class="line">    notification.category = <span class="string">@&quot;INVITE_CATEGORY&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSDictionary</span> *infoDict = [<span class="built_in">NSDictionary</span> dictionaryWithObject:<span class="string">@&quot;two&quot;</span> forKey:<span class="string">@&quot;one&quot;</span>];</span><br><span class="line">    notification.userInfo = infoDict;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">UIApplication</span> *app = [<span class="built_in">UIApplication</span> sharedApplication];</span><br><span class="line">[app scheduleLocalNotification:notification];</span><br></pre></td></tr></table></figure>
<p>以上就是一个动作的事件的注册过程，其中用到了<code>UIMutableUserNotificationAction</code>和<code>UIMutableUserNotificationCategory</code>具体用法可参考官方文档<br><a target="_blank" rel="noopener" href="https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIMutableUserNotificationAction_class/index.html#//apple_ref/occ/cl/UIMutableUserNotificationAction">UIMutableUserNotificationAction</a><br><a target="_blank" rel="noopener" href="https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIMutableUserNotificationCategory_class/index.html#//apple_ref/occ/cl/UIMutableUserNotificationCategory">UIMutableUserNotificationCategory</a><br>这两个类，注册完之后，特别需要主意，要在本地通知中进行设置，否则没有效果。值为注册时category指定的ID</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">notification.category = <span class="string">@&quot;INVITE_CATEGORY&quot;</span>;</span><br></pre></td></tr></table></figure>
<p>这样当我们收到通知，下拉一下就可看到动作事件，有事件，就有事件的回调函数</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)application:(<span class="built_in">UIApplication</span> *)application handleActionWithIdentifier:(<span class="built_in">NSString</span> *)identifier forLocalNotification:(<span class="built_in">UILocalNotification</span> *)notification completionHandler:(<span class="keyword">void</span> (^)())completionHandler</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> ([identifier isEqualToString:<span class="string">@&quot;accept_action&quot;</span>]) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;-----accept action&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([identifier isEqualToString:<span class="string">@&quot;cancel_action&quot;</span>]) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;-----cancel action&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (completionHandler) &#123;</span><br><span class="line">        completionHandler();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过id我们就可以区分不同的动作，然后对其进行相应处理，最后调用<code>completionHandler()</code>;</p>
<hr>
<p><em>观点仅代表自己，期待你的留言。</em><br><a target="_blank" rel="noopener" href="http://zuolun.me/blog/2015/01/08/ios-ben-di-tui-song/">http://zuolun.me/blog/2015/01/08/ios-ben-di-tui-song/</a></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/iOS/" rel="tag">iOS</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%BD%AC%E8%BD%BD/" rel="tag">转载</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>











  
    <article id="post-ios-muti-task" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/04/01/ios-muti-task/" class="article-date">
  	<time datetime="2016-04-01T10:05:52.000Z" itemprop="datePublished">2016-04-01</time>
</a>
      <div class="analysis-container">
	<i class="fa fa-line-chart"></i>
	已阅读<span id=“busuanzi_container_page_pv”><span id="busuanzi_value_page_pv"><i class="fa fa-spinner fa-spin"></i></span></span> 次
</div>

    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/04/01/ios-muti-task/">iOS 7 的多任务</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
              
        <p>在 iOS 7 之前，当程序置于后台之后开发者们对他们程序所能做的事情非常有限。除了 VOIP 和基于地理位置特性以外，唯一能做的地方就是使用后台任务（background tasks）让代码可以执行几分钟。如果你想下载比较大的视频文件以便离线浏览，亦或者备份用户的照片到你的服务器上，你都仅能完成一部分工作。</p>
<p>iOS 7 添加了两个新的 API 以便你的程序可以在后台更新界面以及内容。首先是后台获取（Background Fetch），它允许你定期地从网络获取新的内容。第二个 API 就是远程通知（Remote Notifications），这是一个当事件发生时可以让推送通知主动提醒应用的新特性，这两者都为你的应用界面保持最新提供了极大的帮助。在新的后台传输服务 (Background Transfer Service) 中执行定期的任务，也允许你在进程之外可以执行网络传输（下载和上传）工作。</p>
<p>后台获取 (Background Fetch) 和远程通知 (Remote Notification) 基于简单的 ApplicationDelegate 钩子，在应用程序挂起之前的 30 秒时钟时间执行工作。它们不是用于 CPU 频繁工作或者长时间运行任务，而是用来处理长时间运行的网络请求队列，例如下载一部很大的电影，或者执行快速的内容更新。</p>
<p>对用户来说，多任务处理有一点显而易见的改变就是新的应用切换程序 (the new app switcher)，它用来呈现应用到后台时的界面快照。这些快照的存在是有一定理由的–现在你可以在后台完成工作后更新程序快照，以用来呈现新的内容。社交网络、新闻或者天气等应用现在都可以直接呈现最新的内容而不需要用户重新打开应用。我们稍后会介绍如何更新屏幕快照。</p>
<h2 id="后台获取"><a href="#后台获取" class="headerlink" title="后台获取"></a>后台获取</h2><p>后台获取是一种智能的轮询机制，它很适合需要经常更新内容的程序，像社交网络，新闻或天气的程序。为了在用户启动程序前提前触发后台获取，系统会根据用户行为唤醒应用程序。举个例子，如果用户经常在下午 1 点使用某个应用程序，系统会学习，适应并在使用周期前执行后台获取。为了减少电池使用，使用设备无线通信的所有应用的后台获取会被合并，如果你向系统报告新数据无法获取，iOS 会适应并使用此信息避免会继续获取。</p>
<p>开启后台获取的第一步是在 info plist 文件中对 <a target="_blank" rel="noopener" href="https://developer.apple.com/library/ios/documentation/general/Reference/InfoPlistKeyReference/Articles/iPhoneOSKeys.html#//apple_ref/doc/uid/TP40009252-SW22">UIBackgroundModes</a> 键指定特定的值。最简单的途径是在 Xcode 5 的 project editor 中新的 Capabilities 标签页中设置，这个标签页包含了后台模式部分，可以方便配置多任务选项。<br><img src="/images/capabilities-on-bgfetch.jpg"><br>或者，你可以手动编辑这个值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;key&gt;UIBackgroundModes&lt;/key&gt;</span><br><span class="line">&lt;array&gt;</span><br><span class="line">    &lt;string&gt;fetch&lt;/string&gt;</span><br><span class="line">&lt;/array&gt;  </span><br></pre></td></tr></table></figure>
<p>接下来，告诉 iOS 多久进行一次数据获取</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions</span><br><span class="line">&#123;</span><br><span class="line">    [application setMinimumBackgroundFetchInterval:UIApplicationBackgroundFetchIntervalMinimum];</span><br><span class="line"></span><br><span class="line">    return YES;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>iOS 默认不进行后台获取，所以你需要设置一个时间间隔，否则，你的应用程序永远不能在后台被唤醒。UIApplicationBackgroundFetchIntervalMinimum 这个值要求系统尽可能频繁地去管理你的程序到底什么时候应该被唤醒，但如果你不需要这样的话，你也应该指定一个你想要的的时间间隔。例如，一个天气的应用程序，可能只需要几个小时才更新一次，iOS 将会在后台获取之间至少等待你指定的时间间隔。</p>
<p>如果你的应用允许用户退出登录，那么就没有获取新数据的需要了，你应该把 minimumBackgroundFetchInterval 设置为 UIApplicationBackgroundFetchIntervalNever，这样可以节省资源。</p>
<p>最后一步是在应用程序委托中实现下列方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">- (void) application:(UIApplication *)application </span><br><span class="line">  performFetchWithCompletionHandler:(void (^)(UIBackgroundFetchResult))completionHandler</span><br><span class="line">&#123;</span><br><span class="line">    NSURLSessionConfiguration *sessionConfiguration = [NSURLSessionConfiguration defaultSessionConfiguration];</span><br><span class="line">    NSURLSession *session = [NSURLSession sessionWithConfiguration:sessionConfiguration];</span><br><span class="line"></span><br><span class="line">    NSURL *url = [[NSURL alloc] initWithString:@&quot;http://yourserver.com/data.json&quot;];</span><br><span class="line">    NSURLSessionDataTask *task = [session dataTaskWithURL:url </span><br><span class="line">                                        completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) &#123;</span><br><span class="line"></span><br><span class="line">        if (error) &#123;</span><br><span class="line">            completionHandler(UIBackgroundFetchResultFailed);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 解析响应/数据以决定新内容是否可用</span><br><span class="line">        BOOL hasNewData = ...</span><br><span class="line">        if (hasNewData) &#123;</span><br><span class="line">            completionHandler(UIBackgroundFetchResultNewData);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            completionHandler(UIBackgroundFetchResultNoData);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line">    // 开始任务</span><br><span class="line">    [task resume];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>系统唤醒应用程序后将会执行这个委托方法。需要注意的是，你只有 30 秒的时间来确定获取的新内容是否可用，然后处理新内容并更新界面。30 秒时间应该足够去从网络获取数据和获取界面的缩略图，但是最多只有 30 秒。当完成了网络请求和更新界面后，你应该执行完成的回调。</p>
<p>完成回调的执行有两个目的。首先，系统会估量你的进程消耗的电量，并根据你传递的 UIBackgroundFetchResult 参数记录新数据是否可用。其次，当你调用完成的处理代码时，应用的界面缩略图会被采用，并更新应用程序切换器。当用户在应用间切换时，用户将会看到新内容。这种通过 completion handler 来报告并且生成截图的方法，在新的多任务处理 API 中是很常见的。</p>
<p>在实际应用中，你应该将 completionHandler 传递到应用程序的子组件，然后在处理完数据和更新界面后调用。</p>
<p>在这里，你可能想知道 iOS 是如何在应用程序后台运行时获得界面截图的，并且想知道应用程序的生命周期与后台获取之间有什么关系。如果应用程序处于挂起状态，系统会先唤醒应用，然后再调用 application: performFetchWithCompletionHandler:。如果应用程序还没有启动，系统将会启动它，然后调用常见的委托方法，包括 application: didFinishLaunchingWithOptions:。你可以把这种应用程序运行的方式想像为用户从 Springboard 启动这个程序，区别仅仅在于界面是看不见的，在屏幕外渲染的。</p>
<p>大多数情况下，无论应用在后台启动或者在前台，你会执行相同的工作，但你可以通过查看 UIApplication 的 applicationState 属性来判断应用是不是从后台启动。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions</span><br><span class="line">&#123;</span><br><span class="line">    NSLog(@&quot;Launched in background %d&quot;, UIApplicationStateBackground == application.applicationState);</span><br><span class="line"></span><br><span class="line">    return YES;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="测试后台数据获取"><a href="#测试后台数据获取" class="headerlink" title="测试后台数据获取"></a>测试后台数据获取</h2><p>有两种可以模拟后台获取的途径。最简单是从 Xcode 运行你的应用，当应用运行时，在 Xcode 的 Debug 菜单选择 Simulate Background Fetch.</p>
<p>第二种方法，使用 scheme 更改 Xcode 运行程序的方式。在 Xcode 菜单的 Product 选项，选择 Scheme 然后选择 Manage Schemes。在这里，你可以编辑或者添加一个新的 scheme，然后选中 Launch due to a background fetch event 。如下图：<br><img src="/images/edit-scheme-simulate-background-fetch.png"></p>
<h2 id="远程通知"><a href="#远程通知" class="headerlink" title="远程通知"></a>远程通知</h2><p>远程通知允许你在重要事件发生时，告知你的应用。你可能需要发送新的即时信息，突发新闻的提醒，或者用户喜爱电视的最新剧集已经可以下载以便离线观看的消息。远程通知很适合用于那些偶尔出现，但却很重要的内容，如果使用后台获取模式中在两次获取间需要等待的时间是不可接受的话，远程通知会是一个不错的选择。远程通知会比后台获取更有效率，因为应用程序只有在需要的时候才会启动。</p>
<p>一条远程通知实际上只是一条普通的带有 content-available 标志的推送通知。你可以发送一条带有提醒信息的推送去告诉用户有事请发生了，同时在后台对界面进行更新。但远程通知也可以做到在安静地，没有提醒消息或者任何声音的情况下，只去更新应用界面或者触发后台工作。然后你可以在完成下载或者处理完新内容后，发送一条本地通知。</p>
<p>静默的推送通知有速度限制，所以你可以大胆地根据应用程序的需要发送尽可能多的通知。iOS 和苹果推送服务会控制推送通知多久被递送，发送很多推送通知是没有问题的。如果你的推送通知达到了限制，推送通知可能会被延迟，直到设备下次发送保持活动状态的数据包，或者收到另外一个通知。</p>
<h2 id="发送远程通知"><a href="#发送远程通知" class="headerlink" title="发送远程通知"></a>发送远程通知</h2><p>要发送一条远程通知，需要在推送通知的有效负载（payload）设置 content－available 标志。content-available 标志和用来通知 报刊应用（Newsstand）的健值是一样的，因此，大多数推送脚本和库都已经支持远程通知。当你发送一条远程通知时，你可能还想要包含一些通知有效负载中的数据，让你应用程序可以引用事件。这可以为你节省一些网络请求，并提高应用程序的响应度。</p>
<p>我建议在开发的时候，使用 <a target="_blank" rel="noopener" href="http://nomad-cli.com/#houston">Nomad CLI’s Houston</a> 工具发送推送消息，当然你也可以使用你喜欢的库或脚本。</p>
<p>你可以通过 nomad-cli ruby gem 来安装 Houston</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gem install nomad-cli</span><br></pre></td></tr></table></figure>
<p>然后通过包含在 Nomad 的 apn 实用工具发送一条通知：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># Send a Push Notification to your Device</span><br><span class="line">apn push &lt;device token&gt; -c /path/to/key-cert.pem -n -d content-id=42</span><br></pre></td></tr></table></figure>
<p>在这里，-n 标志指定应该包含 content-available 健值，-d 标志允许添加我们自定义的数据健值到有效负荷。</p>
<p>通知的有效负荷（payload）结果和下面类似：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;aps&quot; : &#123;</span><br><span class="line">        &quot;content-available&quot; : 1</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;content-id&quot; : 42</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>iOS 7 添加了一个新的应用程序委托方法，当接收到一条带有 content－available 的推送通知时，下面的方法会被调用：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- (void)application:(UIApplication *)application </span><br><span class="line">  didReceiveRemoteNotification:(NSDictionary *)userInfo </span><br><span class="line">        fetchCompletionHandler:(void (^)(UIBackgroundFetchResult))completionHandler</span><br><span class="line">&#123;</span><br><span class="line">    NSLog(@&quot;Remote Notification userInfo is %@&quot;, userInfo);</span><br><span class="line"></span><br><span class="line">    NSNumber *contentID = userInfo[@&quot;content-id&quot;];</span><br><span class="line">    // 根据 content ID 进行操作</span><br><span class="line">    completionHandler(UIBackgroundFetchResultNewData);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>和后台抓取一样，应用程序进入后台启动，也有 30 秒的时间去获取新内容并更新界面，最后调用完成的处理代码。我们可以像后台获取那样，执行快速的网络请求，但我们可以使用新的强大的后台传输服务，处理任务队列，下面看看我们如何在任务完成后更新界面。</p>
<h2 id="NSURLSession-和-后台传输服务（Background-Transfer-Service）"><a href="#NSURLSession-和-后台传输服务（Background-Transfer-Service）" class="headerlink" title="NSURLSession 和 后台传输服务（Background Transfer Service）"></a>NSURLSession 和 后台传输服务（Background Transfer Service）</h2><p>NSURLSession 是 iOS 7 添加的一个新类，它也是 Foundation networking 中的新技术。作为 NSURLConnection 的替代品，一些熟悉的概念和类都保留下来了，例如 NSURL，NSURLRequest 和 NSURLResponse。所以，你可以使用 NSURLSessionTask 这一 NSURLConnection 的替代品，来处理网络请求及响应。一共有 3 种会话任务：数据，下载和上传。每一种都向 NSURLSessionTask 添加了语法糖，根据你的需要，适当选择一种。</p>
<p>一个 NSURLSession 对象协调一个或多个 NSURLSessionTask 对象，并根据 NSURLSessionTask 创建的 NSURLSessionConfiguration 实现不同的功能。使用相同的配置，你也可以创建多组具有相关任务的 NSURLSession 对象。要利用后台传输服务，你将会使用 [NSURLSessionConfiguration backgroundSessionConfiguration] 来创建一个会话配置。添加到后台会话的任务在外部进程运行，即使应用程序被挂起，崩溃，或者被杀死，它依然会运行。</p>
<p>NSURLSessionConfiguration 允许你设置默认的 HTTP 头，配置缓存策略，限制使用蜂窝数据等等。其中一个选项是 discretionary 标志，这个标志允许系统为分配任务进行性能优化。这意味着只有当设备有足够电量时，设备才通过 Wifi 进行数据传输。如果电量低，或者只仅有一个蜂窝连接，传输任务是不会运行的。后台传输总是在 discretionary 模式下运行。</p>
<p>目前为止，我们大概了解了 NSURLSession，以及一个后台会话如何进行，接下来，让我们回到远程通知的例子，添加一些代码来处理后台传输服务的下载队列。当下载完成后，我们会通知用户该文件已经可以使用了。</p>
<h2 id="NSURLSessionDownloadTask"><a href="#NSURLSessionDownloadTask" class="headerlink" title="NSURLSessionDownloadTask"></a>NSURLSessionDownloadTask</h2><p>首先，我们先处理一条远程通知，并把一个 NSURLSessionDownloadTask 添加到后台传输服务的队列。在 backgroundURLSession 方法中，我们根据后台会话配置，创建一个 NSURLSession 对象，并把 application delegate 作为会话的委托对象。文档不建议对于相同的标识符 (identifier) 创建多个会话对象，所以我们使用 dispatch_once 来避免潜在的问题：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">- (NSURLSession *)backgroundURLSession</span><br><span class="line">&#123;</span><br><span class="line">    static NSURLSession *session = nil;</span><br><span class="line">    static dispatch_once_t onceToken;</span><br><span class="line">    dispatch_once(&amp;onceToken, ^&#123;</span><br><span class="line">        NSString *identifier = @&quot;io.objc.backgroundTransferExample&quot;;</span><br><span class="line">        NSURLSessionConfiguration* sessionConfig = [NSURLSessionConfiguration backgroundSessionConfiguration:identifier];</span><br><span class="line">        session = [NSURLSession sessionWithConfiguration:sessionConfig </span><br><span class="line">                                                delegate:self </span><br><span class="line">                                           delegateQueue:[NSOperationQueue mainQueue]];</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    return session;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)           application:(UIApplication *)application </span><br><span class="line">  didReceiveRemoteNotification:(NSDictionary *)userInfo </span><br><span class="line">        fetchCompletionHandler:(void (^)(UIBackgroundFetchResult))completionHandler</span><br><span class="line">&#123;</span><br><span class="line">    NSLog(@&quot;Received remote notification with userInfo %@&quot;, userInfo);</span><br><span class="line"></span><br><span class="line">    NSNumber *contentID = userInfo[@&quot;content-id&quot;];</span><br><span class="line">    NSString *downloadURLString = [NSString stringWithFormat:@&quot;http://yourserver.com/downloads/%d.mp3&quot;, [contentID intValue]];</span><br><span class="line">    NSURL* downloadURL = [NSURL URLWithString:downloadURLString];</span><br><span class="line"></span><br><span class="line">    NSURLRequest *request = [NSURLRequest requestWithURL:downloadURL];</span><br><span class="line">    NSURLSessionDownloadTask *task = [[self backgroundURLSession] downloadTaskWithRequest:request];</span><br><span class="line">    task.taskDescription = [NSString stringWithFormat:@&quot;Podcast Episode %d&quot;, [contentID intValue]];</span><br><span class="line">    [task resume];</span><br><span class="line"></span><br><span class="line">    completionHandler(UIBackgroundFetchResultNewData);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们使用 NSURLSession 类方法创建一个下载任务，配置请求，并提供说明供以后使用。因为所有会话任务一开始处于挂起状态，你必须谨记要调用 [task resume] 保证开始了任务。</p>
<p>现在，我们需要实现 NSURLSessionDownloadDelegate 的委托方法，当下载完成时，调用回调函数。如果你需要处理认证或会话生命周期的其他事件，你可能还需要实现 NSURLSessionDelegate 或 NSURLSessionTaskDelegate 的方法。你应该阅读 Apple 的 <a target="_blank" rel="noopener" href="https://developer.apple.com/library/ios/documentation/cocoa/Conceptual/URLLoadingSystem/NSURLSessionConcepts/NSURLSessionConcepts.html#//apple_ref/doc/uid/10000165i-CH2-SW42">Life Cycle of a URL Session with Custom Delegates</a> 文档，它讲解了所有类型的会话任务的完整生命周期。</p>
<p>NSURLSessionDownloadDelegate 中的委托方法全部是必须实现的，尽管在这个例子中我们只需要用到 [NSURLSession downloadTask:didFinishDownloadingToURL:]。任务完成下载时，你会得到一个磁盘上该文件的临时 URL。你必须把这个文件移动或复制你的应用程序空间，因为当你从这个委托方法返回时，该文件将从临时存储中删除。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">#Pragma Mark - NSURLSessionDownloadDelegate</span><br><span class="line"></span><br><span class="line">- (void)         URLSession:(NSURLSession *)session </span><br><span class="line">               downloadTask:(NSURLSessionDownloadTask *)downloadTask</span><br><span class="line">  didFinishDownloadingToURL:(NSURL *)location</span><br><span class="line">&#123;</span><br><span class="line">    NSLog(@&quot;downloadTask:%@ didFinishDownloadingToURL:%@&quot;, downloadTask.taskDescription, location);</span><br><span class="line"></span><br><span class="line">    // 用 NSFileManager 将文件复制到应用的存储中</span><br><span class="line">    // ...</span><br><span class="line"></span><br><span class="line">    // 通知 UI 刷新</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)  URLSession:(NSURLSession *)session </span><br><span class="line">        downloadTask:(NSURLSessionDownloadTask *)downloadTask </span><br><span class="line">   didResumeAtOffset:(int64_t)fileOffset </span><br><span class="line">  expectedTotalBytes:(int64_t)expectedTotalBytes</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)         URLSession:(NSURLSession *)session </span><br><span class="line">               downloadTask:(NSURLSessionDownloadTask *)downloadTask </span><br><span class="line">               didWriteData:(int64_t)bytesWritten totalBytesWritten:(int64_t)totalBytesWritten </span><br><span class="line">  totalBytesExpectedToWrite:(int64_t)totalBytesExpectedToWrite</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当后台会话任务完成时，如果你的应用程序仍然在前台运行，上面的代码已经足够了。然而，在大多数情况下，你的应用程序可能是没有运行的，或者在后台被挂起。在这些情况下，你必须实现应用程序委托的两个方法，这样系统就可以唤醒你的应用程序。不同于以往的委托回调，该应用程序委托会被调用两次，因为您的会话和任务委托可能会收到一系列消息。app delegate 的：handleEventsForBackgroundURLSession： 方法会在这些 NSURLSession 委托的消息发送前被调用，然后，URLSessionDidFinishEventsForBackgroundURLSession 在随后被调用。在前面的方法中，包含了一个后台完成的回调（completionHandler），并在后面的方法中执行回调以便更新界面:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">- (void)                  application:(UIApplication *)application </span><br><span class="line">  handleEventsForBackgroundURLSession:(NSString *)identifier completionHandler:(void (^)())completionHandler</span><br><span class="line">&#123;</span><br><span class="line">    // 你必须重新建立一个后台 seesiong 的参照</span><br><span class="line">    // 否则 NSURLSessionDownloadDelegate 和 NSURLSessionDelegate 方法会因为</span><br><span class="line">    // 没有 对 session 的 delegate 设定而不会被调用。参见上面的 backgroundURLSession</span><br><span class="line">    NSURLSession *backgroundSession = [self backgroundURLSession];</span><br><span class="line"></span><br><span class="line">    NSLog(@&quot;Rejoining session with identifier %@ %@&quot;, identifier, backgroundSession);</span><br><span class="line"></span><br><span class="line">    // 保存 completion handler 以在处理 session 事件后更新 UI</span><br><span class="line">    [self addCompletionHandler:completionHandler forSession:identifier];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)URLSessionDidFinishEventsForBackgroundURLSession:(NSURLSession *)session</span><br><span class="line">&#123;</span><br><span class="line">    NSLog(@&quot;Background URL session %@ finished events.\n&quot;, session);</span><br><span class="line"></span><br><span class="line">    if (session.configuration.identifier) &#123;</span><br><span class="line">        // 调用在 -application:handleEventsForBackgroundURLSession: 中保存的 handler</span><br><span class="line">        [self callCompletionHandlerForSession:session.configuration.identifier];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)addCompletionHandler:(CompletionHandlerType)handler forSession:(NSString *)identifier</span><br><span class="line">&#123;</span><br><span class="line">    if ([self.completionHandlerDictionary objectForKey:identifier]) &#123;</span><br><span class="line">        NSLog(@&quot;Error: Got multiple handlers for a single session identifier.  This should not happen.\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [self.completionHandlerDictionary setObject:handler forKey:identifier];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)callCompletionHandlerForSession: (NSString *)identifier</span><br><span class="line">&#123;</span><br><span class="line">    CompletionHandlerType handler = [self.completionHandlerDictionary objectForKey: identifier];</span><br><span class="line"></span><br><span class="line">    if (handler) &#123;</span><br><span class="line">        [self.completionHandlerDictionary removeObjectForKey: identifier];</span><br><span class="line">        NSLog(@&quot;Calling completion handler for session %@&quot;, identifier);</span><br><span class="line"></span><br><span class="line">        handler();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>如果当后台传输完成时，应用程序不再停留在前台，那么，对于更新程序界面来说，这个两步处理过程是必要的。此外，如果当后台传输完成时，应用程序根本没有在运行，iOS 将会在后台启动该应用程序，然后前面的应用程序和会话的委托方法会在 application:didFinishLaunchingWithOptions: 方法被调用之后被调用。</p>
<h2 id="配置和限制"><a href="#配置和限制" class="headerlink" title="配置和限制"></a>配置和限制</h2><p>我们简单地体验了后台传输的强大之处，但你应该深入文档，阅读 NSURLSessionConfiguration 部分，以便最好地满足你的使用场景。例如，NSURLSessionTasks 通过 NSURLSessionConfiguration 的 timeoutIntervalForResource 属性，支持资源超时特性。你可以使用这个特性指定你允许完成一个传输所需的最长时间。内容只在有限的时间可用，或者在用户只有有限 Wifi 带宽的时间内无法下载或上传资源的情况下，你也可以使用这个特性。</p>
<p>除了下载任务，NSURLSession 也全面支持上传任务，因此，你可能会在后台将视频上传到服务器，这保证用户不需要再像 iOS 6 那样保持应用程序前台运行。如果当传输完成时你的应用程序不需要在后台运行，一个比较好的做法是，把 NSURLSessionConfiguration 的 sessionSendsLaunchEvents 属性设置为 NO。高效利用系统资源，是一件让 iOS 和用户都高兴的事。</p>
<p>最后，我们来说一说使用后台会话的几个限制。作为一个必须实现的委托，您不能对 NSURLSession 使用简单的基于 block 的回调方法。后台启动应用程序，是相对耗费较多资源的，所以总是采用 HTTP 重定向。后台传输服务只支持 HTTP 和 HTTPS，你不能使用自定义的协议。系统会根据可用的资源进行优化，在任何时候你都不能强制传输任务在后台进行。</p>
<p>另外，要注意的是在后台会话中，NSURLSessionDataTasks 是完全不支持的，你应该只出于短期的，小请求为目的使用这些任务，而不是用来下载或上传。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>iOS 7 中强大的多任务和网络 API 为现有应用和新应用开启了一系列全新的可能性。如果你的应用程序可以从进程外的网络传输和数据中获益，那么尽情地使用这些美妙的 API。一般情况下，你可以就像你的应用正在前台运行那样去实现后台传输，并进行适当的界面更新，而这里绝大多数的工作都已经为你完成了。</p>
<ul>
<li>使用适当的新 API 来为你的应用程序提供内容。</li>
<li>尽可能早地调用 completion handler 以提高效率。</li>
<li>让 completion handler 为应用程序更新界面快照。<h2 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h2><a target="_blank" rel="noopener" href="https://developer.apple.com/wwdc/videos/?id=204">WWDC 2013 session “What’s New with Multitasking”</a><br><a target="_blank" rel="noopener" href="https://developer.apple.com/wwdc/videos/?id=705">WWDC 2013 session “What’s New in Foundation Networking”</a><br><a target="_blank" rel="noopener" href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/URLLoadingSystem/URLLoadingSystem.html#//apple_ref/doc/uid/10000165i">URL Loading System Programming Guide</a></li>
</ul>
<hr>
<p><em>观点仅代表自己，期待你的留言。</em><br><a target="_blank" rel="noopener" href="http://objccn.io/issue-5-5/">http://objccn.io/issue-5-5/</a></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/iOS/" rel="tag">iOS</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%BD%AC%E8%BD%BD/" rel="tag">转载</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>











  
    <article id="post-ios-msg-transfer" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/03/30/ios-msg-transfer/" class="article-date">
  	<time datetime="2016-03-30T09:39:24.000Z" itemprop="datePublished">2016-03-30</time>
</a>
      <div class="analysis-container">
	<i class="fa fa-line-chart"></i>
	已阅读<span id=“busuanzi_container_page_pv”><span id="busuanzi_value_page_pv"><i class="fa fa-spinner fa-spin"></i></span></span> 次
</div>

    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/03/30/ios-msg-transfer/">iOS开发过程中几种消息传递机制的理解</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
              
        <h2 id="几种消息传递机制"><a href="#几种消息传递机制" class="headerlink" title="几种消息传递机制"></a>几种消息传递机制</h2><p>首先我们来看看每种机制的具体特点。在这个基础上，下一节我们会画一个流程图来帮我们在具体情况下正确选择应该使用的机制。最后，我们会介绍一些苹果框架里的例子并且解释为什么在那些用例中会选择这样的机制。</p>
<h3 id="KVO"><a href="#KVO" class="headerlink" title="KVO"></a>KVO</h3><p>KVO 是提供对象属性被改变时的通知的机制。KVO 的实现在 Foundation 中，很多基于 Foundation 的框架都依赖它。</p>
<p>如果只对某个对象的值的改变感兴趣的话，就可以使用 KVO 消息传递。不过有一些前提：第一，接收者（接收对象改变的通知的对象）需要知道发送者 （值会改变的对象）；第二，接收者需要知道发送者的生命周期，因为它需要在发送者被销毁前注销观察者身份。如果这两个要去符合的话，这个消息传递机制可以一对多（多个观察者可以注册观察同一个对象的变化）</p>
<p>如果要在 Core Data 上使用 KVO 的话，方法会有些许差别。这和 Core Data 的惰性加载 (faulting) 机制有关。一旦一个 managed object 被惰性加载处理的话，即使它的属性没有被改变，它还是会触发相应的观察者。</p>
<p><strong>编者注</strong> 把属性值先取入缓存中，在对象需要的时候再进行一次访问，这在 Core Data 中是默认行为，这种技术称为 Faulting。这么做可以避免降低内存开销，但是如果你确定将访问结果对象的具体属性值时，可以禁用 Faults 以提高获取性能。关于这个技术更多的情况，请移步<a target="_blank" rel="noopener" href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/CoreData/Articles/cdFaultingUniquing.html">官方文档</a></p>
<h3 id="通知"><a href="#通知" class="headerlink" title="通知"></a>通知</h3><p>要在代码中的两个不相关的模块中传递消息时，通知机制是非常好的工具。通知机制广播消息，当消息内容丰富而且无需指望接收者一定要关注的话这一招特别有用。</p>
<p>通知可以用来发送任意消息，甚至可以包含一个 userInfo 字典。你也可以继承 NSNotification 写一个自己的通知类来自定义行为。通知的独特之处在于，发送者和接收者不需要相互知道对方，所以通知可以被用来在不同的相隔很远的模块之间传递消息。这就意味着这种消息传递是单向的，我们不能回复一个通知。</p>
<h3 id="委托-Delegation"><a href="#委托-Delegation" class="headerlink" title="委托 (Delegation)"></a>委托 (Delegation)</h3><p>Delegation 在苹果的框架中广泛存在。它让我们能自定义对象的行为，并收到一些触发的事件。要使用 delegation 模式的话，发送者需要知道接收者，但是反过来没有要求。因为发送者只需要知道接收者符合一定的协议，所以它们两者结合的很松。</p>
<p>因为 delegate 协议可以定义任何的方法，我们可以照着自己的需求来传递消息。可以用方法参数来传递消息内容，delegate 可以通过返回值的形式来给发送者作出回应。如果只要在相对接近的两个模块间传递消息，delgation 是很灵活很直接的消息传递机制。</p>
<p>过度使用 delegation 也会带来风险。如果两个对象结合得很紧密，任何其中一个对象都不能单独运转，那么就不需要用 delegate 协议了。这些情况下，对象已经知道各自的类型，可以直接交流。两个比较新的例子是 UICollectionViewLayout 和 NSURLSessionConfiguration。</p>
<h3 id="Block"><a href="#Block" class="headerlink" title="Block"></a>Block</h3><p>Block 是最近才加入 Objective-C 的，首次出现在 OS X 10.6 和 iOS 4 平台上。Block 通常可以完全替代 delegation 消息传递机制的角色。不过这两种机制都有它们自己的独特需求和优势。</p>
<p>一个不使用 block 的理由通常是 block 会存在导致 retain 环 (retain cycles) 的风险。如果发送者需要 retain block 但又不能确保引用在什么时候被赋值为 nil， 那么所有在 block 内对 self 的引用就会发生潜在的 retain 环。</p>
<p>假设我们要实现一个用 block 回调而不是 delegate 机制的 table view 里的选择方法，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">self.myTableView.selectionHandler = ^void(NSIndexPath *selectedIndexPath) &#123;</span><br><span class="line">    // 处理选择</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这儿的问题是，self 会 retain table view，table view 为了让 block 之后可以使用而又需要 retain 这个 block。然而 table view 不能把这个引用设为 nil，因为它不知道什么时候不需要这个 block 了。如果我们不能保证打破 retain 环并且我们需要 retain 发送者，那么 block 就不是一个的好选择。</p>
<p>NSOperation 是使用 block 的一个好范例。因为它在一定的地方打破了 retain 环，解决了上述的问题。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">self.queue = [[NSOperationQueue alloc] init];</span><br><span class="line">MyOperation *operation = [[MyOperation alloc] init];</span><br><span class="line">operation.completionBlock = ^&#123;</span><br><span class="line">    [self finishedOperation];</span><br><span class="line">&#125;;</span><br><span class="line">[self.queue addOperation:operation];</span><br></pre></td></tr></table></figure>
<p>一眼看来好像上面的代码有一个 retain 环：self retain 了 queue，queue retain 了 operation， operation retain 了 completionBlock， 而 completionBlock retain 了 self。然而，把 operation 加入 queue 中会使 operation 在某个时间被执行，然后被从 queue 中移除。（如果没被执行，问题就大了。）一旦 queue 把 operation 移除，retain 环就被打破了。</p>
<p>另一个例子是：我们在写一个视频编码器的类，在类里面我们会调用一个 encodeWithCompletionHandler: 的方法。为了不出问题，我们需要保证编码器对象在某个时间点会释放对 block 的引用。其代码如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">@interface Encoder ()</span><br><span class="line">@property (nonatomic, copy) void (^completionHandler)();</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation Encoder</span><br><span class="line"></span><br><span class="line">- (void)encodeWithCompletionHandler:(void (^)())handler</span><br><span class="line">&#123;</span><br><span class="line">    self.completionHandler = handler;</span><br><span class="line">    // 进行异步处理...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 这个方法会在完成后被调用一次</span><br><span class="line">- (void)finishedEncoding</span><br><span class="line">&#123;</span><br><span class="line">    self.completionHandler();</span><br><span class="line">    self.completionHandler = nil; // &lt;- 不要忘了这个!</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>一旦任务完成，completion block 调用过了以后，我们就应该把它设为 nil。</p>
<p>如果一个被调用的方法需要发送一个一次性的消息作为回复，那么使用 block 是很好的选择， 因为这样做我们可以打破潜在的 retain 环。另外，如果将处理的消息和对消息的调用放在一起可以增强可读性的话，我们也很难拒绝使用 block 来进行处理。在用例之中，使用 block 来做完成的回调，错误的回调，或者类似的事情，是很常见的情况。</p>
<h3 id="Target-Action"><a href="#Target-Action" class="headerlink" title="Target-Action"></a>Target-Action</h3><p>Target-Action 是回应 UI 事件时典型的消息传递方式。iOS 上的 UIControl 和 Mac 上的 NSControl/NSCell 都支持这个机制。Target-Action 在消息的发送者和接收者之间建立了一个松散的关系。消息的接收者不知道发送者，甚至消息的发送者也不知道消息的接收者会是什么。如果 target 是 nil，action 会在<a target="_blank" rel="noopener" href="https://developer.apple.com/library/ios/documentation/general/conceptual/Devpedia-CocoaApp/Responder.html">响应链 (responder chain) </a>中被传递下去，直到找到一个响应它的对象。在 iOS 中，每个控件甚至可以和多个 target-action 关联。</p>
<p>基于 target-action 传递机制的一个局限是，发送的消息不能携带自定义的信息。在 Mac 平台上 action 方法的第一个参数永远接收者。iOS 中，可以选择性的把发送者和触发 action 的事件作为参数。除此之外就没有别的控制 action 消息内容的方法了。</p>
<h3 id="做出正确的选择"><a href="#做出正确的选择" class="headerlink" title="做出正确的选择"></a>做出正确的选择</h3><p>基于上述对不同消息传递机制的特点，我们画了一个流程图来帮助我们在不同情境下做出不同的选择。一句忠告：流程图的建议不代表最终答案。有些时候别的选择依然能达到应有的效果。只不过大多数情况下这张图能引导你做出正确的决定。<br><img src="/images/communication-patterns-flow-chart.png"><br>图中有些细节值得深究：</p>
<p>有个框中说到： 发送者支持 KVO。这不仅仅是说发送者会在值改变的时候发送 KVO 通知，而且说明观察者需要知道发送者的生命周期。如果发送者被存在一个 weak 属性中，那么发送者有可能会自己变成 nil，那时观察者会导致内存泄露。</p>
<p>一个在最后一行的框里说，消息直接响应方法调用。也就是说方法调用的接收者需要给调用者一个消息作为方法调用的直接反馈。这也就是说处理消息的代码和调用方法的代码必须在同一个地方。</p>
<p>最后在右下角的地方，一个选择分支这样说：发送者能确保释放对 block 的引用吗？这涉及到了我们之前讨论 block 的 API 存在潜在的 retain 环的问题。如果发送者不能保证在某个时间点会释放对 block 的引用，那么你会惹上 retain 环的麻烦。</p>
<h2 id="Framework-示例"><a href="#Framework-示例" class="headerlink" title="Framework 示例"></a>Framework 示例</h2><p>本节我们通过一些苹果框架里的例子来验证流程图的选择是否有道理，同时解释为什么苹果会选择用这些机制。</p>
<h3 id="KVO-1"><a href="#KVO-1" class="headerlink" title="KVO"></a>KVO</h3><p>NSOperationQueue 用了 KVO 观察队列中的 operation 状态属性的改变情况 (isFinished，isExecuting，isCancelled)。当状态改变的时候，队列会收到 KVO 通知。为什么 operation 队列要用 KVO 呢？</p>
<p>消息的接收者（operation 队列）知道消息的发送者（operation），并 retain 它并控制后者的生命周期。另外，在这种情况下只需要单向的消息传递机制。当然如果考虑到 oepration 队列只关心那些改变 operation 的值的改变情况的话，就还不足以说服大家使用 KVO 了。但我们可以这么理解：被传递的消息可以被当成值的改变来处理。因为 state 属性在 operation 队列以外也是有用的，所以这里适合用 KVO。<br><img src="/images/kvo-flow-chart.png"><br>当然 KVO 不是唯一的选择。我们也可以将 operation 队列作为 operation 的 delegate 来使用，operation 会调用类似 operationDidFinish: 或者 operationDidBeginExecuting: 等方法把它的 state 传递给 queue。这样就不太方便了，因为 operation 要保存 state 属性，以便于调用这些 delegate 方法。另外，由于 queue 不能主动获取 state 信息，所以 queue 也必须保存所有 operation 的 state。</p>
<h3 id="Notifications"><a href="#Notifications" class="headerlink" title="Notifications"></a>Notifications</h3><p>Core Data 使用 notification 传递事件（例如一个 managed object context 中的改变————NSManagedObjectContextObjectsDidChangeNotification）</p>
<p>发生改变时触发的 notification 是由 managed object contexts 发出的，所以我们不能假定消息的接收者知道消息的发送者。因为消息的源头不是一个 UI 事件，很多接收者可能在关注着此消息，并且消息传递是单向的，所以 notification 是唯一可行的选择。<br><img src="/images/notification-flow-chart.png"></p>
<h3 id="Delegation"><a href="#Delegation" class="headerlink" title="Delegation"></a>Delegation</h3><p>Table view 的 delegate 有多重功能，它可以从管理 accessory view，直到追踪在屏幕上显示的 cell。例如我们可以看看 tableView:didSelectRowAtIndexPath: 方法。为什么用 delegate 实现而不是 target-action 机制？</p>
<p>正如我们在上述流程图中看到的，用 target-action 时，不能传递自定义的数据。而选中 table view 的某个 cell 时，collection view 不仅需要告诉我们一个 cell 被选中了，也要通过 index path 告诉我们哪个 cell 被选中了。如果我们照着这个思路，流程图会引导我们使用 delegation 机制。<br><img src="/images/delegation-flow-chart.png"><br>如果不在消息传递中包含选中 cell 的 index path，而是让选中项改变时我们像 table view 主动询问并获取选中 cell 的相关信息，会怎样呢？这会非常不方便，因为我们必须记住当前选中项的数据，这样才能在多选择中知道哪些 cell 是被新选中的。</p>
<p>同理，我们可以想象通过观察 table view 选中项的 index path 属性，当该值发生改变的时候，获得一个选中项改变的通知。不过我们会遇到上述相似问题：不做记录的话我们就不能分辨哪一个 cell 被选择或取消选择了。</p>
<h3 id="Block-1"><a href="#Block-1" class="headerlink" title="Block"></a>Block</h3><p>我们用 -[NSURLSession dataTaskWithURL:completionHandler:] 来作为一个 block API 的介绍。那么从 URL 加载部分返回给调用者是怎么传递消息的呢？首先，作为 API 的调用者，我们知道消息的发送者，但是我们并没有 retain 它。另外，这是个单向的消息传递————它直接调用 dataTaskWithURL: 的方法。如果我们对照流程图，会发现这属于 block 消息传递机制。<br><img src="/images/block-flow-chart.png"><br>有其他的选项吗？当然，苹果自己的 NSURLConnection 就是最好的例子。NSURLConnection在 block 问世之前就存在了，所以它并没有用 block 来实现消息传递，而是使用 delegation 来完成。当 block 出现以后，苹果就在 OS X 10.7 和 iOS 5 平台上的 NSURLConnection 中加了 sendAsynchronousRequest:queue:completionHandler:，所以我们不再在简单的任务中使用 delegate 了。</p>
<p>因为 NSURLSession 是个最近在 OS X 10.9 和 iOS 7 才出现的 API，所以它们使用 block 来实现消息传递机制（NSURLSession 有一个 delegate，但是是用于其他目的）。</p>
<h3 id="Target-Action-1"><a href="#Target-Action-1" class="headerlink" title="Target-Action"></a>Target-Action</h3><p>一个明显的 target-action 用例是按钮。按钮在不被按下的时候不需要发送任何的信息。为了这个目的，target-action 是 UI 中消息传递的最佳选择。<br><img src="/images/target-action-flow-chart.png"><br>如果 target 是明确指定的，那么 action 消息会发送给指定的对象。如果 target 是 nil， action 消息会一直在响应链中被传递下去，直到找到一个能处理它的对象。在这种情况下，我们有一个完全解耦的消息传递机制：发送者不需要知道接收者，反之亦然。</p>
<p>Target-action 机制非常适合响应 UI 的事件。没有其他的消息传递机制能够提供相同的功能。虽然 notification 在发送者和接收者的松散关系上最接近它，但是 target-action 可以用于响应链——只有一个对象获得 action 并响应，action 在响应链中传递，直到能遇到响应这个 action 的对象。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>一开始接触这么多的消息传递机制的时候，我们可能有些无所适从，觉得所有的机制都可以被选用。不过一旦我们仔细分析每个机制的时候，它们各自都有特殊的要求和能力。</p>
<p>文中的选择流程图是帮助你清楚认识这些机制的好的开始，当然它不是所有问题的答案。如果你觉得这和你自己选择机制的方式相似或是有任何缺漏，欢迎来信指正。</p>
<hr>
<p><em>观点仅代表自己，期待你的留言。</em><br><a target="_blank" rel="noopener" href="http://objccn.io/issue-7-4/">http://objccn.io/issue-7-4/</a></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/iOS/" rel="tag">iOS</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%BD%AC%E8%BD%BD/" rel="tag">转载</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>











  
    <article id="post-ios-sendmsg" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/03/30/ios-sendmsg/" class="article-date">
  	<time datetime="2016-03-30T08:44:25.000Z" itemprop="datePublished">2016-03-30</time>
</a>
      <div class="analysis-container">
	<i class="fa fa-line-chart"></i>
	已阅读<span id=“busuanzi_container_page_pv”><span id="busuanzi_value_page_pv"><i class="fa fa-spinner fa-spin"></i></span></span> 次
</div>

    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/03/30/ios-sendmsg/">Effective Objective-C 理解消息传递机制</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
              
        <h2 id="最简单的动态"><a href="#最简单的动态" class="headerlink" title="最简单的动态"></a>最简单的动态</h2><p>Objective-C 是一门极其动态的语言，许多东西都可以推迟到运行时决定、修改。那么到底何为动态、何为静态？我们通过一个简单的例子对比下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">/***********  例1 静态绑定   ***********/</span><br><span class="line">#import &lt;stdio.h&gt;</span><br><span class="line">void printHello() &#123;</span><br><span class="line">    printf(&quot;Hello, world!\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">void printGoodbye() &#123;</span><br><span class="line">    printf(&quot;Goodbye, world!\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">void saySomething(int type) </span><br><span class="line">&#123;</span><br><span class="line">    if (type == 0) &#123;</span><br><span class="line">        printHello();</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        printGoodbye();</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">/***********  例2 动态绑定   ***********/</span><br><span class="line">#import &lt;stdio.h&gt;</span><br><span class="line">void printHello() &#123;</span><br><span class="line">    printf(&quot;Hello, world!\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">void printGoodbye() &#123;</span><br><span class="line">    printf(&quot;Goodbye, world!\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">void saySomething(int type) </span><br><span class="line">&#123;</span><br><span class="line">    void (*func)();</span><br><span class="line">    if (type == 0) &#123;</span><br><span class="line">        func = printHello;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        func = printGoodbye;</span><br><span class="line">    &#125;</span><br><span class="line">    func();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例1的代码在编译期，编译器就已经知道了有 void printHello()、void printGoodbye() 俩函数，并且在 saySomething() 函数中，调用的函数明确，可以直接将函数名硬编码成地址，生成调用指令，这就是 __静态绑定__（static binding）。那么例2呢？例2的调用的是 func() 函数，而这函数实际调用的地址只能到程序运行时才能确定，这就是所谓的 __动态绑定__（dynamic binding）。动态绑定将函数调用从编译期推迟到了运行时。</p>
<p>在 Objective-C 中，向对象传递消息，就会使用这种动态绑定机制来决定需要调用的方法，这种动态特性使得 Objective-C 成为一门真正动态的语言。</p>
<h2 id="objec-msgSend-函数"><a href="#objec-msgSend-函数" class="headerlink" title="objec_msgSend 函数"></a>objec_msgSend 函数</h2><p>Objective-C 的方法调用通常都是下面这种形式</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">id returnValue = [someObject messageName:parameter];</span><br></pre></td></tr></table></figure>
<p>这种方法调用其实就是消息传递，编译器看到这条消息会转换成一条标准的 C 语言函数调用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">id returnValue = objc_msgSend(someObject,</span><br><span class="line">                              @selector(messageName:),</span><br><span class="line">                              parameter);</span><br></pre></td></tr></table></figure>
<p>用消息传递的话来解释就是：向 someObject 对象发送了一个名叫 messageName 的消息，这个消息携带了一个叫 parameter 的参数。这里用到了一个 objc_msgSend 函数，其函数原型如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void objc_msgSend(id self, SEL cmd, ...);</span><br></pre></td></tr></table></figure>
<p>这是一个可变参数的函数，第一个参数代表消息接收者，第二个代表 SEL 类型，后面的参数就是消息传递中使用的参数。</p>
<p>那么什么是 SEL 呢？SEL 就是代码在编译时，编译器根据方法签名来生成的一个唯一 ID。此 ID 可以用以区分不同的方法，只要 ID 一致，即看成同一个方法，ID 不同，即为不同的方法。</p>
<p>当进行消息传递，对象在响应消息时，是通过 SEL 在 methodlist 中查找函数指针 IMP，找到后直接通过指针调用函数，这其实就是前文介绍的 __动态绑定__。若是找到对应函数就跳转到实现代码，若找不到，就沿着继承链往上查找，直到找到相应的实现代码为止。若最终还是没找到实现代码，说明当前对象无法响应此消息，接下来就会执行 <strong>消息转发</strong> 操作，以试图找到一个能响应此消息的对象。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 获取 SEL </span><br><span class="line">SEL sel = @selector(methodName);</span><br><span class="line">// 获取 IMP</span><br><span class="line">IMP imp = methodForSelector(sel);</span><br></pre></td></tr></table></figure>
<h2 id="消息转发"><a href="#消息转发" class="headerlink" title="消息转发"></a>消息转发</h2><p>消息转发并不神奇，我们其实早已接触过，只是不知道而已</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-[__NSCFNumber lowercaseString]:unrecognized selector sent to instance 0x87</span><br><span class="line">*** Terminating app due to uncaught exception &#x27;NSInvalidArgumentException&#x27;, reason:&#x27;-[NSCFNumber lowercaseString]:unrecognized selector sent to instance 0x87&#x27;</span><br></pre></td></tr></table></figure>
<p>这段异常代码就是由 NSObject 的 doesNotRecognizeSelector: 方法所抛出的，异常表明：消息的接收者类型为 __NSCFNumber，无法响应 lowercaseString 消息，从而转发给 NSObject 处理。</p>
<p>消息转发分为三大阶段</p>
<ul>
<li>第一阶段先征询消息接收者所属的类，看其是否能动态添加方法，以处理当前这个无法响应的 selector，这叫做 动态方法解析（dynamic method resolution）。如果运行期系统（runtime system） 第一阶段执行结束，接收者就无法再以动态新增方法的手段来响应消息，进入第二阶段。</li>
<li>第二阶段看看有没有其他对象（备援接收者，replacement receiver）能处理此消息。如果有，运行期系统会把消息转发给那个对象，转发过程结束；如果没有，则启动完整的消息转发机制。</li>
<li>第三阶段 完整的消息转发机制。运行期系统会把与消息有关的全部细节都封装到 NSInvocation 对象中，再给接收者最后一次机会，令其设法解决当前还未处理的消息。</li>
</ul>
<h3 id="动态方法解析"><a href="#动态方法解析" class="headerlink" title="动态方法解析"></a>动态方法解析</h3><p>对象在收到无法响应的消息后，会调用其所属类的下列方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> *  如果尚未实现的方法是实例方法，则调用此函数</span><br><span class="line"> *</span><br><span class="line"> *  @param selector 未处理的方法</span><br><span class="line"> *</span><br><span class="line"> *  @return 返回布尔值，表示是否能新增实例方法用以处理selector</span><br><span class="line"> */</span><br><span class="line">+ (BOOL)resolveInstanceMethod:(SEL)selector;</span><br><span class="line">/**</span><br><span class="line"> *  如果尚未实现的方法是类方法，则调用此函数</span><br><span class="line"> *</span><br><span class="line"> *  @param selector 未处理的方法</span><br><span class="line"> *</span><br><span class="line"> *  @return 返回布尔值，表示是否能新增类方法用以处理selector</span><br><span class="line"> */</span><br><span class="line">+ (BOOL)resolveClassMethod:(SEL)selector;</span><br></pre></td></tr></table></figure>
<p>方法返回布尔类型，表示是否能新增一个方法来处理 selector，此方案通常用来实现 @dynamic 属性。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">/************** 使用 resolveInstanceMethod 实现 @dynamic 属性 **************/</span><br><span class="line">id autoDictionaryGetter(id self, SEL _cmd);</span><br><span class="line">void autoDictionarySetter(id self, SEL _cmd, id value);</span><br><span class="line">+ (BOOL)resolveInstanceMethod:(SEL)selector</span><br><span class="line">&#123;</span><br><span class="line">    NSString *selectorString = NSStringFromSelector(selector);</span><br><span class="line">    if (/* selector is from a @dynamic property */)</span><br><span class="line">    &#123;</span><br><span class="line">        if ([selectorString hasPrefix:@&quot;set&quot;])</span><br><span class="line">        &#123;</span><br><span class="line">            // 添加 setter 方法</span><br><span class="line">            class_addMethod(self, selector, (IMP)autoDictionarySetter, &quot;v@:@&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            // 添加 getter 方法</span><br><span class="line">            class_addMethod(self, selector, (IMP)autoDictionaryGetter, &quot;@@:&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        return YES;</span><br><span class="line">    &#125;</span><br><span class="line">    return [super resolveInstanceMethod:selector];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="备援接收者"><a href="#备援接收者" class="headerlink" title="备援接收者"></a>备援接收者</h3><p>如果无法 __动态解析方法__，运行期系统就会询问是否能将消息转给其他接收者来处理，对应的方法为</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> *  此方法询问是否能将消息转给其他接收者来处理</span><br><span class="line"> *</span><br><span class="line"> *  @param aSelector 未处理的方法</span><br><span class="line"> *</span><br><span class="line"> *  @return 如果当前接收者能找到备援对象，就将其返回；否则返回nil；</span><br><span class="line"> */</span><br><span class="line">- (id)forwardingTargetForSelector:(SEL)aSelector;</span><br></pre></td></tr></table></figure>
<p>在对象内部，可能还有其他对象，该对象可通过此方法将能够处理 selector 的相关内部对象返回，在外界看来，就好像是该对象自己处理的似得。</p>
<h3 id="完整的消息转发机制"><a href="#完整的消息转发机制" class="headerlink" title="完整的消息转发机制"></a>完整的消息转发机制</h3><p>如果前面两步都无法处理消息，就会启动完整的消息转发机制。首先创建 NSInvocation 对象，把尚未处理的那条消息有关的全部细节装在里面，在触发 NSInvocation 对象时，消息派发系统（message-dispatch system）将会把消息指派给目标对象。对应的方法为</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> *  消息派发系统通过此方法，将消息派发给目标对象</span><br><span class="line"> *</span><br><span class="line"> *  @param anInvocation 之前创建的NSInvocation实例对象，用于装载有关消息的所有内容</span><br><span class="line"> */</span><br><span class="line">- (void)forwardInvocation:(NSInvocation *)anInvocation;</span><br></pre></td></tr></table></figure>
<p>这个方法可以实现的很简单，通过改变调用的目标对象，使得消息在新目标对象上得以调用即可。然而这样实现的效果与 <strong>备援接收者</strong> 差不多，所以很少人会这么做。更加有用的实现方式为：在触发消息前，先以某种方式改变消息内容，比如追加另一个参数、修改 selector 等等。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><img src="/images/image_note64270_1.png"></p>
<hr>
<p><em>观点仅代表自己，期待你的留言。</em><br><a target="_blank" rel="noopener" href="https://www.zybuluo.com/MicroCai/note/64270">https://www.zybuluo.com/MicroCai/note/64270</a></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/iOS/" rel="tag">iOS</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%BD%AC%E8%BD%BD/" rel="tag">转载</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>











  
    <article id="post-ios-load-initialize" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/03/29/ios-load-initialize/" class="article-date">
  	<time datetime="2016-03-29T07:42:47.000Z" itemprop="datePublished">2016-03-29</time>
</a>
      <div class="analysis-container">
	<i class="fa fa-line-chart"></i>
	已阅读<span id=“busuanzi_container_page_pv”><span id="busuanzi_value_page_pv"><i class="fa fa-spinner fa-spin"></i></span></span> 次
</div>

    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/03/29/ios-load-initialize/">NSObject的+load与+initialize方法的区别</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
              
        <p>先来看看NSObject Class Reference里对这两个方法说明：<br>+(void)initialize</p>
<p>The runtime sends initialize to each class in a program exactly one time just before the class, or any class that inherits from it, is sent its first message from within the program. (Thus the method may never be invoked if the class is not used.) The runtime sends the initialize message to classes in a thread-safe manner. Superclasses receive this message before their subclasses.</p>
<p>+(void)load<br>The load message is sent to classes and categories that are both dynamically loaded and statically linked, but only if the newly loaded class or category implements a method that can respond.<br>The order of initialization is as follows:</p>
<p>All initializers in any framework you link to.<br>All +load methods in your image.<br>All C++ static initializers and C/C++ <strong>attribute</strong>(constructor) functions in your image.<br>All initializers in frameworks that link to you.<br>In addition:</p>
<p>A class’s +load method is called after all of its superclasses’ +load methods.<br>A category +load method is called after the class’s own +load method.<br>In a custom implementation of load you can therefore safely message other unrelated classes from the same image, but any load methods implemented by those classes may not have run yet.</p>
<p>Apple的文档很清楚地说明了initialize和load的区别在于：load是只要类所在文件被引用就会被调用，而initialize是在类或者其子类的第一个方法被调用前调用。所以如果类没有被引用进项目，就不会有load调用；但即使类文件被引用进来，但是没有使用，那么initialize也不会被调用。</p>
<p>它们的相同点在于：方法只会被调用一次。（其实这是相对runtime来说的，后边会做进一步解释）。</p>
<p>文档也明确阐述了方法调用的顺序：父类(Superclass)的方法优先于子类(Subclass)的方法，类中的方法优先于类别(Category)中的方法。</p>
<p><strong>总结：</strong></p>
<table>
<thead>
<tr>
<th align="left">-</th>
<th align="left">+(void)load</th>
<th align="left">+(void)initialize</th>
</tr>
</thead>
<tbody><tr>
<td align="left">执行时机</td>
<td align="left">在程序运行后立即执行</td>
<td align="left">在类的方法第一次被调时执行</td>
</tr>
<tr>
<td align="left">若自身未定义，是否沿用父类的方法？</td>
<td align="left">否</td>
<td align="left">是</td>
</tr>
<tr>
<td align="left">类别中的定义</td>
<td align="left">全都执行，但后于类中的方法</td>
<td align="left">覆盖类中的方法，只执行一个</td>
</tr>
</tbody></table>
<hr>
<p><em>观点仅代表自己，期待你的留言。</em></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/iOS/" rel="tag">iOS</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%BD%AC%E8%BD%BD/" rel="tag">转载</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>











  
    <article id="post-ios-loadview" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/03/29/ios-loadview/" class="article-date">
  	<time datetime="2016-03-29T07:41:52.000Z" itemprop="datePublished">2016-03-29</time>
</a>
      <div class="analysis-container">
	<i class="fa fa-line-chart"></i>
	已阅读<span id=“busuanzi_container_page_pv”><span id="busuanzi_value_page_pv"><i class="fa fa-spinner fa-spin"></i></span></span> 次
</div>

    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/03/29/ios-loadview/">iOS中UIViewController初始化过程及LoadView默认实现</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
              
        <h2 id="Xib或者Storyboard方式初始化UIViewController"><a href="#Xib或者Storyboard方式初始化UIViewController" class="headerlink" title="Xib或者Storyboard方式初始化UIViewController"></a>Xib或者Storyboard方式初始化UIViewController</h2><p>1、系统会通过 (instancetype)initWithCoder:(NSCoder *)aDecoder创建Controller对象实例。<br>2、当需要将UIController的View添加到父级View时则会通过loadViewIfRequired方法来先判断self.view对象是否为nil<br>    如果为nil则会调用 (void)loadView进行view的初始化。然后会调用viewDidLoad方法</p>
<p><img src="/images/xib_init.png"></p>
<h2 id="编码的方式初始化UIViewController"><a href="#编码的方式初始化UIViewController" class="headerlink" title="编码的方式初始化UIViewController"></a>编码的方式初始化UIViewController</h2><p>[[UIViewController alloc] init]，系统会调用[[UIViewController alloc] initWithNibName:(NSString *)nibNameOrNil bundle:(NSBundle *)nibBundleOrNil]创建实例对象<br><img src="/images/code_init.png"></p>
<h2 id="系统默认loadView实现"><a href="#系统默认loadView实现" class="headerlink" title="系统默认loadView实现"></a>系统默认loadView实现</h2><p>通过initWithNibName保存的nibName来加载对应的nib资源并赋值于self.view, 如果nibName为空，则创建一个空的UIView实例赋值。</p>
<p><img src="/images/def_loadview.png"></p>
<p>__注意：__在loadView方法自定义实现中由于view未进行初始化，如果使用self.view获取值，由会再次触发调用loadView方法造成loadView的递归调用。在ios9.3环境下通过self.view进行赋值则不存在此情况。</p>
<p>附一张UIViewController生命周期图：<br><img src="/images/uiviewcontroller-lifecycle.jpg"></p>
<hr>
<p><em>观点仅代表自己，期待你的留言。</em></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/iOS/" rel="tag">iOS</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%8E%9F%E5%88%9B/" rel="tag">原创</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>











  
    <article id="post-ios-hitTest" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/03/24/ios-hitTest/" class="article-date">
  	<time datetime="2016-03-24T02:45:13.000Z" itemprop="datePublished">2016-03-24</time>
</a>
      <div class="analysis-container">
	<i class="fa fa-line-chart"></i>
	已阅读<span id=“busuanzi_container_page_pv”><span id="busuanzi_value_page_pv"><i class="fa fa-spinner fa-spin"></i></span></span> 次
</div>

    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/03/24/ios-hitTest/">iOS-hitTest:withEvent与pointInside:withEvent</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
              
        <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>对于触摸事件的响应，首先要找到能够响应该事件的对象，iOS是用hit-testing 来找到哪个视图被触摸了（hit-test view），也就是以keyWindow为起点，hit-test view为终点,逐级调用hitTest:withEvent。</p>
<p><img src="/images/1452221174578074.png"></p>
<h2 id="hitTest-withEvent-方法的处理流程"><a href="#hitTest-withEvent-方法的处理流程" class="headerlink" title="hitTest:withEvent:方法的处理流程:"></a>hitTest:withEvent:方法的处理流程:</h2><p>先调用pointInside:withEvent:判断触摸点是否在当前视图内<br>1.如果返回YES，那么该视图的所有子视图调用hitTest:withEvent,调用顺序由层级低到高（top-&gt;bottom）依次调用。</p>
<p>2.如果返回NO，那么hitTest:withEvent返回nil，该视图的所有子视图的分支全部被忽略</p>
<p>如果某视图的pointInside:withEvent:返回YES，并且他的所有子视图hitTest:withEvent:都返回nil，或者该视图没有子视图，那么该视图的hitTest:withEvent:返回自己。<br>如果子视图的hitTest:withEvent:返回非空对象，那么当前视图的hitTest:withEvent:也返回这个对象，也就是沿原路回推，最终将hit-test view传递给keyWindow<br>以下视图的hitTest:withEvent:方法会返回nil，导致自身和其所有子视图不能被hit-testing发现，无法响应触摸事件：<br> 1.隐藏(hidden=YES)的视图<br> 2.禁止用户操作(userInteractionEnabled=NO)的视图<br> 3.alpha&lt;0.01的视图<br> 4.视图超出父视图的区域</p>
<hr>
<p><em>观点仅代表自己，期待你的留言。</em></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/iOS/" rel="tag">iOS</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%BD%AC%E8%BD%BD/" rel="tag">转载</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>











  
    <article id="post-ios-layoutsubviews" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/03/22/ios-layoutsubviews/" class="article-date">
  	<time datetime="2016-03-22T03:35:23.000Z" itemprop="datePublished">2016-03-22</time>
</a>
      <div class="analysis-container">
	<i class="fa fa-line-chart"></i>
	已阅读<span id=“busuanzi_container_page_pv”><span id="busuanzi_value_page_pv"><i class="fa fa-spinner fa-spin"></i></span></span> 次
</div>

    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/03/22/ios-layoutsubviews/">UIView的layoutSubviews和drawRect</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
              
        <p>UIView的setNeedsDisplay和setNeedsLayout方法。首先两个方法都是异步执行的。setNeedsDisplay会调用自动调用drawRect方法，这样可以拿到UIGraphicsGetCurrentContext，就可以画画了。而setNeedsLayout会默认调用layoutSubViews，就可以处理子视图中的一些数据。<br>综上两个方法都是异步执行的，layoutSubviews方便数据计算，drawRect方便视图重绘。</p>
<p>先大概看下ios layout机制相关的这几个方法：</p>
<ul>
<li>(CGSize)sizeThatFits:(CGSize)size</li>
<li>(void)sizeToFit<br>——————-</li>
<li>(void)layoutSubviews</li>
<li>(void)layoutIfNeeded</li>
<li>(void)setNeedsLayout<br>——————–</li>
<li>(void)setNeedsDisplay</li>
<li>(void)drawRect</li>
</ul>
<h4 id="一、layoutSubviews在以下情况下会被调用："><a href="#一、layoutSubviews在以下情况下会被调用：" class="headerlink" title="一、layoutSubviews在以下情况下会被调用："></a>一、layoutSubviews在以下情况下会被调用：</h4><p>1、init初始化不会触发layoutSubviews。<br>2、addSubview会触发layoutSubviews。<br>3、设置view的Frame会触发layoutSubviews，当然前提是frame的值设置前后发生了变化。<br>4、滚动一个UIScrollView会触发layoutSubviews。<br>5、旋转Screen会触发父UIView上的layoutSubviews事件。<br>6、改变一个UIView大小的时候也会触发父UIView上的layoutSubviews事件。<br>7、直接调用setLayoutSubviews。<br>8、直接调用setNeedsLayout。<br>在苹果的官方文档中强调:You should override this method only if the autoresizing behaviors of the subviews do not offer the behavior you want.<br>layoutSubviews, 当我们在某个类的内部调整子视图位置时，需要调用。<br>反过来的意思就是说：如果你想要在外部设置subviews的位置，就不要重写。</p>
<p> 刷新子对象布局<br>-layoutSubviews方法：这个方法，默认没有做任何事情，需要子类进行重写<br>-setNeedsLayout方法： 标记为需要重新布局，异步调用layoutIfNeeded刷新布局，不立即刷新，但layoutSubviews一定会被调用<br>-layoutIfNeeded方法：如果，有需要刷新的标记，立即调用layoutSubviews进行布局（如果没有标记，不会调用layoutSubviews）<br>如果要立即刷新，要先调用[view setNeedsLayout]，把标记设为需要布局，然后马上调用[view layoutIfNeeded]，实现布局<br>在视图第一次显示之前，标记总是“需要刷新”的，可以直接调用[view layoutIfNeeded]</p>
<h4 id="二、drawRect在以下情况下会被调用："><a href="#二、drawRect在以下情况下会被调用：" class="headerlink" title="二、drawRect在以下情况下会被调用："></a>二、drawRect在以下情况下会被调用：</h4><p>1、如果在UIView初始化时没有设置rect大小，将直接导致drawRect不被自动调用。drawRect 掉用是在Controller-&gt;loadView, Controller-&gt;viewDidLoad 两方法之后掉用的.所以不用担心在 控制器中,这些View的drawRect就开始画了.这样可以在控制器中设置一些值给View(如果这些View draw的时候需要用到某些变量 值).<br>2、该方法在调用sizeToFit后被调用，所以可以先调用sizeToFit计算出size。然后系统自动调用drawRect:方法。<br>sizeToFit会自动调用sizeThatFits方法；<br>sizeToFit不应该在子类中被重写，应该重写sizeThatFits<br>sizeThatFits传入的参数是receiver当前的size，返回一个适合的size<br>sizeToFit可以被手动直接调用<br>sizeToFit和sizeThatFits方法都没有递归，对subviews也不负责，只负责自己<br>3、通过设置contentMode属性值为UIViewContentModeRedraw。那么将在每次设置或更改frame的时候自动调用drawRect:。<br>4、直接调用setNeedsDisplay，或者setNeedsDisplayInRect:触发drawRect:，但是有个前提条件是rect不能为0。<br>-setNeedsDisplay方法：标记为需要重绘，异步调用drawRect<br>-setNeedsDisplayInRect:(CGRect)invalidRect方法：标记为需要局部重绘<br>以上1,2推荐；而3,4不提倡</p>
<p>drawRect方法使用注意点：<br>1、 若使用UIView绘图，只能在drawRect：方法中获取相应的contextRef并绘图。如果在其他方法中获取将获取到一个invalidate 的ref并且不能用于画图。drawRect：方法不能手动显示调用，必须通过调用setNeedsDisplay 或 者 setNeedsDisplayInRect，让系统自动调该方法。<br>2、若使用calayer绘图，只能在drawInContext: 中（类似鱼drawRect）绘制，或者在delegate中的相应方法绘制。同样也是调用setNeedDisplay等间接调用以上方法<br>3、若要实时画图，不能使用gestureRecognizer，只能使用touchbegan等方法来掉用setNeedsDisplay实时刷新屏幕</p>
<h4 id="三、layoutSubviews对subviews重新布局"><a href="#三、layoutSubviews对subviews重新布局" class="headerlink" title="三、layoutSubviews对subviews重新布局"></a>三、layoutSubviews对subviews重新布局</h4><p>layoutSubviews方法调用先于drawRect<br>setNeedsLayout在receiver标上一个需要被重新布局的标记，在系统runloop的下一个周期自动调用layoutSubviews<br>layoutIfNeeded方法如其名，UIKit会判断该receiver是否需要layout.根据Apple官方文档,layoutIfNeeded方法应该是这样的<br>layoutIfNeeded遍历的不是superview链，应该是subviews链<br>drawRect是对receiver的重绘，能获得context<br>setNeedDisplay在receiver标上一个需要被重新绘图的标记，在下一个draw周期自动重绘，iphone device的刷新频率是60hz，也就是1/60秒后重绘</p>
<hr>
<p>原地址：<a target="_blank" rel="noopener" href="http://justsee.iteye.com/blog/1886463">http://justsee.iteye.com/blog/1886463</a></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/iOS/" rel="tag">iOS</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%BD%AC%E8%BD%BD/" rel="tag">转载</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>











  
  
    <nav id="page-nav">
      <a class="extend prev" rel="prev" href="/page/8/">上一页</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><a class="page-number" href="/page/8/">8</a><span class="page-number current">9</span><a class="page-number" href="/page/10/">10</a><a class="extend next" rel="next" href="/page/10/">下一页</a>
    </nav>
  

</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2024 建均笔记
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    
  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">



<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: true,
		isPost: false,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>

<script src="/js/require-2.1.6,jquery-1.9.1.min.js"></script>


<script src="/js/main.js"></script>



<!-- Google Analytics -->
<script type="text/javascript">
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'true', 'auto');
ga('send', 'pageview');

</script>
<!-- End Google Analytics -->



<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>




<link href="//cdn.bootcss.com/highlight.js/8.0/styles/tomorrow-night-bright.min.css" rel="stylesheet">  
<script src="//cdn.bootcss.com/highlight.js/8.0/highlight.min.js"></script>  
<script> 
jQuery('td.code pre').each(function(i, block) {
  hljs.highlightBlock(block);
});
</script>


  </div>
</body>
</html>