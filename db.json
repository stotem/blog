{"meta":{"version":1,"warehouse":"4.0.0"},"models":{"Asset":[{"_id":"themes/yilia/source/css/style.styl","path":"css/style.styl","modified":0,"renderable":1},{"_id":"themes/yilia/source/fancybox/fancybox_loading.gif","path":"fancybox/fancybox_loading.gif","modified":0,"renderable":1},{"_id":"themes/yilia/source/fancybox/blank.gif","path":"fancybox/blank.gif","modified":0,"renderable":1},{"_id":"themes/yilia/source/fancybox/fancybox_loading@2x.gif","path":"fancybox/fancybox_loading@2x.gif","modified":0,"renderable":1},{"_id":"themes/yilia/source/fancybox/fancybox_overlay.png","path":"fancybox/fancybox_overlay.png","modified":0,"renderable":1},{"_id":"themes/yilia/source/fancybox/fancybox_sprite.png","path":"fancybox/fancybox_sprite.png","modified":0,"renderable":1},{"_id":"themes/yilia/source/fancybox/fancybox_sprite@2x.png","path":"fancybox/fancybox_sprite@2x.png","modified":0,"renderable":1},{"_id":"themes/yilia/source/fancybox/jquery.fancybox.css","path":"fancybox/jquery.fancybox.css","modified":0,"renderable":1},{"_id":"themes/yilia/source/fancybox/jquery.fancybox.js","path":"fancybox/jquery.fancybox.js","modified":0,"renderable":1},{"_id":"themes/yilia/source/fancybox/jquery.fancybox.pack.js","path":"fancybox/jquery.fancybox.pack.js","modified":0,"renderable":1},{"_id":"themes/yilia/source/img/avatar.jpg","path":"img/avatar.jpg","modified":0,"renderable":1},{"_id":"themes/yilia/source/img/coderwall.png","path":"img/coderwall.png","modified":0,"renderable":1},{"_id":"themes/yilia/source/img/delicious.png","path":"img/delicious.png","modified":0,"renderable":1},{"_id":"themes/yilia/source/img/facebook.png","path":"img/facebook.png","modified":0,"renderable":1},{"_id":"themes/yilia/source/img/douban.png","path":"img/douban.png","modified":0,"renderable":1},{"_id":"themes/yilia/source/img/github.png","path":"img/github.png","modified":0,"renderable":1},{"_id":"themes/yilia/source/img/google.png","path":"img/google.png","modified":0,"renderable":1},{"_id":"themes/yilia/source/img/img-err.png","path":"img/img-err.png","modified":0,"renderable":1},{"_id":"themes/yilia/source/img/img-loading.png","path":"img/img-loading.png","modified":0,"renderable":1},{"_id":"themes/yilia/source/img/linkedin.png","path":"img/linkedin.png","modified":0,"renderable":1},{"_id":"themes/yilia/source/img/mail.png","path":"img/mail.png","modified":0,"renderable":1},{"_id":"themes/yilia/source/img/oschina.png","path":"img/oschina.png","modified":0,"renderable":1},{"_id":"themes/yilia/source/img/pinboard.png","path":"img/pinboard.png","modified":0,"renderable":1},{"_id":"themes/yilia/source/img/pinterest.png","path":"img/pinterest.png","modified":0,"renderable":1},{"_id":"themes/yilia/source/img/rss.png","path":"img/rss.png","modified":0,"renderable":1},{"_id":"themes/yilia/source/img/scrollbar_arrow.png","path":"img/scrollbar_arrow.png","modified":0,"renderable":1},{"_id":"themes/yilia/source/img/stackoverflow.png","path":"img/stackoverflow.png","modified":0,"renderable":1},{"_id":"themes/yilia/source/img/twitter.png","path":"img/twitter.png","modified":0,"renderable":1},{"_id":"themes/yilia/source/img/weibo.png","path":"img/weibo.png","modified":0,"renderable":1},{"_id":"themes/yilia/source/img/zhihu.png","path":"img/zhihu.png","modified":0,"renderable":1},{"_id":"themes/yilia/source/js/instagram.js","path":"js/instagram.js","modified":0,"renderable":1},{"_id":"themes/yilia/source/js/jquery.lazyload.js","path":"js/jquery.lazyload.js","modified":0,"renderable":1},{"_id":"themes/yilia/source/js/main.js","path":"js/main.js","modified":0,"renderable":1},{"_id":"themes/yilia/source/js/mobile.js","path":"js/mobile.js","modified":0,"renderable":1},{"_id":"themes/yilia/source/js/pc.js","path":"js/pc.js","modified":0,"renderable":1},{"_id":"themes/yilia/source/css/fonts/fontawesome-webfont.eot","path":"css/fonts/fontawesome-webfont.eot","modified":0,"renderable":1},{"_id":"themes/yilia/source/css/fonts/fontawesome-webfont.svg","path":"css/fonts/fontawesome-webfont.svg","modified":0,"renderable":1},{"_id":"themes/yilia/source/css/fonts/fontawesome-webfont.ttf","path":"css/fonts/fontawesome-webfont.ttf","modified":0,"renderable":1},{"_id":"themes/yilia/source/css/fonts/fontawesome-webfont.woff","path":"css/fonts/fontawesome-webfont.woff","modified":0,"renderable":1},{"_id":"themes/yilia/source/fancybox/helpers/jquery.fancybox-buttons.css","path":"fancybox/helpers/jquery.fancybox-buttons.css","modified":0,"renderable":1},{"_id":"themes/yilia/source/fancybox/helpers/fancybox_buttons.png","path":"fancybox/helpers/fancybox_buttons.png","modified":0,"renderable":1},{"_id":"themes/yilia/source/fancybox/helpers/jquery.fancybox-buttons.js","path":"fancybox/helpers/jquery.fancybox-buttons.js","modified":0,"renderable":1},{"_id":"themes/yilia/source/fancybox/helpers/jquery.fancybox-media.js","path":"fancybox/helpers/jquery.fancybox-media.js","modified":0,"renderable":1},{"_id":"themes/yilia/source/fancybox/helpers/jquery.fancybox-thumbs.css","path":"fancybox/helpers/jquery.fancybox-thumbs.css","modified":0,"renderable":1},{"_id":"themes/yilia/source/fancybox/helpers/jquery.fancybox-thumbs.js","path":"fancybox/helpers/jquery.fancybox-thumbs.js","modified":0,"renderable":1},{"_id":"themes/yilia/source/css/fonts/fontawesome-webfont.svgz","path":"css/fonts/fontawesome-webfont.svgz","modified":0,"renderable":1},{"_id":"source/404.html","path":"404.html","modified":0,"renderable":0},{"_id":"source/CNAME","path":"CNAME","modified":0,"renderable":0},{"_id":"source/baidu_verify_wrSuuz9pXa.html","path":"baidu_verify_wrSuuz9pXa.html","modified":0,"renderable":0},{"_id":"source/google7ed0b016804177b7.html","path":"google7ed0b016804177b7.html","modified":0,"renderable":0},{"_id":"source/data/t_airport_terminal_code.sql","path":"data/t_airport_terminal_code.sql","modified":0,"renderable":0},{"_id":"source/data/t_city.sql","path":"data/t_city.sql","modified":0,"renderable":0},{"_id":"source/libs/commons-pool-1.5.5.jar","path":"libs/commons-pool-1.5.5.jar","modified":0,"renderable":0},{"_id":"source/libs/commons-pool2-2.2.jar","path":"libs/commons-pool2-2.2.jar","modified":0,"renderable":0},{"_id":"source/libs/jedis-2.0.0.jar","path":"libs/jedis-2.0.0.jar","modified":0,"renderable":0},{"_id":"source/libs/tomcat-redis-session-manager-1.2-tomcat-7-1.2.jar","path":"libs/tomcat-redis-session-manager-1.2-tomcat-7-1.2.jar","modified":0,"renderable":0},{"_id":"source/images/1452221174578074.png","path":"images/1452221174578074.png","modified":0,"renderable":0},{"_id":"source/images/QQ20160316-0.png","path":"images/QQ20160316-0.png","modified":0,"renderable":0},{"_id":"source/images/QQ20160316-1.png","path":"images/QQ20160316-1.png","modified":0,"renderable":0},{"_id":"source/images/QQ20160316-2.png","path":"images/QQ20160316-2.png","modified":0,"renderable":0},{"_id":"source/images/QQ20160317-0.png","path":"images/QQ20160317-0.png","modified":0,"renderable":0},{"_id":"source/images/QQ20160317-1.png","path":"images/QQ20160317-1.png","modified":0,"renderable":0},{"_id":"source/images/QQ20160317-2.png","path":"images/QQ20160317-2.png","modified":0,"renderable":0},{"_id":"source/images/QQ20160318-0.png","path":"images/QQ20160318-0.png","modified":0,"renderable":0},{"_id":"source/images/QQ20160318-1.png","path":"images/QQ20160318-1.png","modified":0,"renderable":0},{"_id":"source/images/QQ20160318-2.png","path":"images/QQ20160318-2.png","modified":0,"renderable":0},{"_id":"source/images/QQ20160318-3.png","path":"images/QQ20160318-3.png","modified":0,"renderable":0},{"_id":"source/images/QQ20160321-0.png","path":"images/QQ20160321-0.png","modified":0,"renderable":0},{"_id":"source/images/QQ20160817-0.png","path":"images/QQ20160817-0.png","modified":0,"renderable":0},{"_id":"source/images/add.png","path":"images/add.png","modified":0,"renderable":0},{"_id":"source/images/block-flow-chart.png","path":"images/block-flow-chart.png","modified":0,"renderable":0},{"_id":"source/images/cap-theorem.png","path":"images/cap-theorem.png","modified":0,"renderable":0},{"_id":"source/images/capabilities-on-bgfetch.jpg","path":"images/capabilities-on-bgfetch.jpg","modified":0,"renderable":0},{"_id":"source/images/cas-shiro-auth-flow.png","path":"images/cas-shiro-auth-flow.png","modified":0,"renderable":0},{"_id":"source/images/code_init.png","path":"images/code_init.png","modified":0,"renderable":0},{"_id":"source/images/communication-patterns-flow-chart.png","path":"images/communication-patterns-flow-chart.png","modified":0,"renderable":0},{"_id":"source/images/def_loadview.png","path":"images/def_loadview.png","modified":0,"renderable":0},{"_id":"source/images/delegation-flow-chart.png","path":"images/delegation-flow-chart.png","modified":0,"renderable":0},{"_id":"source/images/delete.png","path":"images/delete.png","modified":0,"renderable":0},{"_id":"source/images/docker-group.png","path":"images/docker-group.png","modified":0,"renderable":0},{"_id":"source/images/docker-hosted.png","path":"images/docker-hosted.png","modified":0,"renderable":0},{"_id":"source/images/docker-images-redis.png","path":"images/docker-images-redis.png","modified":0,"renderable":0},{"_id":"source/images/docker-plugin-image-configuration.png","path":"images/docker-plugin-image-configuration.png","modified":0,"renderable":0},{"_id":"source/images/docker-plugin-notice.png","path":"images/docker-plugin-notice.png","modified":0,"renderable":0},{"_id":"source/images/docker-plugin-remote-connect.png","path":"images/docker-plugin-remote-connect.png","modified":0,"renderable":0},{"_id":"source/images/docker-proxy.png","path":"images/docker-proxy.png","modified":0,"renderable":0},{"_id":"source/images/docker-realms.png","path":"images/docker-realms.png","modified":0,"renderable":0},{"_id":"source/images/dtcs-seq.jpg","path":"images/dtcs-seq.jpg","modified":0,"renderable":0},{"_id":"source/images/edit-scheme-simulate-background-fetch.png","path":"images/edit-scheme-simulate-background-fetch.png","modified":0,"renderable":0},{"_id":"source/images/image_note64270_1.png","path":"images/image_note64270_1.png","modified":0,"renderable":0},{"_id":"source/images/ios-mvc.png","path":"images/ios-mvc.png","modified":0,"renderable":0},{"_id":"source/images/ios-mvvm.png","path":"images/ios-mvvm.png","modified":0,"renderable":0},{"_id":"source/images/java-stream-1.png","path":"images/java-stream-1.png","modified":0,"renderable":0},{"_id":"source/images/java-stream-2.png","path":"images/java-stream-2.png","modified":0,"renderable":0},{"_id":"source/images/kvo-flow-chart.png","path":"images/kvo-flow-chart.png","modified":0,"renderable":0},{"_id":"source/images/list.png","path":"images/list.png","modified":0,"renderable":0},{"_id":"source/images/multi-rocketmq-1.png","path":"images/multi-rocketmq-1.png","modified":0,"renderable":0},{"_id":"source/images/nginx-tomcat-redis.png","path":"images/nginx-tomcat-redis.png","modified":0,"renderable":0},{"_id":"source/images/nginx.png","path":"images/nginx.png","modified":0,"renderable":0},{"_id":"source/images/nginx_auth.png","path":"images/nginx_auth.png","modified":0,"renderable":0},{"_id":"source/images/notification-flow-chart.png","path":"images/notification-flow-chart.png","modified":0,"renderable":0},{"_id":"source/images/obs-1.png","path":"images/obs-1.png","modified":0,"renderable":0},{"_id":"source/images/obs-2.png","path":"images/obs-2.png","modified":0,"renderable":0},{"_id":"source/images/one-way-https.jpg","path":"images/one-way-https.jpg","modified":0,"renderable":0},{"_id":"source/images/performance-optimize.jpg","path":"images/performance-optimize.jpg","modified":0,"renderable":0},{"_id":"source/images/podman-images.png","path":"images/podman-images.png","modified":0,"renderable":0},{"_id":"source/images/rmq-1.png","path":"images/rmq-1.png","modified":0,"renderable":0},{"_id":"source/images/show.png","path":"images/show.png","modified":0,"renderable":0},{"_id":"source/images/spring-mutiview-0.png","path":"images/spring-mutiview-0.png","modified":0,"renderable":0},{"_id":"source/images/spring-mutiview-1.png","path":"images/spring-mutiview-1.png","modified":0,"renderable":0},{"_id":"source/images/spring-mutiview-2.png","path":"images/spring-mutiview-2.png","modified":0,"renderable":0},{"_id":"source/images/spring-mutiview-3.png","path":"images/spring-mutiview-3.png","modified":0,"renderable":0},{"_id":"source/images/spring-mutiview-4.png","path":"images/spring-mutiview-4.png","modified":0,"renderable":0},{"_id":"source/images/spring-mutiview-5.png","path":"images/spring-mutiview-5.png","modified":0,"renderable":0},{"_id":"source/images/spring-mutiview-6.png","path":"images/spring-mutiview-6.png","modified":0,"renderable":0},{"_id":"source/images/spring-mutiview-7.png","path":"images/spring-mutiview-7.png","modified":0,"renderable":0},{"_id":"source/images/target-action-flow-chart.png","path":"images/target-action-flow-chart.png","modified":0,"renderable":0},{"_id":"source/images/two-way-https.jpg","path":"images/two-way-https.jpg","modified":0,"renderable":0},{"_id":"source/images/uiviewcontroller-lifecycle.jpg","path":"images/uiviewcontroller-lifecycle.jpg","modified":0,"renderable":0},{"_id":"source/images/update.png","path":"images/update.png","modified":0,"renderable":0},{"_id":"source/images/vlc-1.png","path":"images/vlc-1.png","modified":0,"renderable":0},{"_id":"source/images/vlc-2.png","path":"images/vlc-2.png","modified":0,"renderable":0},{"_id":"source/images/vts.png","path":"images/vts.png","modified":0,"renderable":0},{"_id":"source/images/xib_init.png","path":"images/xib_init.png","modified":0,"renderable":0},{"_id":"source/images/xopen-dtp.gif","path":"images/xopen-dtp.gif","modified":0,"renderable":0},{"_id":"source/images/zk-cluster-manager.gif","path":"images/zk-cluster-manager.gif","modified":0,"renderable":0},{"_id":"source/images/zk-config-manager.gif","path":"images/zk-config-manager.gif","modified":0,"renderable":0},{"_id":"source/images/zk_data_model.gif","path":"images/zk_data_model.gif","modified":0,"renderable":0},{"_id":"source/images/四大体系.png","path":"images/四大体系.png","modified":0,"renderable":0},{"_id":"source/images/电商业务模块总览.png","path":"images/电商业务模块总览.png","modified":0,"renderable":0}],"Cache":[{"_id":"source/CNAME","hash":"5596d1dd375f5074f1e5e81bcc5b3af3d12aa7d6","modified":1630419791536},{"_id":"source/404.html","hash":"e96149df55b6541ba5b858b4c1c06e580d4c2257","modified":1630419791536},{"_id":"source/baidu_verify_wrSuuz9pXa.html","hash":"c36e9462972e13413f9189d5e8ed5db31e56d901","modified":1630419791554},{"_id":"source/google7ed0b016804177b7.html","hash":"d1d5aa3e5c7a512313bc2b599b35a81a62285961","modified":1630419791559},{"_id":"source/_posts/airport-terminal-code.md","hash":"f0fdf51861a4709dcbf42b377a66a42d6db2e783","modified":1630419791536},{"_id":"source/_posts/architecture-optimize.md","hash":"3e5aea98dccc131ce5a2a3f552845c255d7f8f83","modified":1630461280645},{"_id":"source/_posts/bussiness-market-plan.md","hash":"02048eceb98080c4b9c4cf93c41a4caf910b36dc","modified":1630462185384},{"_id":"source/_posts/bigdata-data-governance.md","hash":"1a6368a96d9803f4b0dd1c9a39642cb0c986b8cf","modified":1630461675369},{"_id":"source/_posts/cas-attribute.md","hash":"008bcafa650474b0825c430af9821b6e0613fe9c","modified":1630419791537},{"_id":"source/_posts/bussiness-operate-target.md","hash":"f49a4cf0c6c6e852b4df42617f1439a4ce944c09","modified":1630462365512},{"_id":"source/_posts/bussiness-operate.md","hash":"5c7d4bdf3fb56038d90dff5bd1953c305c8b4a73","modified":1630462361921},{"_id":"source/_posts/cas-shiro-auth-flow.md","hash":"5dcc8690577826f71f9cfa1be80505326ceb696b","modified":1630419791537},{"_id":"source/_posts/china-city-data.md","hash":"d92a4891e273c126f622b1cb715de27691f55e64","modified":1630419791538},{"_id":"source/_posts/cdt-java.md","hash":"22dd9c987dcdf85e139f6067f619e603d56551c4","modified":1630419791537},{"_id":"source/_posts/cron-expression.md","hash":"a3b3e1c2c4ed5175d4845ce1888ed7042b240adf","modified":1631934155814},{"_id":"source/_posts/data-wh.md","hash":"647470ae3fbe86508e47751a38ee767ade5e9722","modified":1630461554533},{"_id":"source/_posts/demand-source.md","hash":"5cc28b17635a982b343f8fe5886aee3b6d3dddf0","modified":1630460952876},{"_id":"source/_posts/code-findbugs-plugin.md","hash":"3b478053bbb7d1419db634c661edc99e6332b47a","modified":1630566973713},{"_id":"source/_posts/distributed-redis-locked-queue.md","hash":"cca0e942ca4cc99193995354f4ee7fe50667fffc","modified":1631934221855},{"_id":"source/_posts/docker-data-network.md","hash":"836d1d4db8f487d142bcb2e9598143a68a53238b","modified":1630419791539},{"_id":"source/_posts/docker-dockerfile.md","hash":"921f5cbfde66e38ff5c6dbba3c0f0e0a1e74b462","modified":1630419791539},{"_id":"source/_posts/dtcs-seq.md","hash":"1052314c6dc6616f88428f6b7ea4df4202d0a44b","modified":1630419791540},{"_id":"source/_posts/docker-cmd-summarize.md","hash":"326af8582a3a743172b1ae993661ca0061c42e35","modified":1630419791539},{"_id":"source/_posts/docker-install-issue.md","hash":"d3fb484bdeea69c50889b025c3052ddd6edbc25d","modified":1630419791539},{"_id":"source/_posts/e-bussiness-architecture.md","hash":"a2e3b4f3e030d0ca6093dcaef0f9c0105948f29c","modified":1630419791540},{"_id":"source/_posts/ggcode-lib.md","hash":"00ec28f4a43077a2a43fb44515fcd39e3d04d0b6","modified":1630419791540},{"_id":"source/_posts/google-pagination-note.md","hash":"c3b7e313919882838b00f6333724f2f05691d06c","modified":1630419791541},{"_id":"source/_posts/header-version.md","hash":"ed22000eb1bb82df7876b0076f8e130f1cf29f88","modified":1630419791541},{"_id":"source/_posts/https-cr-demo.md","hash":"386ec60baeebdfe7fdec6d2580b58f71c747369f","modified":1630419791541},{"_id":"source/_posts/ios-hitTest.md","hash":"31237e91cac24346d8f36f19d973317430c9ad42","modified":1630419791541},{"_id":"source/_posts/https-flow.md","hash":"20d39678a9807cd7316af5bf4066a1078b8871b7","modified":1630419791541},{"_id":"source/_posts/ios-layoutsubviews.md","hash":"c26f3622675f2d562d98ad7879906cd97b1425d2","modified":1630419791542},{"_id":"source/_posts/ios-loadview.md","hash":"8401af5dd2d2c9f9c9c894c0a480af459b471918","modified":1630419791542},{"_id":"source/_posts/ios-load-initialize.md","hash":"c95efc49177a1427cd2237fe9aade6110aabe9cc","modified":1631934172742},{"_id":"source/_posts/ios-local-notification.md","hash":"2a1314ac8047eef8c1bfa97ac82c22bfc73786d8","modified":1630419791542},{"_id":"source/_posts/ios-msg-transfer.md","hash":"93312ab591e21aacf7f3edf6a5958ee33612e07b","modified":1630419791543},{"_id":"source/_posts/ios-mvvm.md","hash":"09bf7d441b7ae61e577cd07f16d6afa42635fa04","modified":1630419791543},{"_id":"source/_posts/ios-muti-task.md","hash":"8fd6bfb2791f471b8e44277ba0b64b44b5e96dac","modified":1630419791543},{"_id":"source/_posts/ios-sendmsg.md","hash":"9ddb3fc24b85301efff5a5dd8edd2138e1fe5045","modified":1630419791544},{"_id":"source/_posts/java-script-engine.md","hash":"5c7e61dae2261e4756b7aaa1e7a8be2bde467cc5","modified":1630419791544},{"_id":"source/_posts/jvm-tools-jmap.md","hash":"1bcc38009fba6c96e32c2480c2756496124648f8","modified":1631934239590},{"_id":"source/_posts/jvm-tools-jstat.md","hash":"d736e3cceee45b12198de76aac95849bf8c4c786","modified":1630419791545},{"_id":"source/_posts/linux-cmd-notes.md","hash":"3f85eb10907957b2309e60acd55eb386fc821145","modified":1630419791545},{"_id":"source/_posts/linux-autostart.md","hash":"4401b70e1a51b54eaeffb273b931a0a9bab88e72","modified":1630419791545},{"_id":"source/_posts/java8-stream.md","hash":"3a81408590ae88c7826340ea70a928259757d042","modified":1631942398729},{"_id":"source/_posts/linux-crontab.md","hash":"d125c22381ec818fb69acd65d3ddfef8ce805453","modified":1630461795528},{"_id":"source/_posts/maven-deploy.md","hash":"62278887b12f7e1a84614e010d9dea640c623cb1","modified":1630419791546},{"_id":"source/_posts/linux-strace.md","hash":"d4dd48a9bfb73e1ce805af200fdca3377e6f2a13","modified":1631942036724},{"_id":"source/_posts/linux-remote.md","hash":"9c9f9b755c5dd55512bbbcb8616f9e428977fb5c","modified":1630582401283},{"_id":"source/_posts/maven-profile.md","hash":"298330fae8672347339d9a6636205c589a8b4118","modified":1630419791546},{"_id":"source/_posts/module-multi-rocketmq.md","hash":"5a480e9f61c9a0dcb3ae7267b504ac1f9465923f","modified":1630419791546},{"_id":"source/_posts/maven-source-doc.md","hash":"fa46620ce6c2113fc65db75c2747ca8cbb1b94ba","modified":1630419791546},{"_id":"source/_posts/mq-rocketmq-manuals.md","hash":"15efa428f049061bc7baf3ae5e105385ba25c0af","modified":1631934279241},{"_id":"source/_posts/multi-process-read.md","hash":"14c81016ae45ed094e1c4808b1034a8de71051db","modified":1630419791547},{"_id":"source/_posts/mq-rocketmq-module.md","hash":"d9cb6df9ca3f4b1aeafab0c3d69c67b7a5ce076e","modified":1630419791547},{"_id":"source/_posts/mysql-lock-transaction.md","hash":"f1559f2e880e2cb5d7122c7d1f1f66ea850b8487","modified":1631934318704},{"_id":"source/_posts/nginx-install.md","hash":"d672cf3b113dcea6306c203da2a5a77dc76c8b58","modified":1630419791547},{"_id":"source/_posts/nginx-muti-domain.md","hash":"e2cdf6fdb67311570be581a1cd3cb54c57ca8159","modified":1630419791547},{"_id":"source/_posts/nginx-upgrade.md","hash":"b93ee79d916d060264632206fee6819efa813456","modified":1630419791548},{"_id":"source/_posts/nginx-upstream-jvm-route.md","hash":"8fc7dfdc49db6b56cb363cb541a5e13a689509aa","modified":1630419791548},{"_id":"source/_posts/nginx-log-config.md","hash":"7d4e87cacfeaa8e742f1aaeb25e978391d60a085","modified":1630460417385},{"_id":"source/_posts/nginx-rtmp-obs.md","hash":"66efe0a92ddca61cf3ea8b4d85403d3e43a01e53","modified":1630419791548},{"_id":"source/_posts/os-port-forward.md","hash":"a1d95490c593e560a0908260f5cef5998a3e2d25","modified":1630419791548},{"_id":"source/_posts/podman-dockerfile-maven-plugin.md","hash":"26c99ee19310e1eb2e04899a6ff4bd58efa3c060","modified":1632825809187},{"_id":"source/_posts/no-transaction.md","hash":"8685002a41f048c747a8527420b65e0b0a879452","modified":1630419791548},{"_id":"source/_posts/php-fpm.md","hash":"28cf0783d3b31fe58844ff40cd166b0c7e53fb19","modified":1630419791549},{"_id":"source/_posts/podman-env-install.md","hash":"c5360b552514b4abb792c68eef33f9d09f1780a4","modified":1632714401296},{"_id":"source/_posts/redis-advanced.md","hash":"d2590189449b156ac669b4da169d4041d2d2adc6","modified":1630419791549},{"_id":"source/_posts/redis-cluster-note.md","hash":"086e51e81297d9c23d8af3f8b6007dd2dc07a45f","modified":1630419791549},{"_id":"source/_posts/podman-ideaj-docker-plugin.md","hash":"1319fe525ef647dcd4367232510fdd8fb7a5823b","modified":1632825407639},{"_id":"source/_posts/redis-data-type.md","hash":"ebcee8a3788501cc545c72faaa6e5281f8b7bffb","modified":1630419791549},{"_id":"source/_posts/podman-private-svr.md","hash":"0345f4940b87e450a2cb33ef5e6f2fc09f0b6a6c","modified":1632817576938},{"_id":"source/_posts/shiro-restful-api-session.md","hash":"40b589f5e7c8f521aff0058f96d0c6733c9fa178","modified":1630419791549},{"_id":"source/_posts/software-test-point.md","hash":"e97bfb5008b7d5ca09cbc39b235b00d5973d4644","modified":1630419791549},{"_id":"source/_posts/shiro-smscode-auth.md","hash":"0bee70ef5f9bd172ed9c304a7872b352401f9858","modified":1630419791549},{"_id":"source/_posts/spring-compositeCacheManager.md","hash":"df9080c12b791de4e559b025f50204f41fc506f4","modified":1630419791550},{"_id":"source/_posts/spring-initializingbean.md","hash":"11d679dbae54e9320a35fdea17b9a596a6ae0d9f","modified":1630419791550},{"_id":"source/_posts/spring-aop-annotation.md","hash":"c8ce0a358976f8eef333eb142af128390602ce1d","modified":1630419791550},{"_id":"source/_posts/spring-core-interface.md","hash":"75b1f44b618c90ae3fbfb328699f5d8138fd7ede","modified":1630419791550},{"_id":"source/_posts/springboot-step1.md","hash":"0147ef798eee92a88dc93a448e0c70c2ce7baae9","modified":1630419791551},{"_id":"source/_posts/spring-mutiview.md","hash":"58b16503babb3e689a47a6beaa18335aac044f5f","modified":1630419791550},{"_id":"source/_posts/started.md","hash":"4c6801f14aafa6a470e48e97c5fcac91626305bc","modified":1630419791552},{"_id":"source/_posts/springcloud-step1.md","hash":"6f990a651f40412f0e5afef74151af889074a2b5","modified":1630419791551},{"_id":"source/_posts/store-flag-bit.md","hash":"27a4e082bee47417c23b457ee86ad5903b6db085","modified":1630419791552},{"_id":"source/_posts/system-main-fn.md","hash":"b660f3959e0f60842eddcaf038ea3fbcd5ced70a","modified":1630462305297},{"_id":"source/_posts/string-format.md","hash":"ebe9d94de0ed777903e583e649992d9a26acb30a","modified":1631934332967},{"_id":"source/_posts/tech-company.md","hash":"1d310976bced65a75de76ffb485e6b3c9032168c","modified":1630461426619},{"_id":"source/_posts/thinkpad-battery-limit.md","hash":"0fad1788b464ffe79aca5bee848a3bc53ee66b49","modified":1630419791552},{"_id":"source/_posts/tomcat-redis-session.md","hash":"0c478fbaf36073febef7b1d4ef94e167a90e1250","modified":1630419791552},{"_id":"source/_posts/transaction-distributed.md","hash":"98602e42e0dd7d8f1932a3cb44b9e2e1202a2fac","modified":1630419791553},{"_id":"source/_posts/transaction-mark-rollbackonly.md","hash":"fcbf1e97d1da232f25ceede48295c7ccdf0f7195","modified":1630419791553},{"_id":"source/_posts/zookeeper-note.md","hash":"71cc538ea06c51ddda4d46c4f08f232a1e47d444","modified":1630419791553},{"_id":"source/_posts/transaction-isolation-levels.md","hash":"cc20580e973d732631c07caf9ba4729b0a2c64d8","modified":1631934328371},{"_id":"source/libs/tomcat-redis-session-manager-1.2-tomcat-7-1.2.jar","hash":"2c59f54408b0ee30279189863d5387ad6b5759cc","modified":1630419791670},{"_id":"source/images/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1632715506275},{"_id":"source/images/QQ20160316-0.png","hash":"a8ae0d167e5e8fa72e6d70cfc222d0338f484bfe","modified":1630419791563},{"_id":"source/images/QQ20160316-1.png","hash":"e0195155c9ec7eda965abc23c52509d52611e1d4","modified":1630419791564},{"_id":"source/images/QQ20160317-0.png","hash":"9229b7041193094fa8656d0e8711d9f86a49946e","modified":1630419791570},{"_id":"source/images/QQ20160317-1.png","hash":"17fa5f00f6e6f01b5a8eb1b31d1c504c231aced6","modified":1630419791570},{"_id":"source/images/QQ20160317-2.png","hash":"d4b8ebd1c3f5b65c02147311e8794485389616f8","modified":1630419791570},{"_id":"source/images/QQ20160318-0.png","hash":"f0864b2a6c1f831f8c335c4e69aa8aa91218c9ca","modified":1630419791571},{"_id":"source/images/QQ20160318-1.png","hash":"25cd039a53ce7be2cc242064e3cd4e8080672641","modified":1630419791572},{"_id":"source/images/cap-theorem.png","hash":"ae672dd4361dd87e4b62ff31005ef5e8b294442d","modified":1630419791585},{"_id":"source/images/code_init.png","hash":"a5cf7d6f9de5d4a2cd8d454457d018c1b67f7d63","modified":1630419791590},{"_id":"source/images/def_loadview.png","hash":"de652e800e0ba147b24a4bb6becf7947c8a9caf6","modified":1630419791592},{"_id":"source/images/ios-mvvm.png","hash":"7a82e95897f92653b781b776ce1e53f0fc1cbe84","modified":1630419791611},{"_id":"source/about/index.md","hash":"c709ac0c25e737996099411af8b3c21fa51a4fd4","modified":1630419791554},{"_id":"source/images/multi-rocketmq-1.png","hash":"b12aed4a295e83911ce26c86ce90b9450da21c94","modified":1630419791616},{"_id":"source/images/nginx-tomcat-redis.png","hash":"92afb600c8444a34673d23e87b81a8d7ac2d7a8e","modified":1630419791616},{"_id":"source/images/nginx_auth.png","hash":"6d3075c028e961bcd19f60e3959bd3f9eec16fda","modified":1630419791617},{"_id":"source/images/nginx.png","hash":"b90011b4d89245d1ea7ac0f361e97abcb24933d1","modified":1630419791617},{"_id":"source/images/obs-1.png","hash":"012ef39a74807d0b3f5fa3d71fccc8665c7eb703","modified":1630419791621},{"_id":"source/images/obs-2.png","hash":"7ce12a3a49b47f9bf2a4275237b892becc78ec5c","modified":1630419791621},{"_id":"source/images/rmq-1.png","hash":"fc0746dd6c95192a50b191bbc54884801f18566a","modified":1630419791626},{"_id":"source/images/spring-mutiview-2.png","hash":"2335e31443bd43a7e846df8975758a9acb552fca","modified":1630419791629},{"_id":"source/images/spring-mutiview-1.png","hash":"6dc6a225df943768dcd0a7060f219179d7fed525","modified":1630419791629},{"_id":"source/images/uiviewcontroller-lifecycle.jpg","hash":"56f54fb04ffcd74b04aa276266b6360195d40c51","modified":1630419791646},{"_id":"source/images/vlc-2.png","hash":"7e590049be829e01c71c943881c5c027090f6d9b","modified":1630419791649},{"_id":"source/images/xopen-dtp.gif","hash":"32faf7790b973bed2959eca3c4a8c698e7ece485","modified":1630419791653},{"_id":"source/images/vlc-1.png","hash":"b750d76cf2510294fdaa8b34cf2f6e603ab2e54a","modified":1630419791649},{"_id":"source/images/xib_init.png","hash":"32b2312313e0be0a5f978a4ca39129b5e0b0a318","modified":1630419791652},{"_id":"source/images/zk_data_model.gif","hash":"ef39da363e5a7a744a7870a4d3ad1651093abe2e","modified":1630419791661},{"_id":"source/images/zk-cluster-manager.gif","hash":"a18bec8dc9248e5225d6d68a1e923335c2732679","modified":1630419791656},{"_id":"source/libs/commons-pool-1.5.5.jar","hash":"7d8ffbdc47aa0c5a8afe5dc2aaf512f369f1d19b","modified":1630419791667},{"_id":"source/images/1452221174578074.png","hash":"d124e45f6d9b2db2cafc7414cca8d3f93f1cfad4","modified":1630419791562},{"_id":"source/images/QQ20160316-2.png","hash":"e01c8b8f052683f8f3b3cac71b4a2607069413bb","modified":1630419791567},{"_id":"source/images/QQ20160318-2.png","hash":"bd6252a4dac27b765f74f73d56e442d9c152f95d","modified":1630419791574},{"_id":"source/libs/commons-pool2-2.2.jar","hash":"bd1a6e384f3cf0f9b9a60e1e6c1c1ecbbee7e0b7","modified":1630419791668},{"_id":"source/libs/jedis-2.0.0.jar","hash":"83fd129417dab44c09d85f8e125fe8007ee52bc7","modified":1630419791670},{"_id":"source/images/QQ20160318-3.png","hash":"167c87b197a36efc1d675c5e751809629e504a5c","modified":1630419791575},{"_id":"source/images/QQ20160321-0.png","hash":"e801b1b6eabaa5c6053a66d0b98f7c3f03142d04","modified":1630419791577},{"_id":"source/images/add.png","hash":"b981637f1b5a973adf6ab400ce975222f244ef49","modified":1630419791582},{"_id":"source/images/capabilities-on-bgfetch.jpg","hash":"d8253bc306cb7551af326e6cd242d31919957af2","modified":1630419791586},{"_id":"source/images/communication-patterns-flow-chart.png","hash":"56d22932f27d7209e1f0b2e7a7e1950340445a41","modified":1630419791592},{"_id":"source/images/delegation-flow-chart.png","hash":"825b24a956fd0e1643d128584caaa01bcc57db47","modified":1630419791594},{"_id":"source/images/delete.png","hash":"5e4de75faf5a5c161345a08a969aa92a27276954","modified":1630419791597},{"_id":"source/images/docker-plugin-image-configuration.png","hash":"8c982e9d3c89fc6600387d86434d9586df750c3a","modified":1632816668599},{"_id":"source/images/zk-config-manager.gif","hash":"f493011fdabd0f2c5e953c50f222912f1058ed3d","modified":1630419791660},{"_id":"source/images/block-flow-chart.png","hash":"102fe272596f6482c8fa57acd520d867c8b9a662","modified":1630419791584},{"_id":"source/images/cas-shiro-auth-flow.png","hash":"e0d26b7f5aba0092643149ad94bd6c5501a304f7","modified":1630419791589},{"_id":"source/images/docker-realms.png","hash":"fb1716f9012666313d466184f3322a5c0f6f3f13","modified":1632715706583},{"_id":"source/images/image_note64270_1.png","hash":"421b8cab3a182b6caa709a5d2cc06b7073ab3380","modified":1630419791600},{"_id":"source/images/kvo-flow-chart.png","hash":"1ec1708eb128985eb2b3877cbab83b2f0375fcbc","modified":1630419791613},{"_id":"source/images/list.png","hash":"ef0b3a113f9dffa7f4d6984752088c57e661d8b0","modified":1630419791615},{"_id":"source/images/edit-scheme-simulate-background-fetch.png","hash":"0c3febd99f08d3e120b346716d61db9760ee690b","modified":1630419791599},{"_id":"source/images/docker-plugin-remote-connect.png","hash":"bf392f161005a89b29739969e3d84353d0985d30","modified":1632796476808},{"_id":"source/images/docker-plugin-notice.png","hash":"ad9eaeac79e5e421d2c2c45c9747c4e41f27adbc","modified":1632817271548},{"_id":"source/images/java-stream-1.png","hash":"a868097fa23e5bfb1b06ae4c16c12ca3b5c81c11","modified":1631934828294},{"_id":"source/images/notification-flow-chart.png","hash":"aee495c8c0ee05c86d2a3223d9ec331b7e7d8b7e","modified":1630419791619},{"_id":"source/images/spring-mutiview-0.png","hash":"fe021f593b4b02e4772ad11f0577647810c5ebdb","modified":1630419791628},{"_id":"source/images/show.png","hash":"ac12fdc53fac75316745869bd54fbdc58232fd8d","modified":1630419791627},{"_id":"source/images/spring-mutiview-7.png","hash":"bd121ffa50e327882c5aa9a07473b84ce7dbd950","modified":1630419791638},{"_id":"source/images/target-action-flow-chart.png","hash":"078a5bb159e89978663f8aca09490b5ec36d4d8e","modified":1630419791639},{"_id":"source/images/vts.png","hash":"8103c6089c64060a4f1ce84d72227c381414251e","modified":1630419791651},{"_id":"source/images/spring-mutiview-3.png","hash":"5916496ea9b196d4e66f9f88d2a58d6b453a564f","modified":1630419791630},{"_id":"source/images/spring-mutiview-4.png","hash":"d0cb72f1872524af704b133d937c509d7834b5a2","modified":1630419791632},{"_id":"source/images/四大体系.png","hash":"aa146685c5f96e229f6d6a11fa60d7a3027ea056","modified":1630419791662},{"_id":"source/images/电商业务模块总览.png","hash":"38288a96dc371e64bf976e9e5ca6f5b90639c3b4","modified":1630419791665},{"_id":"source/images/docker-group.png","hash":"6416d3706ba508a1bdd698856a38795ada11d431","modified":1632715494029},{"_id":"source/images/docker-hosted.png","hash":"c51a73892520c5cc693739d217a34e5c91dccf62","modified":1632715180837},{"_id":"source/images/docker-images-redis.png","hash":"9fb7293ea58dcd3ae08b18fe3fff6f7bf5102ca6","modified":1632716490766},{"_id":"source/images/docker-proxy.png","hash":"16b544b5ab3d658861be8d2e86b6cf319415ec17","modified":1632715315057},{"_id":"source/images/dtcs-seq.jpg","hash":"8e0709b6ed5326ac1acffbf9e7dd074d0deacb49","modified":1630419791598},{"_id":"source/images/java-stream-2.png","hash":"1427b010d82af884c54174fe4f7da989403c84d6","modified":1631935506900},{"_id":"source/images/podman-images.png","hash":"45678886fd5fc74f102432fc26b27f3f9b87fe95","modified":1632817358959},{"_id":"source/images/spring-mutiview-5.png","hash":"f530629e3b711b9fbbf7d1cf648c84bee6f912bc","modified":1630419791633},{"_id":"source/images/update.png","hash":"91d59f94a3fb3ccfc3744bb3b5122d734c3a1e85","modified":1630419791648},{"_id":"source/images/spring-mutiview-6.png","hash":"2b7fc1ec3d920d5f8628871dbe7fe6617d28d3c2","modified":1630419791636},{"_id":"source/images/QQ20160817-0.png","hash":"ff1f6654b697b37149f751345671f7514c46df76","modified":1630419791580},{"_id":"source/images/one-way-https.jpg","hash":"531ad36c6ec0f78ba01b9cefd9a500bf3f4f0a71","modified":1630419791625},{"_id":"source/images/performance-optimize.jpg","hash":"ff6993070f854c16d8cdaa87fae0dbb1bcdaaecd","modified":1591702080346},{"_id":"source/images/two-way-https.jpg","hash":"2368244fc0e7fbbc4b09699609a6bc7b1a967130","modified":1630419791644},{"_id":"source/data/t_airport_terminal_code.sql","hash":"725f266ff8c9f763e2dbd2a9073e09219f206914","modified":1630419791557},{"_id":"source/data/t_city.sql","hash":"cabb4f7396ddb431038bbc863468923c5c0522f3","modified":1630419791559},{"_id":"themes/yilia/_config.yml","hash":"4b29fd5bdbb86b9ac5dd1e4a0a7a24741d57704b","modified":1632887545734},{"_id":"themes/yilia/package.json","hash":"00357ef6f24eb049074da81809e98f973f528cca","modified":1630419791702},{"_id":"themes/yilia/languages/de.yml","hash":"ecb13af8af81ccc033ae7494cb2f94f84f6466ad","modified":1630419791695},{"_id":"themes/yilia/README.md","hash":"8648a81b3ae08a4accd6b0541533e662511e6400","modified":1630419791695},{"_id":"themes/yilia/languages/default.yml","hash":"3717fd994ba464eda30dd53cb1069f9ec5447d31","modified":1630468795127},{"_id":"themes/yilia/languages/en.yml","hash":"4ae39543807fe41aae78a7981ad905960997f66c","modified":1630419791696},{"_id":"themes/yilia/languages/fr-FR.yml","hash":"12cfa96dc412ecb6f8bf4de2690575929464906e","modified":1630419791696},{"_id":"themes/yilia/languages/zh-Hans.yml","hash":"1f624b7f52899d8d704f43fa887f75bdf7c4113d","modified":1630468769335},{"_id":"themes/yilia/languages/ru.yml","hash":"9997425292031ee8a58a93346ac6d3f38f18e566","modified":1630419791696},{"_id":"themes/yilia/languages/zh-hk.yml","hash":"606dfb34d3fec1d7895a654ff7a5a1de0c6a5c55","modified":1630419791697},{"_id":"themes/yilia/layout/category.ejs","hash":"765426a9c8236828dc34759e604cc2c52292835a","modified":1630419791701},{"_id":"themes/yilia/layout/archive.ejs","hash":"2703b07cc8ac64ae46d1d263f4653013c7e1666b","modified":1630419791700},{"_id":"themes/yilia/layout/index.ejs","hash":"aa1b4456907bdb43e629be3931547e2d29ac58c8","modified":1630419791701},{"_id":"themes/yilia/layout/layout.ejs","hash":"4a5566f704f3246f5ef77badddf18d2e16750328","modified":1630419791701},{"_id":"themes/yilia/layout/page.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1630419791701},{"_id":"themes/yilia/layout/post.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1630419791701},{"_id":"themes/yilia/layout/tag.ejs","hash":"eaa7b4ccb2ca7befb90142e4e68995fb1ea68b2e","modified":1630419791701},{"_id":"themes/yilia/layout/_partial/archive-post.ejs","hash":"da1b90452acee43b65cf7b011d02b0ce373bbbf8","modified":1630419791697},{"_id":"themes/yilia/layout/_partial/after-footer.ejs","hash":"2096691a7b07e2b2073aa4b8ab6f1a7382523f5c","modified":1632888009798},{"_id":"themes/yilia/layout/_partial/article.ejs","hash":"242aebdde35f8f11a99952c4d006e2989d942af5","modified":1630419791698},{"_id":"themes/yilia/layout/_partial/archive.ejs","hash":"e817d187e27246f5342d543731d8fd96977b3937","modified":1630468887520},{"_id":"themes/yilia/layout/_partial/google-analytics.ejs","hash":"f921e7f9223d7c95165e0f835f353b2938e40c45","modified":1630419791698},{"_id":"themes/yilia/layout/_partial/footer.ejs","hash":"f2994e0acd1d606ebf4680afc4fa652e148ccf4e","modified":1630419791698},{"_id":"themes/yilia/layout/_partial/baidu-analytics.ejs","hash":"9ed2b261a0429d0656de175bfe5043255dc45b98","modified":1632887458927},{"_id":"themes/yilia/layout/_partial/header.ejs","hash":"6387a93dad7c3d778eb91e3821852fbf6813880c","modified":1630419791698},{"_id":"themes/yilia/layout/_partial/highlight.ejs","hash":"e26032892f6ef37ff8e62e3f046135a87b8cf282","modified":1630419791699},{"_id":"themes/yilia/layout/_partial/left-col.ejs","hash":"6f9e2aa1c5bf89793cc6080520bbb8d720866256","modified":1630467477021},{"_id":"themes/yilia/layout/_partial/head.ejs","hash":"8c7387d4fa84c3ed455aa3a604af23a242a01f1c","modified":1632888070227},{"_id":"themes/yilia/layout/_partial/mathjax.ejs","hash":"54fab4d3d64cb937d6baec7324ffabf9f202b883","modified":1630419791699},{"_id":"themes/yilia/layout/_partial/mobile-nav.ejs","hash":"445da689e55e9026ecb304b36e8360dfcc07f9eb","modified":1632890434960},{"_id":"themes/yilia/source/css/_extend.styl","hash":"8ab1ad313bd6707d248c5ca1ee9a5eab8d815e42","modified":1630419791702},{"_id":"themes/yilia/source/css/_variables.styl","hash":"8b63ea3c7199524b9a1541075c6f8fb2c0d0ea3d","modified":1630419791706},{"_id":"themes/yilia/source/css/style.styl","hash":"456e8cfe3b0b0371e81848ea9b0bc7ffd5360921","modified":1630419791712},{"_id":"themes/yilia/source/fancybox/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1630419791713},{"_id":"themes/yilia/source/fancybox/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1630419791712},{"_id":"themes/yilia/source/fancybox/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1630419791713},{"_id":"themes/yilia/source/fancybox/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1630419791713},{"_id":"themes/yilia/source/fancybox/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1630419791714},{"_id":"themes/yilia/source/fancybox/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1630419791714},{"_id":"themes/yilia/source/fancybox/jquery.fancybox.css","hash":"b6aa6692c2e5f8bd74d96827b78570f0c5683c20","modified":1630419791715},{"_id":"themes/yilia/source/img/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1630484100832},{"_id":"themes/yilia/source/fancybox/jquery.fancybox.js","hash":"a82597493d75ea989ca586e09173cff332efe41e","modified":1630419791715},{"_id":"themes/yilia/source/fancybox/jquery.fancybox.pack.js","hash":"9e0d51ca1dbe66f6c0c7aefd552dc8122e694a6e","modified":1630419791715},{"_id":"themes/yilia/source/img/coderwall.png","hash":"fa84676c4d654e040e51fd34bfcd9f9348cd5331","modified":1630419791717},{"_id":"themes/yilia/source/img/delicious.png","hash":"9553a5f5189e4a953e04a58a49dbfa74b86b73dd","modified":1630419791717},{"_id":"themes/yilia/source/img/facebook.png","hash":"d19ad7a0903daf26817afd8753cd97e0cc714f54","modified":1630419791718},{"_id":"themes/yilia/source/img/douban.png","hash":"e2ade003ffadd5826ee66ec23901c2d6e8607e4e","modified":1630419791718},{"_id":"themes/yilia/source/img/img-err.png","hash":"23a63ea26eb3c1d5e677d9883cf36cc1a1a1228b","modified":1630419791718},{"_id":"themes/yilia/source/img/github.png","hash":"b84d03b32fa388dcbf149296ebd16dce6223d48d","modified":1630419791718},{"_id":"themes/yilia/source/img/google.png","hash":"61a21fec7346fa3400b747ac9a201cf3d5bc013d","modified":1630419791718},{"_id":"themes/yilia/source/img/img-loading.png","hash":"a9cd5cd11866824f31e3d1c5e23badfeb3f73031","modified":1630419791719},{"_id":"themes/yilia/source/img/mail.png","hash":"fca8199cc77fdbd700a45bf56d091c82f4a67fe7","modified":1630419791719},{"_id":"themes/yilia/source/img/linkedin.png","hash":"e203138fb53c257cb214e97f4e30091b9c568d2c","modified":1630419791719},{"_id":"themes/yilia/source/img/oschina.png","hash":"af975deb0fd94e2f3015567333d3c50aea9e2591","modified":1630419791719},{"_id":"themes/yilia/source/img/pinboard.png","hash":"0891fbb6d092fa012bf936019923383d84c6aeb0","modified":1630419791719},{"_id":"themes/yilia/source/img/pinterest.png","hash":"9c72917f8779c083157c6ce7a5d62ed4874f0630","modified":1630419791720},{"_id":"themes/yilia/source/img/scrollbar_arrow.png","hash":"d64a33c4ddfbdb89deeb6f4e3d36eb84dc4777c0","modified":1630419791720},{"_id":"themes/yilia/source/img/rss.png","hash":"430fd47340e75214c081abd05cd7410cf7c71b86","modified":1630419791720},{"_id":"themes/yilia/source/img/stackoverflow.png","hash":"da5dfe9043055c95e479d49c78cd3b020de608f2","modified":1630419791720},{"_id":"themes/yilia/source/img/twitter.png","hash":"14dbb8e62d056525253bc0de13acd1723da7a934","modified":1630419791720},{"_id":"themes/yilia/source/img/weibo.png","hash":"280dae3fd38086158b4a1b57edb94c06b1a5014b","modified":1630419791720},{"_id":"themes/yilia/source/img/zhihu.png","hash":"a6d6ef65e9ac82e613a311810391ebb90d9b1c1d","modified":1630419791721},{"_id":"themes/yilia/source/js/instagram.js","hash":"81e13cacf4947118ed1920e59b04ccf6beef6b86","modified":1630419791721},{"_id":"themes/yilia/source/js/jquery.lazyload.js","hash":"c11a2e7b330d16d06feabd0a8477099adf9d6799","modified":1630419791721},{"_id":"themes/yilia/source/js/main.js","hash":"e2633f282e377a4169649c9f17dc96036ad4fc64","modified":1630419791722},{"_id":"themes/yilia/source/js/pc.js","hash":"a5397d34a04084ee089b4b1e26457ab46ecea63e","modified":1630419791722},{"_id":"themes/yilia/source/js/mobile.js","hash":"b68cc01d24e80973c48205f551da87f3f3427644","modified":1630419791722},{"_id":"themes/yilia/layout/_partial/post/date.ejs","hash":"c0c988334e857a77ba455a056dfa21809e7e76a5","modified":1630419791699},{"_id":"themes/yilia/layout/_partial/post/analysis.ejs","hash":"a70bd528316df77335467cafe69477fd3224b757","modified":1630419791699},{"_id":"themes/yilia/layout/_partial/post/category.ejs","hash":"d4f0e36f9a2167e91082dbd7d52425a06d2bebbf","modified":1630419791699},{"_id":"themes/yilia/layout/_partial/post/duoshuo.ejs","hash":"e8399025ed3b980aedb821c92855889f5f12fd5b","modified":1630419791700},{"_id":"themes/yilia/layout/_partial/post/share_addthis.ejs","hash":"0ac35bd92e58983c189ac0c35df404ebc6ee826e","modified":1630419791700},{"_id":"themes/yilia/layout/_partial/post/nav.ejs","hash":"d19dee2082528e1844bed3aa4e4bd59f15fd7a7a","modified":1630419791700},{"_id":"themes/yilia/layout/_partial/post/tag.ejs","hash":"78612cfc091d7d861a70455a0dc8c3036e460879","modified":1630419791700},{"_id":"themes/yilia/layout/_partial/post/share_jia.ejs","hash":"924744aa3c1bce9056ba03cec02e19e095009126","modified":1630419791700},{"_id":"themes/yilia/layout/_partial/post/title.ejs","hash":"2f275739b6f1193c123646a5a31f37d48644c667","modified":1630419791700},{"_id":"themes/yilia/layout/_partial/post/uyan.ejs","hash":"9da475dcd62622da0c3560c60ef3ae7e4e19ca6a","modified":1630419791700},{"_id":"themes/yilia/source/css/_partial/archive.styl","hash":"8b349f1605024dcdae054e04f02d71a2e84957c2","modified":1630419791702},{"_id":"themes/yilia/source/css/_partial/footer.styl","hash":"7ca837a4cc34db1c35f01baec85eb10ccc64ea86","modified":1630419791703},{"_id":"themes/yilia/source/css/_partial/article.styl","hash":"7dead6ab6c9ea8adf35fb83496398063cc0260f7","modified":1630419791702},{"_id":"themes/yilia/source/css/_partial/header.styl","hash":"67e59feb18eee6026717cb440d86ab9551782628","modified":1630419791703},{"_id":"themes/yilia/source/css/_partial/highlight.styl","hash":"08d3205dde3235f3e6881126268e6c473f46a8ac","modified":1630419791703},{"_id":"themes/yilia/source/css/_partial/instagram.styl","hash":"8a7b07bf5ea2d3588c0019f722c245bb1a8696af","modified":1630419791703},{"_id":"themes/yilia/source/css/_partial/main.styl","hash":"7d9bd36b8a864f73200d54f17c1fe6989002cdf7","modified":1630419791703},{"_id":"themes/yilia/source/css/_partial/mobile-slider.styl","hash":"e19c7fae6968ad3ea6cfc110900a991f9b5fce31","modified":1630419791703},{"_id":"themes/yilia/source/css/_partial/page.styl","hash":"720b5b169bc28ccba3794efce9b7cd39f243dec7","modified":1630419791704},{"_id":"themes/yilia/source/css/_partial/mobile.styl","hash":"778d4410f29de18ab9e0809aadbbd952c90b9c9c","modified":1630419791703},{"_id":"themes/yilia/source/css/_partial/scroll.styl","hash":"5539a38f9acd603d453a0ea0d8ce10893cf83d22","modified":1630419791704},{"_id":"themes/yilia/source/css/_partial/tagcloud.styl","hash":"af0115de5c6455f899a2e09225b50224982c039d","modified":1630419791704},{"_id":"themes/yilia/source/css/_partial/share.styl","hash":"22697b9a9877ab9f018364feb57aeea4a8313c9a","modified":1630419791704},{"_id":"themes/yilia/source/css/_util/grid.styl","hash":"1aa883ab432d9e4139c89dcbd40ae2bd1528d029","modified":1630419791705},{"_id":"themes/yilia/source/css/_util/mixin.styl","hash":"429bad87fc156eacf226c5e35b0eafc277f2504b","modified":1630419791706},{"_id":"themes/yilia/source/css/_partial/wheelmenu.styl","hash":"74630c56944e27bef53ef0c0e391611a2eec2ed0","modified":1630419791705},{"_id":"themes/yilia/source/css/fonts/fontawesome-webfont.ttf","hash":"1480b8101b02da9bc4c60341b5e185e63e585064","modified":1630419791711},{"_id":"themes/yilia/source/css/fonts/fontawesome-webfont.eot","hash":"3ce87b82c7a4ffdf65e96765c2ffda10b1a283c6","modified":1630419791707},{"_id":"themes/yilia/source/css/fonts/fontawesome-webfont.woff","hash":"cafc4ac5761a0a252d33dce4ea3952cf9a38d832","modified":1630419791712},{"_id":"themes/yilia/source/fancybox/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1630419791714},{"_id":"themes/yilia/source/fancybox/helpers/jquery.fancybox-buttons.js","hash":"dc3645529a4bf72983a39fa34c1eb9146e082019","modified":1630419791714},{"_id":"themes/yilia/source/fancybox/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1630419791714},{"_id":"themes/yilia/source/fancybox/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1630419791715},{"_id":"themes/yilia/source/fancybox/helpers/jquery.fancybox-media.js","hash":"294420f9ff20f4e3584d212b0c262a00a96ecdb3","modified":1630419791714},{"_id":"themes/yilia/source/fancybox/helpers/jquery.fancybox-thumbs.js","hash":"47da1ae5401c24b5c17cc18e2730780f5c1a7a0c","modified":1630419791715},{"_id":"themes/yilia/source/css/fonts/fontawesome-webfont.svgz","hash":"4bfdd33ed702e32ae01399fcc2652377f78e7626","modified":1630419791709},{"_id":"themes/yilia/source/css/fonts/fontawesome-webfont.svg","hash":"ba13657479b46daecb6336bfe376f84cef3ae58b","modified":1630419791708},{"_id":"themes/yilia/languages/zh-tw.yml","hash":"9e4034870b57d2bb3063c91f8d206a6c4d7b3789","modified":1630419791697},{"_id":"themes/yilia/source/img/avatar.jpg","hash":"cf41790fc2b2df9fed99a0e21612b876474238cb","modified":1630484574106},{"_id":"source/images/ios-mvc.png","hash":"ccec6faa0d1d92841f1d7e4c7e474daf6e7d0a91","modified":1630419791609},{"_id":"public/baidusitemap.xml","hash":"9c327d05515a8e9ab8267e06eae6cee4c77d125c","modified":1632893092542},{"_id":"public/atom.xml","hash":"b9f5482b6bc7829ef774b4bd1fa4df3ac205ceec","modified":1632893092542},{"_id":"public/sitemap.xml","hash":"b76dd9c79dcad9db48b4d27c123b9264055041e7","modified":1632893092542},{"_id":"public/about/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1632893092542},{"_id":"public/2021/09/28/podman-dockerfile-maven-plugin/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1632893092542},{"_id":"public/2021/09/27/podman-ideaj-docker-plugin/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1632893092542},{"_id":"public/2021/09/27/podman-private-svr/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1632893092542},{"_id":"public/2021/09/18/java8-stream/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1632893092542},{"_id":"public/2021/09/03/podman-env-install/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1632893092542},{"_id":"public/2021/09/02/linux-remote/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1632893092542},{"_id":"public/2021/09/02/code-findbugs-plugin/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1632893092542},{"_id":"public/2021/08/28/bussiness-market-plan/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1632893092542},{"_id":"public/2021/08/26/bussiness-operate-target/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1632893092542},{"_id":"public/2021/08/26/bussiness-operate/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1632893092542},{"_id":"public/2021/08/26/system-main-fn/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1632893092542},{"_id":"public/2021/07/30/linux-crontab/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1632893092542},{"_id":"public/2021/07/04/bigdata-data-governance/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1632893092542},{"_id":"public/2021/03/31/data-wh/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1632893092542},{"_id":"public/2020/11/02/tech-company/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1632893092542},{"_id":"public/2020/06/08/demand-source/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1632893092542},{"_id":"public/2020/06/01/architecture-optimize/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1632893092542},{"_id":"public/2020/05/04/nginx-log-config/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1632893092542},{"_id":"public/2019/01/14/springcloud-step1/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1632893092542},{"_id":"public/2019/01/08/software-test-point/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1632893092542},{"_id":"public/2019/01/07/springboot-step1/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1632893092542},{"_id":"public/2018/12/25/redis-data-type/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1632893092542},{"_id":"public/2018/10/24/shiro-restful-api-session/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1632893092542},{"_id":"public/2018/09/13/https-cr-demo/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1632893092542},{"_id":"public/2018/09/11/https-flow/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1632893092542},{"_id":"public/2018/09/10/linux-cmd-notes/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1632893092542},{"_id":"public/2018/08/30/shiro-smscode-auth/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1632893092542},{"_id":"public/2018/08/24/cdt-java/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1632893092542},{"_id":"public/2018/08/22/module-multi-rocketmq/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1632893092542},{"_id":"public/2018/07/18/java-script-engine/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1632893092542},{"_id":"public/2018/04/10/redis-advanced/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1632893092542},{"_id":"public/2018/04/04/mq-rocketmq-manuals/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1632893092542},{"_id":"public/2018/04/04/mq-rocketmq-module/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1632893092542},{"_id":"public/2017/10/27/dtcs-seq/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1632893092542},{"_id":"public/2017/10/18/thinkpad-battery-limit/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1632893092542},{"_id":"public/2017/10/15/nginx-rtmp-obs/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1632893092542},{"_id":"public/2017/09/18/transaction-distributed/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1632893092542},{"_id":"public/2017/09/05/cron-expression/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1632893092542},{"_id":"public/2017/08/24/store-flag-bit/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1632893092542},{"_id":"public/2017/07/21/no-transaction/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1632893092542},{"_id":"public/2017/07/21/transaction-mark-rollbackonly/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1632893092542},{"_id":"public/2017/07/18/spring-initializingbean/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1632893092542},{"_id":"public/2017/07/07/multi-process-read/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1632893092542},{"_id":"public/2017/06/29/airport-terminal-code/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1632893092542},{"_id":"public/2016/10/09/linux-autostart/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1632893092542},{"_id":"public/2016/09/22/jvm-tools-jstat/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1632893092542},{"_id":"public/2016/09/21/jvm-tools-jmap/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1632893092542},{"_id":"public/2016/09/01/china-city-data/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1632893092542},{"_id":"public/2016/08/29/spring-core-interface/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1632893092542},{"_id":"public/2016/08/22/ggcode-lib/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1632893092542},{"_id":"public/2016/08/17/cas-shiro-auth-flow/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1632893092542},{"_id":"public/2016/08/16/cas-attribute/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1632893092542},{"_id":"public/2016/07/19/spring-compositeCacheManager/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1632893092542},{"_id":"public/2016/07/12/google-pagination-note/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1632893092542},{"_id":"public/2016/06/30/spring-aop-annotation/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1632893092542},{"_id":"public/2016/06/29/spring-mutiview/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1632893092542},{"_id":"public/2016/06/12/maven-source-doc/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1632893092542},{"_id":"public/2016/06/03/zookeeper-note/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1632893092542},{"_id":"public/2016/05/31/redis-cluster-note/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1632893092542},{"_id":"public/2016/05/31/distributed-redis-locked-queue/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1632893092542},{"_id":"public/2016/05/30/mysql-lock-transaction/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1632893092542},{"_id":"public/2016/05/27/transaction-isolation-levels/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1632893092542},{"_id":"public/2016/05/26/maven-deploy/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1632893092542},{"_id":"public/2016/05/26/maven-profile/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1632893092542},{"_id":"public/2016/05/26/os-port-forward/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1632893092542},{"_id":"public/2016/04/19/docker-dockerfile/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1632893092542},{"_id":"public/2016/04/18/docker-data-network/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1632893092542},{"_id":"public/2016/04/15/docker-cmd-summarize/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1632893092542},{"_id":"public/2016/04/13/string-format/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1632893092542},{"_id":"public/2016/04/07/ios-mvvm/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1632893092542},{"_id":"public/2016/04/06/docker-install-issue/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1632893092542},{"_id":"public/2016/04/05/ios-local-notification/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1632893092542},{"_id":"public/2016/04/01/ios-muti-task/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1632893092542},{"_id":"public/2016/03/30/ios-msg-transfer/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1632893092542},{"_id":"public/2016/03/30/ios-sendmsg/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1632893092542},{"_id":"public/2016/03/29/ios-load-initialize/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1632893092542},{"_id":"public/2016/03/29/ios-loadview/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1632893092542},{"_id":"public/2016/03/24/ios-hitTest/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1632893092542},{"_id":"public/2016/03/22/ios-layoutsubviews/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1632893092542},{"_id":"public/2016/03/21/header-version/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1632893092542},{"_id":"public/2016/03/21/php-fpm/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1632893092542},{"_id":"public/2016/03/18/nginx-muti-domain/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1632893092542},{"_id":"public/2016/03/18/linux-strace/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1632893092542},{"_id":"public/2016/03/18/nginx-upstream-jvm-route/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1632893092542},{"_id":"public/2016/03/17/tomcat-redis-session/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1632893092542},{"_id":"public/2016/03/16/nginx-upgrade/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1632893092542},{"_id":"public/2016/03/14/nginx-install/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1632893092542},{"_id":"public/2016/03/11/e-bussiness-architecture/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1632893092542},{"_id":"public/2016/03/10/started/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1632893092542},{"_id":"public/archives/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1632893092542},{"_id":"public/archives/page/2/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1632893092542},{"_id":"public/archives/page/3/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1632893092542},{"_id":"public/archives/page/4/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1632893092542},{"_id":"public/archives/page/5/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1632893092542},{"_id":"public/archives/page/6/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1632893092542},{"_id":"public/archives/page/7/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1632893092542},{"_id":"public/archives/page/8/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1632893092542},{"_id":"public/archives/page/9/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1632893092542},{"_id":"public/archives/2016/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1632893092542},{"_id":"public/archives/2016/page/2/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1632893092542},{"_id":"public/archives/2016/page/3/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1632893092542},{"_id":"public/archives/2016/page/4/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1632893092542},{"_id":"public/archives/2016/page/5/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1632893092542},{"_id":"public/archives/2016/03/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1632893092542},{"_id":"public/archives/2016/03/page/2/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1632893092542},{"_id":"public/archives/2016/04/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1632893092542},{"_id":"public/archives/2016/05/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1632893092542},{"_id":"public/archives/2016/06/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1632893092542},{"_id":"public/archives/2016/07/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1632893092542},{"_id":"public/archives/2016/08/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1632893092542},{"_id":"public/archives/2016/09/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1632893092542},{"_id":"public/archives/2016/10/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1632893092542},{"_id":"public/archives/2017/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1632893092542},{"_id":"public/archives/2017/page/2/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1632893092542},{"_id":"public/archives/2017/06/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1632893092542},{"_id":"public/archives/2017/07/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1632893092542},{"_id":"public/archives/2017/08/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1632893092542},{"_id":"public/archives/2017/09/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1632893092542},{"_id":"public/archives/2017/10/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1632893092542},{"_id":"public/archives/2018/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1632893092542},{"_id":"public/archives/2018/page/2/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1632893092542},{"_id":"public/archives/2018/04/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1632893092542},{"_id":"public/archives/2018/07/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1632893092542},{"_id":"public/archives/2018/08/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1632893092542},{"_id":"public/archives/2018/09/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1632893092542},{"_id":"public/archives/2018/10/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1632893092542},{"_id":"public/archives/2018/12/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1632893092542},{"_id":"public/archives/2019/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1632893092542},{"_id":"public/archives/2019/01/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1632893092542},{"_id":"public/archives/2020/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1632893092542},{"_id":"public/archives/2020/05/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1632893092542},{"_id":"public/archives/2020/06/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1632893092542},{"_id":"public/archives/2020/11/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1632893092542},{"_id":"public/archives/2021/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1632893092542},{"_id":"public/archives/2021/page/2/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1632893092542},{"_id":"public/archives/2021/03/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1632893092542},{"_id":"public/archives/2021/07/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1632893092542},{"_id":"public/archives/2021/08/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1632893092542},{"_id":"public/archives/2021/09/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1632893092542},{"_id":"public/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1632893092542},{"_id":"public/page/2/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1632893092542},{"_id":"public/page/3/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1632893092542},{"_id":"public/page/4/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1632893092542},{"_id":"public/page/5/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1632893092542},{"_id":"public/page/6/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1632893092542},{"_id":"public/page/7/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1632893092542},{"_id":"public/page/8/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1632893092542},{"_id":"public/page/9/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1632893092542},{"_id":"public/tags/原创/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1632893092542},{"_id":"public/tags/原创/page/2/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1632893092542},{"_id":"public/tags/原创/page/3/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1632893092542},{"_id":"public/tags/原创/page/4/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1632893092542},{"_id":"public/tags/原创/page/5/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1632893092542},{"_id":"public/tags/原创/page/6/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1632893092542},{"_id":"public/tags/原创/page/7/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1632893092542},{"_id":"public/tags/原创/page/8/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1632893092542},{"_id":"public/tags/转载/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1632893092542},{"_id":"public/tags/转载/page/2/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1632893092542},{"_id":"public/tags/大数据/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1632893092542},{"_id":"public/tags/cdt/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1632893092542},{"_id":"public/tags/Redis/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1632893092542},{"_id":"public/tags/Docker/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1632893092542},{"_id":"public/tags/分布式事务/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1632893092542},{"_id":"public/tags/电商/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1632893092542},{"_id":"public/tags/架构/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1632893092542},{"_id":"public/tags/https/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1632893092542},{"_id":"public/tags/iOS/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1632893092542},{"_id":"public/tags/linux/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1632893092542},{"_id":"public/tags/Maven/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1632893092542},{"_id":"public/tags/rocketmq/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1632893092542},{"_id":"public/tags/分布式/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1632893092542},{"_id":"public/tags/多进程/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1632893092542},{"_id":"public/tags/并发/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1632893092542},{"_id":"public/tags/Nginx/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1632893092542},{"_id":"public/tags/nginx-obs/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1632893092542},{"_id":"public/tags/spring/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1632893092542},{"_id":"public/tags/transaction/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1632893092542},{"_id":"public/tags/操作系统/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1632893092542},{"_id":"public/tags/php-fpm/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1632893092542},{"_id":"public/tags/podman/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1632893092542},{"_id":"public/tags/Podman/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1632893092542},{"_id":"public/tags/shiro/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1632893092542},{"_id":"public/tags/springcloud/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1632893092542},{"_id":"public/tags/随笔/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1632893092542},{"_id":"public/tags/Java/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1632893092542},{"_id":"public/tags/笔记/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1632893092542},{"_id":"public/tags/tomcat/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1632893092542},{"_id":"public/tags/redis/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1632893092542},{"_id":"public/tags/总结/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1632893092542},{"_id":"public/tags/Transaction/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1632893092542},{"_id":"public/tags/关键笔记/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1632893092542},{"_id":"public/fancybox/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1632893092542},{"_id":"public/fancybox/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1632893092542},{"_id":"public/fancybox/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1632893092542},{"_id":"public/fancybox/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1632893092542},{"_id":"public/fancybox/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1632893092542},{"_id":"public/fancybox/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1632893092542},{"_id":"public/img/coderwall.png","hash":"fa84676c4d654e040e51fd34bfcd9f9348cd5331","modified":1632893092542},{"_id":"public/img/delicious.png","hash":"9553a5f5189e4a953e04a58a49dbfa74b86b73dd","modified":1632893092542},{"_id":"public/img/facebook.png","hash":"d19ad7a0903daf26817afd8753cd97e0cc714f54","modified":1632893092542},{"_id":"public/img/douban.png","hash":"e2ade003ffadd5826ee66ec23901c2d6e8607e4e","modified":1632893092542},{"_id":"public/img/github.png","hash":"b84d03b32fa388dcbf149296ebd16dce6223d48d","modified":1632893092542},{"_id":"public/img/google.png","hash":"61a21fec7346fa3400b747ac9a201cf3d5bc013d","modified":1632893092542},{"_id":"public/img/img-err.png","hash":"23a63ea26eb3c1d5e677d9883cf36cc1a1a1228b","modified":1632893092542},{"_id":"public/img/img-loading.png","hash":"a9cd5cd11866824f31e3d1c5e23badfeb3f73031","modified":1632893092542},{"_id":"public/img/linkedin.png","hash":"e203138fb53c257cb214e97f4e30091b9c568d2c","modified":1632893092542},{"_id":"public/img/mail.png","hash":"fca8199cc77fdbd700a45bf56d091c82f4a67fe7","modified":1632893092542},{"_id":"public/img/oschina.png","hash":"af975deb0fd94e2f3015567333d3c50aea9e2591","modified":1632893092542},{"_id":"public/img/pinboard.png","hash":"0891fbb6d092fa012bf936019923383d84c6aeb0","modified":1632893092542},{"_id":"public/img/pinterest.png","hash":"9c72917f8779c083157c6ce7a5d62ed4874f0630","modified":1632893092542},{"_id":"public/img/rss.png","hash":"430fd47340e75214c081abd05cd7410cf7c71b86","modified":1632893092542},{"_id":"public/img/scrollbar_arrow.png","hash":"d64a33c4ddfbdb89deeb6f4e3d36eb84dc4777c0","modified":1632893092542},{"_id":"public/img/stackoverflow.png","hash":"da5dfe9043055c95e479d49c78cd3b020de608f2","modified":1632893092542},{"_id":"public/img/twitter.png","hash":"14dbb8e62d056525253bc0de13acd1723da7a934","modified":1632893092542},{"_id":"public/img/weibo.png","hash":"280dae3fd38086158b4a1b57edb94c06b1a5014b","modified":1632893092542},{"_id":"public/img/zhihu.png","hash":"a6d6ef65e9ac82e613a311810391ebb90d9b1c1d","modified":1632893092542},{"_id":"public/css/fonts/fontawesome-webfont.eot","hash":"3ce87b82c7a4ffdf65e96765c2ffda10b1a283c6","modified":1632893092542},{"_id":"public/css/fonts/fontawesome-webfont.ttf","hash":"1480b8101b02da9bc4c60341b5e185e63e585064","modified":1632893092542},{"_id":"public/css/fonts/fontawesome-webfont.woff","hash":"cafc4ac5761a0a252d33dce4ea3952cf9a38d832","modified":1632893092542},{"_id":"public/fancybox/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1632893092542},{"_id":"public/css/fonts/fontawesome-webfont.svgz","hash":"4bfdd33ed702e32ae01399fcc2652377f78e7626","modified":1632893092542},{"_id":"public/404.html","hash":"e96149df55b6541ba5b858b4c1c06e580d4c2257","modified":1632893092542},{"_id":"public/CNAME","hash":"5596d1dd375f5074f1e5e81bcc5b3af3d12aa7d6","modified":1632893092542},{"_id":"public/baidu_verify_wrSuuz9pXa.html","hash":"c36e9462972e13413f9189d5e8ed5db31e56d901","modified":1632893092542},{"_id":"public/google7ed0b016804177b7.html","hash":"d1d5aa3e5c7a512313bc2b599b35a81a62285961","modified":1632893092542},{"_id":"public/libs/tomcat-redis-session-manager-1.2-tomcat-7-1.2.jar","hash":"2c59f54408b0ee30279189863d5387ad6b5759cc","modified":1632893092542},{"_id":"public/images/QQ20160316-0.png","hash":"a8ae0d167e5e8fa72e6d70cfc222d0338f484bfe","modified":1632893092542},{"_id":"public/images/QQ20160316-1.png","hash":"e0195155c9ec7eda965abc23c52509d52611e1d4","modified":1632893092542},{"_id":"public/images/QQ20160317-0.png","hash":"9229b7041193094fa8656d0e8711d9f86a49946e","modified":1632893092542},{"_id":"public/images/QQ20160317-1.png","hash":"17fa5f00f6e6f01b5a8eb1b31d1c504c231aced6","modified":1632893092542},{"_id":"public/images/QQ20160317-2.png","hash":"d4b8ebd1c3f5b65c02147311e8794485389616f8","modified":1632893092542},{"_id":"public/images/QQ20160318-0.png","hash":"f0864b2a6c1f831f8c335c4e69aa8aa91218c9ca","modified":1632893092542},{"_id":"public/images/QQ20160318-1.png","hash":"25cd039a53ce7be2cc242064e3cd4e8080672641","modified":1632893092542},{"_id":"public/images/cap-theorem.png","hash":"ae672dd4361dd87e4b62ff31005ef5e8b294442d","modified":1632893092542},{"_id":"public/images/code_init.png","hash":"a5cf7d6f9de5d4a2cd8d454457d018c1b67f7d63","modified":1632893092542},{"_id":"public/images/def_loadview.png","hash":"de652e800e0ba147b24a4bb6becf7947c8a9caf6","modified":1632893092542},{"_id":"public/images/ios-mvvm.png","hash":"7a82e95897f92653b781b776ce1e53f0fc1cbe84","modified":1632893092542},{"_id":"public/images/multi-rocketmq-1.png","hash":"b12aed4a295e83911ce26c86ce90b9450da21c94","modified":1632893092542},{"_id":"public/images/nginx-tomcat-redis.png","hash":"92afb600c8444a34673d23e87b81a8d7ac2d7a8e","modified":1632893092542},{"_id":"public/images/nginx.png","hash":"b90011b4d89245d1ea7ac0f361e97abcb24933d1","modified":1632893092542},{"_id":"public/images/nginx_auth.png","hash":"6d3075c028e961bcd19f60e3959bd3f9eec16fda","modified":1632893092542},{"_id":"public/images/obs-1.png","hash":"012ef39a74807d0b3f5fa3d71fccc8665c7eb703","modified":1632893092542},{"_id":"public/images/obs-2.png","hash":"7ce12a3a49b47f9bf2a4275237b892becc78ec5c","modified":1632893092542},{"_id":"public/images/rmq-1.png","hash":"fc0746dd6c95192a50b191bbc54884801f18566a","modified":1632893092542},{"_id":"public/images/spring-mutiview-1.png","hash":"6dc6a225df943768dcd0a7060f219179d7fed525","modified":1632893092542},{"_id":"public/images/spring-mutiview-2.png","hash":"2335e31443bd43a7e846df8975758a9acb552fca","modified":1632893092542},{"_id":"public/images/uiviewcontroller-lifecycle.jpg","hash":"56f54fb04ffcd74b04aa276266b6360195d40c51","modified":1632893092542},{"_id":"public/images/vlc-1.png","hash":"b750d76cf2510294fdaa8b34cf2f6e603ab2e54a","modified":1632893092542},{"_id":"public/images/vlc-2.png","hash":"7e590049be829e01c71c943881c5c027090f6d9b","modified":1632893092542},{"_id":"public/images/xib_init.png","hash":"32b2312313e0be0a5f978a4ca39129b5e0b0a318","modified":1632893092542},{"_id":"public/images/xopen-dtp.gif","hash":"32faf7790b973bed2959eca3c4a8c698e7ece485","modified":1632893092542},{"_id":"public/images/zk-cluster-manager.gif","hash":"a18bec8dc9248e5225d6d68a1e923335c2732679","modified":1632893092542},{"_id":"public/images/zk-config-manager.gif","hash":"f493011fdabd0f2c5e953c50f222912f1058ed3d","modified":1632893092542},{"_id":"public/images/zk_data_model.gif","hash":"ef39da363e5a7a744a7870a4d3ad1651093abe2e","modified":1632893092542},{"_id":"public/css/fonts/fontawesome-webfont.svg","hash":"ba13657479b46daecb6336bfe376f84cef3ae58b","modified":1632893092542},{"_id":"public/libs/commons-pool-1.5.5.jar","hash":"7d8ffbdc47aa0c5a8afe5dc2aaf512f369f1d19b","modified":1632893092542},{"_id":"public/libs/jedis-2.0.0.jar","hash":"83fd129417dab44c09d85f8e125fe8007ee52bc7","modified":1632893092542},{"_id":"public/libs/commons-pool2-2.2.jar","hash":"bd1a6e384f3cf0f9b9a60e1e6c1c1ecbbee7e0b7","modified":1632893092542},{"_id":"public/images/1452221174578074.png","hash":"d124e45f6d9b2db2cafc7414cca8d3f93f1cfad4","modified":1632893092542},{"_id":"public/images/QQ20160316-2.png","hash":"e01c8b8f052683f8f3b3cac71b4a2607069413bb","modified":1632893092542},{"_id":"public/images/QQ20160318-2.png","hash":"bd6252a4dac27b765f74f73d56e442d9c152f95d","modified":1632893092542},{"_id":"public/images/QQ20160318-3.png","hash":"167c87b197a36efc1d675c5e751809629e504a5c","modified":1632893092542},{"_id":"public/images/QQ20160321-0.png","hash":"e801b1b6eabaa5c6053a66d0b98f7c3f03142d04","modified":1632893092542},{"_id":"public/images/add.png","hash":"b981637f1b5a973adf6ab400ce975222f244ef49","modified":1632893092542},{"_id":"public/images/block-flow-chart.png","hash":"102fe272596f6482c8fa57acd520d867c8b9a662","modified":1632893092542},{"_id":"public/images/capabilities-on-bgfetch.jpg","hash":"d8253bc306cb7551af326e6cd242d31919957af2","modified":1632893092542},{"_id":"public/images/cas-shiro-auth-flow.png","hash":"e0d26b7f5aba0092643149ad94bd6c5501a304f7","modified":1632893092542},{"_id":"public/images/communication-patterns-flow-chart.png","hash":"56d22932f27d7209e1f0b2e7a7e1950340445a41","modified":1632893092542},{"_id":"public/images/delegation-flow-chart.png","hash":"825b24a956fd0e1643d128584caaa01bcc57db47","modified":1632893092542},{"_id":"public/images/delete.png","hash":"5e4de75faf5a5c161345a08a969aa92a27276954","modified":1632893092542},{"_id":"public/images/docker-plugin-image-configuration.png","hash":"8c982e9d3c89fc6600387d86434d9586df750c3a","modified":1632893092542},{"_id":"public/images/docker-plugin-notice.png","hash":"ad9eaeac79e5e421d2c2c45c9747c4e41f27adbc","modified":1632893092542},{"_id":"public/images/docker-plugin-remote-connect.png","hash":"bf392f161005a89b29739969e3d84353d0985d30","modified":1632893092542},{"_id":"public/images/docker-realms.png","hash":"fb1716f9012666313d466184f3322a5c0f6f3f13","modified":1632893092542},{"_id":"public/images/edit-scheme-simulate-background-fetch.png","hash":"0c3febd99f08d3e120b346716d61db9760ee690b","modified":1632893092542},{"_id":"public/images/image_note64270_1.png","hash":"421b8cab3a182b6caa709a5d2cc06b7073ab3380","modified":1632893092542},{"_id":"public/images/java-stream-1.png","hash":"a868097fa23e5bfb1b06ae4c16c12ca3b5c81c11","modified":1632893092542},{"_id":"public/images/kvo-flow-chart.png","hash":"1ec1708eb128985eb2b3877cbab83b2f0375fcbc","modified":1632893092542},{"_id":"public/images/list.png","hash":"ef0b3a113f9dffa7f4d6984752088c57e661d8b0","modified":1632893092542},{"_id":"public/images/notification-flow-chart.png","hash":"aee495c8c0ee05c86d2a3223d9ec331b7e7d8b7e","modified":1632893092542},{"_id":"public/images/show.png","hash":"ac12fdc53fac75316745869bd54fbdc58232fd8d","modified":1632893092542},{"_id":"public/images/spring-mutiview-0.png","hash":"fe021f593b4b02e4772ad11f0577647810c5ebdb","modified":1632893092542},{"_id":"public/images/spring-mutiview-3.png","hash":"5916496ea9b196d4e66f9f88d2a58d6b453a564f","modified":1632893092542},{"_id":"public/images/spring-mutiview-4.png","hash":"d0cb72f1872524af704b133d937c509d7834b5a2","modified":1632893092542},{"_id":"public/images/spring-mutiview-7.png","hash":"bd121ffa50e327882c5aa9a07473b84ce7dbd950","modified":1632893092542},{"_id":"public/images/target-action-flow-chart.png","hash":"078a5bb159e89978663f8aca09490b5ec36d4d8e","modified":1632893092542},{"_id":"public/images/vts.png","hash":"8103c6089c64060a4f1ce84d72227c381414251e","modified":1632893092542},{"_id":"public/images/四大体系.png","hash":"aa146685c5f96e229f6d6a11fa60d7a3027ea056","modified":1632893092542},{"_id":"public/images/电商业务模块总览.png","hash":"38288a96dc371e64bf976e9e5ca6f5b90639c3b4","modified":1632893092542},{"_id":"public/images/docker-hosted.png","hash":"c51a73892520c5cc693739d217a34e5c91dccf62","modified":1632893092542},{"_id":"public/images/docker-group.png","hash":"6416d3706ba508a1bdd698856a38795ada11d431","modified":1632893092542},{"_id":"public/images/docker-images-redis.png","hash":"9fb7293ea58dcd3ae08b18fe3fff6f7bf5102ca6","modified":1632893092542},{"_id":"public/images/docker-proxy.png","hash":"16b544b5ab3d658861be8d2e86b6cf319415ec17","modified":1632893092542},{"_id":"public/images/dtcs-seq.jpg","hash":"8e0709b6ed5326ac1acffbf9e7dd074d0deacb49","modified":1632893092542},{"_id":"public/images/java-stream-2.png","hash":"1427b010d82af884c54174fe4f7da989403c84d6","modified":1632893092542},{"_id":"public/images/podman-images.png","hash":"45678886fd5fc74f102432fc26b27f3f9b87fe95","modified":1632893092542},{"_id":"public/images/spring-mutiview-5.png","hash":"f530629e3b711b9fbbf7d1cf648c84bee6f912bc","modified":1632893092542},{"_id":"public/images/spring-mutiview-6.png","hash":"2b7fc1ec3d920d5f8628871dbe7fe6617d28d3c2","modified":1632893092542},{"_id":"public/images/update.png","hash":"91d59f94a3fb3ccfc3744bb3b5122d734c3a1e85","modified":1632893092542},{"_id":"public/fancybox/jquery.fancybox.css","hash":"b6aa6692c2e5f8bd74d96827b78570f0c5683c20","modified":1632893092542},{"_id":"public/js/instagram.js","hash":"f19adbcc0dac33536bc6660598059048ec901882","modified":1632893092542},{"_id":"public/js/jquery.lazyload.js","hash":"c11a2e7b330d16d06feabd0a8477099adf9d6799","modified":1632893092542},{"_id":"public/js/main.js","hash":"0640b68a76fab3c693b3cd1e4d04d14be1e53940","modified":1632893092542},{"_id":"public/js/mobile.js","hash":"b68cc01d24e80973c48205f551da87f3f3427644","modified":1632893092542},{"_id":"public/js/pc.js","hash":"fdbc039fc9ffa70815b5fc4daaa587ae29693f10","modified":1632893092542},{"_id":"public/fancybox/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1632893092542},{"_id":"public/fancybox/helpers/jquery.fancybox-buttons.js","hash":"dc3645529a4bf72983a39fa34c1eb9146e082019","modified":1632893092542},{"_id":"public/fancybox/helpers/jquery.fancybox-media.js","hash":"294420f9ff20f4e3584d212b0c262a00a96ecdb3","modified":1632893092542},{"_id":"public/fancybox/helpers/jquery.fancybox-thumbs.js","hash":"47da1ae5401c24b5c17cc18e2730780f5c1a7a0c","modified":1632893092542},{"_id":"public/fancybox/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1632893092542},{"_id":"public/css/style.css","hash":"d3c6f0b3dd84384f1c4c203776e167100a55fa6b","modified":1632893092542},{"_id":"public/img/avatar.jpg","hash":"cf41790fc2b2df9fed99a0e21612b876474238cb","modified":1632893092542},{"_id":"public/images/QQ20160817-0.png","hash":"ff1f6654b697b37149f751345671f7514c46df76","modified":1632893092542},{"_id":"public/images/one-way-https.jpg","hash":"531ad36c6ec0f78ba01b9cefd9a500bf3f4f0a71","modified":1632893092542},{"_id":"public/images/performance-optimize.jpg","hash":"ff6993070f854c16d8cdaa87fae0dbb1bcdaaecd","modified":1632893092542},{"_id":"public/fancybox/jquery.fancybox.pack.js","hash":"9e0d51ca1dbe66f6c0c7aefd552dc8122e694a6e","modified":1632893092542},{"_id":"public/images/two-way-https.jpg","hash":"2368244fc0e7fbbc4b09699609a6bc7b1a967130","modified":1632893092542},{"_id":"public/fancybox/jquery.fancybox.js","hash":"a82597493d75ea989ca586e09173cff332efe41e","modified":1632893092542},{"_id":"public/data/t_airport_terminal_code.sql","hash":"725f266ff8c9f763e2dbd2a9073e09219f206914","modified":1632893092542},{"_id":"public/data/t_city.sql","hash":"cabb4f7396ddb431038bbc863468923c5c0522f3","modified":1632893092542},{"_id":"public/images/ios-mvc.png","hash":"ccec6faa0d1d92841f1d7e4c7e474daf6e7d0a91","modified":1632893092542}],"Category":[],"Data":[],"Page":[{"title":"关于我","date":"2016-03-09T08:54:19.000Z","_content":"\n热情、专注、分享、坚持！\n\n原博客地址: [http://wujianjun.iteye.com/](http://wujianjun.iteye.com/)\n\n任职经历\n-----\n+ 2016年 __神马专车__\n工作内容/方向：\n·  微服务架构细粒度拆分，交易主链路解藕，高效可靠的任务调度，全面透明的微服务监管，可靠的数据获取与存储。\n·  业务和技术方案的落地实施，核心服务研发，实验型项目的方案验证等。\n·  研发团队的日常管理&团队成员的培训与提升。\n\n+ 2014年 __地利控股（西咸新区）网络农业有限公司__\n工作内容/方向：\n农产品交易主站买/卖双方SOA服务模块研发、订单系统、移动设备交互网关\n\n+ 2010年 __成都四方信息技术有限公司__\n工作内容/方向：\n四川省运行平台SOA架构、华为MVAS项目、类ApacheMINA通讯组件\n\n+ 2009年 __成都市全友家私有限公司__\n工作内容/方向：\n便捷友好高效的CRM系统、SAP MM模块业务顾问\n\n+ 2009年 __重庆叠彩科技有限公司__\n工作内容/方向：\n公牛进销存研发\n\n相关项目\n-----\n+ 农丰网商城app for iOS\n[https://itunes.apple.com/cn/app/nong-feng-wang/id984349424](https://itunes.apple.com/cn/app/nong-feng-wang/id984349424)\n+ 园区销售易app for iOS\n+ 农丰网移动设备网关系统\n[http://mobapi.nong12.com](http://mobapi.nong12.com)\n+ 农丰网主站\n[http://www.nong12.com](http://www.nong12.com)\n+ 四川省依法规范公开运行平台\n[http://www.sefon.com/solution/data/30.html](http://www.sefon.com/solution/data/30.html)\n+ 华为MVAS2890产品\n[http://www.sefonsoft.com/txyw/201502/32.html](http://www.sefonsoft.com/txyw/201502/32.html)\n+ Anti spamming 产品全球WEB版本图形化自动监控功能实现\n[http://www.sefonsoft.com/txyw/201502/24.html](http://www.sefonsoft.com/txyw/201502/24.html)\n+ 中国移动重庆人工仲裁平台\n[http://www.sefonsoft.com/txyw/201502/24.html](http://www.sefonsoft.com/txyw/201502/24.html)\n+ 华为MVAS2890 for android\n+ 全友家私CRM系统 [http://www.iquanyou.com.cn](http://www.iquanyou.com.cn)\n+ 重庆公牛进销存系统 （内部系统）\n+ Remote Console （Java Library）\n\n相关技能\n-----\nJava， Objective-C，J2EE网络服务，iPhone应用开发， iPhone AutoLayout， UIKit，\nXcode，Spring Framework，JSON，XML，TCP/IP，网络编程，接口层设计与开发，\nLinux服务器，jQuery，JavaScript， Ajax\n","source":"about/index.md","raw":"---\ntitle: 关于我\ndate: 2016-03-09 16:54:19\n---\n\n热情、专注、分享、坚持！\n\n原博客地址: [http://wujianjun.iteye.com/](http://wujianjun.iteye.com/)\n\n任职经历\n-----\n+ 2016年 __神马专车__\n工作内容/方向：\n·  微服务架构细粒度拆分，交易主链路解藕，高效可靠的任务调度，全面透明的微服务监管，可靠的数据获取与存储。\n·  业务和技术方案的落地实施，核心服务研发，实验型项目的方案验证等。\n·  研发团队的日常管理&团队成员的培训与提升。\n\n+ 2014年 __地利控股（西咸新区）网络农业有限公司__\n工作内容/方向：\n农产品交易主站买/卖双方SOA服务模块研发、订单系统、移动设备交互网关\n\n+ 2010年 __成都四方信息技术有限公司__\n工作内容/方向：\n四川省运行平台SOA架构、华为MVAS项目、类ApacheMINA通讯组件\n\n+ 2009年 __成都市全友家私有限公司__\n工作内容/方向：\n便捷友好高效的CRM系统、SAP MM模块业务顾问\n\n+ 2009年 __重庆叠彩科技有限公司__\n工作内容/方向：\n公牛进销存研发\n\n相关项目\n-----\n+ 农丰网商城app for iOS\n[https://itunes.apple.com/cn/app/nong-feng-wang/id984349424](https://itunes.apple.com/cn/app/nong-feng-wang/id984349424)\n+ 园区销售易app for iOS\n+ 农丰网移动设备网关系统\n[http://mobapi.nong12.com](http://mobapi.nong12.com)\n+ 农丰网主站\n[http://www.nong12.com](http://www.nong12.com)\n+ 四川省依法规范公开运行平台\n[http://www.sefon.com/solution/data/30.html](http://www.sefon.com/solution/data/30.html)\n+ 华为MVAS2890产品\n[http://www.sefonsoft.com/txyw/201502/32.html](http://www.sefonsoft.com/txyw/201502/32.html)\n+ Anti spamming 产品全球WEB版本图形化自动监控功能实现\n[http://www.sefonsoft.com/txyw/201502/24.html](http://www.sefonsoft.com/txyw/201502/24.html)\n+ 中国移动重庆人工仲裁平台\n[http://www.sefonsoft.com/txyw/201502/24.html](http://www.sefonsoft.com/txyw/201502/24.html)\n+ 华为MVAS2890 for android\n+ 全友家私CRM系统 [http://www.iquanyou.com.cn](http://www.iquanyou.com.cn)\n+ 重庆公牛进销存系统 （内部系统）\n+ Remote Console （Java Library）\n\n相关技能\n-----\nJava， Objective-C，J2EE网络服务，iPhone应用开发， iPhone AutoLayout， UIKit，\nXcode，Spring Framework，JSON，XML，TCP/IP，网络编程，接口层设计与开发，\nLinux服务器，jQuery，JavaScript， Ajax\n","updated":"2021-08-31T14:23:11.554Z","path":"about/index.html","comments":1,"layout":"page","_id":"cku52dyko0000bbin6itlgg2q","content":"<p>热情、专注、分享、坚持！</p>\n<p>原博客地址: <a href=\"http://wujianjun.iteye.com/\">http://wujianjun.iteye.com/</a></p>\n<h2 id=\"任职经历\"><a href=\"#任职经历\" class=\"headerlink\" title=\"任职经历\"></a>任职经历</h2><ul>\n<li><p>2016年 <strong>神马专车</strong><br>工作内容/方向：<br>·  微服务架构细粒度拆分，交易主链路解藕，高效可靠的任务调度，全面透明的微服务监管，可靠的数据获取与存储。<br>·  业务和技术方案的落地实施，核心服务研发，实验型项目的方案验证等。<br>·  研发团队的日常管理&amp;团队成员的培训与提升。</p>\n</li>\n<li><p>2014年 <strong>地利控股（西咸新区）网络农业有限公司</strong><br>工作内容/方向：<br>农产品交易主站买/卖双方SOA服务模块研发、订单系统、移动设备交互网关</p>\n</li>\n<li><p>2010年 <strong>成都四方信息技术有限公司</strong><br>工作内容/方向：<br>四川省运行平台SOA架构、华为MVAS项目、类ApacheMINA通讯组件</p>\n</li>\n<li><p>2009年 <strong>成都市全友家私有限公司</strong><br>工作内容/方向：<br>便捷友好高效的CRM系统、SAP MM模块业务顾问</p>\n</li>\n<li><p>2009年 <strong>重庆叠彩科技有限公司</strong><br>工作内容/方向：<br>公牛进销存研发</p>\n</li>\n</ul>\n<h2 id=\"相关项目\"><a href=\"#相关项目\" class=\"headerlink\" title=\"相关项目\"></a>相关项目</h2><ul>\n<li>农丰网商城app for iOS<br><a href=\"https://itunes.apple.com/cn/app/nong-feng-wang/id984349424\">https://itunes.apple.com/cn/app/nong-feng-wang/id984349424</a></li>\n<li>园区销售易app for iOS</li>\n<li>农丰网移动设备网关系统<br><a href=\"http://mobapi.nong12.com/\">http://mobapi.nong12.com</a></li>\n<li>农丰网主站<br><a href=\"http://www.nong12.com/\">http://www.nong12.com</a></li>\n<li>四川省依法规范公开运行平台<br><a href=\"http://www.sefon.com/solution/data/30.html\">http://www.sefon.com/solution/data/30.html</a></li>\n<li>华为MVAS2890产品<br><a href=\"http://www.sefonsoft.com/txyw/201502/32.html\">http://www.sefonsoft.com/txyw/201502/32.html</a></li>\n<li>Anti spamming 产品全球WEB版本图形化自动监控功能实现<br><a href=\"http://www.sefonsoft.com/txyw/201502/24.html\">http://www.sefonsoft.com/txyw/201502/24.html</a></li>\n<li>中国移动重庆人工仲裁平台<br><a href=\"http://www.sefonsoft.com/txyw/201502/24.html\">http://www.sefonsoft.com/txyw/201502/24.html</a></li>\n<li>华为MVAS2890 for android</li>\n<li>全友家私CRM系统 <a href=\"http://www.iquanyou.com.cn/\">http://www.iquanyou.com.cn</a></li>\n<li>重庆公牛进销存系统 （内部系统）</li>\n<li>Remote Console （Java Library）</li>\n</ul>\n<h2 id=\"相关技能\"><a href=\"#相关技能\" class=\"headerlink\" title=\"相关技能\"></a>相关技能</h2><p>Java， Objective-C，J2EE网络服务，iPhone应用开发， iPhone AutoLayout， UIKit，<br>Xcode，Spring Framework，JSON，XML，TCP/IP，网络编程，接口层设计与开发，<br>Linux服务器，jQuery，JavaScript， Ajax</p>\n","site":{"data":{}},"excerpt":"","more":"<p>热情、专注、分享、坚持！</p>\n<p>原博客地址: <a href=\"http://wujianjun.iteye.com/\">http://wujianjun.iteye.com/</a></p>\n<h2 id=\"任职经历\"><a href=\"#任职经历\" class=\"headerlink\" title=\"任职经历\"></a>任职经历</h2><ul>\n<li><p>2016年 <strong>神马专车</strong><br>工作内容/方向：<br>·  微服务架构细粒度拆分，交易主链路解藕，高效可靠的任务调度，全面透明的微服务监管，可靠的数据获取与存储。<br>·  业务和技术方案的落地实施，核心服务研发，实验型项目的方案验证等。<br>·  研发团队的日常管理&amp;团队成员的培训与提升。</p>\n</li>\n<li><p>2014年 <strong>地利控股（西咸新区）网络农业有限公司</strong><br>工作内容/方向：<br>农产品交易主站买/卖双方SOA服务模块研发、订单系统、移动设备交互网关</p>\n</li>\n<li><p>2010年 <strong>成都四方信息技术有限公司</strong><br>工作内容/方向：<br>四川省运行平台SOA架构、华为MVAS项目、类ApacheMINA通讯组件</p>\n</li>\n<li><p>2009年 <strong>成都市全友家私有限公司</strong><br>工作内容/方向：<br>便捷友好高效的CRM系统、SAP MM模块业务顾问</p>\n</li>\n<li><p>2009年 <strong>重庆叠彩科技有限公司</strong><br>工作内容/方向：<br>公牛进销存研发</p>\n</li>\n</ul>\n<h2 id=\"相关项目\"><a href=\"#相关项目\" class=\"headerlink\" title=\"相关项目\"></a>相关项目</h2><ul>\n<li>农丰网商城app for iOS<br><a href=\"https://itunes.apple.com/cn/app/nong-feng-wang/id984349424\">https://itunes.apple.com/cn/app/nong-feng-wang/id984349424</a></li>\n<li>园区销售易app for iOS</li>\n<li>农丰网移动设备网关系统<br><a href=\"http://mobapi.nong12.com/\">http://mobapi.nong12.com</a></li>\n<li>农丰网主站<br><a href=\"http://www.nong12.com/\">http://www.nong12.com</a></li>\n<li>四川省依法规范公开运行平台<br><a href=\"http://www.sefon.com/solution/data/30.html\">http://www.sefon.com/solution/data/30.html</a></li>\n<li>华为MVAS2890产品<br><a href=\"http://www.sefonsoft.com/txyw/201502/32.html\">http://www.sefonsoft.com/txyw/201502/32.html</a></li>\n<li>Anti spamming 产品全球WEB版本图形化自动监控功能实现<br><a href=\"http://www.sefonsoft.com/txyw/201502/24.html\">http://www.sefonsoft.com/txyw/201502/24.html</a></li>\n<li>中国移动重庆人工仲裁平台<br><a href=\"http://www.sefonsoft.com/txyw/201502/24.html\">http://www.sefonsoft.com/txyw/201502/24.html</a></li>\n<li>华为MVAS2890 for android</li>\n<li>全友家私CRM系统 <a href=\"http://www.iquanyou.com.cn/\">http://www.iquanyou.com.cn</a></li>\n<li>重庆公牛进销存系统 （内部系统）</li>\n<li>Remote Console （Java Library）</li>\n</ul>\n<h2 id=\"相关技能\"><a href=\"#相关技能\" class=\"headerlink\" title=\"相关技能\"></a>相关技能</h2><p>Java， Objective-C，J2EE网络服务，iPhone应用开发， iPhone AutoLayout， UIKit，<br>Xcode，Spring Framework，JSON，XML，TCP/IP，网络编程，接口层设计与开发，<br>Linux服务器，jQuery，JavaScript， Ajax</p>\n"}],"Post":[{"title":"机场航站楼三字码四字码信息数据库","keywords":["机场三字码","机场四字码"],"date":"2017-06-29T09:23:50.000Z","_content":"\n## 简介\n由于携程航班号查询取消了起止城市信息的返回，为了补全信息，特从网络爬取了8644条机场航站楼对应三字码四字码信息，共享于网络供有需要的朋友使用。\n\n数据抓取源: [便民查询网](https://airportcode.51240.com)\n\n[机场航站楼三字码四字码附件，点击下载](/data/t_airport_terminal_code.sql)\n\n-----\n\n*观点仅代表自己，期待你的留言。*\n","source":"_posts/airport-terminal-code.md","raw":"---\ntitle: 机场航站楼三字码四字码信息数据库\nkeywords:\n  - 机场三字码\n  - 机场四字码\ntags:\n  - 原创\ndate: 2017-06-29 17:23:50\n---\n\n## 简介\n由于携程航班号查询取消了起止城市信息的返回，为了补全信息，特从网络爬取了8644条机场航站楼对应三字码四字码信息，共享于网络供有需要的朋友使用。\n\n数据抓取源: [便民查询网](https://airportcode.51240.com)\n\n[机场航站楼三字码四字码附件，点击下载](/data/t_airport_terminal_code.sql)\n\n-----\n\n*观点仅代表自己，期待你的留言。*\n","slug":"airport-terminal-code","published":1,"updated":"2021-08-31T14:23:11.536Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cku52dyl70001bbin8ydgclb6","content":"<h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><p>由于携程航班号查询取消了起止城市信息的返回，为了补全信息，特从网络爬取了8644条机场航站楼对应三字码四字码信息，共享于网络供有需要的朋友使用。</p>\n<p>数据抓取源: <a href=\"https://airportcode.51240.com/\">便民查询网</a></p>\n<p><a href=\"/data/t_airport_terminal_code.sql\">机场航站楼三字码四字码附件，点击下载</a></p>\n<hr>\n<p><em>观点仅代表自己，期待你的留言。</em></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><p>由于携程航班号查询取消了起止城市信息的返回，为了补全信息，特从网络爬取了8644条机场航站楼对应三字码四字码信息，共享于网络供有需要的朋友使用。</p>\n<p>数据抓取源: <a href=\"https://airportcode.51240.com/\">便民查询网</a></p>\n<p><a href=\"/data/t_airport_terminal_code.sql\">机场航站楼三字码四字码附件，点击下载</a></p>\n<hr>\n<p><em>观点仅代表自己，期待你的留言。</em></p>\n"},{"title":"架构优化","date":"2020-06-01T00:34:27.000Z","_content":"\n## 业务架构优化\n复杂的事情简单化，简单的事情标准化，标准的事情流程化，流程的事情自动化，自动的事情智能化。\n## 性能优化十大策略\n![性能优化十大策略](/images/performance-optimize.jpg)\n\n\n-----\n\n*观点仅代表自己，期待你的留言。*\n","source":"_posts/architecture-optimize.md","raw":"---\ntitle: 架构优化\ntags:\n  - 原创\n  - 转载\ndate: 2020-06-01 08:34:27\n---\n\n## 业务架构优化\n复杂的事情简单化，简单的事情标准化，标准的事情流程化，流程的事情自动化，自动的事情智能化。\n## 性能优化十大策略\n![性能优化十大策略](/images/performance-optimize.jpg)\n\n\n-----\n\n*观点仅代表自己，期待你的留言。*\n","slug":"architecture-optimize","published":1,"updated":"2021-09-01T01:54:40.645Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cku52dylg0002bbin5frm82zd","content":"<h2 id=\"业务架构优化\"><a href=\"#业务架构优化\" class=\"headerlink\" title=\"业务架构优化\"></a>业务架构优化</h2><p>复杂的事情简单化，简单的事情标准化，标准的事情流程化，流程的事情自动化，自动的事情智能化。</p>\n<h2 id=\"性能优化十大策略\"><a href=\"#性能优化十大策略\" class=\"headerlink\" title=\"性能优化十大策略\"></a>性能优化十大策略</h2><p><img src=\"/images/performance-optimize.jpg\" alt=\"性能优化十大策略\"></p>\n<hr>\n<p><em>观点仅代表自己，期待你的留言。</em></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"业务架构优化\"><a href=\"#业务架构优化\" class=\"headerlink\" title=\"业务架构优化\"></a>业务架构优化</h2><p>复杂的事情简单化，简单的事情标准化，标准的事情流程化，流程的事情自动化，自动的事情智能化。</p>\n<h2 id=\"性能优化十大策略\"><a href=\"#性能优化十大策略\" class=\"headerlink\" title=\"性能优化十大策略\"></a>性能优化十大策略</h2><p><img src=\"/images/performance-optimize.jpg\" alt=\"性能优化十大策略\"></p>\n<hr>\n<p><em>观点仅代表自己，期待你的留言。</em></p>\n"},{"title":"运营之活动策划","keywords":["活动策划","运营"],"date":"2021-08-28T00:57:29.000Z","_content":"\n## 运营之活动策划\n日常活动（提升UV、拉新）\n- 签到\n- 0点、10点、15点限时兑换、限时秒杀\n- 抽奖\n- 会员日专属福利\n- 邀请码\n- 虚拟宝贝养成计划\n业务事件活动（提升复购率）\n- 消费即返券、消费即返积分\n- 按消费习惯进行个性推荐\n热点事件活动（提升UV）\n- 周年庆\n- 有奖竞猜\n- 事件评论、事件转发\n- 节日\n\n\n-----\n\n*观点仅代表自己，期待你的留言。*\n","source":"_posts/bussiness-market-plan.md","raw":"---\ntitle: 运营之活动策划\ntags:\n  - 原创\nkeywords:\n  - 活动策划\n  - 运营\ndate: 2021-08-28 08:57:29\n---\n\n## 运营之活动策划\n日常活动（提升UV、拉新）\n- 签到\n- 0点、10点、15点限时兑换、限时秒杀\n- 抽奖\n- 会员日专属福利\n- 邀请码\n- 虚拟宝贝养成计划\n业务事件活动（提升复购率）\n- 消费即返券、消费即返积分\n- 按消费习惯进行个性推荐\n热点事件活动（提升UV）\n- 周年庆\n- 有奖竞猜\n- 事件评论、事件转发\n- 节日\n\n\n-----\n\n*观点仅代表自己，期待你的留言。*\n","slug":"bussiness-market-plan","published":1,"updated":"2021-09-01T02:09:45.384Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cku52dylj0004bbinb4g81nkn","content":"<h2 id=\"运营之活动策划\"><a href=\"#运营之活动策划\" class=\"headerlink\" title=\"运营之活动策划\"></a>运营之活动策划</h2><p>日常活动（提升UV、拉新）</p>\n<ul>\n<li>签到</li>\n<li>0点、10点、15点限时兑换、限时秒杀</li>\n<li>抽奖</li>\n<li>会员日专属福利</li>\n<li>邀请码</li>\n<li>虚拟宝贝养成计划<br>业务事件活动（提升复购率）</li>\n<li>消费即返券、消费即返积分</li>\n<li>按消费习惯进行个性推荐<br>热点事件活动（提升UV）</li>\n<li>周年庆</li>\n<li>有奖竞猜</li>\n<li>事件评论、事件转发</li>\n<li>节日</li>\n</ul>\n<hr>\n<p><em>观点仅代表自己，期待你的留言。</em></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"运营之活动策划\"><a href=\"#运营之活动策划\" class=\"headerlink\" title=\"运营之活动策划\"></a>运营之活动策划</h2><p>日常活动（提升UV、拉新）</p>\n<ul>\n<li>签到</li>\n<li>0点、10点、15点限时兑换、限时秒杀</li>\n<li>抽奖</li>\n<li>会员日专属福利</li>\n<li>邀请码</li>\n<li>虚拟宝贝养成计划<br>业务事件活动（提升复购率）</li>\n<li>消费即返券、消费即返积分</li>\n<li>按消费习惯进行个性推荐<br>热点事件活动（提升UV）</li>\n<li>周年庆</li>\n<li>有奖竞猜</li>\n<li>事件评论、事件转发</li>\n<li>节日</li>\n</ul>\n<hr>\n<p><em>观点仅代表自己，期待你的留言。</em></p>\n"},{"title":"大数据之数据治理","keywords":["大数据","数据治理"],"date":"2021-07-04T03:59:42.000Z","_content":"\n## 数据集成平台：\n1. 组成：数据汇集、数据集成、数据安全守护、离线调度、数据共享\n2. 特点：\n- 多样化汇集方式\n- 结构化半结构化非结构化数据汇集与集成\n- 高数据汇集实时性\n- 多样的集成算法\n- 高效的全流程监控的调度\n- 多样的数据实时非实时共享方式\n\n## 数据管理平台：\n1. 组成：元数据管理、数据建模、主数据管理、数据标准、数据标签、数据安全审计、数据质量评估\n2. 特点：\n- 多源异构管理数据源\n- 高效全面读取元数据\n- 元数据变更管理\n- 全面真实的元数据全链\n- 异构数据源数据模型转换\n- 权威可行的数据标准（本地、国标、行标）管理与应用\n- 业务贴合紧密的数据标签体系\n- 元数据设定安全规则管控与授权，保障数据的安全访问和更新\n- 源数据及数仓数据的全链校验，识别源头问题和数据集成期问题\n\n## 数据运维平台：\n1. 组成：安装部署、日常巡检、软硬件及业务监控、主被动告警通知、动态伸缩集群、日志审计\n2. 特点：\n- 监控指标丰富可插拔\n- 业务解耦，保持独立性\n- WebSSH\n\n## 数据运营平台：\n1. 组成：统一认证中心. 组织机构管理、用户帐户管理、角色授权管理\n2. 特点：\n- 标准接口开放与对接，如oauth2\n- 高效稳定的数据接口\n- 灵活可扩展\n\n-----\n\n*观点仅代表自己，期待你的留言。*\n","source":"_posts/bigdata-data-governance.md","raw":"---\ntitle: 大数据之数据治理\ntags:\n  - 原创\n  - 大数据\nkeywords:\n  - 大数据\n  - 数据治理\ndate: 2021-07-04 11:59:42\n---\n\n## 数据集成平台：\n1. 组成：数据汇集、数据集成、数据安全守护、离线调度、数据共享\n2. 特点：\n- 多样化汇集方式\n- 结构化半结构化非结构化数据汇集与集成\n- 高数据汇集实时性\n- 多样的集成算法\n- 高效的全流程监控的调度\n- 多样的数据实时非实时共享方式\n\n## 数据管理平台：\n1. 组成：元数据管理、数据建模、主数据管理、数据标准、数据标签、数据安全审计、数据质量评估\n2. 特点：\n- 多源异构管理数据源\n- 高效全面读取元数据\n- 元数据变更管理\n- 全面真实的元数据全链\n- 异构数据源数据模型转换\n- 权威可行的数据标准（本地、国标、行标）管理与应用\n- 业务贴合紧密的数据标签体系\n- 元数据设定安全规则管控与授权，保障数据的安全访问和更新\n- 源数据及数仓数据的全链校验，识别源头问题和数据集成期问题\n\n## 数据运维平台：\n1. 组成：安装部署、日常巡检、软硬件及业务监控、主被动告警通知、动态伸缩集群、日志审计\n2. 特点：\n- 监控指标丰富可插拔\n- 业务解耦，保持独立性\n- WebSSH\n\n## 数据运营平台：\n1. 组成：统一认证中心. 组织机构管理、用户帐户管理、角色授权管理\n2. 特点：\n- 标准接口开放与对接，如oauth2\n- 高效稳定的数据接口\n- 灵活可扩展\n\n-----\n\n*观点仅代表自己，期待你的留言。*\n","slug":"bigdata-data-governance","published":1,"updated":"2021-09-01T02:01:15.369Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cku52dylk0005bbineygdhgkv","content":"<h2 id=\"数据集成平台：\"><a href=\"#数据集成平台：\" class=\"headerlink\" title=\"数据集成平台：\"></a>数据集成平台：</h2><ol>\n<li>组成：数据汇集、数据集成、数据安全守护、离线调度、数据共享</li>\n<li>特点：</li>\n</ol>\n<ul>\n<li>多样化汇集方式</li>\n<li>结构化半结构化非结构化数据汇集与集成</li>\n<li>高数据汇集实时性</li>\n<li>多样的集成算法</li>\n<li>高效的全流程监控的调度</li>\n<li>多样的数据实时非实时共享方式</li>\n</ul>\n<h2 id=\"数据管理平台：\"><a href=\"#数据管理平台：\" class=\"headerlink\" title=\"数据管理平台：\"></a>数据管理平台：</h2><ol>\n<li>组成：元数据管理、数据建模、主数据管理、数据标准、数据标签、数据安全审计、数据质量评估</li>\n<li>特点：</li>\n</ol>\n<ul>\n<li>多源异构管理数据源</li>\n<li>高效全面读取元数据</li>\n<li>元数据变更管理</li>\n<li>全面真实的元数据全链</li>\n<li>异构数据源数据模型转换</li>\n<li>权威可行的数据标准（本地、国标、行标）管理与应用</li>\n<li>业务贴合紧密的数据标签体系</li>\n<li>元数据设定安全规则管控与授权，保障数据的安全访问和更新</li>\n<li>源数据及数仓数据的全链校验，识别源头问题和数据集成期问题</li>\n</ul>\n<h2 id=\"数据运维平台：\"><a href=\"#数据运维平台：\" class=\"headerlink\" title=\"数据运维平台：\"></a>数据运维平台：</h2><ol>\n<li>组成：安装部署、日常巡检、软硬件及业务监控、主被动告警通知、动态伸缩集群、日志审计</li>\n<li>特点：</li>\n</ol>\n<ul>\n<li>监控指标丰富可插拔</li>\n<li>业务解耦，保持独立性</li>\n<li>WebSSH</li>\n</ul>\n<h2 id=\"数据运营平台：\"><a href=\"#数据运营平台：\" class=\"headerlink\" title=\"数据运营平台：\"></a>数据运营平台：</h2><ol>\n<li>组成：统一认证中心. 组织机构管理、用户帐户管理、角色授权管理</li>\n<li>特点：</li>\n</ol>\n<ul>\n<li>标准接口开放与对接，如oauth2</li>\n<li>高效稳定的数据接口</li>\n<li>灵活可扩展</li>\n</ul>\n<hr>\n<p><em>观点仅代表自己，期待你的留言。</em></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"数据集成平台：\"><a href=\"#数据集成平台：\" class=\"headerlink\" title=\"数据集成平台：\"></a>数据集成平台：</h2><ol>\n<li>组成：数据汇集、数据集成、数据安全守护、离线调度、数据共享</li>\n<li>特点：</li>\n</ol>\n<ul>\n<li>多样化汇集方式</li>\n<li>结构化半结构化非结构化数据汇集与集成</li>\n<li>高数据汇集实时性</li>\n<li>多样的集成算法</li>\n<li>高效的全流程监控的调度</li>\n<li>多样的数据实时非实时共享方式</li>\n</ul>\n<h2 id=\"数据管理平台：\"><a href=\"#数据管理平台：\" class=\"headerlink\" title=\"数据管理平台：\"></a>数据管理平台：</h2><ol>\n<li>组成：元数据管理、数据建模、主数据管理、数据标准、数据标签、数据安全审计、数据质量评估</li>\n<li>特点：</li>\n</ol>\n<ul>\n<li>多源异构管理数据源</li>\n<li>高效全面读取元数据</li>\n<li>元数据变更管理</li>\n<li>全面真实的元数据全链</li>\n<li>异构数据源数据模型转换</li>\n<li>权威可行的数据标准（本地、国标、行标）管理与应用</li>\n<li>业务贴合紧密的数据标签体系</li>\n<li>元数据设定安全规则管控与授权，保障数据的安全访问和更新</li>\n<li>源数据及数仓数据的全链校验，识别源头问题和数据集成期问题</li>\n</ul>\n<h2 id=\"数据运维平台：\"><a href=\"#数据运维平台：\" class=\"headerlink\" title=\"数据运维平台：\"></a>数据运维平台：</h2><ol>\n<li>组成：安装部署、日常巡检、软硬件及业务监控、主被动告警通知、动态伸缩集群、日志审计</li>\n<li>特点：</li>\n</ol>\n<ul>\n<li>监控指标丰富可插拔</li>\n<li>业务解耦，保持独立性</li>\n<li>WebSSH</li>\n</ul>\n<h2 id=\"数据运营平台：\"><a href=\"#数据运营平台：\" class=\"headerlink\" title=\"数据运营平台：\"></a>数据运营平台：</h2><ol>\n<li>组成：统一认证中心. 组织机构管理、用户帐户管理、角色授权管理</li>\n<li>特点：</li>\n</ol>\n<ul>\n<li>标准接口开放与对接，如oauth2</li>\n<li>高效稳定的数据接口</li>\n<li>灵活可扩展</li>\n</ul>\n<hr>\n<p><em>观点仅代表自己，期待你的留言。</em></p>\n"},{"title":"业务运营之运营指标","keywords":["运营指标","运营"],"date":"2021-08-26T13:04:02.000Z","_content":"\n## 业务运营之运营指标\n1. 用户获取\n- 渠道到达量（曝光量）\n- 渠道转化率（CPM，CPC，CPS，CPD，CPT等）\n- 渠道ROI\n- 日应用下载量\n- 日新增用户数\n- 用户获客成本（CAC）\n- 一次会话用户数\n2. 用户活跃\n- 活跃用户（DAU、WAU、MAU）\n- PV和UV\n- 用户会话次数\n- 用户访问时长\n- 功能使用率\n3. 用户留存\n- 留存率\n- 用户流失率\n- 退出率\n4. 营销\n- 用户生命周期\n- 用户生命周期价值\n- 客户/用户忠诚指数\n- 客户/用户流失指数\n- 客户/用户价值指数（RMF模型和PCA模型）\n5. 传播/活动\n- K因子\n- 病毒传播周期\n- 用户分享率\n- 活动曝光量/浏览量\n- 活动参与率\n6. 营收\n- 活跃交易用户数\n- GMV\n- 客单价\n- 复购率\n- 退货率\n\n-----\n\n*观点仅代表自己，期待你的留言。*\n","source":"_posts/bussiness-operate-target.md","raw":"---\ntitle: 业务运营之运营指标\ntags:\n  - 原创\nkeywords:\n  - 运营指标\n  - 运营\n\ndate: 2021-08-26 21:04:02\n---\n\n## 业务运营之运营指标\n1. 用户获取\n- 渠道到达量（曝光量）\n- 渠道转化率（CPM，CPC，CPS，CPD，CPT等）\n- 渠道ROI\n- 日应用下载量\n- 日新增用户数\n- 用户获客成本（CAC）\n- 一次会话用户数\n2. 用户活跃\n- 活跃用户（DAU、WAU、MAU）\n- PV和UV\n- 用户会话次数\n- 用户访问时长\n- 功能使用率\n3. 用户留存\n- 留存率\n- 用户流失率\n- 退出率\n4. 营销\n- 用户生命周期\n- 用户生命周期价值\n- 客户/用户忠诚指数\n- 客户/用户流失指数\n- 客户/用户价值指数（RMF模型和PCA模型）\n5. 传播/活动\n- K因子\n- 病毒传播周期\n- 用户分享率\n- 活动曝光量/浏览量\n- 活动参与率\n6. 营收\n- 活跃交易用户数\n- GMV\n- 客单价\n- 复购率\n- 退货率\n\n-----\n\n*观点仅代表自己，期待你的留言。*\n","slug":"bussiness-operate-target","published":1,"updated":"2021-09-01T02:12:45.512Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cku52dyll0006bbin4qrp6zam","content":"<h2 id=\"业务运营之运营指标\"><a href=\"#业务运营之运营指标\" class=\"headerlink\" title=\"业务运营之运营指标\"></a>业务运营之运营指标</h2><ol>\n<li>用户获取</li>\n</ol>\n<ul>\n<li>渠道到达量（曝光量）</li>\n<li>渠道转化率（CPM，CPC，CPS，CPD，CPT等）</li>\n<li>渠道ROI</li>\n<li>日应用下载量</li>\n<li>日新增用户数</li>\n<li>用户获客成本（CAC）</li>\n<li>一次会话用户数</li>\n</ul>\n<ol start=\"2\">\n<li>用户活跃</li>\n</ol>\n<ul>\n<li>活跃用户（DAU、WAU、MAU）</li>\n<li>PV和UV</li>\n<li>用户会话次数</li>\n<li>用户访问时长</li>\n<li>功能使用率</li>\n</ul>\n<ol start=\"3\">\n<li>用户留存</li>\n</ol>\n<ul>\n<li>留存率</li>\n<li>用户流失率</li>\n<li>退出率</li>\n</ul>\n<ol start=\"4\">\n<li>营销</li>\n</ol>\n<ul>\n<li>用户生命周期</li>\n<li>用户生命周期价值</li>\n<li>客户/用户忠诚指数</li>\n<li>客户/用户流失指数</li>\n<li>客户/用户价值指数（RMF模型和PCA模型）</li>\n</ul>\n<ol start=\"5\">\n<li>传播/活动</li>\n</ol>\n<ul>\n<li>K因子</li>\n<li>病毒传播周期</li>\n<li>用户分享率</li>\n<li>活动曝光量/浏览量</li>\n<li>活动参与率</li>\n</ul>\n<ol start=\"6\">\n<li>营收</li>\n</ol>\n<ul>\n<li>活跃交易用户数</li>\n<li>GMV</li>\n<li>客单价</li>\n<li>复购率</li>\n<li>退货率</li>\n</ul>\n<hr>\n<p><em>观点仅代表自己，期待你的留言。</em></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"业务运营之运营指标\"><a href=\"#业务运营之运营指标\" class=\"headerlink\" title=\"业务运营之运营指标\"></a>业务运营之运营指标</h2><ol>\n<li>用户获取</li>\n</ol>\n<ul>\n<li>渠道到达量（曝光量）</li>\n<li>渠道转化率（CPM，CPC，CPS，CPD，CPT等）</li>\n<li>渠道ROI</li>\n<li>日应用下载量</li>\n<li>日新增用户数</li>\n<li>用户获客成本（CAC）</li>\n<li>一次会话用户数</li>\n</ul>\n<ol start=\"2\">\n<li>用户活跃</li>\n</ol>\n<ul>\n<li>活跃用户（DAU、WAU、MAU）</li>\n<li>PV和UV</li>\n<li>用户会话次数</li>\n<li>用户访问时长</li>\n<li>功能使用率</li>\n</ul>\n<ol start=\"3\">\n<li>用户留存</li>\n</ol>\n<ul>\n<li>留存率</li>\n<li>用户流失率</li>\n<li>退出率</li>\n</ul>\n<ol start=\"4\">\n<li>营销</li>\n</ol>\n<ul>\n<li>用户生命周期</li>\n<li>用户生命周期价值</li>\n<li>客户/用户忠诚指数</li>\n<li>客户/用户流失指数</li>\n<li>客户/用户价值指数（RMF模型和PCA模型）</li>\n</ul>\n<ol start=\"5\">\n<li>传播/活动</li>\n</ol>\n<ul>\n<li>K因子</li>\n<li>病毒传播周期</li>\n<li>用户分享率</li>\n<li>活动曝光量/浏览量</li>\n<li>活动参与率</li>\n</ul>\n<ol start=\"6\">\n<li>营收</li>\n</ol>\n<ul>\n<li>活跃交易用户数</li>\n<li>GMV</li>\n<li>客单价</li>\n<li>复购率</li>\n<li>退货率</li>\n</ul>\n<hr>\n<p><em>观点仅代表自己，期待你的留言。</em></p>\n"},{"title":"业务运营之会员制","keywords":["会员制","运营"],"date":"2021-08-26T13:04:02.000Z","_content":"\n## 业务运营之会员制\n- 付费会员：通过将一整年的权益打包，一次性付费的形式，锁定客户的长期价值。而后续的续费率/复购率则需要企业通过优质的服务+产品来确保。如：京东plus会员、盒马X会员、视频网站会员。\n- 成长型会员：客户达到一定的消费金额或消费次数，即可升级会员等级，并享受相应的等级权益。如：星巴克会员\n- 储值会员：预充值会员，一次性充值一定的金额，享受会员权益。如：每周领购物券、会员日、商品以会员价/非会员价进行销售。\n\n\n-----\n\n*观点仅代表自己，期待你的留言。*\n","source":"_posts/bussiness-operate.md","raw":"---\ntitle: 业务运营之会员制\ntags:\n  - 原创\nkeywords:\n  - 会员制\n  - 运营\n\ndate: 2021-08-26 21:04:02\n---\n\n## 业务运营之会员制\n- 付费会员：通过将一整年的权益打包，一次性付费的形式，锁定客户的长期价值。而后续的续费率/复购率则需要企业通过优质的服务+产品来确保。如：京东plus会员、盒马X会员、视频网站会员。\n- 成长型会员：客户达到一定的消费金额或消费次数，即可升级会员等级，并享受相应的等级权益。如：星巴克会员\n- 储值会员：预充值会员，一次性充值一定的金额，享受会员权益。如：每周领购物券、会员日、商品以会员价/非会员价进行销售。\n\n\n-----\n\n*观点仅代表自己，期待你的留言。*\n","slug":"bussiness-operate","published":1,"updated":"2021-09-01T02:12:41.921Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cku52dylw0009bbincqkw2dcc","content":"<h2 id=\"业务运营之会员制\"><a href=\"#业务运营之会员制\" class=\"headerlink\" title=\"业务运营之会员制\"></a>业务运营之会员制</h2><ul>\n<li>付费会员：通过将一整年的权益打包，一次性付费的形式，锁定客户的长期价值。而后续的续费率/复购率则需要企业通过优质的服务+产品来确保。如：京东plus会员、盒马X会员、视频网站会员。</li>\n<li>成长型会员：客户达到一定的消费金额或消费次数，即可升级会员等级，并享受相应的等级权益。如：星巴克会员</li>\n<li>储值会员：预充值会员，一次性充值一定的金额，享受会员权益。如：每周领购物券、会员日、商品以会员价/非会员价进行销售。</li>\n</ul>\n<hr>\n<p><em>观点仅代表自己，期待你的留言。</em></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"业务运营之会员制\"><a href=\"#业务运营之会员制\" class=\"headerlink\" title=\"业务运营之会员制\"></a>业务运营之会员制</h2><ul>\n<li>付费会员：通过将一整年的权益打包，一次性付费的形式，锁定客户的长期价值。而后续的续费率/复购率则需要企业通过优质的服务+产品来确保。如：京东plus会员、盒马X会员、视频网站会员。</li>\n<li>成长型会员：客户达到一定的消费金额或消费次数，即可升级会员等级，并享受相应的等级权益。如：星巴克会员</li>\n<li>储值会员：预充值会员，一次性充值一定的金额，享受会员权益。如：每周领购物券、会员日、商品以会员价/非会员价进行销售。</li>\n</ul>\n<hr>\n<p><em>观点仅代表自己，期待你的留言。</em></p>\n"},{"title":"开源SSO项目cas认证返回更多的attribute信息","keywords":["cas sso","attribute","更多信息返回"],"date":"2016-08-16T10:41:39.000Z","_content":"\n## CAS项目介绍\n介绍网址： https://github.com/apereo/cas\ngithub地址：https://github.com/apereo/cas.git\n\n默认情况下，当用户认证成功后，客户端代码中只能获取到用户的登录名称，不能获取到其它的信息（如：手机号，所属角色，已有授权等），好在提供了一个attribute的map可以进行其它信息的返回。\n```\nAttributePrincipal ap = AssertionHolder.getAssertion().getPrincipal();\nString name = ap.getName();\nMap<String,Object> attribute = ap.getAttributes();\n```\n## 增加attribute信息返回\n### 修改ticket验证接口返回的xml信息\n找到WEB-INF/view/jsp/protocol/2.0/casServiceValidationSuccess.jsp，在</cas:authenticationSuccess>节点之前添加以下内容。\n```\n<cas:serviceResponse xmlns:cas='http://www.yale.edu/tp/cas'>\n    <cas:authenticationSuccess>\n    \t//...原有信息..//\n\t\t<c:if test=\"${fn:length(assertion.chainedAuthentications[fn:length(assertion.chainedAuthentications)-1].principal.attributes) > 0}\">\n            <cas:attributes>\n                <c:forEach var=\"attr\" items=\"${assertion.chainedAuthentications[fn:length(assertion.chainedAuthentications)-1].principal.attributes}\">\n                    <cas:attribute>\n                        <cas:${fn:escapeXml(attr.key)}>${fn:escapeXml(attr.value)}</cas:${fn:escapeXml(attr.key)}>\n                    </cas:attribute>\n                </c:forEach>\n            </cas:attributes>\n        </c:if>\n    </cas:authenticationSuccess>\n</cas:serviceResponse>\n```\n### 在用户登录验证时增加attribute关联\n\n在deployerConfigContext.xml配置文件中，默认采用AcceptUsersAuthenticationHandler类的users属性（以key为登录名value为密码）进行系统用户的设定。\n而通过PersonDirectoryPrincipalResolver的attributeRepository属性进行attribute映射和配置。默认由NamedStubPersonAttributeDao类的backingMap属性进行key-value配置，针对所有的用户都生效。\n提示：IPersonAttributeDao有很多的子类实现，可以通过源码查看各自实现的方式，我这里主要介绍json,xml和数据库三种方式实现。\n\n#### json配置的方式\n而在实际业务系统设计中针对不同的用户需要返回不同的attribute这个需求似乎不太适用，经过查看可能配置JsonBackedComplexStubPersonAttributeDao来在json中针对单个用户attribute进行配置。`指定init-method为init方法`\n配置如下：\n```\n<bean id=\"attributeRepository\" class=\"org.jasig.services.persondir.support.JsonBackedComplexStubPersonAttributeDao\" init-method=\"init\">\n    <constructor-arg index=\"0\" value=\"classpath:users.json\" />\n</bean>\n```\n_users.json_\n```\n{\n  \"user1\":{\n    \"id\":[\"1001\"],\n    \"firstName\":[\"View\"],\n    \"lastName\":[\"Jack\"],\n    \"roles\":[\"view\"],\n    \"permissions\":[\"support:*:view\"]\n  },\n  \"user2\":{\n    \"id\":[\"1002\"],\n    \"firstName\":[\"Admin\"],\n    \"lastName\":[\"One\"],\n    \"roles\":[\"admin\"],\n    \"permissions\":[\"support\"]\n  }\n}\n```\n#### xml配置的方式\n配置attributeRepository为XmlPersonAttributeDao来在xml中针对单个用户的attribute进行配置。\n配置如下：\n```\n<bean id=\"attributeRepository\" class=\"org.jasig.services.persondir.support.xml.XmlPersonAttributeDao\">\n    <property name=\"mappedXmlResource\" value=\"classpath:users.xml\" />\n</bean>\n```\n#### database读取的方式\n配置attributeRepository为NamedParameterJdbcPersonAttributeDao来在数据库按用户名进行attribute的配置加载。\n```\n<bean id=\"attributeRepository\" class=\"org.jasig.services.persondir.support.jdbc.SingleRowJdbcPersonAttributeDao\">\n    <property name=\"dataSource\" ref=\"datasource\" />\n    <property name=\"sql\" value=\"select email,name,username,password from cas_user where {0}\" />\n    <!-- 组装sql用的查询条件属性 -->\t\n\t<property name=\"queryAttributeMapping\">\n\t\t<map>\n\t\t    <!-- key必须是uername而且是小写否则会导致取不到用户的其它信息，value对应数据库用户名字段,系统会自己匹配 -->\n\t\t\t<entry key=\"username\" value=\"username\" />\n\t\t</map>\n\t</property>\n\t<property name=\"resultAttributeMapping\">\n\t\t<map>\n\t\t    <!-- key为对应的数据库字段名称，value为提供给客户端获取的属性名字，系统会自动填充值 -->\n\t\t\t<entry key=\"username\" value=\"username\" />\n\t\t\t<entry key=\"email\" value=\"email\" />\n\t\t\t<entry key=\"name\" value=\"name\" />\n\t\t\t<entry key=\"password\" value=\"password\" />\n\t\t</map>\n\t</property>\n</bean>\n```\n## 密码加密方式配置\n在实际开发中不能任由密码明文进行传输，一般来讲会进行加密。而cas可直接通过配置的方式进行加密方式的确定。\n在配置的AcceptUsersAuthenticationHandler中继承了父类中的一个名为passwordEncoder的PasswordEncoder类型属性。通过给这个属性配置加密方式值就能实现。默认为PlainTextPasswordEncoder加密方式。\n如配置md5的方式：\n```\n<bean id=\"primaryAuthenticationHandler\" class=\"org.jasig.cas.authentication.AcceptUsersAuthenticationHandler\">\n\t<property name=\"passwordEncoder\" ref=\"passwordEncoder\" />\n\t<property name=\"users\">\n        <map>\n            <entry key=\"user1\" value=\"123\" />\n            <entry key=\"user2\" value=\"123\" />\n        </map>\n    </property>\n</bean>\n<bean id=\"passwordEncoder\" class=\"org.jasig.cas.authentication.handler.DefaultPasswordEncoder\">\n\t<property name=\"characterEncoding\" value=\"utf-8\" />\n\t<property name=\"encodingAlgorithm\" value=\"MD5\" />\n</bean>\n```\n\n`提示：`配置了密码方式之后，所有配置文件或数据库中所存储的密码则应修改为密文。\n\n## 重要发现\n用户登录验证采用的AuthenticationHandler接口的子类实现，当我们自定义实现类完成验证时，不要妄想在通过HandlerResult的getPrincipal()获取到Principal然后给它设置attribute,因为cas在调用认证方式后会针对Principal的数据进行name的复制，所以即使你的认证方式进行了attribute的设置，在进行对象复制时也会丢掉。\n\n详见：PolicyBasedAuthenticationManager的authenticateInternal方法中的逻辑。\n![PolicyBasedAuthenticationManager-authenticateInternal](/images/QQ20160817-0.png)\n\n-----\n\n*观点仅代表自己，期待你的留言。*","source":"_posts/cas-attribute.md","raw":"---\ntitle: 开源SSO项目cas认证返回更多的attribute信息\nkeywords:\n  - cas sso\n  - attribute\n  - 更多信息返回\ntags:\n  - 原创\ndate: 2016-08-16 18:41:39\n---\n\n## CAS项目介绍\n介绍网址： https://github.com/apereo/cas\ngithub地址：https://github.com/apereo/cas.git\n\n默认情况下，当用户认证成功后，客户端代码中只能获取到用户的登录名称，不能获取到其它的信息（如：手机号，所属角色，已有授权等），好在提供了一个attribute的map可以进行其它信息的返回。\n```\nAttributePrincipal ap = AssertionHolder.getAssertion().getPrincipal();\nString name = ap.getName();\nMap<String,Object> attribute = ap.getAttributes();\n```\n## 增加attribute信息返回\n### 修改ticket验证接口返回的xml信息\n找到WEB-INF/view/jsp/protocol/2.0/casServiceValidationSuccess.jsp，在</cas:authenticationSuccess>节点之前添加以下内容。\n```\n<cas:serviceResponse xmlns:cas='http://www.yale.edu/tp/cas'>\n    <cas:authenticationSuccess>\n    \t//...原有信息..//\n\t\t<c:if test=\"${fn:length(assertion.chainedAuthentications[fn:length(assertion.chainedAuthentications)-1].principal.attributes) > 0}\">\n            <cas:attributes>\n                <c:forEach var=\"attr\" items=\"${assertion.chainedAuthentications[fn:length(assertion.chainedAuthentications)-1].principal.attributes}\">\n                    <cas:attribute>\n                        <cas:${fn:escapeXml(attr.key)}>${fn:escapeXml(attr.value)}</cas:${fn:escapeXml(attr.key)}>\n                    </cas:attribute>\n                </c:forEach>\n            </cas:attributes>\n        </c:if>\n    </cas:authenticationSuccess>\n</cas:serviceResponse>\n```\n### 在用户登录验证时增加attribute关联\n\n在deployerConfigContext.xml配置文件中，默认采用AcceptUsersAuthenticationHandler类的users属性（以key为登录名value为密码）进行系统用户的设定。\n而通过PersonDirectoryPrincipalResolver的attributeRepository属性进行attribute映射和配置。默认由NamedStubPersonAttributeDao类的backingMap属性进行key-value配置，针对所有的用户都生效。\n提示：IPersonAttributeDao有很多的子类实现，可以通过源码查看各自实现的方式，我这里主要介绍json,xml和数据库三种方式实现。\n\n#### json配置的方式\n而在实际业务系统设计中针对不同的用户需要返回不同的attribute这个需求似乎不太适用，经过查看可能配置JsonBackedComplexStubPersonAttributeDao来在json中针对单个用户attribute进行配置。`指定init-method为init方法`\n配置如下：\n```\n<bean id=\"attributeRepository\" class=\"org.jasig.services.persondir.support.JsonBackedComplexStubPersonAttributeDao\" init-method=\"init\">\n    <constructor-arg index=\"0\" value=\"classpath:users.json\" />\n</bean>\n```\n_users.json_\n```\n{\n  \"user1\":{\n    \"id\":[\"1001\"],\n    \"firstName\":[\"View\"],\n    \"lastName\":[\"Jack\"],\n    \"roles\":[\"view\"],\n    \"permissions\":[\"support:*:view\"]\n  },\n  \"user2\":{\n    \"id\":[\"1002\"],\n    \"firstName\":[\"Admin\"],\n    \"lastName\":[\"One\"],\n    \"roles\":[\"admin\"],\n    \"permissions\":[\"support\"]\n  }\n}\n```\n#### xml配置的方式\n配置attributeRepository为XmlPersonAttributeDao来在xml中针对单个用户的attribute进行配置。\n配置如下：\n```\n<bean id=\"attributeRepository\" class=\"org.jasig.services.persondir.support.xml.XmlPersonAttributeDao\">\n    <property name=\"mappedXmlResource\" value=\"classpath:users.xml\" />\n</bean>\n```\n#### database读取的方式\n配置attributeRepository为NamedParameterJdbcPersonAttributeDao来在数据库按用户名进行attribute的配置加载。\n```\n<bean id=\"attributeRepository\" class=\"org.jasig.services.persondir.support.jdbc.SingleRowJdbcPersonAttributeDao\">\n    <property name=\"dataSource\" ref=\"datasource\" />\n    <property name=\"sql\" value=\"select email,name,username,password from cas_user where {0}\" />\n    <!-- 组装sql用的查询条件属性 -->\t\n\t<property name=\"queryAttributeMapping\">\n\t\t<map>\n\t\t    <!-- key必须是uername而且是小写否则会导致取不到用户的其它信息，value对应数据库用户名字段,系统会自己匹配 -->\n\t\t\t<entry key=\"username\" value=\"username\" />\n\t\t</map>\n\t</property>\n\t<property name=\"resultAttributeMapping\">\n\t\t<map>\n\t\t    <!-- key为对应的数据库字段名称，value为提供给客户端获取的属性名字，系统会自动填充值 -->\n\t\t\t<entry key=\"username\" value=\"username\" />\n\t\t\t<entry key=\"email\" value=\"email\" />\n\t\t\t<entry key=\"name\" value=\"name\" />\n\t\t\t<entry key=\"password\" value=\"password\" />\n\t\t</map>\n\t</property>\n</bean>\n```\n## 密码加密方式配置\n在实际开发中不能任由密码明文进行传输，一般来讲会进行加密。而cas可直接通过配置的方式进行加密方式的确定。\n在配置的AcceptUsersAuthenticationHandler中继承了父类中的一个名为passwordEncoder的PasswordEncoder类型属性。通过给这个属性配置加密方式值就能实现。默认为PlainTextPasswordEncoder加密方式。\n如配置md5的方式：\n```\n<bean id=\"primaryAuthenticationHandler\" class=\"org.jasig.cas.authentication.AcceptUsersAuthenticationHandler\">\n\t<property name=\"passwordEncoder\" ref=\"passwordEncoder\" />\n\t<property name=\"users\">\n        <map>\n            <entry key=\"user1\" value=\"123\" />\n            <entry key=\"user2\" value=\"123\" />\n        </map>\n    </property>\n</bean>\n<bean id=\"passwordEncoder\" class=\"org.jasig.cas.authentication.handler.DefaultPasswordEncoder\">\n\t<property name=\"characterEncoding\" value=\"utf-8\" />\n\t<property name=\"encodingAlgorithm\" value=\"MD5\" />\n</bean>\n```\n\n`提示：`配置了密码方式之后，所有配置文件或数据库中所存储的密码则应修改为密文。\n\n## 重要发现\n用户登录验证采用的AuthenticationHandler接口的子类实现，当我们自定义实现类完成验证时，不要妄想在通过HandlerResult的getPrincipal()获取到Principal然后给它设置attribute,因为cas在调用认证方式后会针对Principal的数据进行name的复制，所以即使你的认证方式进行了attribute的设置，在进行对象复制时也会丢掉。\n\n详见：PolicyBasedAuthenticationManager的authenticateInternal方法中的逻辑。\n![PolicyBasedAuthenticationManager-authenticateInternal](/images/QQ20160817-0.png)\n\n-----\n\n*观点仅代表自己，期待你的留言。*","slug":"cas-attribute","published":1,"updated":"2021-08-31T14:23:11.537Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cku52dylx000bbbin1qm6b8j8","content":"<h2 id=\"CAS项目介绍\"><a href=\"#CAS项目介绍\" class=\"headerlink\" title=\"CAS项目介绍\"></a>CAS项目介绍</h2><p>介绍网址： <a href=\"https://github.com/apereo/cas\">https://github.com/apereo/cas</a><br>github地址：<a href=\"https://github.com/apereo/cas.git\">https://github.com/apereo/cas.git</a></p>\n<p>默认情况下，当用户认证成功后，客户端代码中只能获取到用户的登录名称，不能获取到其它的信息（如：手机号，所属角色，已有授权等），好在提供了一个attribute的map可以进行其它信息的返回。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">AttributePrincipal ap = AssertionHolder.getAssertion().getPrincipal();</span><br><span class=\"line\">String name = ap.getName();</span><br><span class=\"line\">Map&lt;String,Object&gt; attribute = ap.getAttributes();</span><br></pre></td></tr></table></figure>\n<h2 id=\"增加attribute信息返回\"><a href=\"#增加attribute信息返回\" class=\"headerlink\" title=\"增加attribute信息返回\"></a>增加attribute信息返回</h2><h3 id=\"修改ticket验证接口返回的xml信息\"><a href=\"#修改ticket验证接口返回的xml信息\" class=\"headerlink\" title=\"修改ticket验证接口返回的xml信息\"></a>修改ticket验证接口返回的xml信息</h3><p>找到WEB-INF/view/jsp/protocol/2.0/casServiceValidationSuccess.jsp，在</cas:authenticationSuccess>节点之前添加以下内容。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;cas:serviceResponse xmlns:cas=&#x27;http://www.yale.edu/tp/cas&#x27;&gt;</span><br><span class=\"line\">    &lt;cas:authenticationSuccess&gt;</span><br><span class=\"line\">    \t//...原有信息..//</span><br><span class=\"line\">\t\t&lt;c:if test=&quot;$&#123;fn:length(assertion.chainedAuthentications[fn:length(assertion.chainedAuthentications)-1].principal.attributes) &gt; 0&#125;&quot;&gt;</span><br><span class=\"line\">            &lt;cas:attributes&gt;</span><br><span class=\"line\">                &lt;c:forEach var=&quot;attr&quot; items=&quot;$&#123;assertion.chainedAuthentications[fn:length(assertion.chainedAuthentications)-1].principal.attributes&#125;&quot;&gt;</span><br><span class=\"line\">                    &lt;cas:attribute&gt;</span><br><span class=\"line\">                        &lt;cas:$&#123;fn:escapeXml(attr.key)&#125;&gt;$&#123;fn:escapeXml(attr.value)&#125;&lt;/cas:$&#123;fn:escapeXml(attr.key)&#125;&gt;</span><br><span class=\"line\">                    &lt;/cas:attribute&gt;</span><br><span class=\"line\">                &lt;/c:forEach&gt;</span><br><span class=\"line\">            &lt;/cas:attributes&gt;</span><br><span class=\"line\">        &lt;/c:if&gt;</span><br><span class=\"line\">    &lt;/cas:authenticationSuccess&gt;</span><br><span class=\"line\">&lt;/cas:serviceResponse&gt;</span><br></pre></td></tr></table></figure>\n<h3 id=\"在用户登录验证时增加attribute关联\"><a href=\"#在用户登录验证时增加attribute关联\" class=\"headerlink\" title=\"在用户登录验证时增加attribute关联\"></a>在用户登录验证时增加attribute关联</h3><p>在deployerConfigContext.xml配置文件中，默认采用AcceptUsersAuthenticationHandler类的users属性（以key为登录名value为密码）进行系统用户的设定。<br>而通过PersonDirectoryPrincipalResolver的attributeRepository属性进行attribute映射和配置。默认由NamedStubPersonAttributeDao类的backingMap属性进行key-value配置，针对所有的用户都生效。<br>提示：IPersonAttributeDao有很多的子类实现，可以通过源码查看各自实现的方式，我这里主要介绍json,xml和数据库三种方式实现。</p>\n<h4 id=\"json配置的方式\"><a href=\"#json配置的方式\" class=\"headerlink\" title=\"json配置的方式\"></a>json配置的方式</h4><p>而在实际业务系统设计中针对不同的用户需要返回不同的attribute这个需求似乎不太适用，经过查看可能配置JsonBackedComplexStubPersonAttributeDao来在json中针对单个用户attribute进行配置。<code>指定init-method为init方法</code><br>配置如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;bean id=&quot;attributeRepository&quot; class=&quot;org.jasig.services.persondir.support.JsonBackedComplexStubPersonAttributeDao&quot; init-method=&quot;init&quot;&gt;</span><br><span class=\"line\">    &lt;constructor-arg index=&quot;0&quot; value=&quot;classpath:users.json&quot; /&gt;</span><br><span class=\"line\">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>\n<p><em>users.json</em></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;user1&quot;:&#123;</span><br><span class=\"line\">    &quot;id&quot;:[&quot;1001&quot;],</span><br><span class=\"line\">    &quot;firstName&quot;:[&quot;View&quot;],</span><br><span class=\"line\">    &quot;lastName&quot;:[&quot;Jack&quot;],</span><br><span class=\"line\">    &quot;roles&quot;:[&quot;view&quot;],</span><br><span class=\"line\">    &quot;permissions&quot;:[&quot;support:*:view&quot;]</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  &quot;user2&quot;:&#123;</span><br><span class=\"line\">    &quot;id&quot;:[&quot;1002&quot;],</span><br><span class=\"line\">    &quot;firstName&quot;:[&quot;Admin&quot;],</span><br><span class=\"line\">    &quot;lastName&quot;:[&quot;One&quot;],</span><br><span class=\"line\">    &quot;roles&quot;:[&quot;admin&quot;],</span><br><span class=\"line\">    &quot;permissions&quot;:[&quot;support&quot;]</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"xml配置的方式\"><a href=\"#xml配置的方式\" class=\"headerlink\" title=\"xml配置的方式\"></a>xml配置的方式</h4><p>配置attributeRepository为XmlPersonAttributeDao来在xml中针对单个用户的attribute进行配置。<br>配置如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;bean id=&quot;attributeRepository&quot; class=&quot;org.jasig.services.persondir.support.xml.XmlPersonAttributeDao&quot;&gt;</span><br><span class=\"line\">    &lt;property name=&quot;mappedXmlResource&quot; value=&quot;classpath:users.xml&quot; /&gt;</span><br><span class=\"line\">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>\n<h4 id=\"database读取的方式\"><a href=\"#database读取的方式\" class=\"headerlink\" title=\"database读取的方式\"></a>database读取的方式</h4><p>配置attributeRepository为NamedParameterJdbcPersonAttributeDao来在数据库按用户名进行attribute的配置加载。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;bean id=&quot;attributeRepository&quot; class=&quot;org.jasig.services.persondir.support.jdbc.SingleRowJdbcPersonAttributeDao&quot;&gt;</span><br><span class=\"line\">    &lt;property name=&quot;dataSource&quot; ref=&quot;datasource&quot; /&gt;</span><br><span class=\"line\">    &lt;property name=&quot;sql&quot; value=&quot;select email,name,username,password from cas_user where &#123;0&#125;&quot; /&gt;</span><br><span class=\"line\">    &lt;!-- 组装sql用的查询条件属性 --&gt;\t</span><br><span class=\"line\">\t&lt;property name=&quot;queryAttributeMapping&quot;&gt;</span><br><span class=\"line\">\t\t&lt;map&gt;</span><br><span class=\"line\">\t\t    &lt;!-- key必须是uername而且是小写否则会导致取不到用户的其它信息，value对应数据库用户名字段,系统会自己匹配 --&gt;</span><br><span class=\"line\">\t\t\t&lt;entry key=&quot;username&quot; value=&quot;username&quot; /&gt;</span><br><span class=\"line\">\t\t&lt;/map&gt;</span><br><span class=\"line\">\t&lt;/property&gt;</span><br><span class=\"line\">\t&lt;property name=&quot;resultAttributeMapping&quot;&gt;</span><br><span class=\"line\">\t\t&lt;map&gt;</span><br><span class=\"line\">\t\t    &lt;!-- key为对应的数据库字段名称，value为提供给客户端获取的属性名字，系统会自动填充值 --&gt;</span><br><span class=\"line\">\t\t\t&lt;entry key=&quot;username&quot; value=&quot;username&quot; /&gt;</span><br><span class=\"line\">\t\t\t&lt;entry key=&quot;email&quot; value=&quot;email&quot; /&gt;</span><br><span class=\"line\">\t\t\t&lt;entry key=&quot;name&quot; value=&quot;name&quot; /&gt;</span><br><span class=\"line\">\t\t\t&lt;entry key=&quot;password&quot; value=&quot;password&quot; /&gt;</span><br><span class=\"line\">\t\t&lt;/map&gt;</span><br><span class=\"line\">\t&lt;/property&gt;</span><br><span class=\"line\">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>\n<h2 id=\"密码加密方式配置\"><a href=\"#密码加密方式配置\" class=\"headerlink\" title=\"密码加密方式配置\"></a>密码加密方式配置</h2><p>在实际开发中不能任由密码明文进行传输，一般来讲会进行加密。而cas可直接通过配置的方式进行加密方式的确定。<br>在配置的AcceptUsersAuthenticationHandler中继承了父类中的一个名为passwordEncoder的PasswordEncoder类型属性。通过给这个属性配置加密方式值就能实现。默认为PlainTextPasswordEncoder加密方式。<br>如配置md5的方式：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;bean id=&quot;primaryAuthenticationHandler&quot; class=&quot;org.jasig.cas.authentication.AcceptUsersAuthenticationHandler&quot;&gt;</span><br><span class=\"line\">\t&lt;property name=&quot;passwordEncoder&quot; ref=&quot;passwordEncoder&quot; /&gt;</span><br><span class=\"line\">\t&lt;property name=&quot;users&quot;&gt;</span><br><span class=\"line\">        &lt;map&gt;</span><br><span class=\"line\">            &lt;entry key=&quot;user1&quot; value=&quot;123&quot; /&gt;</span><br><span class=\"line\">            &lt;entry key=&quot;user2&quot; value=&quot;123&quot; /&gt;</span><br><span class=\"line\">        &lt;/map&gt;</span><br><span class=\"line\">    &lt;/property&gt;</span><br><span class=\"line\">&lt;/bean&gt;</span><br><span class=\"line\">&lt;bean id=&quot;passwordEncoder&quot; class=&quot;org.jasig.cas.authentication.handler.DefaultPasswordEncoder&quot;&gt;</span><br><span class=\"line\">\t&lt;property name=&quot;characterEncoding&quot; value=&quot;utf-8&quot; /&gt;</span><br><span class=\"line\">\t&lt;property name=&quot;encodingAlgorithm&quot; value=&quot;MD5&quot; /&gt;</span><br><span class=\"line\">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>\n\n<p><code>提示：</code>配置了密码方式之后，所有配置文件或数据库中所存储的密码则应修改为密文。</p>\n<h2 id=\"重要发现\"><a href=\"#重要发现\" class=\"headerlink\" title=\"重要发现\"></a>重要发现</h2><p>用户登录验证采用的AuthenticationHandler接口的子类实现，当我们自定义实现类完成验证时，不要妄想在通过HandlerResult的getPrincipal()获取到Principal然后给它设置attribute,因为cas在调用认证方式后会针对Principal的数据进行name的复制，所以即使你的认证方式进行了attribute的设置，在进行对象复制时也会丢掉。</p>\n<p>详见：PolicyBasedAuthenticationManager的authenticateInternal方法中的逻辑。<br><img src=\"/images/QQ20160817-0.png\" alt=\"PolicyBasedAuthenticationManager-authenticateInternal\"></p>\n<hr>\n<p><em>观点仅代表自己，期待你的留言。</em></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"CAS项目介绍\"><a href=\"#CAS项目介绍\" class=\"headerlink\" title=\"CAS项目介绍\"></a>CAS项目介绍</h2><p>介绍网址： <a href=\"https://github.com/apereo/cas\">https://github.com/apereo/cas</a><br>github地址：<a href=\"https://github.com/apereo/cas.git\">https://github.com/apereo/cas.git</a></p>\n<p>默认情况下，当用户认证成功后，客户端代码中只能获取到用户的登录名称，不能获取到其它的信息（如：手机号，所属角色，已有授权等），好在提供了一个attribute的map可以进行其它信息的返回。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">AttributePrincipal ap = AssertionHolder.getAssertion().getPrincipal();</span><br><span class=\"line\">String name = ap.getName();</span><br><span class=\"line\">Map&lt;String,Object&gt; attribute = ap.getAttributes();</span><br></pre></td></tr></table></figure>\n<h2 id=\"增加attribute信息返回\"><a href=\"#增加attribute信息返回\" class=\"headerlink\" title=\"增加attribute信息返回\"></a>增加attribute信息返回</h2><h3 id=\"修改ticket验证接口返回的xml信息\"><a href=\"#修改ticket验证接口返回的xml信息\" class=\"headerlink\" title=\"修改ticket验证接口返回的xml信息\"></a>修改ticket验证接口返回的xml信息</h3><p>找到WEB-INF/view/jsp/protocol/2.0/casServiceValidationSuccess.jsp，在</cas:authenticationSuccess>节点之前添加以下内容。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;cas:serviceResponse xmlns:cas=&#x27;http://www.yale.edu/tp/cas&#x27;&gt;</span><br><span class=\"line\">    &lt;cas:authenticationSuccess&gt;</span><br><span class=\"line\">    \t//...原有信息..//</span><br><span class=\"line\">\t\t&lt;c:if test=&quot;$&#123;fn:length(assertion.chainedAuthentications[fn:length(assertion.chainedAuthentications)-1].principal.attributes) &gt; 0&#125;&quot;&gt;</span><br><span class=\"line\">            &lt;cas:attributes&gt;</span><br><span class=\"line\">                &lt;c:forEach var=&quot;attr&quot; items=&quot;$&#123;assertion.chainedAuthentications[fn:length(assertion.chainedAuthentications)-1].principal.attributes&#125;&quot;&gt;</span><br><span class=\"line\">                    &lt;cas:attribute&gt;</span><br><span class=\"line\">                        &lt;cas:$&#123;fn:escapeXml(attr.key)&#125;&gt;$&#123;fn:escapeXml(attr.value)&#125;&lt;/cas:$&#123;fn:escapeXml(attr.key)&#125;&gt;</span><br><span class=\"line\">                    &lt;/cas:attribute&gt;</span><br><span class=\"line\">                &lt;/c:forEach&gt;</span><br><span class=\"line\">            &lt;/cas:attributes&gt;</span><br><span class=\"line\">        &lt;/c:if&gt;</span><br><span class=\"line\">    &lt;/cas:authenticationSuccess&gt;</span><br><span class=\"line\">&lt;/cas:serviceResponse&gt;</span><br></pre></td></tr></table></figure>\n<h3 id=\"在用户登录验证时增加attribute关联\"><a href=\"#在用户登录验证时增加attribute关联\" class=\"headerlink\" title=\"在用户登录验证时增加attribute关联\"></a>在用户登录验证时增加attribute关联</h3><p>在deployerConfigContext.xml配置文件中，默认采用AcceptUsersAuthenticationHandler类的users属性（以key为登录名value为密码）进行系统用户的设定。<br>而通过PersonDirectoryPrincipalResolver的attributeRepository属性进行attribute映射和配置。默认由NamedStubPersonAttributeDao类的backingMap属性进行key-value配置，针对所有的用户都生效。<br>提示：IPersonAttributeDao有很多的子类实现，可以通过源码查看各自实现的方式，我这里主要介绍json,xml和数据库三种方式实现。</p>\n<h4 id=\"json配置的方式\"><a href=\"#json配置的方式\" class=\"headerlink\" title=\"json配置的方式\"></a>json配置的方式</h4><p>而在实际业务系统设计中针对不同的用户需要返回不同的attribute这个需求似乎不太适用，经过查看可能配置JsonBackedComplexStubPersonAttributeDao来在json中针对单个用户attribute进行配置。<code>指定init-method为init方法</code><br>配置如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;bean id=&quot;attributeRepository&quot; class=&quot;org.jasig.services.persondir.support.JsonBackedComplexStubPersonAttributeDao&quot; init-method=&quot;init&quot;&gt;</span><br><span class=\"line\">    &lt;constructor-arg index=&quot;0&quot; value=&quot;classpath:users.json&quot; /&gt;</span><br><span class=\"line\">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>\n<p><em>users.json</em></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;user1&quot;:&#123;</span><br><span class=\"line\">    &quot;id&quot;:[&quot;1001&quot;],</span><br><span class=\"line\">    &quot;firstName&quot;:[&quot;View&quot;],</span><br><span class=\"line\">    &quot;lastName&quot;:[&quot;Jack&quot;],</span><br><span class=\"line\">    &quot;roles&quot;:[&quot;view&quot;],</span><br><span class=\"line\">    &quot;permissions&quot;:[&quot;support:*:view&quot;]</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  &quot;user2&quot;:&#123;</span><br><span class=\"line\">    &quot;id&quot;:[&quot;1002&quot;],</span><br><span class=\"line\">    &quot;firstName&quot;:[&quot;Admin&quot;],</span><br><span class=\"line\">    &quot;lastName&quot;:[&quot;One&quot;],</span><br><span class=\"line\">    &quot;roles&quot;:[&quot;admin&quot;],</span><br><span class=\"line\">    &quot;permissions&quot;:[&quot;support&quot;]</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"xml配置的方式\"><a href=\"#xml配置的方式\" class=\"headerlink\" title=\"xml配置的方式\"></a>xml配置的方式</h4><p>配置attributeRepository为XmlPersonAttributeDao来在xml中针对单个用户的attribute进行配置。<br>配置如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;bean id=&quot;attributeRepository&quot; class=&quot;org.jasig.services.persondir.support.xml.XmlPersonAttributeDao&quot;&gt;</span><br><span class=\"line\">    &lt;property name=&quot;mappedXmlResource&quot; value=&quot;classpath:users.xml&quot; /&gt;</span><br><span class=\"line\">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>\n<h4 id=\"database读取的方式\"><a href=\"#database读取的方式\" class=\"headerlink\" title=\"database读取的方式\"></a>database读取的方式</h4><p>配置attributeRepository为NamedParameterJdbcPersonAttributeDao来在数据库按用户名进行attribute的配置加载。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;bean id=&quot;attributeRepository&quot; class=&quot;org.jasig.services.persondir.support.jdbc.SingleRowJdbcPersonAttributeDao&quot;&gt;</span><br><span class=\"line\">    &lt;property name=&quot;dataSource&quot; ref=&quot;datasource&quot; /&gt;</span><br><span class=\"line\">    &lt;property name=&quot;sql&quot; value=&quot;select email,name,username,password from cas_user where &#123;0&#125;&quot; /&gt;</span><br><span class=\"line\">    &lt;!-- 组装sql用的查询条件属性 --&gt;\t</span><br><span class=\"line\">\t&lt;property name=&quot;queryAttributeMapping&quot;&gt;</span><br><span class=\"line\">\t\t&lt;map&gt;</span><br><span class=\"line\">\t\t    &lt;!-- key必须是uername而且是小写否则会导致取不到用户的其它信息，value对应数据库用户名字段,系统会自己匹配 --&gt;</span><br><span class=\"line\">\t\t\t&lt;entry key=&quot;username&quot; value=&quot;username&quot; /&gt;</span><br><span class=\"line\">\t\t&lt;/map&gt;</span><br><span class=\"line\">\t&lt;/property&gt;</span><br><span class=\"line\">\t&lt;property name=&quot;resultAttributeMapping&quot;&gt;</span><br><span class=\"line\">\t\t&lt;map&gt;</span><br><span class=\"line\">\t\t    &lt;!-- key为对应的数据库字段名称，value为提供给客户端获取的属性名字，系统会自动填充值 --&gt;</span><br><span class=\"line\">\t\t\t&lt;entry key=&quot;username&quot; value=&quot;username&quot; /&gt;</span><br><span class=\"line\">\t\t\t&lt;entry key=&quot;email&quot; value=&quot;email&quot; /&gt;</span><br><span class=\"line\">\t\t\t&lt;entry key=&quot;name&quot; value=&quot;name&quot; /&gt;</span><br><span class=\"line\">\t\t\t&lt;entry key=&quot;password&quot; value=&quot;password&quot; /&gt;</span><br><span class=\"line\">\t\t&lt;/map&gt;</span><br><span class=\"line\">\t&lt;/property&gt;</span><br><span class=\"line\">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>\n<h2 id=\"密码加密方式配置\"><a href=\"#密码加密方式配置\" class=\"headerlink\" title=\"密码加密方式配置\"></a>密码加密方式配置</h2><p>在实际开发中不能任由密码明文进行传输，一般来讲会进行加密。而cas可直接通过配置的方式进行加密方式的确定。<br>在配置的AcceptUsersAuthenticationHandler中继承了父类中的一个名为passwordEncoder的PasswordEncoder类型属性。通过给这个属性配置加密方式值就能实现。默认为PlainTextPasswordEncoder加密方式。<br>如配置md5的方式：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;bean id=&quot;primaryAuthenticationHandler&quot; class=&quot;org.jasig.cas.authentication.AcceptUsersAuthenticationHandler&quot;&gt;</span><br><span class=\"line\">\t&lt;property name=&quot;passwordEncoder&quot; ref=&quot;passwordEncoder&quot; /&gt;</span><br><span class=\"line\">\t&lt;property name=&quot;users&quot;&gt;</span><br><span class=\"line\">        &lt;map&gt;</span><br><span class=\"line\">            &lt;entry key=&quot;user1&quot; value=&quot;123&quot; /&gt;</span><br><span class=\"line\">            &lt;entry key=&quot;user2&quot; value=&quot;123&quot; /&gt;</span><br><span class=\"line\">        &lt;/map&gt;</span><br><span class=\"line\">    &lt;/property&gt;</span><br><span class=\"line\">&lt;/bean&gt;</span><br><span class=\"line\">&lt;bean id=&quot;passwordEncoder&quot; class=&quot;org.jasig.cas.authentication.handler.DefaultPasswordEncoder&quot;&gt;</span><br><span class=\"line\">\t&lt;property name=&quot;characterEncoding&quot; value=&quot;utf-8&quot; /&gt;</span><br><span class=\"line\">\t&lt;property name=&quot;encodingAlgorithm&quot; value=&quot;MD5&quot; /&gt;</span><br><span class=\"line\">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>\n\n<p><code>提示：</code>配置了密码方式之后，所有配置文件或数据库中所存储的密码则应修改为密文。</p>\n<h2 id=\"重要发现\"><a href=\"#重要发现\" class=\"headerlink\" title=\"重要发现\"></a>重要发现</h2><p>用户登录验证采用的AuthenticationHandler接口的子类实现，当我们自定义实现类完成验证时，不要妄想在通过HandlerResult的getPrincipal()获取到Principal然后给它设置attribute,因为cas在调用认证方式后会针对Principal的数据进行name的复制，所以即使你的认证方式进行了attribute的设置，在进行对象复制时也会丢掉。</p>\n<p>详见：PolicyBasedAuthenticationManager的authenticateInternal方法中的逻辑。<br><img src=\"/images/QQ20160817-0.png\" alt=\"PolicyBasedAuthenticationManager-authenticateInternal\"></p>\n<hr>\n<p><em>观点仅代表自己，期待你的留言。</em></p>\n"},{"title":"Shiro与Cas集成后的登录流程时序图","date":"2016-08-17T08:44:13.000Z","_content":"\n## 框架介绍\nShiro是apache开源项目，主要用户客户端管理登录用户权限提示非常方式的认证接口及丰富的注解。\nCAS （ Central Authentication Service ）是Yale大学发起的一个企业级的、开源的项目，旨在为 Web 应用系统提供一种可靠的单点登录解决方案（属于Web SSO）。主要用于用户登录认证与登录有效期认证。\n\n## 调用时序\n![集成cas与shiro后的用户登录时序图](/images/cas-shiro-auth-flow.png)\n\n-----\n\n*观点仅代表自己，期待你的留言。*","source":"_posts/cas-shiro-auth-flow.md","raw":"---\ntitle: Shiro与Cas集成后的登录流程时序图\ntags:\n  - 原创\ndate: 2016-08-17 16:44:13\n---\n\n## 框架介绍\nShiro是apache开源项目，主要用户客户端管理登录用户权限提示非常方式的认证接口及丰富的注解。\nCAS （ Central Authentication Service ）是Yale大学发起的一个企业级的、开源的项目，旨在为 Web 应用系统提供一种可靠的单点登录解决方案（属于Web SSO）。主要用于用户登录认证与登录有效期认证。\n\n## 调用时序\n![集成cas与shiro后的用户登录时序图](/images/cas-shiro-auth-flow.png)\n\n-----\n\n*观点仅代表自己，期待你的留言。*","slug":"cas-shiro-auth-flow","published":1,"updated":"2021-08-31T14:23:11.537Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cku52dym1000ebbingxa842qa","content":"<h2 id=\"框架介绍\"><a href=\"#框架介绍\" class=\"headerlink\" title=\"框架介绍\"></a>框架介绍</h2><p>Shiro是apache开源项目，主要用户客户端管理登录用户权限提示非常方式的认证接口及丰富的注解。<br>CAS （ Central Authentication Service ）是Yale大学发起的一个企业级的、开源的项目，旨在为 Web 应用系统提供一种可靠的单点登录解决方案（属于Web SSO）。主要用于用户登录认证与登录有效期认证。</p>\n<h2 id=\"调用时序\"><a href=\"#调用时序\" class=\"headerlink\" title=\"调用时序\"></a>调用时序</h2><p><img src=\"/images/cas-shiro-auth-flow.png\" alt=\"集成cas与shiro后的用户登录时序图\"></p>\n<hr>\n<p><em>观点仅代表自己，期待你的留言。</em></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"框架介绍\"><a href=\"#框架介绍\" class=\"headerlink\" title=\"框架介绍\"></a>框架介绍</h2><p>Shiro是apache开源项目，主要用户客户端管理登录用户权限提示非常方式的认证接口及丰富的注解。<br>CAS （ Central Authentication Service ）是Yale大学发起的一个企业级的、开源的项目，旨在为 Web 应用系统提供一种可靠的单点登录解决方案（属于Web SSO）。主要用于用户登录认证与登录有效期认证。</p>\n<h2 id=\"调用时序\"><a href=\"#调用时序\" class=\"headerlink\" title=\"调用时序\"></a>调用时序</h2><p><img src=\"/images/cas-shiro-auth-flow.png\" alt=\"集成cas与shiro后的用户登录时序图\"></p>\n<hr>\n<p><em>观点仅代表自己，期待你的留言。</em></p>\n"},{"title":"中国城市信息数据库","keywords":["国内城市数据库"],"date":"2016-09-01T10:27:21.000Z","_content":"\n## 简介\n最近整理的中国全国城市数据库信息，共享于网络。\n\n[城市数据库附件，点击下载](/data/t_city.sql)\n\n-----\n\n*观点仅代表自己，期待你的留言。*","source":"_posts/china-city-data.md","raw":"---\ntitle: 中国城市信息数据库\nkeywords: \n  - 国内城市数据库\ntags:\n  - 原创\ndate: 2016-09-01 18:27:21\n---\n\n## 简介\n最近整理的中国全国城市数据库信息，共享于网络。\n\n[城市数据库附件，点击下载](/data/t_city.sql)\n\n-----\n\n*观点仅代表自己，期待你的留言。*","slug":"china-city-data","published":1,"updated":"2021-08-31T14:23:11.538Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cku52dym2000gbbin2w4j6yql","content":"<h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><p>最近整理的中国全国城市数据库信息，共享于网络。</p>\n<p><a href=\"/data/t_city.sql\">城市数据库附件，点击下载</a></p>\n<hr>\n<p><em>观点仅代表自己，期待你的留言。</em></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><p>最近整理的中国全国城市数据库信息，共享于网络。</p>\n<p><a href=\"/data/t_city.sql\">城市数据库附件，点击下载</a></p>\n<hr>\n<p><em>观点仅代表自己，期待你的留言。</em></p>\n"},{"title":"Java对中国夏令时的展示","date":"2018-08-24T11:14:57.000Z","_content":"\n## 中国夏令时制度实行时间\n中华人民共和国在1986年~1991年实行了夏令时制度，每年夏令时实行时间如下：\n```text\n1986年5月4日至9月14日（1986年因是实行夏令时的第一年，从5月4日开始到9月14日结束）\n1987年4月12日至9月13日，\n1988年4月10日至9月11日，\n1989年4月16日至9月17日，\n1990年4月15日至9月16日，\n1991年4月14日至9月15日。\n```\n## JDK已有对夏令时的处理\nJava的jdk在Date的toString中已经包含夏令时的计算，以下代码可以印证：\n```java\npublic static void main(String[] args) throws Exception {\n    SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\");\n    String sTime = \"1986-09-13 22:00:00\";\n    sdf.setTimeZone(TimeZone.getTimeZone(\"Asia/Shanghai\"));\n    TimeZone.setDefault(TimeZone.getTimeZone(\"Asia/Shanghai\"));\n    Date time = sdf.parse(sTime);\n    System.out.println(time.getTime());\n    System.out.println(time);\n    Calendar cd = Calendar.getInstance();\n    cd.setTime(time);\n    // 2小时以后是几点？\n    cd.add(Calendar.HOUR, 2);\n    time = cd.getTime();\n    System.out.println(\"------------------------------\");\n    System.out.println(time.getTime());\n    System.out.println(time);\n}\n```\n打印结果:\n```text\n527000400000\nSat Sep 13 22:00:00 CDT 1986\n------------------------------\n527007600000\nSat Sep 13 23:00:00 CST 1986\n```\n`分析`: 上面代码中1986-09-1322:00:00加上2小时，应该变为1986-09-13 24:00:00（或者1986-09-14 00:00:00），但由于在9月14日零点退出夏令时，时钟向后调整1小时，实际变为1986-09-13 23:00:00。\n注意：从9月14日零点退出夏令时，java的Date.toString打印的时区也从CDT恢复为CST( ChinaStandard Time UT+8:00)。\n\n又如：\n```bash\nwujianjun@smzc ~ $ date\n2018年 08月 24日 星期五 19:20:41 CST\nwujianjun@smzc ~ $ date -d @579279600\n1988年 05月 11日 星期三 00:00:00 CDT\nwujianjun@smzc ~ $ date -d @599587200\n1989年 01月 01日 星期日 00:00:00 CST\n\n```\n`结论`: 只要是在实行夏令时的时段都是`CDT`时间，其它都是`CST`\n\n-----\n\n*观点仅代表自己，期待你的留言。*\n","source":"_posts/cdt-java.md","raw":"---\ntitle: Java对中国夏令时的展示\ntags:\n  - 原创\n  - cdt\ndate: 2018-08-24 19:14:57\n---\n\n## 中国夏令时制度实行时间\n中华人民共和国在1986年~1991年实行了夏令时制度，每年夏令时实行时间如下：\n```text\n1986年5月4日至9月14日（1986年因是实行夏令时的第一年，从5月4日开始到9月14日结束）\n1987年4月12日至9月13日，\n1988年4月10日至9月11日，\n1989年4月16日至9月17日，\n1990年4月15日至9月16日，\n1991年4月14日至9月15日。\n```\n## JDK已有对夏令时的处理\nJava的jdk在Date的toString中已经包含夏令时的计算，以下代码可以印证：\n```java\npublic static void main(String[] args) throws Exception {\n    SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\");\n    String sTime = \"1986-09-13 22:00:00\";\n    sdf.setTimeZone(TimeZone.getTimeZone(\"Asia/Shanghai\"));\n    TimeZone.setDefault(TimeZone.getTimeZone(\"Asia/Shanghai\"));\n    Date time = sdf.parse(sTime);\n    System.out.println(time.getTime());\n    System.out.println(time);\n    Calendar cd = Calendar.getInstance();\n    cd.setTime(time);\n    // 2小时以后是几点？\n    cd.add(Calendar.HOUR, 2);\n    time = cd.getTime();\n    System.out.println(\"------------------------------\");\n    System.out.println(time.getTime());\n    System.out.println(time);\n}\n```\n打印结果:\n```text\n527000400000\nSat Sep 13 22:00:00 CDT 1986\n------------------------------\n527007600000\nSat Sep 13 23:00:00 CST 1986\n```\n`分析`: 上面代码中1986-09-1322:00:00加上2小时，应该变为1986-09-13 24:00:00（或者1986-09-14 00:00:00），但由于在9月14日零点退出夏令时，时钟向后调整1小时，实际变为1986-09-13 23:00:00。\n注意：从9月14日零点退出夏令时，java的Date.toString打印的时区也从CDT恢复为CST( ChinaStandard Time UT+8:00)。\n\n又如：\n```bash\nwujianjun@smzc ~ $ date\n2018年 08月 24日 星期五 19:20:41 CST\nwujianjun@smzc ~ $ date -d @579279600\n1988年 05月 11日 星期三 00:00:00 CDT\nwujianjun@smzc ~ $ date -d @599587200\n1989年 01月 01日 星期日 00:00:00 CST\n\n```\n`结论`: 只要是在实行夏令时的时段都是`CDT`时间，其它都是`CST`\n\n-----\n\n*观点仅代表自己，期待你的留言。*\n","slug":"cdt-java","published":1,"updated":"2021-08-31T14:23:11.537Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cku52dym3000jbbin0842aban","content":"<h2 id=\"中国夏令时制度实行时间\"><a href=\"#中国夏令时制度实行时间\" class=\"headerlink\" title=\"中国夏令时制度实行时间\"></a>中国夏令时制度实行时间</h2><p>中华人民共和国在1986年~1991年实行了夏令时制度，每年夏令时实行时间如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1986年5月4日至9月14日（1986年因是实行夏令时的第一年，从5月4日开始到9月14日结束）</span><br><span class=\"line\">1987年4月12日至9月13日，</span><br><span class=\"line\">1988年4月10日至9月11日，</span><br><span class=\"line\">1989年4月16日至9月17日，</span><br><span class=\"line\">1990年4月15日至9月16日，</span><br><span class=\"line\">1991年4月14日至9月15日。</span><br></pre></td></tr></table></figure>\n<h2 id=\"JDK已有对夏令时的处理\"><a href=\"#JDK已有对夏令时的处理\" class=\"headerlink\" title=\"JDK已有对夏令时的处理\"></a>JDK已有对夏令时的处理</h2><p>Java的jdk在Date的toString中已经包含夏令时的计算，以下代码可以印证：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">    SimpleDateFormat sdf = <span class=\"keyword\">new</span> SimpleDateFormat(<span class=\"string\">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class=\"line\">    String sTime = <span class=\"string\">&quot;1986-09-13 22:00:00&quot;</span>;</span><br><span class=\"line\">    sdf.setTimeZone(TimeZone.getTimeZone(<span class=\"string\">&quot;Asia/Shanghai&quot;</span>));</span><br><span class=\"line\">    TimeZone.setDefault(TimeZone.getTimeZone(<span class=\"string\">&quot;Asia/Shanghai&quot;</span>));</span><br><span class=\"line\">    Date time = sdf.parse(sTime);</span><br><span class=\"line\">    System.out.println(time.getTime());</span><br><span class=\"line\">    System.out.println(time);</span><br><span class=\"line\">    Calendar cd = Calendar.getInstance();</span><br><span class=\"line\">    cd.setTime(time);</span><br><span class=\"line\">    <span class=\"comment\">// 2小时以后是几点？</span></span><br><span class=\"line\">    cd.add(Calendar.HOUR, <span class=\"number\">2</span>);</span><br><span class=\"line\">    time = cd.getTime();</span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;------------------------------&quot;</span>);</span><br><span class=\"line\">    System.out.println(time.getTime());</span><br><span class=\"line\">    System.out.println(time);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>打印结果:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">527000400000</span><br><span class=\"line\">Sat Sep 13 22:00:00 CDT 1986</span><br><span class=\"line\">------------------------------</span><br><span class=\"line\">527007600000</span><br><span class=\"line\">Sat Sep 13 23:00:00 CST 1986</span><br></pre></td></tr></table></figure>\n<p><code>分析</code>: 上面代码中1986-09-1322:00:00加上2小时，应该变为1986-09-13 24:00:00（或者1986-09-14 00:00:00），但由于在9月14日零点退出夏令时，时钟向后调整1小时，实际变为1986-09-13 23:00:00。<br>注意：从9月14日零点退出夏令时，java的Date.toString打印的时区也从CDT恢复为CST( ChinaStandard Time UT+8:00)。</p>\n<p>又如：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wujianjun@smzc ~ $ date</span><br><span class=\"line\">2018年 08月 24日 星期五 19:20:41 CST</span><br><span class=\"line\">wujianjun@smzc ~ $ date -d @579279600</span><br><span class=\"line\">1988年 05月 11日 星期三 00:00:00 CDT</span><br><span class=\"line\">wujianjun@smzc ~ $ date -d @599587200</span><br><span class=\"line\">1989年 01月 01日 星期日 00:00:00 CST</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p><code>结论</code>: 只要是在实行夏令时的时段都是<code>CDT</code>时间，其它都是<code>CST</code></p>\n<hr>\n<p><em>观点仅代表自己，期待你的留言。</em></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"中国夏令时制度实行时间\"><a href=\"#中国夏令时制度实行时间\" class=\"headerlink\" title=\"中国夏令时制度实行时间\"></a>中国夏令时制度实行时间</h2><p>中华人民共和国在1986年~1991年实行了夏令时制度，每年夏令时实行时间如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1986年5月4日至9月14日（1986年因是实行夏令时的第一年，从5月4日开始到9月14日结束）</span><br><span class=\"line\">1987年4月12日至9月13日，</span><br><span class=\"line\">1988年4月10日至9月11日，</span><br><span class=\"line\">1989年4月16日至9月17日，</span><br><span class=\"line\">1990年4月15日至9月16日，</span><br><span class=\"line\">1991年4月14日至9月15日。</span><br></pre></td></tr></table></figure>\n<h2 id=\"JDK已有对夏令时的处理\"><a href=\"#JDK已有对夏令时的处理\" class=\"headerlink\" title=\"JDK已有对夏令时的处理\"></a>JDK已有对夏令时的处理</h2><p>Java的jdk在Date的toString中已经包含夏令时的计算，以下代码可以印证：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">    SimpleDateFormat sdf = <span class=\"keyword\">new</span> SimpleDateFormat(<span class=\"string\">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class=\"line\">    String sTime = <span class=\"string\">&quot;1986-09-13 22:00:00&quot;</span>;</span><br><span class=\"line\">    sdf.setTimeZone(TimeZone.getTimeZone(<span class=\"string\">&quot;Asia/Shanghai&quot;</span>));</span><br><span class=\"line\">    TimeZone.setDefault(TimeZone.getTimeZone(<span class=\"string\">&quot;Asia/Shanghai&quot;</span>));</span><br><span class=\"line\">    Date time = sdf.parse(sTime);</span><br><span class=\"line\">    System.out.println(time.getTime());</span><br><span class=\"line\">    System.out.println(time);</span><br><span class=\"line\">    Calendar cd = Calendar.getInstance();</span><br><span class=\"line\">    cd.setTime(time);</span><br><span class=\"line\">    <span class=\"comment\">// 2小时以后是几点？</span></span><br><span class=\"line\">    cd.add(Calendar.HOUR, <span class=\"number\">2</span>);</span><br><span class=\"line\">    time = cd.getTime();</span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;------------------------------&quot;</span>);</span><br><span class=\"line\">    System.out.println(time.getTime());</span><br><span class=\"line\">    System.out.println(time);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>打印结果:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">527000400000</span><br><span class=\"line\">Sat Sep 13 22:00:00 CDT 1986</span><br><span class=\"line\">------------------------------</span><br><span class=\"line\">527007600000</span><br><span class=\"line\">Sat Sep 13 23:00:00 CST 1986</span><br></pre></td></tr></table></figure>\n<p><code>分析</code>: 上面代码中1986-09-1322:00:00加上2小时，应该变为1986-09-13 24:00:00（或者1986-09-14 00:00:00），但由于在9月14日零点退出夏令时，时钟向后调整1小时，实际变为1986-09-13 23:00:00。<br>注意：从9月14日零点退出夏令时，java的Date.toString打印的时区也从CDT恢复为CST( ChinaStandard Time UT+8:00)。</p>\n<p>又如：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wujianjun@smzc ~ $ date</span><br><span class=\"line\">2018年 08月 24日 星期五 19:20:41 CST</span><br><span class=\"line\">wujianjun@smzc ~ $ date -d @579279600</span><br><span class=\"line\">1988年 05月 11日 星期三 00:00:00 CDT</span><br><span class=\"line\">wujianjun@smzc ~ $ date -d @599587200</span><br><span class=\"line\">1989年 01月 01日 星期日 00:00:00 CST</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p><code>结论</code>: 只要是在实行夏令时的时段都是<code>CDT</code>时间，其它都是<code>CST</code></p>\n<hr>\n<p><em>观点仅代表自己，期待你的留言。</em></p>\n"},{"title":"Cron表达式说明","date":"2017-09-05T12:48:08.000Z","_content":"\n## CronTrigger\nCronTriggers往往比SimpleTrigger更有用，如果您需要基于日历的概念，而非SimpleTrigger完全指定的时间间隔，复发的发射工作的时间表。\nCronTrigger，你可以指定触发的时间表如“每星期五中午”，或“每个工作日9:30时”，甚至“每5分钟一班9:00和10:00逢星期一上午，星期三星期五“。\n即便如此，SimpleTrigger一样，CronTrigger拥有的startTime指定的时间表时生效，指定的时间表时，应停止（可选）结束时间。\n### Cron Expressions\ncron的表达式被用来配置CronTrigger实例。 cron的表达式是字符串，实际上是由七子表达式，描述个别细节的时间表。\n这些子表达式是分开的空白，代表：\n1.        Seconds\n2.        Minutes\n3.        Hours\n4.        Day-of-Month\n5.        Month\n6.        Day-of-Week\n7.        Year (可选字段)\n例  \"0 0 12 ? * WED\" 在每星期三下午12:00 执行,\n\n个别子表达式可以包含范围, 例如，在前面的例子里(\"WED\")可以替换成 \"MON-FRI\", \"MON, WED, FRI\"甚至\"MON-WED,SAT\".\n\n“* ” 代表整个时间段.\n\n每一个字段都有一套可以指定有效值，如\n\nSeconds (秒)         ：可以用数字0－59 表示，\n\nMinutes(分)          ：可以用数字0－59 表示，\n\nHours(时)             ：可以用数字0-23表示,\n\nDay-of-Month(天) ：可以用数字1-31 中的任一一个值，但要注意一些特别的月份\n\nMonth(月)            ：可以用0-11 或用字符串  “JAN, FEB, MAR, APR, MAY, JUN, JUL, AUG, SEP, OCT, NOV and DEC” 表示\n\nDay-of-Week(每周)：可以用数字1-7表示（1 ＝ 星期日）或用字符口串“SUN, MON, TUE, WED, THU, FRI and SAT”表示\n\n“/”：为特别单位，表示为“每”如“0/15”表示每隔15分钟执行一次,“0”表示为从“0”分开始, “3/20”表示表示每隔20分钟执行一次，“3”表示从第3分钟开始执行\n\n“?”：表示每月的某一天，或第周的某一天\n\n“L”：用于每月，或每周，表示为每月的最后一天，或每个月的最后星期几如“6L”表示“每月的最后一个星期五”\n\n“W”：表示为最近工作日，如“15W”放在每月（day-of-month）字段上表示为“到本月15日最近的工作日”\n\n““#”：是用来指定“的”每月第n个工作日,例 在每周（day-of-week）这个字段中内容为\"6#3\" or \"FRI#3\" 则表示“每月第三个星期五”\n\n1）Cron表达式的格式：秒 分 时 日 月 周 年(可选)。\n\n   |字段名                 |允许的值                        |允许的特殊字符  \n   |:- |:- |:-\n   |秒                     |0-59                         |  , - * /  \n   |分                     |0-59                         | , - * /  \n   |小时                    |0-23                        | , - * /  \n   |日                     | 1-31                        |   , - * ? / L W C  \n   |月                     | 1-12 or JAN-DEC             |, - * /  \n   |周几                   | 1-7 or SUN-SAT               |  , - * ? / L C #  \n   |年 (可选字段)            |empty, 1970-2099             |, - * /\n\n     “?”字符：表示不确定的值\n\n     “,”字符：指定数个值\n\n     “-”字符：指定一个值的范围\n\n     “/”字符：指定一个值的增加幅度。n/m表示从n开始，每次增加m\n\n     “L”字符：用在日表示一个月中的最后一天，用在周表示该月最后一个星期X\n\n     “W”字符：指定离给定日期最近的工作日(周一到周五)\n\n     “#”字符：表示该月第几个周X。6#3表示该月第3个周五\n 2）Cron表达式范例：\n\n     每隔5秒执行一次：*/5 * * * * ?\n\n     每隔1分钟执行一次：0 */1 * * * ?\n\n     每天23点执行一次：0 0 23 * * ?\n\n     每天凌晨1点执行一次：0 0 1 * * ?\n\n     每月1号凌晨1点执行一次：0 0 1 1 * ?\n\n     每月最后一天23点执行一次：0 0 23 L * ?\n\n     每周星期天凌晨1点实行一次：0 0 1 ? * L\n\n     在26分、29分、33分执行一次：0 26,29,33 * * * ?\n\n     每天的0点、13点、18点、21点都执行一次：0 0 0,13,18,21 * * ?\n\n-----\n转载自：http://www.cnblogs.com/maybo/p/5189617.html\n*观点仅代表自己，期待你的留言。*\n","source":"_posts/cron-expression.md","raw":"---\ntitle: Cron表达式说明\ntags:\n  - 转载\ndate: 2017-09-05 20:48:08\n---\n\n## CronTrigger\nCronTriggers往往比SimpleTrigger更有用，如果您需要基于日历的概念，而非SimpleTrigger完全指定的时间间隔，复发的发射工作的时间表。\nCronTrigger，你可以指定触发的时间表如“每星期五中午”，或“每个工作日9:30时”，甚至“每5分钟一班9:00和10:00逢星期一上午，星期三星期五“。\n即便如此，SimpleTrigger一样，CronTrigger拥有的startTime指定的时间表时生效，指定的时间表时，应停止（可选）结束时间。\n### Cron Expressions\ncron的表达式被用来配置CronTrigger实例。 cron的表达式是字符串，实际上是由七子表达式，描述个别细节的时间表。\n这些子表达式是分开的空白，代表：\n1.        Seconds\n2.        Minutes\n3.        Hours\n4.        Day-of-Month\n5.        Month\n6.        Day-of-Week\n7.        Year (可选字段)\n例  \"0 0 12 ? * WED\" 在每星期三下午12:00 执行,\n\n个别子表达式可以包含范围, 例如，在前面的例子里(\"WED\")可以替换成 \"MON-FRI\", \"MON, WED, FRI\"甚至\"MON-WED,SAT\".\n\n“* ” 代表整个时间段.\n\n每一个字段都有一套可以指定有效值，如\n\nSeconds (秒)         ：可以用数字0－59 表示，\n\nMinutes(分)          ：可以用数字0－59 表示，\n\nHours(时)             ：可以用数字0-23表示,\n\nDay-of-Month(天) ：可以用数字1-31 中的任一一个值，但要注意一些特别的月份\n\nMonth(月)            ：可以用0-11 或用字符串  “JAN, FEB, MAR, APR, MAY, JUN, JUL, AUG, SEP, OCT, NOV and DEC” 表示\n\nDay-of-Week(每周)：可以用数字1-7表示（1 ＝ 星期日）或用字符口串“SUN, MON, TUE, WED, THU, FRI and SAT”表示\n\n“/”：为特别单位，表示为“每”如“0/15”表示每隔15分钟执行一次,“0”表示为从“0”分开始, “3/20”表示表示每隔20分钟执行一次，“3”表示从第3分钟开始执行\n\n“?”：表示每月的某一天，或第周的某一天\n\n“L”：用于每月，或每周，表示为每月的最后一天，或每个月的最后星期几如“6L”表示“每月的最后一个星期五”\n\n“W”：表示为最近工作日，如“15W”放在每月（day-of-month）字段上表示为“到本月15日最近的工作日”\n\n““#”：是用来指定“的”每月第n个工作日,例 在每周（day-of-week）这个字段中内容为\"6#3\" or \"FRI#3\" 则表示“每月第三个星期五”\n\n1）Cron表达式的格式：秒 分 时 日 月 周 年(可选)。\n\n   |字段名                 |允许的值                        |允许的特殊字符  \n   |:- |:- |:-\n   |秒                     |0-59                         |  , - * /  \n   |分                     |0-59                         | , - * /  \n   |小时                    |0-23                        | , - * /  \n   |日                     | 1-31                        |   , - * ? / L W C  \n   |月                     | 1-12 or JAN-DEC             |, - * /  \n   |周几                   | 1-7 or SUN-SAT               |  , - * ? / L C #  \n   |年 (可选字段)            |empty, 1970-2099             |, - * /\n\n     “?”字符：表示不确定的值\n\n     “,”字符：指定数个值\n\n     “-”字符：指定一个值的范围\n\n     “/”字符：指定一个值的增加幅度。n/m表示从n开始，每次增加m\n\n     “L”字符：用在日表示一个月中的最后一天，用在周表示该月最后一个星期X\n\n     “W”字符：指定离给定日期最近的工作日(周一到周五)\n\n     “#”字符：表示该月第几个周X。6#3表示该月第3个周五\n 2）Cron表达式范例：\n\n     每隔5秒执行一次：*/5 * * * * ?\n\n     每隔1分钟执行一次：0 */1 * * * ?\n\n     每天23点执行一次：0 0 23 * * ?\n\n     每天凌晨1点执行一次：0 0 1 * * ?\n\n     每月1号凌晨1点执行一次：0 0 1 1 * ?\n\n     每月最后一天23点执行一次：0 0 23 L * ?\n\n     每周星期天凌晨1点实行一次：0 0 1 ? * L\n\n     在26分、29分、33分执行一次：0 26,29,33 * * * ?\n\n     每天的0点、13点、18点、21点都执行一次：0 0 0,13,18,21 * * ?\n\n-----\n转载自：http://www.cnblogs.com/maybo/p/5189617.html\n*观点仅代表自己，期待你的留言。*\n","slug":"cron-expression","published":1,"updated":"2021-09-18T03:02:35.814Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cku52dym4000lbbin7nat5qlb","content":"<h2 id=\"CronTrigger\"><a href=\"#CronTrigger\" class=\"headerlink\" title=\"CronTrigger\"></a>CronTrigger</h2><p>CronTriggers往往比SimpleTrigger更有用，如果您需要基于日历的概念，而非SimpleTrigger完全指定的时间间隔，复发的发射工作的时间表。<br>CronTrigger，你可以指定触发的时间表如“每星期五中午”，或“每个工作日9:30时”，甚至“每5分钟一班9:00和10:00逢星期一上午，星期三星期五“。<br>即便如此，SimpleTrigger一样，CronTrigger拥有的startTime指定的时间表时生效，指定的时间表时，应停止（可选）结束时间。</p>\n<h3 id=\"Cron-Expressions\"><a href=\"#Cron-Expressions\" class=\"headerlink\" title=\"Cron Expressions\"></a>Cron Expressions</h3><p>cron的表达式被用来配置CronTrigger实例。 cron的表达式是字符串，实际上是由七子表达式，描述个别细节的时间表。<br>这些子表达式是分开的空白，代表：</p>\n<ol>\n<li><pre><code>   Seconds\n</code></pre>\n</li>\n<li><pre><code>   Minutes\n</code></pre>\n</li>\n<li><pre><code>   Hours\n</code></pre>\n</li>\n<li><pre><code>   Day-of-Month\n</code></pre>\n</li>\n<li><pre><code>   Month\n</code></pre>\n</li>\n<li><pre><code>   Day-of-Week\n</code></pre>\n</li>\n<li><pre><code>   Year (可选字段)\n</code></pre>\n例  “0 0 12 ? * WED” 在每星期三下午12:00 执行,</li>\n</ol>\n<p>个别子表达式可以包含范围, 例如，在前面的例子里(“WED”)可以替换成 “MON-FRI”, “MON, WED, FRI”甚至”MON-WED,SAT”.</p>\n<p>“* ” 代表整个时间段.</p>\n<p>每一个字段都有一套可以指定有效值，如</p>\n<p>Seconds (秒)         ：可以用数字0－59 表示，</p>\n<p>Minutes(分)          ：可以用数字0－59 表示，</p>\n<p>Hours(时)             ：可以用数字0-23表示,</p>\n<p>Day-of-Month(天) ：可以用数字1-31 中的任一一个值，但要注意一些特别的月份</p>\n<p>Month(月)            ：可以用0-11 或用字符串  “JAN, FEB, MAR, APR, MAY, JUN, JUL, AUG, SEP, OCT, NOV and DEC” 表示</p>\n<p>Day-of-Week(每周)：可以用数字1-7表示（1 ＝ 星期日）或用字符口串“SUN, MON, TUE, WED, THU, FRI and SAT”表示</p>\n<p>“/”：为特别单位，表示为“每”如“0/15”表示每隔15分钟执行一次,“0”表示为从“0”分开始, “3/20”表示表示每隔20分钟执行一次，“3”表示从第3分钟开始执行</p>\n<p>“?”：表示每月的某一天，或第周的某一天</p>\n<p>“L”：用于每月，或每周，表示为每月的最后一天，或每个月的最后星期几如“6L”表示“每月的最后一个星期五”</p>\n<p>“W”：表示为最近工作日，如“15W”放在每月（day-of-month）字段上表示为“到本月15日最近的工作日”</p>\n<p>““#”：是用来指定“的”每月第n个工作日,例 在每周（day-of-week）这个字段中内容为”6#3” or “FRI#3” 则表示“每月第三个星期五”</p>\n<p>1）Cron表达式的格式：秒 分 时 日 月 周 年(可选)。</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">字段名</th>\n<th align=\"left\">允许的值</th>\n<th align=\"left\">允许的特殊字符</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">秒</td>\n<td align=\"left\">0-59</td>\n<td align=\"left\">, - * /</td>\n</tr>\n<tr>\n<td align=\"left\">分</td>\n<td align=\"left\">0-59</td>\n<td align=\"left\">, - * /</td>\n</tr>\n<tr>\n<td align=\"left\">小时</td>\n<td align=\"left\">0-23</td>\n<td align=\"left\">, - * /</td>\n</tr>\n<tr>\n<td align=\"left\">日</td>\n<td align=\"left\">1-31</td>\n<td align=\"left\">, - * ? / L W C</td>\n</tr>\n<tr>\n<td align=\"left\">月</td>\n<td align=\"left\">1-12 or JAN-DEC</td>\n<td align=\"left\">, - * /</td>\n</tr>\n<tr>\n<td align=\"left\">周几</td>\n<td align=\"left\">1-7 or SUN-SAT</td>\n<td align=\"left\">, - * ? / L C #</td>\n</tr>\n<tr>\n<td align=\"left\">年 (可选字段)</td>\n<td align=\"left\">empty, 1970-2099</td>\n<td align=\"left\">, - * /</td>\n</tr>\n</tbody></table>\n<pre><code> “?”字符：表示不确定的值\n\n “,”字符：指定数个值\n\n “-”字符：指定一个值的范围\n\n “/”字符：指定一个值的增加幅度。n/m表示从n开始，每次增加m\n\n “L”字符：用在日表示一个月中的最后一天，用在周表示该月最后一个星期X\n\n “W”字符：指定离给定日期最近的工作日(周一到周五)\n\n “#”字符：表示该月第几个周X。6#3表示该月第3个周五\n</code></pre>\n<p> 2）Cron表达式范例：</p>\n<pre><code> 每隔5秒执行一次：*/5 * * * * ?\n\n 每隔1分钟执行一次：0 */1 * * * ?\n\n 每天23点执行一次：0 0 23 * * ?\n\n 每天凌晨1点执行一次：0 0 1 * * ?\n\n 每月1号凌晨1点执行一次：0 0 1 1 * ?\n\n 每月最后一天23点执行一次：0 0 23 L * ?\n\n 每周星期天凌晨1点实行一次：0 0 1 ? * L\n\n 在26分、29分、33分执行一次：0 26,29,33 * * * ?\n\n 每天的0点、13点、18点、21点都执行一次：0 0 0,13,18,21 * * ?\n</code></pre>\n<hr>\n<p>转载自：<a href=\"http://www.cnblogs.com/maybo/p/5189617.html\">http://www.cnblogs.com/maybo/p/5189617.html</a><br><em>观点仅代表自己，期待你的留言。</em></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"CronTrigger\"><a href=\"#CronTrigger\" class=\"headerlink\" title=\"CronTrigger\"></a>CronTrigger</h2><p>CronTriggers往往比SimpleTrigger更有用，如果您需要基于日历的概念，而非SimpleTrigger完全指定的时间间隔，复发的发射工作的时间表。<br>CronTrigger，你可以指定触发的时间表如“每星期五中午”，或“每个工作日9:30时”，甚至“每5分钟一班9:00和10:00逢星期一上午，星期三星期五“。<br>即便如此，SimpleTrigger一样，CronTrigger拥有的startTime指定的时间表时生效，指定的时间表时，应停止（可选）结束时间。</p>\n<h3 id=\"Cron-Expressions\"><a href=\"#Cron-Expressions\" class=\"headerlink\" title=\"Cron Expressions\"></a>Cron Expressions</h3><p>cron的表达式被用来配置CronTrigger实例。 cron的表达式是字符串，实际上是由七子表达式，描述个别细节的时间表。<br>这些子表达式是分开的空白，代表：</p>\n<ol>\n<li><pre><code>   Seconds\n</code></pre>\n</li>\n<li><pre><code>   Minutes\n</code></pre>\n</li>\n<li><pre><code>   Hours\n</code></pre>\n</li>\n<li><pre><code>   Day-of-Month\n</code></pre>\n</li>\n<li><pre><code>   Month\n</code></pre>\n</li>\n<li><pre><code>   Day-of-Week\n</code></pre>\n</li>\n<li><pre><code>   Year (可选字段)\n</code></pre>\n例  “0 0 12 ? * WED” 在每星期三下午12:00 执行,</li>\n</ol>\n<p>个别子表达式可以包含范围, 例如，在前面的例子里(“WED”)可以替换成 “MON-FRI”, “MON, WED, FRI”甚至”MON-WED,SAT”.</p>\n<p>“* ” 代表整个时间段.</p>\n<p>每一个字段都有一套可以指定有效值，如</p>\n<p>Seconds (秒)         ：可以用数字0－59 表示，</p>\n<p>Minutes(分)          ：可以用数字0－59 表示，</p>\n<p>Hours(时)             ：可以用数字0-23表示,</p>\n<p>Day-of-Month(天) ：可以用数字1-31 中的任一一个值，但要注意一些特别的月份</p>\n<p>Month(月)            ：可以用0-11 或用字符串  “JAN, FEB, MAR, APR, MAY, JUN, JUL, AUG, SEP, OCT, NOV and DEC” 表示</p>\n<p>Day-of-Week(每周)：可以用数字1-7表示（1 ＝ 星期日）或用字符口串“SUN, MON, TUE, WED, THU, FRI and SAT”表示</p>\n<p>“/”：为特别单位，表示为“每”如“0/15”表示每隔15分钟执行一次,“0”表示为从“0”分开始, “3/20”表示表示每隔20分钟执行一次，“3”表示从第3分钟开始执行</p>\n<p>“?”：表示每月的某一天，或第周的某一天</p>\n<p>“L”：用于每月，或每周，表示为每月的最后一天，或每个月的最后星期几如“6L”表示“每月的最后一个星期五”</p>\n<p>“W”：表示为最近工作日，如“15W”放在每月（day-of-month）字段上表示为“到本月15日最近的工作日”</p>\n<p>““#”：是用来指定“的”每月第n个工作日,例 在每周（day-of-week）这个字段中内容为”6#3” or “FRI#3” 则表示“每月第三个星期五”</p>\n<p>1）Cron表达式的格式：秒 分 时 日 月 周 年(可选)。</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">字段名</th>\n<th align=\"left\">允许的值</th>\n<th align=\"left\">允许的特殊字符</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">秒</td>\n<td align=\"left\">0-59</td>\n<td align=\"left\">, - * /</td>\n</tr>\n<tr>\n<td align=\"left\">分</td>\n<td align=\"left\">0-59</td>\n<td align=\"left\">, - * /</td>\n</tr>\n<tr>\n<td align=\"left\">小时</td>\n<td align=\"left\">0-23</td>\n<td align=\"left\">, - * /</td>\n</tr>\n<tr>\n<td align=\"left\">日</td>\n<td align=\"left\">1-31</td>\n<td align=\"left\">, - * ? / L W C</td>\n</tr>\n<tr>\n<td align=\"left\">月</td>\n<td align=\"left\">1-12 or JAN-DEC</td>\n<td align=\"left\">, - * /</td>\n</tr>\n<tr>\n<td align=\"left\">周几</td>\n<td align=\"left\">1-7 or SUN-SAT</td>\n<td align=\"left\">, - * ? / L C #</td>\n</tr>\n<tr>\n<td align=\"left\">年 (可选字段)</td>\n<td align=\"left\">empty, 1970-2099</td>\n<td align=\"left\">, - * /</td>\n</tr>\n</tbody></table>\n<pre><code> “?”字符：表示不确定的值\n\n “,”字符：指定数个值\n\n “-”字符：指定一个值的范围\n\n “/”字符：指定一个值的增加幅度。n/m表示从n开始，每次增加m\n\n “L”字符：用在日表示一个月中的最后一天，用在周表示该月最后一个星期X\n\n “W”字符：指定离给定日期最近的工作日(周一到周五)\n\n “#”字符：表示该月第几个周X。6#3表示该月第3个周五\n</code></pre>\n<p> 2）Cron表达式范例：</p>\n<pre><code> 每隔5秒执行一次：*/5 * * * * ?\n\n 每隔1分钟执行一次：0 */1 * * * ?\n\n 每天23点执行一次：0 0 23 * * ?\n\n 每天凌晨1点执行一次：0 0 1 * * ?\n\n 每月1号凌晨1点执行一次：0 0 1 1 * ?\n\n 每月最后一天23点执行一次：0 0 23 L * ?\n\n 每周星期天凌晨1点实行一次：0 0 1 ? * L\n\n 在26分、29分、33分执行一次：0 26,29,33 * * * ?\n\n 每天的0点、13点、18点、21点都执行一次：0 0 0,13,18,21 * * ?\n</code></pre>\n<hr>\n<p>转载自：<a href=\"http://www.cnblogs.com/maybo/p/5189617.html\">http://www.cnblogs.com/maybo/p/5189617.html</a><br><em>观点仅代表自己，期待你的留言。</em></p>\n"},{"title":"FindbugsMaven插件集成生成html报告","keywords":["maven","findbugs"],"date":"2021-09-02T07:09:40.000Z","_content":"\n## maven配置\n在pom.xml中加入\n```pom.xml\n<reporting>\n  <plugins>\n    <plugin>\n        <groupId>org.codehaus.mojo</groupId>\n        <artifactId>findbugs-maven-plugin</artifactId>\n        <version>3.0.5</version>\n        <configuration>\n            <effort>Max</effort>\n            <threshold>High</threshold>\n            <xmlOutput>false</xmlOutput>\n        </configuration>\n    </plugin>\n  </plugins>\n</reporting>\n<build>\n  <plugin>\n      <groupId>org.apache.maven.plugins</groupId>\n      <artifactId>maven-site-plugin</artifactId>\n      <version>3.9.1</version>\n      <dependencies>\n          <dependency>\n              <groupId>org.apache.maven.doxia</groupId>\n              <artifactId>doxia-site-renderer</artifactId>\n              <version>1.10</version>\n          </dependency>\n      </dependencies>\n  </plugin>\n</build>\n```\n## 运行\n在pom.xml所在目录执行`mvn compile site`生成报告\n在target/site目录中则能查看到扫描报告\n\n\n\n-----\n\n*观点仅代表自己，期待你的留言。*\n","source":"_posts/code-findbugs-plugin.md","raw":"---\ntitle: FindbugsMaven插件集成生成html报告\ntags:\n  - 原创\nkeywords:\n  - maven\n  - findbugs\ndate: 2021-09-02 15:09:40\n---\n\n## maven配置\n在pom.xml中加入\n```pom.xml\n<reporting>\n  <plugins>\n    <plugin>\n        <groupId>org.codehaus.mojo</groupId>\n        <artifactId>findbugs-maven-plugin</artifactId>\n        <version>3.0.5</version>\n        <configuration>\n            <effort>Max</effort>\n            <threshold>High</threshold>\n            <xmlOutput>false</xmlOutput>\n        </configuration>\n    </plugin>\n  </plugins>\n</reporting>\n<build>\n  <plugin>\n      <groupId>org.apache.maven.plugins</groupId>\n      <artifactId>maven-site-plugin</artifactId>\n      <version>3.9.1</version>\n      <dependencies>\n          <dependency>\n              <groupId>org.apache.maven.doxia</groupId>\n              <artifactId>doxia-site-renderer</artifactId>\n              <version>1.10</version>\n          </dependency>\n      </dependencies>\n  </plugin>\n</build>\n```\n## 运行\n在pom.xml所在目录执行`mvn compile site`生成报告\n在target/site目录中则能查看到扫描报告\n\n\n\n-----\n\n*观点仅代表自己，期待你的留言。*\n","slug":"code-findbugs-plugin","published":1,"updated":"2021-09-02T07:16:13.713Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cku52dym6000obbinb177a6k4","content":"<h2 id=\"maven配置\"><a href=\"#maven配置\" class=\"headerlink\" title=\"maven配置\"></a>maven配置</h2><p>在pom.xml中加入</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;reporting&gt;</span><br><span class=\"line\">  &lt;plugins&gt;</span><br><span class=\"line\">    &lt;plugin&gt;</span><br><span class=\"line\">        &lt;groupId&gt;org.codehaus.mojo&lt;/groupId&gt;</span><br><span class=\"line\">        &lt;artifactId&gt;findbugs-maven-plugin&lt;/artifactId&gt;</span><br><span class=\"line\">        &lt;version&gt;3.0.5&lt;/version&gt;</span><br><span class=\"line\">        &lt;configuration&gt;</span><br><span class=\"line\">            &lt;effort&gt;Max&lt;/effort&gt;</span><br><span class=\"line\">            &lt;threshold&gt;High&lt;/threshold&gt;</span><br><span class=\"line\">            &lt;xmlOutput&gt;false&lt;/xmlOutput&gt;</span><br><span class=\"line\">        &lt;/configuration&gt;</span><br><span class=\"line\">    &lt;/plugin&gt;</span><br><span class=\"line\">  &lt;/plugins&gt;</span><br><span class=\"line\">&lt;/reporting&gt;</span><br><span class=\"line\">&lt;build&gt;</span><br><span class=\"line\">  &lt;plugin&gt;</span><br><span class=\"line\">      &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;</span><br><span class=\"line\">      &lt;artifactId&gt;maven-site-plugin&lt;/artifactId&gt;</span><br><span class=\"line\">      &lt;version&gt;3.9.1&lt;/version&gt;</span><br><span class=\"line\">      &lt;dependencies&gt;</span><br><span class=\"line\">          &lt;dependency&gt;</span><br><span class=\"line\">              &lt;groupId&gt;org.apache.maven.doxia&lt;/groupId&gt;</span><br><span class=\"line\">              &lt;artifactId&gt;doxia-site-renderer&lt;/artifactId&gt;</span><br><span class=\"line\">              &lt;version&gt;1.10&lt;/version&gt;</span><br><span class=\"line\">          &lt;/dependency&gt;</span><br><span class=\"line\">      &lt;/dependencies&gt;</span><br><span class=\"line\">  &lt;/plugin&gt;</span><br><span class=\"line\">&lt;/build&gt;</span><br></pre></td></tr></table></figure>\n<h2 id=\"运行\"><a href=\"#运行\" class=\"headerlink\" title=\"运行\"></a>运行</h2><p>在pom.xml所在目录执行<code>mvn compile site</code>生成报告<br>在target/site目录中则能查看到扫描报告</p>\n<hr>\n<p><em>观点仅代表自己，期待你的留言。</em></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"maven配置\"><a href=\"#maven配置\" class=\"headerlink\" title=\"maven配置\"></a>maven配置</h2><p>在pom.xml中加入</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;reporting&gt;</span><br><span class=\"line\">  &lt;plugins&gt;</span><br><span class=\"line\">    &lt;plugin&gt;</span><br><span class=\"line\">        &lt;groupId&gt;org.codehaus.mojo&lt;/groupId&gt;</span><br><span class=\"line\">        &lt;artifactId&gt;findbugs-maven-plugin&lt;/artifactId&gt;</span><br><span class=\"line\">        &lt;version&gt;3.0.5&lt;/version&gt;</span><br><span class=\"line\">        &lt;configuration&gt;</span><br><span class=\"line\">            &lt;effort&gt;Max&lt;/effort&gt;</span><br><span class=\"line\">            &lt;threshold&gt;High&lt;/threshold&gt;</span><br><span class=\"line\">            &lt;xmlOutput&gt;false&lt;/xmlOutput&gt;</span><br><span class=\"line\">        &lt;/configuration&gt;</span><br><span class=\"line\">    &lt;/plugin&gt;</span><br><span class=\"line\">  &lt;/plugins&gt;</span><br><span class=\"line\">&lt;/reporting&gt;</span><br><span class=\"line\">&lt;build&gt;</span><br><span class=\"line\">  &lt;plugin&gt;</span><br><span class=\"line\">      &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;</span><br><span class=\"line\">      &lt;artifactId&gt;maven-site-plugin&lt;/artifactId&gt;</span><br><span class=\"line\">      &lt;version&gt;3.9.1&lt;/version&gt;</span><br><span class=\"line\">      &lt;dependencies&gt;</span><br><span class=\"line\">          &lt;dependency&gt;</span><br><span class=\"line\">              &lt;groupId&gt;org.apache.maven.doxia&lt;/groupId&gt;</span><br><span class=\"line\">              &lt;artifactId&gt;doxia-site-renderer&lt;/artifactId&gt;</span><br><span class=\"line\">              &lt;version&gt;1.10&lt;/version&gt;</span><br><span class=\"line\">          &lt;/dependency&gt;</span><br><span class=\"line\">      &lt;/dependencies&gt;</span><br><span class=\"line\">  &lt;/plugin&gt;</span><br><span class=\"line\">&lt;/build&gt;</span><br></pre></td></tr></table></figure>\n<h2 id=\"运行\"><a href=\"#运行\" class=\"headerlink\" title=\"运行\"></a>运行</h2><p>在pom.xml所在目录执行<code>mvn compile site</code>生成报告<br>在target/site目录中则能查看到扫描报告</p>\n<hr>\n<p><em>观点仅代表自己，期待你的留言。</em></p>\n"},{"title":"产品需求来源","date":"2020-06-08T00:48:36.000Z","_content":"\n## 产品需求来源\n- 产品理念和战略方向\n- 竞标方案\n- 市场反馈&一线用户优化建议\n- 行业标准\n- 竞品分析(注意得符合产品定位和方向)\n- 运营团队运营策略的演进\n- 技术指标和架构设计的优化提升\n\n\n-----\n\n*观点仅代表自己，期待你的留言。*\n","source":"_posts/demand-source.md","raw":"---\ntitle: 产品需求来源\ntags:\n  - 原创\ndate: 2020-06-08 08:48:36\n---\n\n## 产品需求来源\n- 产品理念和战略方向\n- 竞标方案\n- 市场反馈&一线用户优化建议\n- 行业标准\n- 竞品分析(注意得符合产品定位和方向)\n- 运营团队运营策略的演进\n- 技术指标和架构设计的优化提升\n\n\n-----\n\n*观点仅代表自己，期待你的留言。*\n","slug":"demand-source","published":1,"updated":"2021-09-01T01:49:12.876Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cku52dym9000qbbinew9rh8pk","content":"<h2 id=\"产品需求来源\"><a href=\"#产品需求来源\" class=\"headerlink\" title=\"产品需求来源\"></a>产品需求来源</h2><ul>\n<li>产品理念和战略方向</li>\n<li>竞标方案</li>\n<li>市场反馈&amp;一线用户优化建议</li>\n<li>行业标准</li>\n<li>竞品分析(注意得符合产品定位和方向)</li>\n<li>运营团队运营策略的演进</li>\n<li>技术指标和架构设计的优化提升</li>\n</ul>\n<hr>\n<p><em>观点仅代表自己，期待你的留言。</em></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"产品需求来源\"><a href=\"#产品需求来源\" class=\"headerlink\" title=\"产品需求来源\"></a>产品需求来源</h2><ul>\n<li>产品理念和战略方向</li>\n<li>竞标方案</li>\n<li>市场反馈&amp;一线用户优化建议</li>\n<li>行业标准</li>\n<li>竞品分析(注意得符合产品定位和方向)</li>\n<li>运营团队运营策略的演进</li>\n<li>技术指标和架构设计的优化提升</li>\n</ul>\n<hr>\n<p><em>观点仅代表自己，期待你的留言。</em></p>\n"},{"title":"数据仓库","keywords":["大数据","数据仓库"],"date":"2021-03-31T01:57:16.000Z","_content":"\n## 数据仓库\n- 归集库：从委办局接入数据1：1的建表进行数据归集。\n- 标准层：将归集表结构与数据标签进行映射后转换。\n- 基础层：与标准层1比1建表。（是否有必要）\n- 基础库：通过标准层（基础层）进行去重后的数据落入基础库，表结构与标准层（基础层）1：1。\n- 主题库：按需要提供出去数据的需求清单建立大宽表主题表，通过基础库进行合表、清洗、拆表后落入数据。\n- 共享库：以主题库数据形成共享库，对智慧应用提供数据服务\n\n-----\n\n*观点仅代表自己，期待你的留言。*\n","source":"_posts/data-wh.md","raw":"---\ntitle: 数据仓库\ntags:\n  - 原创\n  - 大数据\nkeywords:\n  - 大数据\n  - 数据仓库\ndate: 2021-03-31 09:57:16\n---\n\n## 数据仓库\n- 归集库：从委办局接入数据1：1的建表进行数据归集。\n- 标准层：将归集表结构与数据标签进行映射后转换。\n- 基础层：与标准层1比1建表。（是否有必要）\n- 基础库：通过标准层（基础层）进行去重后的数据落入基础库，表结构与标准层（基础层）1：1。\n- 主题库：按需要提供出去数据的需求清单建立大宽表主题表，通过基础库进行合表、清洗、拆表后落入数据。\n- 共享库：以主题库数据形成共享库，对智慧应用提供数据服务\n\n-----\n\n*观点仅代表自己，期待你的留言。*\n","slug":"data-wh","published":1,"updated":"2021-09-01T01:59:14.533Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cku52dymb000tbbin6u3b5rlq","content":"<h2 id=\"数据仓库\"><a href=\"#数据仓库\" class=\"headerlink\" title=\"数据仓库\"></a>数据仓库</h2><ul>\n<li>归集库：从委办局接入数据1：1的建表进行数据归集。</li>\n<li>标准层：将归集表结构与数据标签进行映射后转换。</li>\n<li>基础层：与标准层1比1建表。（是否有必要）</li>\n<li>基础库：通过标准层（基础层）进行去重后的数据落入基础库，表结构与标准层（基础层）1：1。</li>\n<li>主题库：按需要提供出去数据的需求清单建立大宽表主题表，通过基础库进行合表、清洗、拆表后落入数据。</li>\n<li>共享库：以主题库数据形成共享库，对智慧应用提供数据服务</li>\n</ul>\n<hr>\n<p><em>观点仅代表自己，期待你的留言。</em></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"数据仓库\"><a href=\"#数据仓库\" class=\"headerlink\" title=\"数据仓库\"></a>数据仓库</h2><ul>\n<li>归集库：从委办局接入数据1：1的建表进行数据归集。</li>\n<li>标准层：将归集表结构与数据标签进行映射后转换。</li>\n<li>基础层：与标准层1比1建表。（是否有必要）</li>\n<li>基础库：通过标准层（基础层）进行去重后的数据落入基础库，表结构与标准层（基础层）1：1。</li>\n<li>主题库：按需要提供出去数据的需求清单建立大宽表主题表，通过基础库进行合表、清洗、拆表后落入数据。</li>\n<li>共享库：以主题库数据形成共享库，对智慧应用提供数据服务</li>\n</ul>\n<hr>\n<p><em>观点仅代表自己，期待你的留言。</em></p>\n"},{"title":"Redis实现分布式锁和分布式队列","keywords":["Redis","分布式锁","分布式队列"],"date":"2016-05-31T03:56:20.000Z","_content":"\n## 分布式锁\n通过Redis做分布式系统的共享内存实现方案中，可以实现分布式锁的功能。实现方法就是用 SET NX 命令设置一个设定了存活周期 TTL 的 Key 来获取锁，通过删除 Key 来释放锁，通过存活周期来保证避免死锁。\n如：`SET resource_name my_random_value NX PX 30000`\n\n _注：_\n\n--------------\n`SET key value [EX seconds] [PX milliseconds] [NX|XX]`\n从2.6.12版本开始，redis为SET命令增加了一系列选项:\n* EX seconds – Set the specified expire time, in seconds.\n* PX milliseconds – Set the specified expire time, in milliseconds.\n* NX – Only set the key if it does not already exist.\n* XX – Only set the key if it already exist.\n* EX seconds – 设置键key的过期时间，单位时秒\n* PX milliseconds – 设置键key的过期时间，单位时毫秒\n* NX – 只有键key不存在的时候才会设置key的值\n* XX – 只有键key存在的时候才会设置key的值\n\n\n但，以上简单方案存在一个单点故障的风险。在master/slave环境下，当：\n1. 客户端A获取到锁.\n2. master节点在将 key 复制到 slave 节点之前崩溃了\n3. 此时，slave节点被提升为master节点.\n4. 客户端 B 从新的 master 节点获得了锁(而这个锁实际上已经由客户端 A 所持有)，导致了系统中有两个客户端在同一时间段内持有同一个互斥锁，破坏了互斥锁的安全性。\n\n__解决方法：__需要解决以上问题，需要在进行锁设值时将惟一标识系统的ID做为value一同存储到Redis中，在完成所有的操作后，进行解锁时取出Redis内存储的value进行比对，\n如果锁key对应的value还是当前系统的ID,那么表示当前锁目前只被当前系统所持有，反之，则表示锁被其它的系统抢占，那么需要回滚所有的操作。\n\n如：\n\n|客户端A（ID为SYSA）\t\t\t\t\t\t\t\t|Redis \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t| 客户端B（ID为SYSB）\n|:- |:- |:- \n| 获取到锁（SET dist_lock SYSA NX PX 30000)\t\t| \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t|\n| 进行其它的业务操作。。。\t\t\t\t\t\t\t| master发生故障，slave被提升为NewMaster(未将master中dist_lock复制到NewMaster) \t|\n| \t\t\t\t\t\t\t\t\t\t\t\t| \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t| 获取到锁（SET dist_lock SYSB NX PX 30000）\n| 解锁 (get dist_lock，对value进行判定，为SYSA则执行解锁，否则回滚业务)|\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t|\n| \t\t\t\t\t\t\t\t\t\t\t\t|\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t| 解锁 (get dist_lock，对value进行判定，为SYSB则执行解锁，否则回滚业务)\n\n\n## 分布式队列\nRedis实现分布式队列主要实现是通过`有序集合`实现，通过ZADD向集合内添加元素，同时添加多个元素时为事务处理（不存在部分成功部分失败的情况）\n\n _注：_\n\n------\n`ZADD key [NX|XX] [CH] [INCR] score member [score member ...]`\n从3.0.2版本开始，增加以下选项：\n* XX: Only update elements that already exist. Never add elements.\n* NX: Don’t update already existing elements. Always add new elements.\n* CH: Modify the return value from the number of new elements added, to the total number of elements changed (CH is an abbreviation of changed). Changed elements are new elements added and elements already existing for which the score was updated. So elements specified in the command line having the same score as they had in the past are not counted. Note: normally the return value of ZADD only counts the number of new elements added.\n* INCR: When this option is specified ZADD acts like ZINCRBY. Only one score-element pair can be specified in this mode.\n\n\n## 另外的选择\n_Java库：_其实也在使用[redisson](https://github.com/mrniko/redisson)来实现分布式锁。它封装了针对Redis各种操作的分布式实现。\n\n其它语言可参照官网文章: http://redis.io/topics/distlock?cm_mc_uid=77610277652214581184982&cm_mc_sid_50200000=1464593765\n\n-----\n\n*观点仅代表自己，期待你的留言。*\n","source":"_posts/distributed-redis-locked-queue.md","raw":"---\ntitle: Redis实现分布式锁和分布式队列\nkeywords:\n  - Redis\n  - 分布式锁\n  - 分布式队列\ntags:\n  - 原创\n  - Redis\ndate: 2016-05-31 11:56:20\n---\n\n## 分布式锁\n通过Redis做分布式系统的共享内存实现方案中，可以实现分布式锁的功能。实现方法就是用 SET NX 命令设置一个设定了存活周期 TTL 的 Key 来获取锁，通过删除 Key 来释放锁，通过存活周期来保证避免死锁。\n如：`SET resource_name my_random_value NX PX 30000`\n\n _注：_\n\n--------------\n`SET key value [EX seconds] [PX milliseconds] [NX|XX]`\n从2.6.12版本开始，redis为SET命令增加了一系列选项:\n* EX seconds – Set the specified expire time, in seconds.\n* PX milliseconds – Set the specified expire time, in milliseconds.\n* NX – Only set the key if it does not already exist.\n* XX – Only set the key if it already exist.\n* EX seconds – 设置键key的过期时间，单位时秒\n* PX milliseconds – 设置键key的过期时间，单位时毫秒\n* NX – 只有键key不存在的时候才会设置key的值\n* XX – 只有键key存在的时候才会设置key的值\n\n\n但，以上简单方案存在一个单点故障的风险。在master/slave环境下，当：\n1. 客户端A获取到锁.\n2. master节点在将 key 复制到 slave 节点之前崩溃了\n3. 此时，slave节点被提升为master节点.\n4. 客户端 B 从新的 master 节点获得了锁(而这个锁实际上已经由客户端 A 所持有)，导致了系统中有两个客户端在同一时间段内持有同一个互斥锁，破坏了互斥锁的安全性。\n\n__解决方法：__需要解决以上问题，需要在进行锁设值时将惟一标识系统的ID做为value一同存储到Redis中，在完成所有的操作后，进行解锁时取出Redis内存储的value进行比对，\n如果锁key对应的value还是当前系统的ID,那么表示当前锁目前只被当前系统所持有，反之，则表示锁被其它的系统抢占，那么需要回滚所有的操作。\n\n如：\n\n|客户端A（ID为SYSA）\t\t\t\t\t\t\t\t|Redis \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t| 客户端B（ID为SYSB）\n|:- |:- |:- \n| 获取到锁（SET dist_lock SYSA NX PX 30000)\t\t| \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t|\n| 进行其它的业务操作。。。\t\t\t\t\t\t\t| master发生故障，slave被提升为NewMaster(未将master中dist_lock复制到NewMaster) \t|\n| \t\t\t\t\t\t\t\t\t\t\t\t| \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t| 获取到锁（SET dist_lock SYSB NX PX 30000）\n| 解锁 (get dist_lock，对value进行判定，为SYSA则执行解锁，否则回滚业务)|\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t|\n| \t\t\t\t\t\t\t\t\t\t\t\t|\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t| 解锁 (get dist_lock，对value进行判定，为SYSB则执行解锁，否则回滚业务)\n\n\n## 分布式队列\nRedis实现分布式队列主要实现是通过`有序集合`实现，通过ZADD向集合内添加元素，同时添加多个元素时为事务处理（不存在部分成功部分失败的情况）\n\n _注：_\n\n------\n`ZADD key [NX|XX] [CH] [INCR] score member [score member ...]`\n从3.0.2版本开始，增加以下选项：\n* XX: Only update elements that already exist. Never add elements.\n* NX: Don’t update already existing elements. Always add new elements.\n* CH: Modify the return value from the number of new elements added, to the total number of elements changed (CH is an abbreviation of changed). Changed elements are new elements added and elements already existing for which the score was updated. So elements specified in the command line having the same score as they had in the past are not counted. Note: normally the return value of ZADD only counts the number of new elements added.\n* INCR: When this option is specified ZADD acts like ZINCRBY. Only one score-element pair can be specified in this mode.\n\n\n## 另外的选择\n_Java库：_其实也在使用[redisson](https://github.com/mrniko/redisson)来实现分布式锁。它封装了针对Redis各种操作的分布式实现。\n\n其它语言可参照官网文章: http://redis.io/topics/distlock?cm_mc_uid=77610277652214581184982&cm_mc_sid_50200000=1464593765\n\n-----\n\n*观点仅代表自己，期待你的留言。*\n","slug":"distributed-redis-locked-queue","published":1,"updated":"2021-09-18T03:03:41.855Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cku52dymc000vbbin6qde15v7","content":"<h2 id=\"分布式锁\"><a href=\"#分布式锁\" class=\"headerlink\" title=\"分布式锁\"></a>分布式锁</h2><p>通过Redis做分布式系统的共享内存实现方案中，可以实现分布式锁的功能。实现方法就是用 SET NX 命令设置一个设定了存活周期 TTL 的 Key 来获取锁，通过删除 Key 来释放锁，通过存活周期来保证避免死锁。<br>如：<code>SET resource_name my_random_value NX PX 30000</code></p>\n<p> <em>注：</em></p>\n<hr>\n<p><code>SET key value [EX seconds] [PX milliseconds] [NX|XX]</code><br>从2.6.12版本开始，redis为SET命令增加了一系列选项:</p>\n<ul>\n<li>EX seconds – Set the specified expire time, in seconds.</li>\n<li>PX milliseconds – Set the specified expire time, in milliseconds.</li>\n<li>NX – Only set the key if it does not already exist.</li>\n<li>XX – Only set the key if it already exist.</li>\n<li>EX seconds – 设置键key的过期时间，单位时秒</li>\n<li>PX milliseconds – 设置键key的过期时间，单位时毫秒</li>\n<li>NX – 只有键key不存在的时候才会设置key的值</li>\n<li>XX – 只有键key存在的时候才会设置key的值</li>\n</ul>\n<p>但，以上简单方案存在一个单点故障的风险。在master/slave环境下，当：</p>\n<ol>\n<li>客户端A获取到锁.</li>\n<li>master节点在将 key 复制到 slave 节点之前崩溃了</li>\n<li>此时，slave节点被提升为master节点.</li>\n<li>客户端 B 从新的 master 节点获得了锁(而这个锁实际上已经由客户端 A 所持有)，导致了系统中有两个客户端在同一时间段内持有同一个互斥锁，破坏了互斥锁的安全性。</li>\n</ol>\n<p>__解决方法：__需要解决以上问题，需要在进行锁设值时将惟一标识系统的ID做为value一同存储到Redis中，在完成所有的操作后，进行解锁时取出Redis内存储的value进行比对，<br>如果锁key对应的value还是当前系统的ID,那么表示当前锁目前只被当前系统所持有，反之，则表示锁被其它的系统抢占，那么需要回滚所有的操作。</p>\n<p>如：</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">客户端A（ID为SYSA）</th>\n<th align=\"left\">Redis</th>\n<th align=\"left\">客户端B（ID为SYSB）</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">获取到锁（SET dist_lock SYSA NX PX 30000)</td>\n<td align=\"left\"></td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">进行其它的业务操作。。。</td>\n<td align=\"left\">master发生故障，slave被提升为NewMaster(未将master中dist_lock复制到NewMaster)</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\"></td>\n<td align=\"left\"></td>\n<td align=\"left\">获取到锁（SET dist_lock SYSB NX PX 30000）</td>\n</tr>\n<tr>\n<td align=\"left\">解锁 (get dist_lock，对value进行判定，为SYSA则执行解锁，否则回滚业务)</td>\n<td align=\"left\"></td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\"></td>\n<td align=\"left\"></td>\n<td align=\"left\">解锁 (get dist_lock，对value进行判定，为SYSB则执行解锁，否则回滚业务)</td>\n</tr>\n</tbody></table>\n<h2 id=\"分布式队列\"><a href=\"#分布式队列\" class=\"headerlink\" title=\"分布式队列\"></a>分布式队列</h2><p>Redis实现分布式队列主要实现是通过<code>有序集合</code>实现，通过ZADD向集合内添加元素，同时添加多个元素时为事务处理（不存在部分成功部分失败的情况）</p>\n<p> <em>注：</em></p>\n<hr>\n<p><code>ZADD key [NX|XX] [CH] [INCR] score member [score member ...]</code><br>从3.0.2版本开始，增加以下选项：</p>\n<ul>\n<li>XX: Only update elements that already exist. Never add elements.</li>\n<li>NX: Don’t update already existing elements. Always add new elements.</li>\n<li>CH: Modify the return value from the number of new elements added, to the total number of elements changed (CH is an abbreviation of changed). Changed elements are new elements added and elements already existing for which the score was updated. So elements specified in the command line having the same score as they had in the past are not counted. Note: normally the return value of ZADD only counts the number of new elements added.</li>\n<li>INCR: When this option is specified ZADD acts like ZINCRBY. Only one score-element pair can be specified in this mode.</li>\n</ul>\n<h2 id=\"另外的选择\"><a href=\"#另外的选择\" class=\"headerlink\" title=\"另外的选择\"></a>另外的选择</h2><p>_Java库：_其实也在使用<a href=\"https://github.com/mrniko/redisson\">redisson</a>来实现分布式锁。它封装了针对Redis各种操作的分布式实现。</p>\n<p>其它语言可参照官网文章: <a href=\"http://redis.io/topics/distlock?cm_mc_uid=77610277652214581184982&amp;cm_mc_sid_50200000=1464593765\">http://redis.io/topics/distlock?cm_mc_uid=77610277652214581184982&amp;cm_mc_sid_50200000=1464593765</a></p>\n<hr>\n<p><em>观点仅代表自己，期待你的留言。</em></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"分布式锁\"><a href=\"#分布式锁\" class=\"headerlink\" title=\"分布式锁\"></a>分布式锁</h2><p>通过Redis做分布式系统的共享内存实现方案中，可以实现分布式锁的功能。实现方法就是用 SET NX 命令设置一个设定了存活周期 TTL 的 Key 来获取锁，通过删除 Key 来释放锁，通过存活周期来保证避免死锁。<br>如：<code>SET resource_name my_random_value NX PX 30000</code></p>\n<p> <em>注：</em></p>\n<hr>\n<p><code>SET key value [EX seconds] [PX milliseconds] [NX|XX]</code><br>从2.6.12版本开始，redis为SET命令增加了一系列选项:</p>\n<ul>\n<li>EX seconds – Set the specified expire time, in seconds.</li>\n<li>PX milliseconds – Set the specified expire time, in milliseconds.</li>\n<li>NX – Only set the key if it does not already exist.</li>\n<li>XX – Only set the key if it already exist.</li>\n<li>EX seconds – 设置键key的过期时间，单位时秒</li>\n<li>PX milliseconds – 设置键key的过期时间，单位时毫秒</li>\n<li>NX – 只有键key不存在的时候才会设置key的值</li>\n<li>XX – 只有键key存在的时候才会设置key的值</li>\n</ul>\n<p>但，以上简单方案存在一个单点故障的风险。在master/slave环境下，当：</p>\n<ol>\n<li>客户端A获取到锁.</li>\n<li>master节点在将 key 复制到 slave 节点之前崩溃了</li>\n<li>此时，slave节点被提升为master节点.</li>\n<li>客户端 B 从新的 master 节点获得了锁(而这个锁实际上已经由客户端 A 所持有)，导致了系统中有两个客户端在同一时间段内持有同一个互斥锁，破坏了互斥锁的安全性。</li>\n</ol>\n<p>__解决方法：__需要解决以上问题，需要在进行锁设值时将惟一标识系统的ID做为value一同存储到Redis中，在完成所有的操作后，进行解锁时取出Redis内存储的value进行比对，<br>如果锁key对应的value还是当前系统的ID,那么表示当前锁目前只被当前系统所持有，反之，则表示锁被其它的系统抢占，那么需要回滚所有的操作。</p>\n<p>如：</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">客户端A（ID为SYSA）</th>\n<th align=\"left\">Redis</th>\n<th align=\"left\">客户端B（ID为SYSB）</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">获取到锁（SET dist_lock SYSA NX PX 30000)</td>\n<td align=\"left\"></td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">进行其它的业务操作。。。</td>\n<td align=\"left\">master发生故障，slave被提升为NewMaster(未将master中dist_lock复制到NewMaster)</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\"></td>\n<td align=\"left\"></td>\n<td align=\"left\">获取到锁（SET dist_lock SYSB NX PX 30000）</td>\n</tr>\n<tr>\n<td align=\"left\">解锁 (get dist_lock，对value进行判定，为SYSA则执行解锁，否则回滚业务)</td>\n<td align=\"left\"></td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\"></td>\n<td align=\"left\"></td>\n<td align=\"left\">解锁 (get dist_lock，对value进行判定，为SYSB则执行解锁，否则回滚业务)</td>\n</tr>\n</tbody></table>\n<h2 id=\"分布式队列\"><a href=\"#分布式队列\" class=\"headerlink\" title=\"分布式队列\"></a>分布式队列</h2><p>Redis实现分布式队列主要实现是通过<code>有序集合</code>实现，通过ZADD向集合内添加元素，同时添加多个元素时为事务处理（不存在部分成功部分失败的情况）</p>\n<p> <em>注：</em></p>\n<hr>\n<p><code>ZADD key [NX|XX] [CH] [INCR] score member [score member ...]</code><br>从3.0.2版本开始，增加以下选项：</p>\n<ul>\n<li>XX: Only update elements that already exist. Never add elements.</li>\n<li>NX: Don’t update already existing elements. Always add new elements.</li>\n<li>CH: Modify the return value from the number of new elements added, to the total number of elements changed (CH is an abbreviation of changed). Changed elements are new elements added and elements already existing for which the score was updated. So elements specified in the command line having the same score as they had in the past are not counted. Note: normally the return value of ZADD only counts the number of new elements added.</li>\n<li>INCR: When this option is specified ZADD acts like ZINCRBY. Only one score-element pair can be specified in this mode.</li>\n</ul>\n<h2 id=\"另外的选择\"><a href=\"#另外的选择\" class=\"headerlink\" title=\"另外的选择\"></a>另外的选择</h2><p>_Java库：_其实也在使用<a href=\"https://github.com/mrniko/redisson\">redisson</a>来实现分布式锁。它封装了针对Redis各种操作的分布式实现。</p>\n<p>其它语言可参照官网文章: <a href=\"http://redis.io/topics/distlock?cm_mc_uid=77610277652214581184982&amp;cm_mc_sid_50200000=1464593765\">http://redis.io/topics/distlock?cm_mc_uid=77610277652214581184982&amp;cm_mc_sid_50200000=1464593765</a></p>\n<hr>\n<p><em>观点仅代表自己，期待你的留言。</em></p>\n"},{"title":"docker常用命令总结","date":"2016-04-15T02:54:54.000Z","_content":"\n### docker pull\n`说明：`获取网络镜像到本地\n ```\n [root@localhost ~]# docker pull --help\n\nUsage:\tdocker pull [OPTIONS] NAME[:TAG|@DIGEST]\n\nPull an image or a repository from a registry\n\n  -a, --all-tags                  Download all tagged images in the repository\n  --disable-content-trust=true    Skip image verification\n  --help                          Print usage\n ```\n当不指定TAG时，默认为：latest\n示例：\n```\n[root@localhost ~]# sudo docker pull ubuntu:12.04\n[root@localhost ~]# docker pull registry.hub.docker.com/ubuntu:12.04\n```\n### docker images\n`说明：`显示本地已有的镜像\n```\n[root@localhost ~]# docker images --help\n\nUsage:\tdocker images [OPTIONS] [REPOSITORY[:TAG]]\n\nList images\n\n  -a, --all          Show all images (default hides intermediate images)\n  --digests          Show digests\n  -f, --filter=[]    Filter output based on conditions provided\n  --format           Pretty-print images using a Go template\n  --help             Print usage\n  --no-trunc         Don't truncate output\n  -q, --quiet        Only show numeric IDs\n```\n镜像的 `ID` 唯一标识了镜像。\n### docker run\n`说明：`使用已下载到本地的镜像启动一个新容器\n```\n[root@localhost ~]# docker run --help\n\nUsage:\tdocker run [OPTIONS] IMAGE [COMMAND] [ARG...]\n\nRun a command in a new container\n\n  -a, --attach=[]                 Attach to STDIN, STDOUT or STDERR\n  --add-host=[]                   Add a custom host-to-IP mapping (host:ip)\n  --blkio-weight                  Block IO (relative weight), between 10 and 1000\n  --blkio-weight-device=[]        Block IO weight (relative device weight)\n  --cpu-shares                    CPU shares (relative weight)\n  --cap-add=[]                    Add Linux capabilities\n  --cap-drop=[]                   Drop Linux capabilities\n  --cgroup-parent                 Optional parent cgroup for the container\n  --cidfile                       Write the container ID to the file\n  --cpu-period                    Limit CPU CFS (Completely Fair Scheduler) period\n  --cpu-quota                     Limit CPU CFS (Completely Fair Scheduler) quota\n  --cpuset-cpus                   CPUs in which to allow execution (0-3, 0,1)\n  --cpuset-mems                   MEMs in which to allow execution (0-3, 0,1)\n  -d, --detach                    Run container in background and print container ID\n  --detach-keys                   Override the key sequence for detaching a container\n  --device=[]                     Add a host device to the container\n  --device-read-bps=[]            Limit read rate (bytes per second) from a device\n  --device-read-iops=[]           Limit read rate (IO per second) from a device\n  --device-write-bps=[]           Limit write rate (bytes per second) to a device\n  --device-write-iops=[]          Limit write rate (IO per second) to a device\n  --disable-content-trust=true    Skip image verification\n  --dns=[]                        Set custom DNS servers\n  --dns-opt=[]                    Set DNS options\n  --dns-search=[]                 Set custom DNS search domains\n  -e, --env=[]                    Set environment variables\n  --entrypoint                    Overwrite the default ENTRYPOINT of the image\n  --env-file=[]                   Read in a file of environment variables\n  --expose=[]                     Expose a port or a range of ports\n  --group-add=[]                  Add additional groups to join\n  -h, --hostname                  Container host name\n  --help                          Print usage\n  -i, --interactive               Keep STDIN open even if not attached\n  --ip                            Container IPv4 address (e.g. 172.30.100.104)\n  --ip6                           Container IPv6 address (e.g. 2001:db8::33)\n  --ipc                           IPC namespace to use\n  --isolation                     Container isolation level\n  --kernel-memory                 Kernel memory limit\n  -l, --label=[]                  Set meta data on a container\n  --label-file=[]                 Read in a line delimited file of labels\n  --link=[]                       Add link to another container\n  --log-driver                    Logging driver for container\n  --log-opt=[]                    Log driver options\n  -m, --memory                    Memory limit\n  --mac-address                   Container MAC address (e.g. 92:d0:c6:0a:29:33)\n  --memory-reservation            Memory soft limit\n  --memory-swap                   Swap limit equal to memory plus swap: '-1' to enable unlimited swap\n  --memory-swappiness=-1          Tune container memory swappiness (0 to 100)\n  --name                          Assign a name to the container\n  --net=default                   Connect a container to a network\n  --net-alias=[]                  Add network-scoped alias for the container\n  --oom-kill-disable              Disable OOM Killer\n  --oom-score-adj                 Tune host's OOM preferences (-1000 to 1000)\n  -P, --publish-all               Publish all exposed ports to random ports\n  -p, --publish=[]                Publish a container's port(s) to the host\n  --pid                           PID namespace to use\n  --privileged                    Give extended privileges to this container\n  --read-only                     Mount the container's root filesystem as read only\n  --restart=no                    Restart policy to apply when a container exits\n  --rm                            Automatically remove the container when it exits\n  --security-opt=[]               Security Options\n  --shm-size                      Size of /dev/shm, default value is 64MB\n  --sig-proxy=true                Proxy received signals to the process\n  --stop-signal=SIGTERM           Signal to stop a container, SIGTERM by default\n  -t, --tty                       Allocate a pseudo-TTY\n  --tmpfs=[]                      Mount a tmpfs directory\n  -u, --user                      Username or UID (format: <name|uid>[:<group|gid>])\n  --ulimit=[]                     Ulimit options\n  --uts                           UTS namespace to use\n  -v, --volume=[]                 Bind mount a volume\n  --volume-driver                 Optional volume driver for the container\n  --volumes-from=[]               Mount volumes from the specified container(s)\n  -w, --workdir                   Working directory inside the container\n```\n`IMAGE`可以为镜像名或者镜像ID。\n示例： \n```\nsudo docker run -t -i ouruser/sinatra:v2 /bin/bash\nsudo docker run -d ubuntu:14.04 /bin/sh -c \"while true; do echo hello world; sleep 1; done\" #守护态运行\n```\n\n在执行 docker run 的时候如果添加 --rm 标记，则容器在终止后会立刻删除。注意，--rm 和 -d 参数不能同时使用。\n\n### docker logs\n`说明：`获取容器输出的信息，适用于守护态运行docker容器。\n```\n[root@localhost ~]# docker logs --help\n\nUsage:\tdocker logs [OPTIONS] CONTAINER\n\nFetch the logs of a container\n\n  -f, --follow        Follow log output\n  --help              Print usage\n  --since             Show logs since timestamp\n  -t, --timestamps    Show timestamps\n  --tail=all          Number of lines to show from the end of the logs\n```\n### docker stop\n`说明：`停止一个正在启动的容器。\n```\n[root@localhost ~]# docker stop --help\n\nUsage:\tdocker stop [OPTIONS] CONTAINER [CONTAINER...]\n\nStop a running container.\nSending SIGTERM and then SIGKILL after a grace period\n\n  --help             Print usage\n  -t, --time=10      Seconds to wait for stop before killing it\n```\n### docker start\n`说明：`启动一个已经停止的容器。\n```\n[root@localhost ~]# docker start --help\n\nUsage:\tdocker start [OPTIONS] CONTAINER [CONTAINER...]\n\nStart one or more stopped containers\n\n  -a, --attach         Attach STDOUT/STDERR and forward signals\n  --detach-keys        Override the key sequence for detaching a container\n  --help               Print usage\n  -i, --interactive    Attach container's STDIN\n```\n### docker restart\n`说明：`将一个运行态的容器终止，然后再重新启动它。\n```\n[root@localhost ~]# docker restart --help\n\nUsage:\tdocker restart [OPTIONS] CONTAINER [CONTAINER...]\n\nRestart a container\n\n  --help             Print usage\n  -t, --time=10      Seconds to wait for stop before killing the container\n```\n### docker attach\n`说明：`在使用 -d 参数时，容器启动后会进入后台。 某些时候需要进入容器进行操作就可以用它。\n```\n[root@localhost ~]# docker attach --help\n\nUsage:\tdocker attach [OPTIONS] CONTAINER\n\nAttach to a running container\n\n  --detach-keys       Override the key sequence for detaching a container\n  --help              Print usage\n  --no-stdin          Do not attach STDIN\n  --sig-proxy=true    Proxy all received signals to the process\n```\n\n### docker commit\n`说明：`将修改后的容器提交保存为一个新的镜像。\n```\n[root@localhost ~]# docker commit --help\n\nUsage:\tdocker commit [OPTIONS] CONTAINER [REPOSITORY[:TAG]]\n\nCreate a new image from a container's changes\n\n  -a, --author        Author (e.g., \"John Hannibal Smith <hannibal@a-team.com>\")\n  -c, --change=[]     Apply Dockerfile instruction to the created image\n  --help              Print usage\n  -m, --message       Commit message\n  -p, --pause=true    Pause container during commit\n```\n示例：\n```\n$ sudo docker commit -m \"Added json gem\" -a \"Docker Newbee\" 0b2616b0e5a8 ouruser/sinatra:v2\n4f177bd27a9ff0f6dc2a830403925b5360bfe0b93d476f7fc3231110e7f71b1c\n```\n### docker tag\n`说明:`修改镜像标签\n```\n[root@localhost ~]# docker tag --help\n\nUsage:\tdocker tag [OPTIONS] IMAGE[:TAG] [REGISTRYHOST/][USERNAME/]NAME[:TAG]\n\nTag an image into a repository\n\n  --help             Print usage\n```\n示例：\n```\ndocker tag 5db5f8471261 ouruser/sinatra:devel #将5db5f8471261的镜像tag更改为devel\n```\n### docker push\n`说明:`自己创建的本地镜像上传到远程仓库中来共享。\n```\n[root@localhost ~]# docker push --help\n\nUsage:\tdocker push [OPTIONS] NAME[:TAG]\n\nPush an image or a repository to a registry\n\n  --disable-content-trust=true    Skip image signing\n  --help                          Print usage\n```\n### docker save\n`说明:`将镜像导出成本地文件\n```\n[root@localhost ~]# docker save --help\n\nUsage:\tdocker save [OPTIONS] IMAGE [IMAGE...]\n\nSave an image(s) to a tar archive (streamed to STDOUT by default)\n\n  --help             Print usage\n  -o, --output       Write to a file, instead of STDOUT\n```\n示例：\n```\n[root@localhost ~]# docker save -o ubuntu_14.04.tar ubuntu:14.04\n```\n### docker load\n`说明:`将镜像本地文件加载成为本地镜像\n```\n[root@localhost ~]# docker load --help\n\nUsage:\tdocker load [OPTIONS]\n\nLoad an image from a tar archive or STDIN\n\n  --help             Print usage\n  -i, --input        Read from a tar archive file, instead of STDIN\n```\n示例：\n```\n[root@localhost ~]# docker load --input ubuntu_14.04.tar\n```\n### docker ps\n`说明：`列出对应的容器\n```\n[root@localhost ~]# docker ps --help\n\nUsage:\tdocker ps [OPTIONS]\n\nList containers\n\n  -a, --all          Show all containers (default shows just running)\n  -f, --filter=[]    Filter output based on conditions provided\n  --format           Pretty-print containers using a Go template\n  --help             Print usage\n  -l, --latest       Show the latest created container (includes all states)\n  -n=-1              Show n last created containers (includes all states)\n  --no-trunc         Don't truncate output\n  -q, --quiet        Only display numeric IDs\n  -s, --size         Display total file sizes\n```\n示例：\n```\n[root@localhost ~]# docker ps -a\n```\n### docker export\n`说明：`导出本地某个容器为快照文件\n```\n[root@localhost ~]# docker export --help\n\nUsage:\tdocker export [OPTIONS] CONTAINER\n\nExport a container's filesystem as a tar archive\n\n  --help             Print usage\n  -o, --output       Write to a file, instead of STDOUT\n```\n### docker import\n`说明：`将容器快照文件导入为本地容器或者本地镜像。与`docker load`的区别在于容器快照文件将丢弃所有的历史记录和元数据信息,而镜像存储文件将保存完整记录，体积也要大。\n```\n[root@localhost ~]# docker import --help\n\nUsage:\tdocker import [OPTIONS] file|URL|- [REPOSITORY[:TAG]]\n\nImport the contents from a tarball to create a filesystem image\n\n  -c, --change=[]    Apply Dockerfile instruction to the created image\n  --help             Print usage\n  -m, --message      Set commit message for imported image\n```\n示例：\n```\n[root@localhost ~]# cat ubuntu.tar | sudo docker import - test/ubuntu:v1.0\n```\n### docker rm\n`说明：`移除容器\n```\n[root@localhost ~]# docker rm --help\n\nUsage:\tdocker rm [OPTIONS] CONTAINER [CONTAINER...]\n\nRemove one or more containers\n\n  -f, --force        Force the removal of a running container (uses SIGKILL)\n  --help             Print usage\n  -l, --link         Remove the specified link\n  -v, --volumes      Remove the volumes associated with the container\n```\n示例：\n```\n[root@localhost ~]# docker rm $(docker ps -a -q) #清理所有处于终止状态的容器\n```\n### docker rmi\n`说明:`移除本地镜像，移出前需要先移除到镜像对应的容器。\n```\n[root@localhost ~]# docker rmi --help\n\nUsage:\tdocker rmi [OPTIONS] IMAGE [IMAGE...]\n\nRemove one or more images\n\n  -f, --force        Force removal of the image\n  --help             Print usage\n  --no-prune         Do not delete untagged parents\n```\n\n清理所有未打过标签的本地镜像：`docker rmi $(docker images -q -f \"dangling=true\")`\n\n### docker inspect\n`说明:`查看容器或者镜像的详情信息。\n```\n[root@localhost ~]# docker inspect --help\n\nUsage:\tdocker inspect [OPTIONS] CONTAINER|IMAGE [CONTAINER|IMAGE...]\n\nReturn low-level information on a container or image\n\n  -f, --format       Format the output using the given go template\n  --help             Print usage\n  -s, --size         Display total file sizes if the type is container\n  --type             Return JSON for specified type, (e.g image or container)\n```\n### docker port\n`说明：`来查看当前映射的端口配置，也可以查看到绑定的地址。\n```\n[root@localhost ~]# docker port --help\n\nUsage:  docker port [OPTIONS] CONTAINER [PRIVATE_PORT[/PROTO]]\n\nList port mappings or a specific mapping for the CONTAINER\n\n  --help             Print usage\n```\n\n-----\n\n\n*观点仅代表自己，期待你的留言。*\n","source":"_posts/docker-cmd-summarize.md","raw":"---\ntitle: docker常用命令总结\ntags:\n  - Docker\n  - 原创\ndate: 2016-04-15 10:54:54\n---\n\n### docker pull\n`说明：`获取网络镜像到本地\n ```\n [root@localhost ~]# docker pull --help\n\nUsage:\tdocker pull [OPTIONS] NAME[:TAG|@DIGEST]\n\nPull an image or a repository from a registry\n\n  -a, --all-tags                  Download all tagged images in the repository\n  --disable-content-trust=true    Skip image verification\n  --help                          Print usage\n ```\n当不指定TAG时，默认为：latest\n示例：\n```\n[root@localhost ~]# sudo docker pull ubuntu:12.04\n[root@localhost ~]# docker pull registry.hub.docker.com/ubuntu:12.04\n```\n### docker images\n`说明：`显示本地已有的镜像\n```\n[root@localhost ~]# docker images --help\n\nUsage:\tdocker images [OPTIONS] [REPOSITORY[:TAG]]\n\nList images\n\n  -a, --all          Show all images (default hides intermediate images)\n  --digests          Show digests\n  -f, --filter=[]    Filter output based on conditions provided\n  --format           Pretty-print images using a Go template\n  --help             Print usage\n  --no-trunc         Don't truncate output\n  -q, --quiet        Only show numeric IDs\n```\n镜像的 `ID` 唯一标识了镜像。\n### docker run\n`说明：`使用已下载到本地的镜像启动一个新容器\n```\n[root@localhost ~]# docker run --help\n\nUsage:\tdocker run [OPTIONS] IMAGE [COMMAND] [ARG...]\n\nRun a command in a new container\n\n  -a, --attach=[]                 Attach to STDIN, STDOUT or STDERR\n  --add-host=[]                   Add a custom host-to-IP mapping (host:ip)\n  --blkio-weight                  Block IO (relative weight), between 10 and 1000\n  --blkio-weight-device=[]        Block IO weight (relative device weight)\n  --cpu-shares                    CPU shares (relative weight)\n  --cap-add=[]                    Add Linux capabilities\n  --cap-drop=[]                   Drop Linux capabilities\n  --cgroup-parent                 Optional parent cgroup for the container\n  --cidfile                       Write the container ID to the file\n  --cpu-period                    Limit CPU CFS (Completely Fair Scheduler) period\n  --cpu-quota                     Limit CPU CFS (Completely Fair Scheduler) quota\n  --cpuset-cpus                   CPUs in which to allow execution (0-3, 0,1)\n  --cpuset-mems                   MEMs in which to allow execution (0-3, 0,1)\n  -d, --detach                    Run container in background and print container ID\n  --detach-keys                   Override the key sequence for detaching a container\n  --device=[]                     Add a host device to the container\n  --device-read-bps=[]            Limit read rate (bytes per second) from a device\n  --device-read-iops=[]           Limit read rate (IO per second) from a device\n  --device-write-bps=[]           Limit write rate (bytes per second) to a device\n  --device-write-iops=[]          Limit write rate (IO per second) to a device\n  --disable-content-trust=true    Skip image verification\n  --dns=[]                        Set custom DNS servers\n  --dns-opt=[]                    Set DNS options\n  --dns-search=[]                 Set custom DNS search domains\n  -e, --env=[]                    Set environment variables\n  --entrypoint                    Overwrite the default ENTRYPOINT of the image\n  --env-file=[]                   Read in a file of environment variables\n  --expose=[]                     Expose a port or a range of ports\n  --group-add=[]                  Add additional groups to join\n  -h, --hostname                  Container host name\n  --help                          Print usage\n  -i, --interactive               Keep STDIN open even if not attached\n  --ip                            Container IPv4 address (e.g. 172.30.100.104)\n  --ip6                           Container IPv6 address (e.g. 2001:db8::33)\n  --ipc                           IPC namespace to use\n  --isolation                     Container isolation level\n  --kernel-memory                 Kernel memory limit\n  -l, --label=[]                  Set meta data on a container\n  --label-file=[]                 Read in a line delimited file of labels\n  --link=[]                       Add link to another container\n  --log-driver                    Logging driver for container\n  --log-opt=[]                    Log driver options\n  -m, --memory                    Memory limit\n  --mac-address                   Container MAC address (e.g. 92:d0:c6:0a:29:33)\n  --memory-reservation            Memory soft limit\n  --memory-swap                   Swap limit equal to memory plus swap: '-1' to enable unlimited swap\n  --memory-swappiness=-1          Tune container memory swappiness (0 to 100)\n  --name                          Assign a name to the container\n  --net=default                   Connect a container to a network\n  --net-alias=[]                  Add network-scoped alias for the container\n  --oom-kill-disable              Disable OOM Killer\n  --oom-score-adj                 Tune host's OOM preferences (-1000 to 1000)\n  -P, --publish-all               Publish all exposed ports to random ports\n  -p, --publish=[]                Publish a container's port(s) to the host\n  --pid                           PID namespace to use\n  --privileged                    Give extended privileges to this container\n  --read-only                     Mount the container's root filesystem as read only\n  --restart=no                    Restart policy to apply when a container exits\n  --rm                            Automatically remove the container when it exits\n  --security-opt=[]               Security Options\n  --shm-size                      Size of /dev/shm, default value is 64MB\n  --sig-proxy=true                Proxy received signals to the process\n  --stop-signal=SIGTERM           Signal to stop a container, SIGTERM by default\n  -t, --tty                       Allocate a pseudo-TTY\n  --tmpfs=[]                      Mount a tmpfs directory\n  -u, --user                      Username or UID (format: <name|uid>[:<group|gid>])\n  --ulimit=[]                     Ulimit options\n  --uts                           UTS namespace to use\n  -v, --volume=[]                 Bind mount a volume\n  --volume-driver                 Optional volume driver for the container\n  --volumes-from=[]               Mount volumes from the specified container(s)\n  -w, --workdir                   Working directory inside the container\n```\n`IMAGE`可以为镜像名或者镜像ID。\n示例： \n```\nsudo docker run -t -i ouruser/sinatra:v2 /bin/bash\nsudo docker run -d ubuntu:14.04 /bin/sh -c \"while true; do echo hello world; sleep 1; done\" #守护态运行\n```\n\n在执行 docker run 的时候如果添加 --rm 标记，则容器在终止后会立刻删除。注意，--rm 和 -d 参数不能同时使用。\n\n### docker logs\n`说明：`获取容器输出的信息，适用于守护态运行docker容器。\n```\n[root@localhost ~]# docker logs --help\n\nUsage:\tdocker logs [OPTIONS] CONTAINER\n\nFetch the logs of a container\n\n  -f, --follow        Follow log output\n  --help              Print usage\n  --since             Show logs since timestamp\n  -t, --timestamps    Show timestamps\n  --tail=all          Number of lines to show from the end of the logs\n```\n### docker stop\n`说明：`停止一个正在启动的容器。\n```\n[root@localhost ~]# docker stop --help\n\nUsage:\tdocker stop [OPTIONS] CONTAINER [CONTAINER...]\n\nStop a running container.\nSending SIGTERM and then SIGKILL after a grace period\n\n  --help             Print usage\n  -t, --time=10      Seconds to wait for stop before killing it\n```\n### docker start\n`说明：`启动一个已经停止的容器。\n```\n[root@localhost ~]# docker start --help\n\nUsage:\tdocker start [OPTIONS] CONTAINER [CONTAINER...]\n\nStart one or more stopped containers\n\n  -a, --attach         Attach STDOUT/STDERR and forward signals\n  --detach-keys        Override the key sequence for detaching a container\n  --help               Print usage\n  -i, --interactive    Attach container's STDIN\n```\n### docker restart\n`说明：`将一个运行态的容器终止，然后再重新启动它。\n```\n[root@localhost ~]# docker restart --help\n\nUsage:\tdocker restart [OPTIONS] CONTAINER [CONTAINER...]\n\nRestart a container\n\n  --help             Print usage\n  -t, --time=10      Seconds to wait for stop before killing the container\n```\n### docker attach\n`说明：`在使用 -d 参数时，容器启动后会进入后台。 某些时候需要进入容器进行操作就可以用它。\n```\n[root@localhost ~]# docker attach --help\n\nUsage:\tdocker attach [OPTIONS] CONTAINER\n\nAttach to a running container\n\n  --detach-keys       Override the key sequence for detaching a container\n  --help              Print usage\n  --no-stdin          Do not attach STDIN\n  --sig-proxy=true    Proxy all received signals to the process\n```\n\n### docker commit\n`说明：`将修改后的容器提交保存为一个新的镜像。\n```\n[root@localhost ~]# docker commit --help\n\nUsage:\tdocker commit [OPTIONS] CONTAINER [REPOSITORY[:TAG]]\n\nCreate a new image from a container's changes\n\n  -a, --author        Author (e.g., \"John Hannibal Smith <hannibal@a-team.com>\")\n  -c, --change=[]     Apply Dockerfile instruction to the created image\n  --help              Print usage\n  -m, --message       Commit message\n  -p, --pause=true    Pause container during commit\n```\n示例：\n```\n$ sudo docker commit -m \"Added json gem\" -a \"Docker Newbee\" 0b2616b0e5a8 ouruser/sinatra:v2\n4f177bd27a9ff0f6dc2a830403925b5360bfe0b93d476f7fc3231110e7f71b1c\n```\n### docker tag\n`说明:`修改镜像标签\n```\n[root@localhost ~]# docker tag --help\n\nUsage:\tdocker tag [OPTIONS] IMAGE[:TAG] [REGISTRYHOST/][USERNAME/]NAME[:TAG]\n\nTag an image into a repository\n\n  --help             Print usage\n```\n示例：\n```\ndocker tag 5db5f8471261 ouruser/sinatra:devel #将5db5f8471261的镜像tag更改为devel\n```\n### docker push\n`说明:`自己创建的本地镜像上传到远程仓库中来共享。\n```\n[root@localhost ~]# docker push --help\n\nUsage:\tdocker push [OPTIONS] NAME[:TAG]\n\nPush an image or a repository to a registry\n\n  --disable-content-trust=true    Skip image signing\n  --help                          Print usage\n```\n### docker save\n`说明:`将镜像导出成本地文件\n```\n[root@localhost ~]# docker save --help\n\nUsage:\tdocker save [OPTIONS] IMAGE [IMAGE...]\n\nSave an image(s) to a tar archive (streamed to STDOUT by default)\n\n  --help             Print usage\n  -o, --output       Write to a file, instead of STDOUT\n```\n示例：\n```\n[root@localhost ~]# docker save -o ubuntu_14.04.tar ubuntu:14.04\n```\n### docker load\n`说明:`将镜像本地文件加载成为本地镜像\n```\n[root@localhost ~]# docker load --help\n\nUsage:\tdocker load [OPTIONS]\n\nLoad an image from a tar archive or STDIN\n\n  --help             Print usage\n  -i, --input        Read from a tar archive file, instead of STDIN\n```\n示例：\n```\n[root@localhost ~]# docker load --input ubuntu_14.04.tar\n```\n### docker ps\n`说明：`列出对应的容器\n```\n[root@localhost ~]# docker ps --help\n\nUsage:\tdocker ps [OPTIONS]\n\nList containers\n\n  -a, --all          Show all containers (default shows just running)\n  -f, --filter=[]    Filter output based on conditions provided\n  --format           Pretty-print containers using a Go template\n  --help             Print usage\n  -l, --latest       Show the latest created container (includes all states)\n  -n=-1              Show n last created containers (includes all states)\n  --no-trunc         Don't truncate output\n  -q, --quiet        Only display numeric IDs\n  -s, --size         Display total file sizes\n```\n示例：\n```\n[root@localhost ~]# docker ps -a\n```\n### docker export\n`说明：`导出本地某个容器为快照文件\n```\n[root@localhost ~]# docker export --help\n\nUsage:\tdocker export [OPTIONS] CONTAINER\n\nExport a container's filesystem as a tar archive\n\n  --help             Print usage\n  -o, --output       Write to a file, instead of STDOUT\n```\n### docker import\n`说明：`将容器快照文件导入为本地容器或者本地镜像。与`docker load`的区别在于容器快照文件将丢弃所有的历史记录和元数据信息,而镜像存储文件将保存完整记录，体积也要大。\n```\n[root@localhost ~]# docker import --help\n\nUsage:\tdocker import [OPTIONS] file|URL|- [REPOSITORY[:TAG]]\n\nImport the contents from a tarball to create a filesystem image\n\n  -c, --change=[]    Apply Dockerfile instruction to the created image\n  --help             Print usage\n  -m, --message      Set commit message for imported image\n```\n示例：\n```\n[root@localhost ~]# cat ubuntu.tar | sudo docker import - test/ubuntu:v1.0\n```\n### docker rm\n`说明：`移除容器\n```\n[root@localhost ~]# docker rm --help\n\nUsage:\tdocker rm [OPTIONS] CONTAINER [CONTAINER...]\n\nRemove one or more containers\n\n  -f, --force        Force the removal of a running container (uses SIGKILL)\n  --help             Print usage\n  -l, --link         Remove the specified link\n  -v, --volumes      Remove the volumes associated with the container\n```\n示例：\n```\n[root@localhost ~]# docker rm $(docker ps -a -q) #清理所有处于终止状态的容器\n```\n### docker rmi\n`说明:`移除本地镜像，移出前需要先移除到镜像对应的容器。\n```\n[root@localhost ~]# docker rmi --help\n\nUsage:\tdocker rmi [OPTIONS] IMAGE [IMAGE...]\n\nRemove one or more images\n\n  -f, --force        Force removal of the image\n  --help             Print usage\n  --no-prune         Do not delete untagged parents\n```\n\n清理所有未打过标签的本地镜像：`docker rmi $(docker images -q -f \"dangling=true\")`\n\n### docker inspect\n`说明:`查看容器或者镜像的详情信息。\n```\n[root@localhost ~]# docker inspect --help\n\nUsage:\tdocker inspect [OPTIONS] CONTAINER|IMAGE [CONTAINER|IMAGE...]\n\nReturn low-level information on a container or image\n\n  -f, --format       Format the output using the given go template\n  --help             Print usage\n  -s, --size         Display total file sizes if the type is container\n  --type             Return JSON for specified type, (e.g image or container)\n```\n### docker port\n`说明：`来查看当前映射的端口配置，也可以查看到绑定的地址。\n```\n[root@localhost ~]# docker port --help\n\nUsage:  docker port [OPTIONS] CONTAINER [PRIVATE_PORT[/PROTO]]\n\nList port mappings or a specific mapping for the CONTAINER\n\n  --help             Print usage\n```\n\n-----\n\n\n*观点仅代表自己，期待你的留言。*\n","slug":"docker-cmd-summarize","published":1,"updated":"2021-08-31T14:23:11.539Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cku52dyme000xbbinah0e3b17","content":"<h3 id=\"docker-pull\"><a href=\"#docker-pull\" class=\"headerlink\" title=\"docker pull\"></a>docker pull</h3><p><code>说明：</code>获取网络镜像到本地<br> <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> [root@localhost ~]# docker pull --help</span><br><span class=\"line\"></span><br><span class=\"line\">Usage:\tdocker pull [OPTIONS] NAME[:TAG|@DIGEST]</span><br><span class=\"line\"></span><br><span class=\"line\">Pull an image or a repository from a registry</span><br><span class=\"line\"></span><br><span class=\"line\">  -a, --all-tags                  Download all tagged images in the repository</span><br><span class=\"line\">  --disable-content-trust=true    Skip image verification</span><br><span class=\"line\">  --help                          Print usage</span><br></pre></td></tr></table></figure><br>当不指定TAG时，默认为：latest<br>示例：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@localhost ~]# sudo docker pull ubuntu:12.04</span><br><span class=\"line\">[root@localhost ~]# docker pull registry.hub.docker.com/ubuntu:12.04</span><br></pre></td></tr></table></figure>\n<h3 id=\"docker-images\"><a href=\"#docker-images\" class=\"headerlink\" title=\"docker images\"></a>docker images</h3><p><code>说明：</code>显示本地已有的镜像</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@localhost ~]# docker images --help</span><br><span class=\"line\"></span><br><span class=\"line\">Usage:\tdocker images [OPTIONS] [REPOSITORY[:TAG]]</span><br><span class=\"line\"></span><br><span class=\"line\">List images</span><br><span class=\"line\"></span><br><span class=\"line\">  -a, --all          Show all images (default hides intermediate images)</span><br><span class=\"line\">  --digests          Show digests</span><br><span class=\"line\">  -f, --filter=[]    Filter output based on conditions provided</span><br><span class=\"line\">  --format           Pretty-print images using a Go template</span><br><span class=\"line\">  --help             Print usage</span><br><span class=\"line\">  --no-trunc         Don&#x27;t truncate output</span><br><span class=\"line\">  -q, --quiet        Only show numeric IDs</span><br></pre></td></tr></table></figure>\n<p>镜像的 <code>ID</code> 唯一标识了镜像。</p>\n<h3 id=\"docker-run\"><a href=\"#docker-run\" class=\"headerlink\" title=\"docker run\"></a>docker run</h3><p><code>说明：</code>使用已下载到本地的镜像启动一个新容器</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@localhost ~]# docker run --help</span><br><span class=\"line\"></span><br><span class=\"line\">Usage:\tdocker run [OPTIONS] IMAGE [COMMAND] [ARG...]</span><br><span class=\"line\"></span><br><span class=\"line\">Run a command in a new container</span><br><span class=\"line\"></span><br><span class=\"line\">  -a, --attach=[]                 Attach to STDIN, STDOUT or STDERR</span><br><span class=\"line\">  --add-host=[]                   Add a custom host-to-IP mapping (host:ip)</span><br><span class=\"line\">  --blkio-weight                  Block IO (relative weight), between 10 and 1000</span><br><span class=\"line\">  --blkio-weight-device=[]        Block IO weight (relative device weight)</span><br><span class=\"line\">  --cpu-shares                    CPU shares (relative weight)</span><br><span class=\"line\">  --cap-add=[]                    Add Linux capabilities</span><br><span class=\"line\">  --cap-drop=[]                   Drop Linux capabilities</span><br><span class=\"line\">  --cgroup-parent                 Optional parent cgroup for the container</span><br><span class=\"line\">  --cidfile                       Write the container ID to the file</span><br><span class=\"line\">  --cpu-period                    Limit CPU CFS (Completely Fair Scheduler) period</span><br><span class=\"line\">  --cpu-quota                     Limit CPU CFS (Completely Fair Scheduler) quota</span><br><span class=\"line\">  --cpuset-cpus                   CPUs in which to allow execution (0-3, 0,1)</span><br><span class=\"line\">  --cpuset-mems                   MEMs in which to allow execution (0-3, 0,1)</span><br><span class=\"line\">  -d, --detach                    Run container in background and print container ID</span><br><span class=\"line\">  --detach-keys                   Override the key sequence for detaching a container</span><br><span class=\"line\">  --device=[]                     Add a host device to the container</span><br><span class=\"line\">  --device-read-bps=[]            Limit read rate (bytes per second) from a device</span><br><span class=\"line\">  --device-read-iops=[]           Limit read rate (IO per second) from a device</span><br><span class=\"line\">  --device-write-bps=[]           Limit write rate (bytes per second) to a device</span><br><span class=\"line\">  --device-write-iops=[]          Limit write rate (IO per second) to a device</span><br><span class=\"line\">  --disable-content-trust=true    Skip image verification</span><br><span class=\"line\">  --dns=[]                        Set custom DNS servers</span><br><span class=\"line\">  --dns-opt=[]                    Set DNS options</span><br><span class=\"line\">  --dns-search=[]                 Set custom DNS search domains</span><br><span class=\"line\">  -e, --env=[]                    Set environment variables</span><br><span class=\"line\">  --entrypoint                    Overwrite the default ENTRYPOINT of the image</span><br><span class=\"line\">  --env-file=[]                   Read in a file of environment variables</span><br><span class=\"line\">  --expose=[]                     Expose a port or a range of ports</span><br><span class=\"line\">  --group-add=[]                  Add additional groups to join</span><br><span class=\"line\">  -h, --hostname                  Container host name</span><br><span class=\"line\">  --help                          Print usage</span><br><span class=\"line\">  -i, --interactive               Keep STDIN open even if not attached</span><br><span class=\"line\">  --ip                            Container IPv4 address (e.g. 172.30.100.104)</span><br><span class=\"line\">  --ip6                           Container IPv6 address (e.g. 2001:db8::33)</span><br><span class=\"line\">  --ipc                           IPC namespace to use</span><br><span class=\"line\">  --isolation                     Container isolation level</span><br><span class=\"line\">  --kernel-memory                 Kernel memory limit</span><br><span class=\"line\">  -l, --label=[]                  Set meta data on a container</span><br><span class=\"line\">  --label-file=[]                 Read in a line delimited file of labels</span><br><span class=\"line\">  --link=[]                       Add link to another container</span><br><span class=\"line\">  --log-driver                    Logging driver for container</span><br><span class=\"line\">  --log-opt=[]                    Log driver options</span><br><span class=\"line\">  -m, --memory                    Memory limit</span><br><span class=\"line\">  --mac-address                   Container MAC address (e.g. 92:d0:c6:0a:29:33)</span><br><span class=\"line\">  --memory-reservation            Memory soft limit</span><br><span class=\"line\">  --memory-swap                   Swap limit equal to memory plus swap: &#x27;-1&#x27; to enable unlimited swap</span><br><span class=\"line\">  --memory-swappiness=-1          Tune container memory swappiness (0 to 100)</span><br><span class=\"line\">  --name                          Assign a name to the container</span><br><span class=\"line\">  --net=default                   Connect a container to a network</span><br><span class=\"line\">  --net-alias=[]                  Add network-scoped alias for the container</span><br><span class=\"line\">  --oom-kill-disable              Disable OOM Killer</span><br><span class=\"line\">  --oom-score-adj                 Tune host&#x27;s OOM preferences (-1000 to 1000)</span><br><span class=\"line\">  -P, --publish-all               Publish all exposed ports to random ports</span><br><span class=\"line\">  -p, --publish=[]                Publish a container&#x27;s port(s) to the host</span><br><span class=\"line\">  --pid                           PID namespace to use</span><br><span class=\"line\">  --privileged                    Give extended privileges to this container</span><br><span class=\"line\">  --read-only                     Mount the container&#x27;s root filesystem as read only</span><br><span class=\"line\">  --restart=no                    Restart policy to apply when a container exits</span><br><span class=\"line\">  --rm                            Automatically remove the container when it exits</span><br><span class=\"line\">  --security-opt=[]               Security Options</span><br><span class=\"line\">  --shm-size                      Size of /dev/shm, default value is 64MB</span><br><span class=\"line\">  --sig-proxy=true                Proxy received signals to the process</span><br><span class=\"line\">  --stop-signal=SIGTERM           Signal to stop a container, SIGTERM by default</span><br><span class=\"line\">  -t, --tty                       Allocate a pseudo-TTY</span><br><span class=\"line\">  --tmpfs=[]                      Mount a tmpfs directory</span><br><span class=\"line\">  -u, --user                      Username or UID (format: &lt;name|uid&gt;[:&lt;group|gid&gt;])</span><br><span class=\"line\">  --ulimit=[]                     Ulimit options</span><br><span class=\"line\">  --uts                           UTS namespace to use</span><br><span class=\"line\">  -v, --volume=[]                 Bind mount a volume</span><br><span class=\"line\">  --volume-driver                 Optional volume driver for the container</span><br><span class=\"line\">  --volumes-from=[]               Mount volumes from the specified container(s)</span><br><span class=\"line\">  -w, --workdir                   Working directory inside the container</span><br></pre></td></tr></table></figure>\n<p><code>IMAGE</code>可以为镜像名或者镜像ID。<br>示例： </p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo docker run -t -i ouruser/sinatra:v2 /bin/bash</span><br><span class=\"line\">sudo docker run -d ubuntu:14.04 /bin/sh -c &quot;while true; do echo hello world; sleep 1; done&quot; #守护态运行</span><br></pre></td></tr></table></figure>\n\n<p>在执行 docker run 的时候如果添加 –rm 标记，则容器在终止后会立刻删除。注意，–rm 和 -d 参数不能同时使用。</p>\n<h3 id=\"docker-logs\"><a href=\"#docker-logs\" class=\"headerlink\" title=\"docker logs\"></a>docker logs</h3><p><code>说明：</code>获取容器输出的信息，适用于守护态运行docker容器。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@localhost ~]# docker logs --help</span><br><span class=\"line\"></span><br><span class=\"line\">Usage:\tdocker logs [OPTIONS] CONTAINER</span><br><span class=\"line\"></span><br><span class=\"line\">Fetch the logs of a container</span><br><span class=\"line\"></span><br><span class=\"line\">  -f, --follow        Follow log output</span><br><span class=\"line\">  --help              Print usage</span><br><span class=\"line\">  --since             Show logs since timestamp</span><br><span class=\"line\">  -t, --timestamps    Show timestamps</span><br><span class=\"line\">  --tail=all          Number of lines to show from the end of the logs</span><br></pre></td></tr></table></figure>\n<h3 id=\"docker-stop\"><a href=\"#docker-stop\" class=\"headerlink\" title=\"docker stop\"></a>docker stop</h3><p><code>说明：</code>停止一个正在启动的容器。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@localhost ~]# docker stop --help</span><br><span class=\"line\"></span><br><span class=\"line\">Usage:\tdocker stop [OPTIONS] CONTAINER [CONTAINER...]</span><br><span class=\"line\"></span><br><span class=\"line\">Stop a running container.</span><br><span class=\"line\">Sending SIGTERM and then SIGKILL after a grace period</span><br><span class=\"line\"></span><br><span class=\"line\">  --help             Print usage</span><br><span class=\"line\">  -t, --time=10      Seconds to wait for stop before killing it</span><br></pre></td></tr></table></figure>\n<h3 id=\"docker-start\"><a href=\"#docker-start\" class=\"headerlink\" title=\"docker start\"></a>docker start</h3><p><code>说明：</code>启动一个已经停止的容器。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@localhost ~]# docker start --help</span><br><span class=\"line\"></span><br><span class=\"line\">Usage:\tdocker start [OPTIONS] CONTAINER [CONTAINER...]</span><br><span class=\"line\"></span><br><span class=\"line\">Start one or more stopped containers</span><br><span class=\"line\"></span><br><span class=\"line\">  -a, --attach         Attach STDOUT/STDERR and forward signals</span><br><span class=\"line\">  --detach-keys        Override the key sequence for detaching a container</span><br><span class=\"line\">  --help               Print usage</span><br><span class=\"line\">  -i, --interactive    Attach container&#x27;s STDIN</span><br></pre></td></tr></table></figure>\n<h3 id=\"docker-restart\"><a href=\"#docker-restart\" class=\"headerlink\" title=\"docker restart\"></a>docker restart</h3><p><code>说明：</code>将一个运行态的容器终止，然后再重新启动它。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@localhost ~]# docker restart --help</span><br><span class=\"line\"></span><br><span class=\"line\">Usage:\tdocker restart [OPTIONS] CONTAINER [CONTAINER...]</span><br><span class=\"line\"></span><br><span class=\"line\">Restart a container</span><br><span class=\"line\"></span><br><span class=\"line\">  --help             Print usage</span><br><span class=\"line\">  -t, --time=10      Seconds to wait for stop before killing the container</span><br></pre></td></tr></table></figure>\n<h3 id=\"docker-attach\"><a href=\"#docker-attach\" class=\"headerlink\" title=\"docker attach\"></a>docker attach</h3><p><code>说明：</code>在使用 -d 参数时，容器启动后会进入后台。 某些时候需要进入容器进行操作就可以用它。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@localhost ~]# docker attach --help</span><br><span class=\"line\"></span><br><span class=\"line\">Usage:\tdocker attach [OPTIONS] CONTAINER</span><br><span class=\"line\"></span><br><span class=\"line\">Attach to a running container</span><br><span class=\"line\"></span><br><span class=\"line\">  --detach-keys       Override the key sequence for detaching a container</span><br><span class=\"line\">  --help              Print usage</span><br><span class=\"line\">  --no-stdin          Do not attach STDIN</span><br><span class=\"line\">  --sig-proxy=true    Proxy all received signals to the process</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"docker-commit\"><a href=\"#docker-commit\" class=\"headerlink\" title=\"docker commit\"></a>docker commit</h3><p><code>说明：</code>将修改后的容器提交保存为一个新的镜像。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@localhost ~]# docker commit --help</span><br><span class=\"line\"></span><br><span class=\"line\">Usage:\tdocker commit [OPTIONS] CONTAINER [REPOSITORY[:TAG]]</span><br><span class=\"line\"></span><br><span class=\"line\">Create a new image from a container&#x27;s changes</span><br><span class=\"line\"></span><br><span class=\"line\">  -a, --author        Author (e.g., &quot;John Hannibal Smith &lt;hannibal@a-team.com&gt;&quot;)</span><br><span class=\"line\">  -c, --change=[]     Apply Dockerfile instruction to the created image</span><br><span class=\"line\">  --help              Print usage</span><br><span class=\"line\">  -m, --message       Commit message</span><br><span class=\"line\">  -p, --pause=true    Pause container during commit</span><br></pre></td></tr></table></figure>\n<p>示例：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo docker commit -m &quot;Added json gem&quot; -a &quot;Docker Newbee&quot; 0b2616b0e5a8 ouruser/sinatra:v2</span><br><span class=\"line\">4f177bd27a9ff0f6dc2a830403925b5360bfe0b93d476f7fc3231110e7f71b1c</span><br></pre></td></tr></table></figure>\n<h3 id=\"docker-tag\"><a href=\"#docker-tag\" class=\"headerlink\" title=\"docker tag\"></a>docker tag</h3><p><code>说明:</code>修改镜像标签</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@localhost ~]# docker tag --help</span><br><span class=\"line\"></span><br><span class=\"line\">Usage:\tdocker tag [OPTIONS] IMAGE[:TAG] [REGISTRYHOST/][USERNAME/]NAME[:TAG]</span><br><span class=\"line\"></span><br><span class=\"line\">Tag an image into a repository</span><br><span class=\"line\"></span><br><span class=\"line\">  --help             Print usage</span><br></pre></td></tr></table></figure>\n<p>示例：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker tag 5db5f8471261 ouruser/sinatra:devel #将5db5f8471261的镜像tag更改为devel</span><br></pre></td></tr></table></figure>\n<h3 id=\"docker-push\"><a href=\"#docker-push\" class=\"headerlink\" title=\"docker push\"></a>docker push</h3><p><code>说明:</code>自己创建的本地镜像上传到远程仓库中来共享。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@localhost ~]# docker push --help</span><br><span class=\"line\"></span><br><span class=\"line\">Usage:\tdocker push [OPTIONS] NAME[:TAG]</span><br><span class=\"line\"></span><br><span class=\"line\">Push an image or a repository to a registry</span><br><span class=\"line\"></span><br><span class=\"line\">  --disable-content-trust=true    Skip image signing</span><br><span class=\"line\">  --help                          Print usage</span><br></pre></td></tr></table></figure>\n<h3 id=\"docker-save\"><a href=\"#docker-save\" class=\"headerlink\" title=\"docker save\"></a>docker save</h3><p><code>说明:</code>将镜像导出成本地文件</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@localhost ~]# docker save --help</span><br><span class=\"line\"></span><br><span class=\"line\">Usage:\tdocker save [OPTIONS] IMAGE [IMAGE...]</span><br><span class=\"line\"></span><br><span class=\"line\">Save an image(s) to a tar archive (streamed to STDOUT by default)</span><br><span class=\"line\"></span><br><span class=\"line\">  --help             Print usage</span><br><span class=\"line\">  -o, --output       Write to a file, instead of STDOUT</span><br></pre></td></tr></table></figure>\n<p>示例：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@localhost ~]# docker save -o ubuntu_14.04.tar ubuntu:14.04</span><br></pre></td></tr></table></figure>\n<h3 id=\"docker-load\"><a href=\"#docker-load\" class=\"headerlink\" title=\"docker load\"></a>docker load</h3><p><code>说明:</code>将镜像本地文件加载成为本地镜像</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@localhost ~]# docker load --help</span><br><span class=\"line\"></span><br><span class=\"line\">Usage:\tdocker load [OPTIONS]</span><br><span class=\"line\"></span><br><span class=\"line\">Load an image from a tar archive or STDIN</span><br><span class=\"line\"></span><br><span class=\"line\">  --help             Print usage</span><br><span class=\"line\">  -i, --input        Read from a tar archive file, instead of STDIN</span><br></pre></td></tr></table></figure>\n<p>示例：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@localhost ~]# docker load --input ubuntu_14.04.tar</span><br></pre></td></tr></table></figure>\n<h3 id=\"docker-ps\"><a href=\"#docker-ps\" class=\"headerlink\" title=\"docker ps\"></a>docker ps</h3><p><code>说明：</code>列出对应的容器</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@localhost ~]# docker ps --help</span><br><span class=\"line\"></span><br><span class=\"line\">Usage:\tdocker ps [OPTIONS]</span><br><span class=\"line\"></span><br><span class=\"line\">List containers</span><br><span class=\"line\"></span><br><span class=\"line\">  -a, --all          Show all containers (default shows just running)</span><br><span class=\"line\">  -f, --filter=[]    Filter output based on conditions provided</span><br><span class=\"line\">  --format           Pretty-print containers using a Go template</span><br><span class=\"line\">  --help             Print usage</span><br><span class=\"line\">  -l, --latest       Show the latest created container (includes all states)</span><br><span class=\"line\">  -n=-1              Show n last created containers (includes all states)</span><br><span class=\"line\">  --no-trunc         Don&#x27;t truncate output</span><br><span class=\"line\">  -q, --quiet        Only display numeric IDs</span><br><span class=\"line\">  -s, --size         Display total file sizes</span><br></pre></td></tr></table></figure>\n<p>示例：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@localhost ~]# docker ps -a</span><br></pre></td></tr></table></figure>\n<h3 id=\"docker-export\"><a href=\"#docker-export\" class=\"headerlink\" title=\"docker export\"></a>docker export</h3><p><code>说明：</code>导出本地某个容器为快照文件</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@localhost ~]# docker export --help</span><br><span class=\"line\"></span><br><span class=\"line\">Usage:\tdocker export [OPTIONS] CONTAINER</span><br><span class=\"line\"></span><br><span class=\"line\">Export a container&#x27;s filesystem as a tar archive</span><br><span class=\"line\"></span><br><span class=\"line\">  --help             Print usage</span><br><span class=\"line\">  -o, --output       Write to a file, instead of STDOUT</span><br></pre></td></tr></table></figure>\n<h3 id=\"docker-import\"><a href=\"#docker-import\" class=\"headerlink\" title=\"docker import\"></a>docker import</h3><p><code>说明：</code>将容器快照文件导入为本地容器或者本地镜像。与<code>docker load</code>的区别在于容器快照文件将丢弃所有的历史记录和元数据信息,而镜像存储文件将保存完整记录，体积也要大。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@localhost ~]# docker import --help</span><br><span class=\"line\"></span><br><span class=\"line\">Usage:\tdocker import [OPTIONS] file|URL|- [REPOSITORY[:TAG]]</span><br><span class=\"line\"></span><br><span class=\"line\">Import the contents from a tarball to create a filesystem image</span><br><span class=\"line\"></span><br><span class=\"line\">  -c, --change=[]    Apply Dockerfile instruction to the created image</span><br><span class=\"line\">  --help             Print usage</span><br><span class=\"line\">  -m, --message      Set commit message for imported image</span><br></pre></td></tr></table></figure>\n<p>示例：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@localhost ~]# cat ubuntu.tar | sudo docker import - test/ubuntu:v1.0</span><br></pre></td></tr></table></figure>\n<h3 id=\"docker-rm\"><a href=\"#docker-rm\" class=\"headerlink\" title=\"docker rm\"></a>docker rm</h3><p><code>说明：</code>移除容器</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@localhost ~]# docker rm --help</span><br><span class=\"line\"></span><br><span class=\"line\">Usage:\tdocker rm [OPTIONS] CONTAINER [CONTAINER...]</span><br><span class=\"line\"></span><br><span class=\"line\">Remove one or more containers</span><br><span class=\"line\"></span><br><span class=\"line\">  -f, --force        Force the removal of a running container (uses SIGKILL)</span><br><span class=\"line\">  --help             Print usage</span><br><span class=\"line\">  -l, --link         Remove the specified link</span><br><span class=\"line\">  -v, --volumes      Remove the volumes associated with the container</span><br></pre></td></tr></table></figure>\n<p>示例：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@localhost ~]# docker rm $(docker ps -a -q) #清理所有处于终止状态的容器</span><br></pre></td></tr></table></figure>\n<h3 id=\"docker-rmi\"><a href=\"#docker-rmi\" class=\"headerlink\" title=\"docker rmi\"></a>docker rmi</h3><p><code>说明:</code>移除本地镜像，移出前需要先移除到镜像对应的容器。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@localhost ~]# docker rmi --help</span><br><span class=\"line\"></span><br><span class=\"line\">Usage:\tdocker rmi [OPTIONS] IMAGE [IMAGE...]</span><br><span class=\"line\"></span><br><span class=\"line\">Remove one or more images</span><br><span class=\"line\"></span><br><span class=\"line\">  -f, --force        Force removal of the image</span><br><span class=\"line\">  --help             Print usage</span><br><span class=\"line\">  --no-prune         Do not delete untagged parents</span><br></pre></td></tr></table></figure>\n\n<p>清理所有未打过标签的本地镜像：<code>docker rmi $(docker images -q -f &quot;dangling=true&quot;)</code></p>\n<h3 id=\"docker-inspect\"><a href=\"#docker-inspect\" class=\"headerlink\" title=\"docker inspect\"></a>docker inspect</h3><p><code>说明:</code>查看容器或者镜像的详情信息。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@localhost ~]# docker inspect --help</span><br><span class=\"line\"></span><br><span class=\"line\">Usage:\tdocker inspect [OPTIONS] CONTAINER|IMAGE [CONTAINER|IMAGE...]</span><br><span class=\"line\"></span><br><span class=\"line\">Return low-level information on a container or image</span><br><span class=\"line\"></span><br><span class=\"line\">  -f, --format       Format the output using the given go template</span><br><span class=\"line\">  --help             Print usage</span><br><span class=\"line\">  -s, --size         Display total file sizes if the type is container</span><br><span class=\"line\">  --type             Return JSON for specified type, (e.g image or container)</span><br></pre></td></tr></table></figure>\n<h3 id=\"docker-port\"><a href=\"#docker-port\" class=\"headerlink\" title=\"docker port\"></a>docker port</h3><p><code>说明：</code>来查看当前映射的端口配置，也可以查看到绑定的地址。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@localhost ~]# docker port --help</span><br><span class=\"line\"></span><br><span class=\"line\">Usage:  docker port [OPTIONS] CONTAINER [PRIVATE_PORT[/PROTO]]</span><br><span class=\"line\"></span><br><span class=\"line\">List port mappings or a specific mapping for the CONTAINER</span><br><span class=\"line\"></span><br><span class=\"line\">  --help             Print usage</span><br></pre></td></tr></table></figure>\n\n<hr>\n<p><em>观点仅代表自己，期待你的留言。</em></p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"docker-pull\"><a href=\"#docker-pull\" class=\"headerlink\" title=\"docker pull\"></a>docker pull</h3><p><code>说明：</code>获取网络镜像到本地<br> <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> [root@localhost ~]# docker pull --help</span><br><span class=\"line\"></span><br><span class=\"line\">Usage:\tdocker pull [OPTIONS] NAME[:TAG|@DIGEST]</span><br><span class=\"line\"></span><br><span class=\"line\">Pull an image or a repository from a registry</span><br><span class=\"line\"></span><br><span class=\"line\">  -a, --all-tags                  Download all tagged images in the repository</span><br><span class=\"line\">  --disable-content-trust=true    Skip image verification</span><br><span class=\"line\">  --help                          Print usage</span><br></pre></td></tr></table></figure><br>当不指定TAG时，默认为：latest<br>示例：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@localhost ~]# sudo docker pull ubuntu:12.04</span><br><span class=\"line\">[root@localhost ~]# docker pull registry.hub.docker.com/ubuntu:12.04</span><br></pre></td></tr></table></figure>\n<h3 id=\"docker-images\"><a href=\"#docker-images\" class=\"headerlink\" title=\"docker images\"></a>docker images</h3><p><code>说明：</code>显示本地已有的镜像</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@localhost ~]# docker images --help</span><br><span class=\"line\"></span><br><span class=\"line\">Usage:\tdocker images [OPTIONS] [REPOSITORY[:TAG]]</span><br><span class=\"line\"></span><br><span class=\"line\">List images</span><br><span class=\"line\"></span><br><span class=\"line\">  -a, --all          Show all images (default hides intermediate images)</span><br><span class=\"line\">  --digests          Show digests</span><br><span class=\"line\">  -f, --filter=[]    Filter output based on conditions provided</span><br><span class=\"line\">  --format           Pretty-print images using a Go template</span><br><span class=\"line\">  --help             Print usage</span><br><span class=\"line\">  --no-trunc         Don&#x27;t truncate output</span><br><span class=\"line\">  -q, --quiet        Only show numeric IDs</span><br></pre></td></tr></table></figure>\n<p>镜像的 <code>ID</code> 唯一标识了镜像。</p>\n<h3 id=\"docker-run\"><a href=\"#docker-run\" class=\"headerlink\" title=\"docker run\"></a>docker run</h3><p><code>说明：</code>使用已下载到本地的镜像启动一个新容器</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@localhost ~]# docker run --help</span><br><span class=\"line\"></span><br><span class=\"line\">Usage:\tdocker run [OPTIONS] IMAGE [COMMAND] [ARG...]</span><br><span class=\"line\"></span><br><span class=\"line\">Run a command in a new container</span><br><span class=\"line\"></span><br><span class=\"line\">  -a, --attach=[]                 Attach to STDIN, STDOUT or STDERR</span><br><span class=\"line\">  --add-host=[]                   Add a custom host-to-IP mapping (host:ip)</span><br><span class=\"line\">  --blkio-weight                  Block IO (relative weight), between 10 and 1000</span><br><span class=\"line\">  --blkio-weight-device=[]        Block IO weight (relative device weight)</span><br><span class=\"line\">  --cpu-shares                    CPU shares (relative weight)</span><br><span class=\"line\">  --cap-add=[]                    Add Linux capabilities</span><br><span class=\"line\">  --cap-drop=[]                   Drop Linux capabilities</span><br><span class=\"line\">  --cgroup-parent                 Optional parent cgroup for the container</span><br><span class=\"line\">  --cidfile                       Write the container ID to the file</span><br><span class=\"line\">  --cpu-period                    Limit CPU CFS (Completely Fair Scheduler) period</span><br><span class=\"line\">  --cpu-quota                     Limit CPU CFS (Completely Fair Scheduler) quota</span><br><span class=\"line\">  --cpuset-cpus                   CPUs in which to allow execution (0-3, 0,1)</span><br><span class=\"line\">  --cpuset-mems                   MEMs in which to allow execution (0-3, 0,1)</span><br><span class=\"line\">  -d, --detach                    Run container in background and print container ID</span><br><span class=\"line\">  --detach-keys                   Override the key sequence for detaching a container</span><br><span class=\"line\">  --device=[]                     Add a host device to the container</span><br><span class=\"line\">  --device-read-bps=[]            Limit read rate (bytes per second) from a device</span><br><span class=\"line\">  --device-read-iops=[]           Limit read rate (IO per second) from a device</span><br><span class=\"line\">  --device-write-bps=[]           Limit write rate (bytes per second) to a device</span><br><span class=\"line\">  --device-write-iops=[]          Limit write rate (IO per second) to a device</span><br><span class=\"line\">  --disable-content-trust=true    Skip image verification</span><br><span class=\"line\">  --dns=[]                        Set custom DNS servers</span><br><span class=\"line\">  --dns-opt=[]                    Set DNS options</span><br><span class=\"line\">  --dns-search=[]                 Set custom DNS search domains</span><br><span class=\"line\">  -e, --env=[]                    Set environment variables</span><br><span class=\"line\">  --entrypoint                    Overwrite the default ENTRYPOINT of the image</span><br><span class=\"line\">  --env-file=[]                   Read in a file of environment variables</span><br><span class=\"line\">  --expose=[]                     Expose a port or a range of ports</span><br><span class=\"line\">  --group-add=[]                  Add additional groups to join</span><br><span class=\"line\">  -h, --hostname                  Container host name</span><br><span class=\"line\">  --help                          Print usage</span><br><span class=\"line\">  -i, --interactive               Keep STDIN open even if not attached</span><br><span class=\"line\">  --ip                            Container IPv4 address (e.g. 172.30.100.104)</span><br><span class=\"line\">  --ip6                           Container IPv6 address (e.g. 2001:db8::33)</span><br><span class=\"line\">  --ipc                           IPC namespace to use</span><br><span class=\"line\">  --isolation                     Container isolation level</span><br><span class=\"line\">  --kernel-memory                 Kernel memory limit</span><br><span class=\"line\">  -l, --label=[]                  Set meta data on a container</span><br><span class=\"line\">  --label-file=[]                 Read in a line delimited file of labels</span><br><span class=\"line\">  --link=[]                       Add link to another container</span><br><span class=\"line\">  --log-driver                    Logging driver for container</span><br><span class=\"line\">  --log-opt=[]                    Log driver options</span><br><span class=\"line\">  -m, --memory                    Memory limit</span><br><span class=\"line\">  --mac-address                   Container MAC address (e.g. 92:d0:c6:0a:29:33)</span><br><span class=\"line\">  --memory-reservation            Memory soft limit</span><br><span class=\"line\">  --memory-swap                   Swap limit equal to memory plus swap: &#x27;-1&#x27; to enable unlimited swap</span><br><span class=\"line\">  --memory-swappiness=-1          Tune container memory swappiness (0 to 100)</span><br><span class=\"line\">  --name                          Assign a name to the container</span><br><span class=\"line\">  --net=default                   Connect a container to a network</span><br><span class=\"line\">  --net-alias=[]                  Add network-scoped alias for the container</span><br><span class=\"line\">  --oom-kill-disable              Disable OOM Killer</span><br><span class=\"line\">  --oom-score-adj                 Tune host&#x27;s OOM preferences (-1000 to 1000)</span><br><span class=\"line\">  -P, --publish-all               Publish all exposed ports to random ports</span><br><span class=\"line\">  -p, --publish=[]                Publish a container&#x27;s port(s) to the host</span><br><span class=\"line\">  --pid                           PID namespace to use</span><br><span class=\"line\">  --privileged                    Give extended privileges to this container</span><br><span class=\"line\">  --read-only                     Mount the container&#x27;s root filesystem as read only</span><br><span class=\"line\">  --restart=no                    Restart policy to apply when a container exits</span><br><span class=\"line\">  --rm                            Automatically remove the container when it exits</span><br><span class=\"line\">  --security-opt=[]               Security Options</span><br><span class=\"line\">  --shm-size                      Size of /dev/shm, default value is 64MB</span><br><span class=\"line\">  --sig-proxy=true                Proxy received signals to the process</span><br><span class=\"line\">  --stop-signal=SIGTERM           Signal to stop a container, SIGTERM by default</span><br><span class=\"line\">  -t, --tty                       Allocate a pseudo-TTY</span><br><span class=\"line\">  --tmpfs=[]                      Mount a tmpfs directory</span><br><span class=\"line\">  -u, --user                      Username or UID (format: &lt;name|uid&gt;[:&lt;group|gid&gt;])</span><br><span class=\"line\">  --ulimit=[]                     Ulimit options</span><br><span class=\"line\">  --uts                           UTS namespace to use</span><br><span class=\"line\">  -v, --volume=[]                 Bind mount a volume</span><br><span class=\"line\">  --volume-driver                 Optional volume driver for the container</span><br><span class=\"line\">  --volumes-from=[]               Mount volumes from the specified container(s)</span><br><span class=\"line\">  -w, --workdir                   Working directory inside the container</span><br></pre></td></tr></table></figure>\n<p><code>IMAGE</code>可以为镜像名或者镜像ID。<br>示例： </p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo docker run -t -i ouruser/sinatra:v2 /bin/bash</span><br><span class=\"line\">sudo docker run -d ubuntu:14.04 /bin/sh -c &quot;while true; do echo hello world; sleep 1; done&quot; #守护态运行</span><br></pre></td></tr></table></figure>\n\n<p>在执行 docker run 的时候如果添加 –rm 标记，则容器在终止后会立刻删除。注意，–rm 和 -d 参数不能同时使用。</p>\n<h3 id=\"docker-logs\"><a href=\"#docker-logs\" class=\"headerlink\" title=\"docker logs\"></a>docker logs</h3><p><code>说明：</code>获取容器输出的信息，适用于守护态运行docker容器。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@localhost ~]# docker logs --help</span><br><span class=\"line\"></span><br><span class=\"line\">Usage:\tdocker logs [OPTIONS] CONTAINER</span><br><span class=\"line\"></span><br><span class=\"line\">Fetch the logs of a container</span><br><span class=\"line\"></span><br><span class=\"line\">  -f, --follow        Follow log output</span><br><span class=\"line\">  --help              Print usage</span><br><span class=\"line\">  --since             Show logs since timestamp</span><br><span class=\"line\">  -t, --timestamps    Show timestamps</span><br><span class=\"line\">  --tail=all          Number of lines to show from the end of the logs</span><br></pre></td></tr></table></figure>\n<h3 id=\"docker-stop\"><a href=\"#docker-stop\" class=\"headerlink\" title=\"docker stop\"></a>docker stop</h3><p><code>说明：</code>停止一个正在启动的容器。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@localhost ~]# docker stop --help</span><br><span class=\"line\"></span><br><span class=\"line\">Usage:\tdocker stop [OPTIONS] CONTAINER [CONTAINER...]</span><br><span class=\"line\"></span><br><span class=\"line\">Stop a running container.</span><br><span class=\"line\">Sending SIGTERM and then SIGKILL after a grace period</span><br><span class=\"line\"></span><br><span class=\"line\">  --help             Print usage</span><br><span class=\"line\">  -t, --time=10      Seconds to wait for stop before killing it</span><br></pre></td></tr></table></figure>\n<h3 id=\"docker-start\"><a href=\"#docker-start\" class=\"headerlink\" title=\"docker start\"></a>docker start</h3><p><code>说明：</code>启动一个已经停止的容器。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@localhost ~]# docker start --help</span><br><span class=\"line\"></span><br><span class=\"line\">Usage:\tdocker start [OPTIONS] CONTAINER [CONTAINER...]</span><br><span class=\"line\"></span><br><span class=\"line\">Start one or more stopped containers</span><br><span class=\"line\"></span><br><span class=\"line\">  -a, --attach         Attach STDOUT/STDERR and forward signals</span><br><span class=\"line\">  --detach-keys        Override the key sequence for detaching a container</span><br><span class=\"line\">  --help               Print usage</span><br><span class=\"line\">  -i, --interactive    Attach container&#x27;s STDIN</span><br></pre></td></tr></table></figure>\n<h3 id=\"docker-restart\"><a href=\"#docker-restart\" class=\"headerlink\" title=\"docker restart\"></a>docker restart</h3><p><code>说明：</code>将一个运行态的容器终止，然后再重新启动它。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@localhost ~]# docker restart --help</span><br><span class=\"line\"></span><br><span class=\"line\">Usage:\tdocker restart [OPTIONS] CONTAINER [CONTAINER...]</span><br><span class=\"line\"></span><br><span class=\"line\">Restart a container</span><br><span class=\"line\"></span><br><span class=\"line\">  --help             Print usage</span><br><span class=\"line\">  -t, --time=10      Seconds to wait for stop before killing the container</span><br></pre></td></tr></table></figure>\n<h3 id=\"docker-attach\"><a href=\"#docker-attach\" class=\"headerlink\" title=\"docker attach\"></a>docker attach</h3><p><code>说明：</code>在使用 -d 参数时，容器启动后会进入后台。 某些时候需要进入容器进行操作就可以用它。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@localhost ~]# docker attach --help</span><br><span class=\"line\"></span><br><span class=\"line\">Usage:\tdocker attach [OPTIONS] CONTAINER</span><br><span class=\"line\"></span><br><span class=\"line\">Attach to a running container</span><br><span class=\"line\"></span><br><span class=\"line\">  --detach-keys       Override the key sequence for detaching a container</span><br><span class=\"line\">  --help              Print usage</span><br><span class=\"line\">  --no-stdin          Do not attach STDIN</span><br><span class=\"line\">  --sig-proxy=true    Proxy all received signals to the process</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"docker-commit\"><a href=\"#docker-commit\" class=\"headerlink\" title=\"docker commit\"></a>docker commit</h3><p><code>说明：</code>将修改后的容器提交保存为一个新的镜像。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@localhost ~]# docker commit --help</span><br><span class=\"line\"></span><br><span class=\"line\">Usage:\tdocker commit [OPTIONS] CONTAINER [REPOSITORY[:TAG]]</span><br><span class=\"line\"></span><br><span class=\"line\">Create a new image from a container&#x27;s changes</span><br><span class=\"line\"></span><br><span class=\"line\">  -a, --author        Author (e.g., &quot;John Hannibal Smith &lt;hannibal@a-team.com&gt;&quot;)</span><br><span class=\"line\">  -c, --change=[]     Apply Dockerfile instruction to the created image</span><br><span class=\"line\">  --help              Print usage</span><br><span class=\"line\">  -m, --message       Commit message</span><br><span class=\"line\">  -p, --pause=true    Pause container during commit</span><br></pre></td></tr></table></figure>\n<p>示例：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo docker commit -m &quot;Added json gem&quot; -a &quot;Docker Newbee&quot; 0b2616b0e5a8 ouruser/sinatra:v2</span><br><span class=\"line\">4f177bd27a9ff0f6dc2a830403925b5360bfe0b93d476f7fc3231110e7f71b1c</span><br></pre></td></tr></table></figure>\n<h3 id=\"docker-tag\"><a href=\"#docker-tag\" class=\"headerlink\" title=\"docker tag\"></a>docker tag</h3><p><code>说明:</code>修改镜像标签</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@localhost ~]# docker tag --help</span><br><span class=\"line\"></span><br><span class=\"line\">Usage:\tdocker tag [OPTIONS] IMAGE[:TAG] [REGISTRYHOST/][USERNAME/]NAME[:TAG]</span><br><span class=\"line\"></span><br><span class=\"line\">Tag an image into a repository</span><br><span class=\"line\"></span><br><span class=\"line\">  --help             Print usage</span><br></pre></td></tr></table></figure>\n<p>示例：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker tag 5db5f8471261 ouruser/sinatra:devel #将5db5f8471261的镜像tag更改为devel</span><br></pre></td></tr></table></figure>\n<h3 id=\"docker-push\"><a href=\"#docker-push\" class=\"headerlink\" title=\"docker push\"></a>docker push</h3><p><code>说明:</code>自己创建的本地镜像上传到远程仓库中来共享。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@localhost ~]# docker push --help</span><br><span class=\"line\"></span><br><span class=\"line\">Usage:\tdocker push [OPTIONS] NAME[:TAG]</span><br><span class=\"line\"></span><br><span class=\"line\">Push an image or a repository to a registry</span><br><span class=\"line\"></span><br><span class=\"line\">  --disable-content-trust=true    Skip image signing</span><br><span class=\"line\">  --help                          Print usage</span><br></pre></td></tr></table></figure>\n<h3 id=\"docker-save\"><a href=\"#docker-save\" class=\"headerlink\" title=\"docker save\"></a>docker save</h3><p><code>说明:</code>将镜像导出成本地文件</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@localhost ~]# docker save --help</span><br><span class=\"line\"></span><br><span class=\"line\">Usage:\tdocker save [OPTIONS] IMAGE [IMAGE...]</span><br><span class=\"line\"></span><br><span class=\"line\">Save an image(s) to a tar archive (streamed to STDOUT by default)</span><br><span class=\"line\"></span><br><span class=\"line\">  --help             Print usage</span><br><span class=\"line\">  -o, --output       Write to a file, instead of STDOUT</span><br></pre></td></tr></table></figure>\n<p>示例：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@localhost ~]# docker save -o ubuntu_14.04.tar ubuntu:14.04</span><br></pre></td></tr></table></figure>\n<h3 id=\"docker-load\"><a href=\"#docker-load\" class=\"headerlink\" title=\"docker load\"></a>docker load</h3><p><code>说明:</code>将镜像本地文件加载成为本地镜像</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@localhost ~]# docker load --help</span><br><span class=\"line\"></span><br><span class=\"line\">Usage:\tdocker load [OPTIONS]</span><br><span class=\"line\"></span><br><span class=\"line\">Load an image from a tar archive or STDIN</span><br><span class=\"line\"></span><br><span class=\"line\">  --help             Print usage</span><br><span class=\"line\">  -i, --input        Read from a tar archive file, instead of STDIN</span><br></pre></td></tr></table></figure>\n<p>示例：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@localhost ~]# docker load --input ubuntu_14.04.tar</span><br></pre></td></tr></table></figure>\n<h3 id=\"docker-ps\"><a href=\"#docker-ps\" class=\"headerlink\" title=\"docker ps\"></a>docker ps</h3><p><code>说明：</code>列出对应的容器</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@localhost ~]# docker ps --help</span><br><span class=\"line\"></span><br><span class=\"line\">Usage:\tdocker ps [OPTIONS]</span><br><span class=\"line\"></span><br><span class=\"line\">List containers</span><br><span class=\"line\"></span><br><span class=\"line\">  -a, --all          Show all containers (default shows just running)</span><br><span class=\"line\">  -f, --filter=[]    Filter output based on conditions provided</span><br><span class=\"line\">  --format           Pretty-print containers using a Go template</span><br><span class=\"line\">  --help             Print usage</span><br><span class=\"line\">  -l, --latest       Show the latest created container (includes all states)</span><br><span class=\"line\">  -n=-1              Show n last created containers (includes all states)</span><br><span class=\"line\">  --no-trunc         Don&#x27;t truncate output</span><br><span class=\"line\">  -q, --quiet        Only display numeric IDs</span><br><span class=\"line\">  -s, --size         Display total file sizes</span><br></pre></td></tr></table></figure>\n<p>示例：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@localhost ~]# docker ps -a</span><br></pre></td></tr></table></figure>\n<h3 id=\"docker-export\"><a href=\"#docker-export\" class=\"headerlink\" title=\"docker export\"></a>docker export</h3><p><code>说明：</code>导出本地某个容器为快照文件</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@localhost ~]# docker export --help</span><br><span class=\"line\"></span><br><span class=\"line\">Usage:\tdocker export [OPTIONS] CONTAINER</span><br><span class=\"line\"></span><br><span class=\"line\">Export a container&#x27;s filesystem as a tar archive</span><br><span class=\"line\"></span><br><span class=\"line\">  --help             Print usage</span><br><span class=\"line\">  -o, --output       Write to a file, instead of STDOUT</span><br></pre></td></tr></table></figure>\n<h3 id=\"docker-import\"><a href=\"#docker-import\" class=\"headerlink\" title=\"docker import\"></a>docker import</h3><p><code>说明：</code>将容器快照文件导入为本地容器或者本地镜像。与<code>docker load</code>的区别在于容器快照文件将丢弃所有的历史记录和元数据信息,而镜像存储文件将保存完整记录，体积也要大。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@localhost ~]# docker import --help</span><br><span class=\"line\"></span><br><span class=\"line\">Usage:\tdocker import [OPTIONS] file|URL|- [REPOSITORY[:TAG]]</span><br><span class=\"line\"></span><br><span class=\"line\">Import the contents from a tarball to create a filesystem image</span><br><span class=\"line\"></span><br><span class=\"line\">  -c, --change=[]    Apply Dockerfile instruction to the created image</span><br><span class=\"line\">  --help             Print usage</span><br><span class=\"line\">  -m, --message      Set commit message for imported image</span><br></pre></td></tr></table></figure>\n<p>示例：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@localhost ~]# cat ubuntu.tar | sudo docker import - test/ubuntu:v1.0</span><br></pre></td></tr></table></figure>\n<h3 id=\"docker-rm\"><a href=\"#docker-rm\" class=\"headerlink\" title=\"docker rm\"></a>docker rm</h3><p><code>说明：</code>移除容器</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@localhost ~]# docker rm --help</span><br><span class=\"line\"></span><br><span class=\"line\">Usage:\tdocker rm [OPTIONS] CONTAINER [CONTAINER...]</span><br><span class=\"line\"></span><br><span class=\"line\">Remove one or more containers</span><br><span class=\"line\"></span><br><span class=\"line\">  -f, --force        Force the removal of a running container (uses SIGKILL)</span><br><span class=\"line\">  --help             Print usage</span><br><span class=\"line\">  -l, --link         Remove the specified link</span><br><span class=\"line\">  -v, --volumes      Remove the volumes associated with the container</span><br></pre></td></tr></table></figure>\n<p>示例：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@localhost ~]# docker rm $(docker ps -a -q) #清理所有处于终止状态的容器</span><br></pre></td></tr></table></figure>\n<h3 id=\"docker-rmi\"><a href=\"#docker-rmi\" class=\"headerlink\" title=\"docker rmi\"></a>docker rmi</h3><p><code>说明:</code>移除本地镜像，移出前需要先移除到镜像对应的容器。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@localhost ~]# docker rmi --help</span><br><span class=\"line\"></span><br><span class=\"line\">Usage:\tdocker rmi [OPTIONS] IMAGE [IMAGE...]</span><br><span class=\"line\"></span><br><span class=\"line\">Remove one or more images</span><br><span class=\"line\"></span><br><span class=\"line\">  -f, --force        Force removal of the image</span><br><span class=\"line\">  --help             Print usage</span><br><span class=\"line\">  --no-prune         Do not delete untagged parents</span><br></pre></td></tr></table></figure>\n\n<p>清理所有未打过标签的本地镜像：<code>docker rmi $(docker images -q -f &quot;dangling=true&quot;)</code></p>\n<h3 id=\"docker-inspect\"><a href=\"#docker-inspect\" class=\"headerlink\" title=\"docker inspect\"></a>docker inspect</h3><p><code>说明:</code>查看容器或者镜像的详情信息。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@localhost ~]# docker inspect --help</span><br><span class=\"line\"></span><br><span class=\"line\">Usage:\tdocker inspect [OPTIONS] CONTAINER|IMAGE [CONTAINER|IMAGE...]</span><br><span class=\"line\"></span><br><span class=\"line\">Return low-level information on a container or image</span><br><span class=\"line\"></span><br><span class=\"line\">  -f, --format       Format the output using the given go template</span><br><span class=\"line\">  --help             Print usage</span><br><span class=\"line\">  -s, --size         Display total file sizes if the type is container</span><br><span class=\"line\">  --type             Return JSON for specified type, (e.g image or container)</span><br></pre></td></tr></table></figure>\n<h3 id=\"docker-port\"><a href=\"#docker-port\" class=\"headerlink\" title=\"docker port\"></a>docker port</h3><p><code>说明：</code>来查看当前映射的端口配置，也可以查看到绑定的地址。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@localhost ~]# docker port --help</span><br><span class=\"line\"></span><br><span class=\"line\">Usage:  docker port [OPTIONS] CONTAINER [PRIVATE_PORT[/PROTO]]</span><br><span class=\"line\"></span><br><span class=\"line\">List port mappings or a specific mapping for the CONTAINER</span><br><span class=\"line\"></span><br><span class=\"line\">  --help             Print usage</span><br></pre></td></tr></table></figure>\n\n<hr>\n<p><em>观点仅代表自己，期待你的留言。</em></p>\n"},{"title":"docker数据卷与网络配置","date":"2016-04-18T03:33:08.000Z","_content":"\n# 数据卷\nDocker 挂载数据卷的默认权限是读写，用户也可以通过 :ro 指定为只读。\n示例：\n```\n$ sudo docker run -d -P --name web -v /src/webapp:/opt/webapp:ro training/webapp python app.py\n```\n## 创建数据卷\n在用 `docker run` 命令的时候，使用 `-v` 标记来创建一个数据卷并挂载到容器里。在一次 run 中多次使用可以挂载多个数据卷。\n示例： \n```\n$ sudo docker run -d -P --name web -v /webapp training/webapp python app.py\n```\n## 挂载一个主机目录作为数据卷\n加载主机的 /src/webapp 目录到容器的 /opt/webapp 目录.\n示例：\n```\n$ sudo docker run -d -P --name web -v /src/webapp:/opt/webapp training/webapp python app.py\n```\n`注意：`本地目录的路径必须是绝对路径，如果目录不存在 Docker 会自动为你创建它。\n## 挂载一个本地主机文件作为数据卷\n-v 标记也可以从主机挂载单个文件到容器中\n示例：\n```\n$ sudo docker run --rm -it -v ~/.bash_history:/.bash_history ubuntu /bin/bash\n```\n## 删除数据卷\n数据卷是被设计用来持久化数据的，它的生命周期独立于容器，Docker不会在容器被删除后自动删除数据卷，并且也不存在垃圾回收这样的机制来处理没有任何容器引用的数据卷。如果需要在删除容器的同时移除数据卷。可以在删除容器的时候使用 `docker rm -v`这个命令。无主的数据卷可能会占据很多空间，要清理会很麻烦。\n## 数据卷容器\n如果你有一些持续更新的数据需要在容器之间共享，最好创建数据卷容器。\n数据卷容器，其实就是一个正常的容器，专门用来提供数据卷供其它容器挂载的。\n首先，创建一个名为 dbdata 的数据卷容器：\n```\n$ sudo docker run -d -v /dbdatas --name dbdata training/postgres echo Data-only container for postgres\n```\n然后，在其他容器中使用 `--volumes-from` 来挂载 dbdata 容器中的数据卷。\n```\n$ sudo docker run -d --volumes-from dbdata --name db1 training/postgres\n$ sudo docker run -d --volumes-from dbdata --name db2 training/postgres\n```\n可以使用超过一个的 --volumes-from 参数来指定从多个容器挂载不同的数据卷。 也可以从其他已经挂载了数据卷的容器来级联挂载数据卷。\n```\n$ sudo docker run -d --name db3 --volumes-from db1 training/postgres\n```\n*注意：使用 `--volumes-from` 参数所挂载数据卷的容器自己并不需要保持在运行状态。\n如果删除了挂载的容器（包括 dbdata、db1 和 db2），数据卷并不会被自动删除。如果要删除一个数据卷，必须在删除最后一个还挂载着它的容器时使用 `docker rm -v` 命令来指定同时删除关联的容器。\n## 利用数据卷容器来备份、恢复、迁移数据卷\n### 备份\n首先使用 --volumes-from 标记来创建一个加载 dbdata 容器卷的容器，并从主机挂载当前目录到容器的 /backup 目录。\n命令如下：\n```\n$ sudo docker run --volumes-from dbdata -v $(pwd):/backup ubuntu tar cvf /backup/backup.tar /dbdata\n```\n容器启动后，使用了 tar 命令来将 dbdata 卷备份为容器中 /backup/backup.tar 文件，也就是主机当前目录下的名为 backup.tar 的文件。\n### 恢复\n如果要恢复数据到一个容器，首先创建一个带有空数据卷的容器 dbdata2。\n```\n$ sudo docker run -v /dbdata --name dbdata2 ubuntu /bin/bash\n```\n然后创建另一个容器，挂载 dbdata2 容器卷中的数据卷，并使用 untar 解压备份文件到挂载的容器卷中。\n```\n$ sudo docker run --volumes-from dbdata2 -v $(pwd):/backup busybox tar xvf /backup/backup.tar\n```\n为了查看/验证恢复的数据，可以再启动一个容器挂载同样的容器卷来查看\n```\n$ sudo docker run --volumes-from dbdata2 busybox /bin/ls /dbdata\n```\n# 网络配置\n## 外部访问容器\ndocker容器一般使用5000做为服务端口（类似于80端口的概念）。\n - docker支持在`docker run`时增加`-P`来将主机随机端口(49000~49900)映射到容器内的5000。可通过`docker ps`查看到对应的占用端口。\n - docker支持在`docker run`时增加`-p`来将指定的主机端口映射到容器内的指定端口。\n \t支持以下格式：\n \t* `ip:hostPort:containerPort`： 将主机指定IP下的指定端口绑定到容器内的指定端口。\n \t* `ip::containerPort`：绑定主机指定IP下的任意端口到容器的指定端口，本地主机会自动分配一个端口。还可以使用 udp 标记来指定 udp 端口。如`$ sudo docker run -d -p 127.0.0.1:5000:5000/udp training/webapp python app.py`\n \t* `hostPort:containerPort`：指定主机所有IP下的指定端口到容器内的指定端口。\n\n使用 `docker port` 来查看当前映射的端口配置，\n__注意：__\n - 容器有自己的内部网络和 ip 地址（使用 docker inspect 可以获取所有的变量，Docker 还可以有一个可变的网络配置。）\n - -p 参数可以多次使用。如：`$ sudo docker run -d -p 5000:5000  -p 3000:80 training/webapp python app.py`\n## 容器互联\n连接系统依据容器的名称来执行。因此，首先需要通过`--name`自定义一个好记的容器命名。使用 `docker ps` 来验证设定的命名。\n\n使用 `--link` 参数可以让容器之间安全的进行交互。参数的格式为 `--link name:alias`，其中 name 是要链接的容器的名称，alias 是这个连接的别名。\n将web容器与db容器连接，且连接被命名为db, 启动命令如下：\n```\n$ sudo docker run -d -P --name web --link db:db training/webapp python app.py\n```\n\n__实现原理：__\nDocker 通过 2 种方式为容器公开连接信息：\n - 环境变量。 通过linux命令`env`可以看到，环境变量通过增加alias做为前缀标识来区别容器的环境变量与连接。\n - 更新 /etc/hosts 文件。在hosts文件中增加alias条目的映射ip。\n\n\n-----\n\n\n*观点仅代表自己，期待你的留言。*\n","source":"_posts/docker-data-network.md","raw":"---\ntitle: docker数据卷与网络配置\ntags:\n  - Docker\n  - 原创\ndate: 2016-04-18 11:33:08\n---\n\n# 数据卷\nDocker 挂载数据卷的默认权限是读写，用户也可以通过 :ro 指定为只读。\n示例：\n```\n$ sudo docker run -d -P --name web -v /src/webapp:/opt/webapp:ro training/webapp python app.py\n```\n## 创建数据卷\n在用 `docker run` 命令的时候，使用 `-v` 标记来创建一个数据卷并挂载到容器里。在一次 run 中多次使用可以挂载多个数据卷。\n示例： \n```\n$ sudo docker run -d -P --name web -v /webapp training/webapp python app.py\n```\n## 挂载一个主机目录作为数据卷\n加载主机的 /src/webapp 目录到容器的 /opt/webapp 目录.\n示例：\n```\n$ sudo docker run -d -P --name web -v /src/webapp:/opt/webapp training/webapp python app.py\n```\n`注意：`本地目录的路径必须是绝对路径，如果目录不存在 Docker 会自动为你创建它。\n## 挂载一个本地主机文件作为数据卷\n-v 标记也可以从主机挂载单个文件到容器中\n示例：\n```\n$ sudo docker run --rm -it -v ~/.bash_history:/.bash_history ubuntu /bin/bash\n```\n## 删除数据卷\n数据卷是被设计用来持久化数据的，它的生命周期独立于容器，Docker不会在容器被删除后自动删除数据卷，并且也不存在垃圾回收这样的机制来处理没有任何容器引用的数据卷。如果需要在删除容器的同时移除数据卷。可以在删除容器的时候使用 `docker rm -v`这个命令。无主的数据卷可能会占据很多空间，要清理会很麻烦。\n## 数据卷容器\n如果你有一些持续更新的数据需要在容器之间共享，最好创建数据卷容器。\n数据卷容器，其实就是一个正常的容器，专门用来提供数据卷供其它容器挂载的。\n首先，创建一个名为 dbdata 的数据卷容器：\n```\n$ sudo docker run -d -v /dbdatas --name dbdata training/postgres echo Data-only container for postgres\n```\n然后，在其他容器中使用 `--volumes-from` 来挂载 dbdata 容器中的数据卷。\n```\n$ sudo docker run -d --volumes-from dbdata --name db1 training/postgres\n$ sudo docker run -d --volumes-from dbdata --name db2 training/postgres\n```\n可以使用超过一个的 --volumes-from 参数来指定从多个容器挂载不同的数据卷。 也可以从其他已经挂载了数据卷的容器来级联挂载数据卷。\n```\n$ sudo docker run -d --name db3 --volumes-from db1 training/postgres\n```\n*注意：使用 `--volumes-from` 参数所挂载数据卷的容器自己并不需要保持在运行状态。\n如果删除了挂载的容器（包括 dbdata、db1 和 db2），数据卷并不会被自动删除。如果要删除一个数据卷，必须在删除最后一个还挂载着它的容器时使用 `docker rm -v` 命令来指定同时删除关联的容器。\n## 利用数据卷容器来备份、恢复、迁移数据卷\n### 备份\n首先使用 --volumes-from 标记来创建一个加载 dbdata 容器卷的容器，并从主机挂载当前目录到容器的 /backup 目录。\n命令如下：\n```\n$ sudo docker run --volumes-from dbdata -v $(pwd):/backup ubuntu tar cvf /backup/backup.tar /dbdata\n```\n容器启动后，使用了 tar 命令来将 dbdata 卷备份为容器中 /backup/backup.tar 文件，也就是主机当前目录下的名为 backup.tar 的文件。\n### 恢复\n如果要恢复数据到一个容器，首先创建一个带有空数据卷的容器 dbdata2。\n```\n$ sudo docker run -v /dbdata --name dbdata2 ubuntu /bin/bash\n```\n然后创建另一个容器，挂载 dbdata2 容器卷中的数据卷，并使用 untar 解压备份文件到挂载的容器卷中。\n```\n$ sudo docker run --volumes-from dbdata2 -v $(pwd):/backup busybox tar xvf /backup/backup.tar\n```\n为了查看/验证恢复的数据，可以再启动一个容器挂载同样的容器卷来查看\n```\n$ sudo docker run --volumes-from dbdata2 busybox /bin/ls /dbdata\n```\n# 网络配置\n## 外部访问容器\ndocker容器一般使用5000做为服务端口（类似于80端口的概念）。\n - docker支持在`docker run`时增加`-P`来将主机随机端口(49000~49900)映射到容器内的5000。可通过`docker ps`查看到对应的占用端口。\n - docker支持在`docker run`时增加`-p`来将指定的主机端口映射到容器内的指定端口。\n \t支持以下格式：\n \t* `ip:hostPort:containerPort`： 将主机指定IP下的指定端口绑定到容器内的指定端口。\n \t* `ip::containerPort`：绑定主机指定IP下的任意端口到容器的指定端口，本地主机会自动分配一个端口。还可以使用 udp 标记来指定 udp 端口。如`$ sudo docker run -d -p 127.0.0.1:5000:5000/udp training/webapp python app.py`\n \t* `hostPort:containerPort`：指定主机所有IP下的指定端口到容器内的指定端口。\n\n使用 `docker port` 来查看当前映射的端口配置，\n__注意：__\n - 容器有自己的内部网络和 ip 地址（使用 docker inspect 可以获取所有的变量，Docker 还可以有一个可变的网络配置。）\n - -p 参数可以多次使用。如：`$ sudo docker run -d -p 5000:5000  -p 3000:80 training/webapp python app.py`\n## 容器互联\n连接系统依据容器的名称来执行。因此，首先需要通过`--name`自定义一个好记的容器命名。使用 `docker ps` 来验证设定的命名。\n\n使用 `--link` 参数可以让容器之间安全的进行交互。参数的格式为 `--link name:alias`，其中 name 是要链接的容器的名称，alias 是这个连接的别名。\n将web容器与db容器连接，且连接被命名为db, 启动命令如下：\n```\n$ sudo docker run -d -P --name web --link db:db training/webapp python app.py\n```\n\n__实现原理：__\nDocker 通过 2 种方式为容器公开连接信息：\n - 环境变量。 通过linux命令`env`可以看到，环境变量通过增加alias做为前缀标识来区别容器的环境变量与连接。\n - 更新 /etc/hosts 文件。在hosts文件中增加alias条目的映射ip。\n\n\n-----\n\n\n*观点仅代表自己，期待你的留言。*\n","slug":"docker-data-network","published":1,"updated":"2021-08-31T14:23:11.539Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cku52dymf0010bbin7egu9vff","content":"<h1 id=\"数据卷\"><a href=\"#数据卷\" class=\"headerlink\" title=\"数据卷\"></a>数据卷</h1><p>Docker 挂载数据卷的默认权限是读写，用户也可以通过 :ro 指定为只读。<br>示例：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo docker run -d -P --name web -v /src/webapp:/opt/webapp:ro training/webapp python app.py</span><br></pre></td></tr></table></figure>\n<h2 id=\"创建数据卷\"><a href=\"#创建数据卷\" class=\"headerlink\" title=\"创建数据卷\"></a>创建数据卷</h2><p>在用 <code>docker run</code> 命令的时候，使用 <code>-v</code> 标记来创建一个数据卷并挂载到容器里。在一次 run 中多次使用可以挂载多个数据卷。<br>示例： </p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo docker run -d -P --name web -v /webapp training/webapp python app.py</span><br></pre></td></tr></table></figure>\n<h2 id=\"挂载一个主机目录作为数据卷\"><a href=\"#挂载一个主机目录作为数据卷\" class=\"headerlink\" title=\"挂载一个主机目录作为数据卷\"></a>挂载一个主机目录作为数据卷</h2><p>加载主机的 /src/webapp 目录到容器的 /opt/webapp 目录.<br>示例：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo docker run -d -P --name web -v /src/webapp:/opt/webapp training/webapp python app.py</span><br></pre></td></tr></table></figure>\n<p><code>注意：</code>本地目录的路径必须是绝对路径，如果目录不存在 Docker 会自动为你创建它。</p>\n<h2 id=\"挂载一个本地主机文件作为数据卷\"><a href=\"#挂载一个本地主机文件作为数据卷\" class=\"headerlink\" title=\"挂载一个本地主机文件作为数据卷\"></a>挂载一个本地主机文件作为数据卷</h2><p>-v 标记也可以从主机挂载单个文件到容器中<br>示例：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo docker run --rm -it -v ~/.bash_history:/.bash_history ubuntu /bin/bash</span><br></pre></td></tr></table></figure>\n<h2 id=\"删除数据卷\"><a href=\"#删除数据卷\" class=\"headerlink\" title=\"删除数据卷\"></a>删除数据卷</h2><p>数据卷是被设计用来持久化数据的，它的生命周期独立于容器，Docker不会在容器被删除后自动删除数据卷，并且也不存在垃圾回收这样的机制来处理没有任何容器引用的数据卷。如果需要在删除容器的同时移除数据卷。可以在删除容器的时候使用 <code>docker rm -v</code>这个命令。无主的数据卷可能会占据很多空间，要清理会很麻烦。</p>\n<h2 id=\"数据卷容器\"><a href=\"#数据卷容器\" class=\"headerlink\" title=\"数据卷容器\"></a>数据卷容器</h2><p>如果你有一些持续更新的数据需要在容器之间共享，最好创建数据卷容器。<br>数据卷容器，其实就是一个正常的容器，专门用来提供数据卷供其它容器挂载的。<br>首先，创建一个名为 dbdata 的数据卷容器：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo docker run -d -v /dbdatas --name dbdata training/postgres echo Data-only container for postgres</span><br></pre></td></tr></table></figure>\n<p>然后，在其他容器中使用 <code>--volumes-from</code> 来挂载 dbdata 容器中的数据卷。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo docker run -d --volumes-from dbdata --name db1 training/postgres</span><br><span class=\"line\">$ sudo docker run -d --volumes-from dbdata --name db2 training/postgres</span><br></pre></td></tr></table></figure>\n<p>可以使用超过一个的 –volumes-from 参数来指定从多个容器挂载不同的数据卷。 也可以从其他已经挂载了数据卷的容器来级联挂载数据卷。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo docker run -d --name db3 --volumes-from db1 training/postgres</span><br></pre></td></tr></table></figure>\n<p>*注意：使用 <code>--volumes-from</code> 参数所挂载数据卷的容器自己并不需要保持在运行状态。<br>如果删除了挂载的容器（包括 dbdata、db1 和 db2），数据卷并不会被自动删除。如果要删除一个数据卷，必须在删除最后一个还挂载着它的容器时使用 <code>docker rm -v</code> 命令来指定同时删除关联的容器。</p>\n<h2 id=\"利用数据卷容器来备份、恢复、迁移数据卷\"><a href=\"#利用数据卷容器来备份、恢复、迁移数据卷\" class=\"headerlink\" title=\"利用数据卷容器来备份、恢复、迁移数据卷\"></a>利用数据卷容器来备份、恢复、迁移数据卷</h2><h3 id=\"备份\"><a href=\"#备份\" class=\"headerlink\" title=\"备份\"></a>备份</h3><p>首先使用 –volumes-from 标记来创建一个加载 dbdata 容器卷的容器，并从主机挂载当前目录到容器的 /backup 目录。<br>命令如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo docker run --volumes-from dbdata -v $(pwd):/backup ubuntu tar cvf /backup/backup.tar /dbdata</span><br></pre></td></tr></table></figure>\n<p>容器启动后，使用了 tar 命令来将 dbdata 卷备份为容器中 /backup/backup.tar 文件，也就是主机当前目录下的名为 backup.tar 的文件。</p>\n<h3 id=\"恢复\"><a href=\"#恢复\" class=\"headerlink\" title=\"恢复\"></a>恢复</h3><p>如果要恢复数据到一个容器，首先创建一个带有空数据卷的容器 dbdata2。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo docker run -v /dbdata --name dbdata2 ubuntu /bin/bash</span><br></pre></td></tr></table></figure>\n<p>然后创建另一个容器，挂载 dbdata2 容器卷中的数据卷，并使用 untar 解压备份文件到挂载的容器卷中。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo docker run --volumes-from dbdata2 -v $(pwd):/backup busybox tar xvf /backup/backup.tar</span><br></pre></td></tr></table></figure>\n<p>为了查看/验证恢复的数据，可以再启动一个容器挂载同样的容器卷来查看</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo docker run --volumes-from dbdata2 busybox /bin/ls /dbdata</span><br></pre></td></tr></table></figure>\n<h1 id=\"网络配置\"><a href=\"#网络配置\" class=\"headerlink\" title=\"网络配置\"></a>网络配置</h1><h2 id=\"外部访问容器\"><a href=\"#外部访问容器\" class=\"headerlink\" title=\"外部访问容器\"></a>外部访问容器</h2><p>docker容器一般使用5000做为服务端口（类似于80端口的概念）。</p>\n<ul>\n<li>docker支持在<code>docker run</code>时增加<code>-P</code>来将主机随机端口(49000~49900)映射到容器内的5000。可通过<code>docker ps</code>查看到对应的占用端口。</li>\n<li>docker支持在<code>docker run</code>时增加<code>-p</code>来将指定的主机端口映射到容器内的指定端口。<br>  支持以下格式：<ul>\n<li><code>ip:hostPort:containerPort</code>： 将主机指定IP下的指定端口绑定到容器内的指定端口。</li>\n<li><code>ip::containerPort</code>：绑定主机指定IP下的任意端口到容器的指定端口，本地主机会自动分配一个端口。还可以使用 udp 标记来指定 udp 端口。如<code>$ sudo docker run -d -p 127.0.0.1:5000:5000/udp training/webapp python app.py</code></li>\n<li><code>hostPort:containerPort</code>：指定主机所有IP下的指定端口到容器内的指定端口。</li>\n</ul>\n</li>\n</ul>\n<p>使用 <code>docker port</code> 来查看当前映射的端口配置，<br><strong>注意：</strong></p>\n<ul>\n<li>容器有自己的内部网络和 ip 地址（使用 docker inspect 可以获取所有的变量，Docker 还可以有一个可变的网络配置。）</li>\n<li>-p 参数可以多次使用。如：<code>$ sudo docker run -d -p 5000:5000  -p 3000:80 training/webapp python app.py</code><h2 id=\"容器互联\"><a href=\"#容器互联\" class=\"headerlink\" title=\"容器互联\"></a>容器互联</h2>连接系统依据容器的名称来执行。因此，首先需要通过<code>--name</code>自定义一个好记的容器命名。使用 <code>docker ps</code> 来验证设定的命名。</li>\n</ul>\n<p>使用 <code>--link</code> 参数可以让容器之间安全的进行交互。参数的格式为 <code>--link name:alias</code>，其中 name 是要链接的容器的名称，alias 是这个连接的别名。<br>将web容器与db容器连接，且连接被命名为db, 启动命令如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo docker run -d -P --name web --link db:db training/webapp python app.py</span><br></pre></td></tr></table></figure>\n\n<p><strong>实现原理：</strong><br>Docker 通过 2 种方式为容器公开连接信息：</p>\n<ul>\n<li>环境变量。 通过linux命令<code>env</code>可以看到，环境变量通过增加alias做为前缀标识来区别容器的环境变量与连接。</li>\n<li>更新 /etc/hosts 文件。在hosts文件中增加alias条目的映射ip。</li>\n</ul>\n<hr>\n<p><em>观点仅代表自己，期待你的留言。</em></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"数据卷\"><a href=\"#数据卷\" class=\"headerlink\" title=\"数据卷\"></a>数据卷</h1><p>Docker 挂载数据卷的默认权限是读写，用户也可以通过 :ro 指定为只读。<br>示例：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo docker run -d -P --name web -v /src/webapp:/opt/webapp:ro training/webapp python app.py</span><br></pre></td></tr></table></figure>\n<h2 id=\"创建数据卷\"><a href=\"#创建数据卷\" class=\"headerlink\" title=\"创建数据卷\"></a>创建数据卷</h2><p>在用 <code>docker run</code> 命令的时候，使用 <code>-v</code> 标记来创建一个数据卷并挂载到容器里。在一次 run 中多次使用可以挂载多个数据卷。<br>示例： </p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo docker run -d -P --name web -v /webapp training/webapp python app.py</span><br></pre></td></tr></table></figure>\n<h2 id=\"挂载一个主机目录作为数据卷\"><a href=\"#挂载一个主机目录作为数据卷\" class=\"headerlink\" title=\"挂载一个主机目录作为数据卷\"></a>挂载一个主机目录作为数据卷</h2><p>加载主机的 /src/webapp 目录到容器的 /opt/webapp 目录.<br>示例：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo docker run -d -P --name web -v /src/webapp:/opt/webapp training/webapp python app.py</span><br></pre></td></tr></table></figure>\n<p><code>注意：</code>本地目录的路径必须是绝对路径，如果目录不存在 Docker 会自动为你创建它。</p>\n<h2 id=\"挂载一个本地主机文件作为数据卷\"><a href=\"#挂载一个本地主机文件作为数据卷\" class=\"headerlink\" title=\"挂载一个本地主机文件作为数据卷\"></a>挂载一个本地主机文件作为数据卷</h2><p>-v 标记也可以从主机挂载单个文件到容器中<br>示例：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo docker run --rm -it -v ~/.bash_history:/.bash_history ubuntu /bin/bash</span><br></pre></td></tr></table></figure>\n<h2 id=\"删除数据卷\"><a href=\"#删除数据卷\" class=\"headerlink\" title=\"删除数据卷\"></a>删除数据卷</h2><p>数据卷是被设计用来持久化数据的，它的生命周期独立于容器，Docker不会在容器被删除后自动删除数据卷，并且也不存在垃圾回收这样的机制来处理没有任何容器引用的数据卷。如果需要在删除容器的同时移除数据卷。可以在删除容器的时候使用 <code>docker rm -v</code>这个命令。无主的数据卷可能会占据很多空间，要清理会很麻烦。</p>\n<h2 id=\"数据卷容器\"><a href=\"#数据卷容器\" class=\"headerlink\" title=\"数据卷容器\"></a>数据卷容器</h2><p>如果你有一些持续更新的数据需要在容器之间共享，最好创建数据卷容器。<br>数据卷容器，其实就是一个正常的容器，专门用来提供数据卷供其它容器挂载的。<br>首先，创建一个名为 dbdata 的数据卷容器：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo docker run -d -v /dbdatas --name dbdata training/postgres echo Data-only container for postgres</span><br></pre></td></tr></table></figure>\n<p>然后，在其他容器中使用 <code>--volumes-from</code> 来挂载 dbdata 容器中的数据卷。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo docker run -d --volumes-from dbdata --name db1 training/postgres</span><br><span class=\"line\">$ sudo docker run -d --volumes-from dbdata --name db2 training/postgres</span><br></pre></td></tr></table></figure>\n<p>可以使用超过一个的 –volumes-from 参数来指定从多个容器挂载不同的数据卷。 也可以从其他已经挂载了数据卷的容器来级联挂载数据卷。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo docker run -d --name db3 --volumes-from db1 training/postgres</span><br></pre></td></tr></table></figure>\n<p>*注意：使用 <code>--volumes-from</code> 参数所挂载数据卷的容器自己并不需要保持在运行状态。<br>如果删除了挂载的容器（包括 dbdata、db1 和 db2），数据卷并不会被自动删除。如果要删除一个数据卷，必须在删除最后一个还挂载着它的容器时使用 <code>docker rm -v</code> 命令来指定同时删除关联的容器。</p>\n<h2 id=\"利用数据卷容器来备份、恢复、迁移数据卷\"><a href=\"#利用数据卷容器来备份、恢复、迁移数据卷\" class=\"headerlink\" title=\"利用数据卷容器来备份、恢复、迁移数据卷\"></a>利用数据卷容器来备份、恢复、迁移数据卷</h2><h3 id=\"备份\"><a href=\"#备份\" class=\"headerlink\" title=\"备份\"></a>备份</h3><p>首先使用 –volumes-from 标记来创建一个加载 dbdata 容器卷的容器，并从主机挂载当前目录到容器的 /backup 目录。<br>命令如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo docker run --volumes-from dbdata -v $(pwd):/backup ubuntu tar cvf /backup/backup.tar /dbdata</span><br></pre></td></tr></table></figure>\n<p>容器启动后，使用了 tar 命令来将 dbdata 卷备份为容器中 /backup/backup.tar 文件，也就是主机当前目录下的名为 backup.tar 的文件。</p>\n<h3 id=\"恢复\"><a href=\"#恢复\" class=\"headerlink\" title=\"恢复\"></a>恢复</h3><p>如果要恢复数据到一个容器，首先创建一个带有空数据卷的容器 dbdata2。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo docker run -v /dbdata --name dbdata2 ubuntu /bin/bash</span><br></pre></td></tr></table></figure>\n<p>然后创建另一个容器，挂载 dbdata2 容器卷中的数据卷，并使用 untar 解压备份文件到挂载的容器卷中。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo docker run --volumes-from dbdata2 -v $(pwd):/backup busybox tar xvf /backup/backup.tar</span><br></pre></td></tr></table></figure>\n<p>为了查看/验证恢复的数据，可以再启动一个容器挂载同样的容器卷来查看</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo docker run --volumes-from dbdata2 busybox /bin/ls /dbdata</span><br></pre></td></tr></table></figure>\n<h1 id=\"网络配置\"><a href=\"#网络配置\" class=\"headerlink\" title=\"网络配置\"></a>网络配置</h1><h2 id=\"外部访问容器\"><a href=\"#外部访问容器\" class=\"headerlink\" title=\"外部访问容器\"></a>外部访问容器</h2><p>docker容器一般使用5000做为服务端口（类似于80端口的概念）。</p>\n<ul>\n<li>docker支持在<code>docker run</code>时增加<code>-P</code>来将主机随机端口(49000~49900)映射到容器内的5000。可通过<code>docker ps</code>查看到对应的占用端口。</li>\n<li>docker支持在<code>docker run</code>时增加<code>-p</code>来将指定的主机端口映射到容器内的指定端口。<br>  支持以下格式：<ul>\n<li><code>ip:hostPort:containerPort</code>： 将主机指定IP下的指定端口绑定到容器内的指定端口。</li>\n<li><code>ip::containerPort</code>：绑定主机指定IP下的任意端口到容器的指定端口，本地主机会自动分配一个端口。还可以使用 udp 标记来指定 udp 端口。如<code>$ sudo docker run -d -p 127.0.0.1:5000:5000/udp training/webapp python app.py</code></li>\n<li><code>hostPort:containerPort</code>：指定主机所有IP下的指定端口到容器内的指定端口。</li>\n</ul>\n</li>\n</ul>\n<p>使用 <code>docker port</code> 来查看当前映射的端口配置，<br><strong>注意：</strong></p>\n<ul>\n<li>容器有自己的内部网络和 ip 地址（使用 docker inspect 可以获取所有的变量，Docker 还可以有一个可变的网络配置。）</li>\n<li>-p 参数可以多次使用。如：<code>$ sudo docker run -d -p 5000:5000  -p 3000:80 training/webapp python app.py</code><h2 id=\"容器互联\"><a href=\"#容器互联\" class=\"headerlink\" title=\"容器互联\"></a>容器互联</h2>连接系统依据容器的名称来执行。因此，首先需要通过<code>--name</code>自定义一个好记的容器命名。使用 <code>docker ps</code> 来验证设定的命名。</li>\n</ul>\n<p>使用 <code>--link</code> 参数可以让容器之间安全的进行交互。参数的格式为 <code>--link name:alias</code>，其中 name 是要链接的容器的名称，alias 是这个连接的别名。<br>将web容器与db容器连接，且连接被命名为db, 启动命令如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo docker run -d -P --name web --link db:db training/webapp python app.py</span><br></pre></td></tr></table></figure>\n\n<p><strong>实现原理：</strong><br>Docker 通过 2 种方式为容器公开连接信息：</p>\n<ul>\n<li>环境变量。 通过linux命令<code>env</code>可以看到，环境变量通过增加alias做为前缀标识来区别容器的环境变量与连接。</li>\n<li>更新 /etc/hosts 文件。在hosts文件中增加alias条目的映射ip。</li>\n</ul>\n<hr>\n<p><em>观点仅代表自己，期待你的留言。</em></p>\n"},{"title":"docker-dockerfile","date":"2016-04-19T02:30:45.000Z","_content":"\n# 基本结构\nDockerfile 由一行行字母大写的指令语句组成，并且支持以 `#` 开头的注释行。\n一般的，Dockerfile 分为四部分：基础镜像信息、维护者信息、镜像操作指令和容器启动时执行指令。\n# 指令\n指令的一般格式为 `INSTRUCTION arguments`，指令包括 FROM、MAINTAINER、RUN 等。\n## FROM\n格式为 `FROM <image>`或`FROM <image>:<tag>`。\n第一条指令必须为 FROM 指令。并且，如果在同一个Dockerfile中创建多个镜像时，可以使用多个 `FROM` 指令（每个镜像一次）。\n## MAINTAINER\n格式为 `MAINTAINER <name>`，指定维护者信息。\n## RUN\n格式为 `RUN <command>` 或 `RUN [\"executable\", \"param1\", \"param2\"]`。\n前者将在 shell 终端中运行命令，即 `/bin/sh -c`；后者则使用 `exec` 执行。指定使用其它终端可以通过第二种方式实现，例如 `RUN [\"/bin/bash\", \"-c\", \"echo hello\"]`。\n每条 `RUN` 指令将在当前镜像基础上执行指定命令，并提交为新的镜像。当命令较长时可以使用 `\\` 来换行。\n## CMD\n\n支持三种格式\n - CMD [\"executable\",\"param1\",\"param2\"] 使用 exec 执行，推荐方式；\n - CMD command param1 param2 在 /bin/sh 中执行，提供给需要交互的应用；\n - CMD [\"param1\",\"param2\"] 提供给 ENTRYPOINT 的默认参数；\n指定启动容器时执行的命令，__每个 Dockerfile 只能有一条 `CMD` 命令__。如果指定了多条命令，只有最后一条会被执行。\n如果用户启动容器时候指定了运行的命令，则会覆盖掉 CMD 指定的命令。\n## EXPOSE\n\n格式为 `EXPOSE <port> [<port>...]`。\n告诉 Docker 服务端容器暴露的端口号，供互联系统使用。在启动容器时需要通过 `-P`，Docker 主机会自动分配一个端口转发到指定的端口。\n\n## ENV\n\n格式为 `ENV <key> <value>`。 指定一个环境变量，会被后续 `RUN` 指令使用，并在容器运行时保持。\n例如\n```\nENV PG_MAJOR 9.3\nENV PG_VERSION 9.3.4\nRUN curl -SL http://example.com/postgres-$PG_VERSION.tar.xz | tar -xJC /usr/src/postgress && …\nENV PATH /usr/local/postgres-$PG_MAJOR/bin:$PATH\n```\n## ADD\n\n格式为 `ADD <src> <dest>`。\n该命令将复制指定的 `<src>` 到容器中的 `<dest>`。 其中 `<src>` 可以是Dockerfile所在目录的一个相对路径；也可以是一个 URL；还可以是一个 tar 文件（自动解压为目录）。\n## COPY\n\n格式为 `COPY <src> <dest>`。\n复制本地主机的 `<src>`（为 Dockerfile 所在目录的相对路径）到容器中的 `<dest>`。\n当使用本地目录为源目录时，推荐使用 `COPY`。\n## ENTRYPOINT\n\n两种格式：\n - ENTRYPOINT [\"executable\", \"param1\", \"param2\"]\n - ENTRYPOINT command param1 param2（shell中执行）。\n配置容器启动后执行的命令，并且不可被 `docker run` 提供的参数覆盖。\n每个 Dockerfile 中只能有一个 `ENTRYPOINT`，__当指定多个时，只有最后一个起效__。\n## VOLUME\n\n格式为 `VOLUME [\"/data\"]`。\n创建一个可以从本地主机或其他容器挂载的挂载点，一般用来存放数据库和需要保持的数据等。\n## USER\n\n格式为 `USER daemon`。\n指定运行容器时的用户名或 UID，后续的 `RUN` 也会使用指定用户。\n当服务不需要管理员权限时，可以通过该命令指定运行用户。并且可以在之前创建所需要的用户，例如：`RUN groupadd -r postgres && useradd -r -g postgres postgres`。要临时获取管理员权限可以使用 `gosu`，而不推荐 `sudo`。\n## WORKDIR\n\n格式为 `WORKDIR /path/to/workdir`。\n为后续的 `RUN、CMD、ENTRYPOINT` 指令配置工作目录。\n可以使用多个 `WORKDIR` 指令，后续命令如果参数是相对路径，则会基于之前命令指定的路径。\n例如\n```\nWORKDIR /a\nWORKDIR b\nWORKDIR c\nRUN pwd\n```\n则最终路径为 `/a/b/c`。\n## ONBUILD\n\n格式为 `ONBUILD [INSTRUCTION]`。\n配置当所创建的镜像作为其它新创建镜像的基础镜像时，所执行的操作指令。\n例如，Dockerfile 使用如下的内容创建了镜像 `image-A`。\n```\n[...]\nONBUILD ADD . /app/src\nONBUILD RUN /usr/local/bin/python-build --dir /app/src\n[...]\n```\n如果基于 `image-A` 创建新的镜像时，新的Dockerfile中使用 `FROM image-A`指定基础镜像时，会自动执行 `ONBUILD` 指令内容，等价于在后面添加了两条指令。\n```\nFROM image-A\n\n#Automatically run the following\nADD . /app/src\nRUN /usr/local/bin/python-build --dir /app/src\n```\n使用 `ONBUILD` 指令的镜像，推荐在标签中注明，例如 `ruby:1.9-onbuild`。\n# 创建镜像\n编写完成 Dockerfile 之后，可以通过 `docker build` 命令来创建镜像。\n基本的格式为 `docker build [选项]` 路径，该命令将读取指定路径下（包括子目录）的 Dockerfile，并将该路径下所有内容发送给 Docker 服务端，由服务端来创建镜像。因此一般建议放置 Dockerfile 的目录为空目录。也可以通过 `.dockerignore`文件（每一行添加一条匹配模式）来让 Docker 忽略路径下的目录和文件。\n要指定镜像的标签信息，可以通过 `-t` 选项，\n例如:\n```\n$ sudo docker build -t myrepo/myapp /tmp/test1/\n```\n\n-----\nhttps://yeasy.gitbooks.io/docker_practice/content/dockerfile/index.html\n\n*观点仅代表自己，期待你的留言。*\n","source":"_posts/docker-dockerfile.md","raw":"---\ntitle: docker-dockerfile\ntags:\n  - Docker\n  - 转载\ndate: 2016-04-19 10:30:45\n---\n\n# 基本结构\nDockerfile 由一行行字母大写的指令语句组成，并且支持以 `#` 开头的注释行。\n一般的，Dockerfile 分为四部分：基础镜像信息、维护者信息、镜像操作指令和容器启动时执行指令。\n# 指令\n指令的一般格式为 `INSTRUCTION arguments`，指令包括 FROM、MAINTAINER、RUN 等。\n## FROM\n格式为 `FROM <image>`或`FROM <image>:<tag>`。\n第一条指令必须为 FROM 指令。并且，如果在同一个Dockerfile中创建多个镜像时，可以使用多个 `FROM` 指令（每个镜像一次）。\n## MAINTAINER\n格式为 `MAINTAINER <name>`，指定维护者信息。\n## RUN\n格式为 `RUN <command>` 或 `RUN [\"executable\", \"param1\", \"param2\"]`。\n前者将在 shell 终端中运行命令，即 `/bin/sh -c`；后者则使用 `exec` 执行。指定使用其它终端可以通过第二种方式实现，例如 `RUN [\"/bin/bash\", \"-c\", \"echo hello\"]`。\n每条 `RUN` 指令将在当前镜像基础上执行指定命令，并提交为新的镜像。当命令较长时可以使用 `\\` 来换行。\n## CMD\n\n支持三种格式\n - CMD [\"executable\",\"param1\",\"param2\"] 使用 exec 执行，推荐方式；\n - CMD command param1 param2 在 /bin/sh 中执行，提供给需要交互的应用；\n - CMD [\"param1\",\"param2\"] 提供给 ENTRYPOINT 的默认参数；\n指定启动容器时执行的命令，__每个 Dockerfile 只能有一条 `CMD` 命令__。如果指定了多条命令，只有最后一条会被执行。\n如果用户启动容器时候指定了运行的命令，则会覆盖掉 CMD 指定的命令。\n## EXPOSE\n\n格式为 `EXPOSE <port> [<port>...]`。\n告诉 Docker 服务端容器暴露的端口号，供互联系统使用。在启动容器时需要通过 `-P`，Docker 主机会自动分配一个端口转发到指定的端口。\n\n## ENV\n\n格式为 `ENV <key> <value>`。 指定一个环境变量，会被后续 `RUN` 指令使用，并在容器运行时保持。\n例如\n```\nENV PG_MAJOR 9.3\nENV PG_VERSION 9.3.4\nRUN curl -SL http://example.com/postgres-$PG_VERSION.tar.xz | tar -xJC /usr/src/postgress && …\nENV PATH /usr/local/postgres-$PG_MAJOR/bin:$PATH\n```\n## ADD\n\n格式为 `ADD <src> <dest>`。\n该命令将复制指定的 `<src>` 到容器中的 `<dest>`。 其中 `<src>` 可以是Dockerfile所在目录的一个相对路径；也可以是一个 URL；还可以是一个 tar 文件（自动解压为目录）。\n## COPY\n\n格式为 `COPY <src> <dest>`。\n复制本地主机的 `<src>`（为 Dockerfile 所在目录的相对路径）到容器中的 `<dest>`。\n当使用本地目录为源目录时，推荐使用 `COPY`。\n## ENTRYPOINT\n\n两种格式：\n - ENTRYPOINT [\"executable\", \"param1\", \"param2\"]\n - ENTRYPOINT command param1 param2（shell中执行）。\n配置容器启动后执行的命令，并且不可被 `docker run` 提供的参数覆盖。\n每个 Dockerfile 中只能有一个 `ENTRYPOINT`，__当指定多个时，只有最后一个起效__。\n## VOLUME\n\n格式为 `VOLUME [\"/data\"]`。\n创建一个可以从本地主机或其他容器挂载的挂载点，一般用来存放数据库和需要保持的数据等。\n## USER\n\n格式为 `USER daemon`。\n指定运行容器时的用户名或 UID，后续的 `RUN` 也会使用指定用户。\n当服务不需要管理员权限时，可以通过该命令指定运行用户。并且可以在之前创建所需要的用户，例如：`RUN groupadd -r postgres && useradd -r -g postgres postgres`。要临时获取管理员权限可以使用 `gosu`，而不推荐 `sudo`。\n## WORKDIR\n\n格式为 `WORKDIR /path/to/workdir`。\n为后续的 `RUN、CMD、ENTRYPOINT` 指令配置工作目录。\n可以使用多个 `WORKDIR` 指令，后续命令如果参数是相对路径，则会基于之前命令指定的路径。\n例如\n```\nWORKDIR /a\nWORKDIR b\nWORKDIR c\nRUN pwd\n```\n则最终路径为 `/a/b/c`。\n## ONBUILD\n\n格式为 `ONBUILD [INSTRUCTION]`。\n配置当所创建的镜像作为其它新创建镜像的基础镜像时，所执行的操作指令。\n例如，Dockerfile 使用如下的内容创建了镜像 `image-A`。\n```\n[...]\nONBUILD ADD . /app/src\nONBUILD RUN /usr/local/bin/python-build --dir /app/src\n[...]\n```\n如果基于 `image-A` 创建新的镜像时，新的Dockerfile中使用 `FROM image-A`指定基础镜像时，会自动执行 `ONBUILD` 指令内容，等价于在后面添加了两条指令。\n```\nFROM image-A\n\n#Automatically run the following\nADD . /app/src\nRUN /usr/local/bin/python-build --dir /app/src\n```\n使用 `ONBUILD` 指令的镜像，推荐在标签中注明，例如 `ruby:1.9-onbuild`。\n# 创建镜像\n编写完成 Dockerfile 之后，可以通过 `docker build` 命令来创建镜像。\n基本的格式为 `docker build [选项]` 路径，该命令将读取指定路径下（包括子目录）的 Dockerfile，并将该路径下所有内容发送给 Docker 服务端，由服务端来创建镜像。因此一般建议放置 Dockerfile 的目录为空目录。也可以通过 `.dockerignore`文件（每一行添加一条匹配模式）来让 Docker 忽略路径下的目录和文件。\n要指定镜像的标签信息，可以通过 `-t` 选项，\n例如:\n```\n$ sudo docker build -t myrepo/myapp /tmp/test1/\n```\n\n-----\nhttps://yeasy.gitbooks.io/docker_practice/content/dockerfile/index.html\n\n*观点仅代表自己，期待你的留言。*\n","slug":"docker-dockerfile","published":1,"updated":"2021-08-31T14:23:11.539Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cku52dymg0012bbineyb9fp1o","content":"<h1 id=\"基本结构\"><a href=\"#基本结构\" class=\"headerlink\" title=\"基本结构\"></a>基本结构</h1><p>Dockerfile 由一行行字母大写的指令语句组成，并且支持以 <code>#</code> 开头的注释行。<br>一般的，Dockerfile 分为四部分：基础镜像信息、维护者信息、镜像操作指令和容器启动时执行指令。</p>\n<h1 id=\"指令\"><a href=\"#指令\" class=\"headerlink\" title=\"指令\"></a>指令</h1><p>指令的一般格式为 <code>INSTRUCTION arguments</code>，指令包括 FROM、MAINTAINER、RUN 等。</p>\n<h2 id=\"FROM\"><a href=\"#FROM\" class=\"headerlink\" title=\"FROM\"></a>FROM</h2><p>格式为 <code>FROM &lt;image&gt;</code>或<code>FROM &lt;image&gt;:&lt;tag&gt;</code>。<br>第一条指令必须为 FROM 指令。并且，如果在同一个Dockerfile中创建多个镜像时，可以使用多个 <code>FROM</code> 指令（每个镜像一次）。</p>\n<h2 id=\"MAINTAINER\"><a href=\"#MAINTAINER\" class=\"headerlink\" title=\"MAINTAINER\"></a>MAINTAINER</h2><p>格式为 <code>MAINTAINER &lt;name&gt;</code>，指定维护者信息。</p>\n<h2 id=\"RUN\"><a href=\"#RUN\" class=\"headerlink\" title=\"RUN\"></a>RUN</h2><p>格式为 <code>RUN &lt;command&gt;</code> 或 <code>RUN [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;]</code>。<br>前者将在 shell 终端中运行命令，即 <code>/bin/sh -c</code>；后者则使用 <code>exec</code> 执行。指定使用其它终端可以通过第二种方式实现，例如 <code>RUN [&quot;/bin/bash&quot;, &quot;-c&quot;, &quot;echo hello&quot;]</code>。<br>每条 <code>RUN</code> 指令将在当前镜像基础上执行指定命令，并提交为新的镜像。当命令较长时可以使用 <code>\\</code> 来换行。</p>\n<h2 id=\"CMD\"><a href=\"#CMD\" class=\"headerlink\" title=\"CMD\"></a>CMD</h2><p>支持三种格式</p>\n<ul>\n<li>CMD [“executable”,”param1”,”param2”] 使用 exec 执行，推荐方式；</li>\n<li>CMD command param1 param2 在 /bin/sh 中执行，提供给需要交互的应用；</li>\n<li>CMD [“param1”,”param2”] 提供给 ENTRYPOINT 的默认参数；<br>指定启动容器时执行的命令，__每个 Dockerfile 只能有一条 <code>CMD</code> 命令__。如果指定了多条命令，只有最后一条会被执行。<br>如果用户启动容器时候指定了运行的命令，则会覆盖掉 CMD 指定的命令。<h2 id=\"EXPOSE\"><a href=\"#EXPOSE\" class=\"headerlink\" title=\"EXPOSE\"></a>EXPOSE</h2></li>\n</ul>\n<p>格式为 <code>EXPOSE &lt;port&gt; [&lt;port&gt;...]</code>。<br>告诉 Docker 服务端容器暴露的端口号，供互联系统使用。在启动容器时需要通过 <code>-P</code>，Docker 主机会自动分配一个端口转发到指定的端口。</p>\n<h2 id=\"ENV\"><a href=\"#ENV\" class=\"headerlink\" title=\"ENV\"></a>ENV</h2><p>格式为 <code>ENV &lt;key&gt; &lt;value&gt;</code>。 指定一个环境变量，会被后续 <code>RUN</code> 指令使用，并在容器运行时保持。<br>例如</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ENV PG_MAJOR 9.3</span><br><span class=\"line\">ENV PG_VERSION 9.3.4</span><br><span class=\"line\">RUN curl -SL http://example.com/postgres-$PG_VERSION.tar.xz | tar -xJC /usr/src/postgress &amp;&amp; …</span><br><span class=\"line\">ENV PATH /usr/local/postgres-$PG_MAJOR/bin:$PATH</span><br></pre></td></tr></table></figure>\n<h2 id=\"ADD\"><a href=\"#ADD\" class=\"headerlink\" title=\"ADD\"></a>ADD</h2><p>格式为 <code>ADD &lt;src&gt; &lt;dest&gt;</code>。<br>该命令将复制指定的 <code>&lt;src&gt;</code> 到容器中的 <code>&lt;dest&gt;</code>。 其中 <code>&lt;src&gt;</code> 可以是Dockerfile所在目录的一个相对路径；也可以是一个 URL；还可以是一个 tar 文件（自动解压为目录）。</p>\n<h2 id=\"COPY\"><a href=\"#COPY\" class=\"headerlink\" title=\"COPY\"></a>COPY</h2><p>格式为 <code>COPY &lt;src&gt; &lt;dest&gt;</code>。<br>复制本地主机的 <code>&lt;src&gt;</code>（为 Dockerfile 所在目录的相对路径）到容器中的 <code>&lt;dest&gt;</code>。<br>当使用本地目录为源目录时，推荐使用 <code>COPY</code>。</p>\n<h2 id=\"ENTRYPOINT\"><a href=\"#ENTRYPOINT\" class=\"headerlink\" title=\"ENTRYPOINT\"></a>ENTRYPOINT</h2><p>两种格式：</p>\n<ul>\n<li>ENTRYPOINT [“executable”, “param1”, “param2”]</li>\n<li>ENTRYPOINT command param1 param2（shell中执行）。<br>配置容器启动后执行的命令，并且不可被 <code>docker run</code> 提供的参数覆盖。<br>每个 Dockerfile 中只能有一个 <code>ENTRYPOINT</code>，__当指定多个时，只有最后一个起效__。<h2 id=\"VOLUME\"><a href=\"#VOLUME\" class=\"headerlink\" title=\"VOLUME\"></a>VOLUME</h2></li>\n</ul>\n<p>格式为 <code>VOLUME [&quot;/data&quot;]</code>。<br>创建一个可以从本地主机或其他容器挂载的挂载点，一般用来存放数据库和需要保持的数据等。</p>\n<h2 id=\"USER\"><a href=\"#USER\" class=\"headerlink\" title=\"USER\"></a>USER</h2><p>格式为 <code>USER daemon</code>。<br>指定运行容器时的用户名或 UID，后续的 <code>RUN</code> 也会使用指定用户。<br>当服务不需要管理员权限时，可以通过该命令指定运行用户。并且可以在之前创建所需要的用户，例如：<code>RUN groupadd -r postgres &amp;&amp; useradd -r -g postgres postgres</code>。要临时获取管理员权限可以使用 <code>gosu</code>，而不推荐 <code>sudo</code>。</p>\n<h2 id=\"WORKDIR\"><a href=\"#WORKDIR\" class=\"headerlink\" title=\"WORKDIR\"></a>WORKDIR</h2><p>格式为 <code>WORKDIR /path/to/workdir</code>。<br>为后续的 <code>RUN、CMD、ENTRYPOINT</code> 指令配置工作目录。<br>可以使用多个 <code>WORKDIR</code> 指令，后续命令如果参数是相对路径，则会基于之前命令指定的路径。<br>例如</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">WORKDIR /a</span><br><span class=\"line\">WORKDIR b</span><br><span class=\"line\">WORKDIR c</span><br><span class=\"line\">RUN pwd</span><br></pre></td></tr></table></figure>\n<p>则最终路径为 <code>/a/b/c</code>。</p>\n<h2 id=\"ONBUILD\"><a href=\"#ONBUILD\" class=\"headerlink\" title=\"ONBUILD\"></a>ONBUILD</h2><p>格式为 <code>ONBUILD [INSTRUCTION]</code>。<br>配置当所创建的镜像作为其它新创建镜像的基础镜像时，所执行的操作指令。<br>例如，Dockerfile 使用如下的内容创建了镜像 <code>image-A</code>。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[...]</span><br><span class=\"line\">ONBUILD ADD . /app/src</span><br><span class=\"line\">ONBUILD RUN /usr/local/bin/python-build --dir /app/src</span><br><span class=\"line\">[...]</span><br></pre></td></tr></table></figure>\n<p>如果基于 <code>image-A</code> 创建新的镜像时，新的Dockerfile中使用 <code>FROM image-A</code>指定基础镜像时，会自动执行 <code>ONBUILD</code> 指令内容，等价于在后面添加了两条指令。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">FROM image-A</span><br><span class=\"line\"></span><br><span class=\"line\">#Automatically run the following</span><br><span class=\"line\">ADD . /app/src</span><br><span class=\"line\">RUN /usr/local/bin/python-build --dir /app/src</span><br></pre></td></tr></table></figure>\n<p>使用 <code>ONBUILD</code> 指令的镜像，推荐在标签中注明，例如 <code>ruby:1.9-onbuild</code>。</p>\n<h1 id=\"创建镜像\"><a href=\"#创建镜像\" class=\"headerlink\" title=\"创建镜像\"></a>创建镜像</h1><p>编写完成 Dockerfile 之后，可以通过 <code>docker build</code> 命令来创建镜像。<br>基本的格式为 <code>docker build [选项]</code> 路径，该命令将读取指定路径下（包括子目录）的 Dockerfile，并将该路径下所有内容发送给 Docker 服务端，由服务端来创建镜像。因此一般建议放置 Dockerfile 的目录为空目录。也可以通过 <code>.dockerignore</code>文件（每一行添加一条匹配模式）来让 Docker 忽略路径下的目录和文件。<br>要指定镜像的标签信息，可以通过 <code>-t</code> 选项，<br>例如:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo docker build -t myrepo/myapp /tmp/test1/</span><br></pre></td></tr></table></figure>\n\n<hr>\n<p><a href=\"https://yeasy.gitbooks.io/docker_practice/content/dockerfile/index.html\">https://yeasy.gitbooks.io/docker_practice/content/dockerfile/index.html</a></p>\n<p><em>观点仅代表自己，期待你的留言。</em></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"基本结构\"><a href=\"#基本结构\" class=\"headerlink\" title=\"基本结构\"></a>基本结构</h1><p>Dockerfile 由一行行字母大写的指令语句组成，并且支持以 <code>#</code> 开头的注释行。<br>一般的，Dockerfile 分为四部分：基础镜像信息、维护者信息、镜像操作指令和容器启动时执行指令。</p>\n<h1 id=\"指令\"><a href=\"#指令\" class=\"headerlink\" title=\"指令\"></a>指令</h1><p>指令的一般格式为 <code>INSTRUCTION arguments</code>，指令包括 FROM、MAINTAINER、RUN 等。</p>\n<h2 id=\"FROM\"><a href=\"#FROM\" class=\"headerlink\" title=\"FROM\"></a>FROM</h2><p>格式为 <code>FROM &lt;image&gt;</code>或<code>FROM &lt;image&gt;:&lt;tag&gt;</code>。<br>第一条指令必须为 FROM 指令。并且，如果在同一个Dockerfile中创建多个镜像时，可以使用多个 <code>FROM</code> 指令（每个镜像一次）。</p>\n<h2 id=\"MAINTAINER\"><a href=\"#MAINTAINER\" class=\"headerlink\" title=\"MAINTAINER\"></a>MAINTAINER</h2><p>格式为 <code>MAINTAINER &lt;name&gt;</code>，指定维护者信息。</p>\n<h2 id=\"RUN\"><a href=\"#RUN\" class=\"headerlink\" title=\"RUN\"></a>RUN</h2><p>格式为 <code>RUN &lt;command&gt;</code> 或 <code>RUN [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;]</code>。<br>前者将在 shell 终端中运行命令，即 <code>/bin/sh -c</code>；后者则使用 <code>exec</code> 执行。指定使用其它终端可以通过第二种方式实现，例如 <code>RUN [&quot;/bin/bash&quot;, &quot;-c&quot;, &quot;echo hello&quot;]</code>。<br>每条 <code>RUN</code> 指令将在当前镜像基础上执行指定命令，并提交为新的镜像。当命令较长时可以使用 <code>\\</code> 来换行。</p>\n<h2 id=\"CMD\"><a href=\"#CMD\" class=\"headerlink\" title=\"CMD\"></a>CMD</h2><p>支持三种格式</p>\n<ul>\n<li>CMD [“executable”,”param1”,”param2”] 使用 exec 执行，推荐方式；</li>\n<li>CMD command param1 param2 在 /bin/sh 中执行，提供给需要交互的应用；</li>\n<li>CMD [“param1”,”param2”] 提供给 ENTRYPOINT 的默认参数；<br>指定启动容器时执行的命令，__每个 Dockerfile 只能有一条 <code>CMD</code> 命令__。如果指定了多条命令，只有最后一条会被执行。<br>如果用户启动容器时候指定了运行的命令，则会覆盖掉 CMD 指定的命令。<h2 id=\"EXPOSE\"><a href=\"#EXPOSE\" class=\"headerlink\" title=\"EXPOSE\"></a>EXPOSE</h2></li>\n</ul>\n<p>格式为 <code>EXPOSE &lt;port&gt; [&lt;port&gt;...]</code>。<br>告诉 Docker 服务端容器暴露的端口号，供互联系统使用。在启动容器时需要通过 <code>-P</code>，Docker 主机会自动分配一个端口转发到指定的端口。</p>\n<h2 id=\"ENV\"><a href=\"#ENV\" class=\"headerlink\" title=\"ENV\"></a>ENV</h2><p>格式为 <code>ENV &lt;key&gt; &lt;value&gt;</code>。 指定一个环境变量，会被后续 <code>RUN</code> 指令使用，并在容器运行时保持。<br>例如</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ENV PG_MAJOR 9.3</span><br><span class=\"line\">ENV PG_VERSION 9.3.4</span><br><span class=\"line\">RUN curl -SL http://example.com/postgres-$PG_VERSION.tar.xz | tar -xJC /usr/src/postgress &amp;&amp; …</span><br><span class=\"line\">ENV PATH /usr/local/postgres-$PG_MAJOR/bin:$PATH</span><br></pre></td></tr></table></figure>\n<h2 id=\"ADD\"><a href=\"#ADD\" class=\"headerlink\" title=\"ADD\"></a>ADD</h2><p>格式为 <code>ADD &lt;src&gt; &lt;dest&gt;</code>。<br>该命令将复制指定的 <code>&lt;src&gt;</code> 到容器中的 <code>&lt;dest&gt;</code>。 其中 <code>&lt;src&gt;</code> 可以是Dockerfile所在目录的一个相对路径；也可以是一个 URL；还可以是一个 tar 文件（自动解压为目录）。</p>\n<h2 id=\"COPY\"><a href=\"#COPY\" class=\"headerlink\" title=\"COPY\"></a>COPY</h2><p>格式为 <code>COPY &lt;src&gt; &lt;dest&gt;</code>。<br>复制本地主机的 <code>&lt;src&gt;</code>（为 Dockerfile 所在目录的相对路径）到容器中的 <code>&lt;dest&gt;</code>。<br>当使用本地目录为源目录时，推荐使用 <code>COPY</code>。</p>\n<h2 id=\"ENTRYPOINT\"><a href=\"#ENTRYPOINT\" class=\"headerlink\" title=\"ENTRYPOINT\"></a>ENTRYPOINT</h2><p>两种格式：</p>\n<ul>\n<li>ENTRYPOINT [“executable”, “param1”, “param2”]</li>\n<li>ENTRYPOINT command param1 param2（shell中执行）。<br>配置容器启动后执行的命令，并且不可被 <code>docker run</code> 提供的参数覆盖。<br>每个 Dockerfile 中只能有一个 <code>ENTRYPOINT</code>，__当指定多个时，只有最后一个起效__。<h2 id=\"VOLUME\"><a href=\"#VOLUME\" class=\"headerlink\" title=\"VOLUME\"></a>VOLUME</h2></li>\n</ul>\n<p>格式为 <code>VOLUME [&quot;/data&quot;]</code>。<br>创建一个可以从本地主机或其他容器挂载的挂载点，一般用来存放数据库和需要保持的数据等。</p>\n<h2 id=\"USER\"><a href=\"#USER\" class=\"headerlink\" title=\"USER\"></a>USER</h2><p>格式为 <code>USER daemon</code>。<br>指定运行容器时的用户名或 UID，后续的 <code>RUN</code> 也会使用指定用户。<br>当服务不需要管理员权限时，可以通过该命令指定运行用户。并且可以在之前创建所需要的用户，例如：<code>RUN groupadd -r postgres &amp;&amp; useradd -r -g postgres postgres</code>。要临时获取管理员权限可以使用 <code>gosu</code>，而不推荐 <code>sudo</code>。</p>\n<h2 id=\"WORKDIR\"><a href=\"#WORKDIR\" class=\"headerlink\" title=\"WORKDIR\"></a>WORKDIR</h2><p>格式为 <code>WORKDIR /path/to/workdir</code>。<br>为后续的 <code>RUN、CMD、ENTRYPOINT</code> 指令配置工作目录。<br>可以使用多个 <code>WORKDIR</code> 指令，后续命令如果参数是相对路径，则会基于之前命令指定的路径。<br>例如</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">WORKDIR /a</span><br><span class=\"line\">WORKDIR b</span><br><span class=\"line\">WORKDIR c</span><br><span class=\"line\">RUN pwd</span><br></pre></td></tr></table></figure>\n<p>则最终路径为 <code>/a/b/c</code>。</p>\n<h2 id=\"ONBUILD\"><a href=\"#ONBUILD\" class=\"headerlink\" title=\"ONBUILD\"></a>ONBUILD</h2><p>格式为 <code>ONBUILD [INSTRUCTION]</code>。<br>配置当所创建的镜像作为其它新创建镜像的基础镜像时，所执行的操作指令。<br>例如，Dockerfile 使用如下的内容创建了镜像 <code>image-A</code>。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[...]</span><br><span class=\"line\">ONBUILD ADD . /app/src</span><br><span class=\"line\">ONBUILD RUN /usr/local/bin/python-build --dir /app/src</span><br><span class=\"line\">[...]</span><br></pre></td></tr></table></figure>\n<p>如果基于 <code>image-A</code> 创建新的镜像时，新的Dockerfile中使用 <code>FROM image-A</code>指定基础镜像时，会自动执行 <code>ONBUILD</code> 指令内容，等价于在后面添加了两条指令。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">FROM image-A</span><br><span class=\"line\"></span><br><span class=\"line\">#Automatically run the following</span><br><span class=\"line\">ADD . /app/src</span><br><span class=\"line\">RUN /usr/local/bin/python-build --dir /app/src</span><br></pre></td></tr></table></figure>\n<p>使用 <code>ONBUILD</code> 指令的镜像，推荐在标签中注明，例如 <code>ruby:1.9-onbuild</code>。</p>\n<h1 id=\"创建镜像\"><a href=\"#创建镜像\" class=\"headerlink\" title=\"创建镜像\"></a>创建镜像</h1><p>编写完成 Dockerfile 之后，可以通过 <code>docker build</code> 命令来创建镜像。<br>基本的格式为 <code>docker build [选项]</code> 路径，该命令将读取指定路径下（包括子目录）的 Dockerfile，并将该路径下所有内容发送给 Docker 服务端，由服务端来创建镜像。因此一般建议放置 Dockerfile 的目录为空目录。也可以通过 <code>.dockerignore</code>文件（每一行添加一条匹配模式）来让 Docker 忽略路径下的目录和文件。<br>要指定镜像的标签信息，可以通过 <code>-t</code> 选项，<br>例如:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo docker build -t myrepo/myapp /tmp/test1/</span><br></pre></td></tr></table></figure>\n\n<hr>\n<p><a href=\"https://yeasy.gitbooks.io/docker_practice/content/dockerfile/index.html\">https://yeasy.gitbooks.io/docker_practice/content/dockerfile/index.html</a></p>\n<p><em>观点仅代表自己，期待你的留言。</em></p>\n"},{"title":"Docker安装问题汇总","date":"2016-04-06T01:55:49.000Z","_content":"### 测试环境\nCentos7_x86_64\n```bash\n[root@localhost ~]# uname -a\nLinux localhost.localdomain 3.10.0-123.el7.x86_64 #1 SMP Mon Jun 30 12:09:22 UTC 2014 x86_64 x86_64 x86_64 GNU/Linux\n```\n### 增加yum源\n```bash\n[root@localhost ~]# sudo tee /etc/yum.repos.d/docker.repo <<-'EOF'\n[dockerrepo]\nname=Docker Repository\nbaseurl=https://yum.dockerproject.org/repo/main/centos/$releasever/\nenabled=1\ngpgcheck=1\ngpgkey=https://yum.dockerproject.org/gpg\nEOF\n```\n### 文件冲突\nTransaction check error:\n  file /usr/lib/systemd/system/blk-availability.service from install of device-mapper-7:1.02.107-5.el7_2.1.x86_64 conflicts with file from package lvm2-7:2.02.105-14.el7.x86_64\n  file /usr/sbin/blkdeactivate from install of device-mapper-7:1.02.107-5.el7_2.1.x86_64 conflicts with file from package lvm2-7:2.02.105-14.el7.x86_64\n  file /usr/share/man/man8/blkdeactivate.8.gz from install of device-mapper-7:1.02.107-5.el7_2.1.x86_64 conflicts with file from package lvm2-7:2.02.105-14.el7.x86_64\n\n`解决方法:` 先安装lvm2\n```bash\n[root@localhost ~]# sudo yum install lvm2 -y\n[root@localhost ~]# sudo yum install docker -y\n[root@localhost ~]# docker -v\nDocker version 1.10.3, build 20f81d\n```\n### Docker daemon未运行\n[root@localhost ~]# docker pull ubuntu\nUsing default tag: latest\nWarning: failed to get default registry endpoint from daemon (Cannot connect to the Docker daemon. Is the docker daemon running on this host?). Using system default: https://index.docker.io/v1/\nCannot connect to the Docker daemon. Is the docker daemon running on this host?\n`解决方法:` 重启docker服务\n```bash\n[root@localhost ~]# service docker restart\nRedirecting to /bin/systemctl restart  docker.service\n```\n### Docker被墙\n[root@localhost ~]# docker pull centos\nUsing default tag: latest\nPulling repository docker.io/library/centos\nError while pulling image: Get https://index.docker.io/v1/repositories/library/centos/images: dial tcp: lookup index.docker.io on 10.28.10.166:53: no such host\n\n由于docker镜像站被墙，推荐使用[灵雀云镜像](https://hub.alauda.cn/)\n`解决方法:` pull的时候使用国内镜像地址\n```bash\n[root@localhost ~]# docker pull index.alauda.cn/tutum/centos\nUsing default tag: latest\nlatest: Pulling from tutum/centos\na3ed95caeb02: Pull complete \n196355c4b639: Pull complete \nedd0a8ebcd9d: Pull complete \n8ba44ed17115: Pull complete \n69f7e70c0063: Pull complete \n54abd94c9217: Pull complete \nDigest: sha256:11bc5863ca1643f1de49962c2741c3d1feca37ef258d5dd91baa2cca9a82b5b5\nStatus: Downloaded newer image for index.alauda.cn/tutum/centos:latest\n[root@localhost ~]# docker images\nREPOSITORY                     TAG                 IMAGE ID            CREATED             SIZE\nindex.alauda.cn/tutum/centos   latest              e90ef4c35b09        2 weeks ago         297.3 MB\n```\n\n-----\n\n\n*观点仅代表自己，期待你的留言。*\n","source":"_posts/docker-install-issue.md","raw":"---\ntitle: Docker安装问题汇总\ntags:\n  - Docker\n  - 原创\ndate: 2016-04-06 09:55:49\n---\n### 测试环境\nCentos7_x86_64\n```bash\n[root@localhost ~]# uname -a\nLinux localhost.localdomain 3.10.0-123.el7.x86_64 #1 SMP Mon Jun 30 12:09:22 UTC 2014 x86_64 x86_64 x86_64 GNU/Linux\n```\n### 增加yum源\n```bash\n[root@localhost ~]# sudo tee /etc/yum.repos.d/docker.repo <<-'EOF'\n[dockerrepo]\nname=Docker Repository\nbaseurl=https://yum.dockerproject.org/repo/main/centos/$releasever/\nenabled=1\ngpgcheck=1\ngpgkey=https://yum.dockerproject.org/gpg\nEOF\n```\n### 文件冲突\nTransaction check error:\n  file /usr/lib/systemd/system/blk-availability.service from install of device-mapper-7:1.02.107-5.el7_2.1.x86_64 conflicts with file from package lvm2-7:2.02.105-14.el7.x86_64\n  file /usr/sbin/blkdeactivate from install of device-mapper-7:1.02.107-5.el7_2.1.x86_64 conflicts with file from package lvm2-7:2.02.105-14.el7.x86_64\n  file /usr/share/man/man8/blkdeactivate.8.gz from install of device-mapper-7:1.02.107-5.el7_2.1.x86_64 conflicts with file from package lvm2-7:2.02.105-14.el7.x86_64\n\n`解决方法:` 先安装lvm2\n```bash\n[root@localhost ~]# sudo yum install lvm2 -y\n[root@localhost ~]# sudo yum install docker -y\n[root@localhost ~]# docker -v\nDocker version 1.10.3, build 20f81d\n```\n### Docker daemon未运行\n[root@localhost ~]# docker pull ubuntu\nUsing default tag: latest\nWarning: failed to get default registry endpoint from daemon (Cannot connect to the Docker daemon. Is the docker daemon running on this host?). Using system default: https://index.docker.io/v1/\nCannot connect to the Docker daemon. Is the docker daemon running on this host?\n`解决方法:` 重启docker服务\n```bash\n[root@localhost ~]# service docker restart\nRedirecting to /bin/systemctl restart  docker.service\n```\n### Docker被墙\n[root@localhost ~]# docker pull centos\nUsing default tag: latest\nPulling repository docker.io/library/centos\nError while pulling image: Get https://index.docker.io/v1/repositories/library/centos/images: dial tcp: lookup index.docker.io on 10.28.10.166:53: no such host\n\n由于docker镜像站被墙，推荐使用[灵雀云镜像](https://hub.alauda.cn/)\n`解决方法:` pull的时候使用国内镜像地址\n```bash\n[root@localhost ~]# docker pull index.alauda.cn/tutum/centos\nUsing default tag: latest\nlatest: Pulling from tutum/centos\na3ed95caeb02: Pull complete \n196355c4b639: Pull complete \nedd0a8ebcd9d: Pull complete \n8ba44ed17115: Pull complete \n69f7e70c0063: Pull complete \n54abd94c9217: Pull complete \nDigest: sha256:11bc5863ca1643f1de49962c2741c3d1feca37ef258d5dd91baa2cca9a82b5b5\nStatus: Downloaded newer image for index.alauda.cn/tutum/centos:latest\n[root@localhost ~]# docker images\nREPOSITORY                     TAG                 IMAGE ID            CREATED             SIZE\nindex.alauda.cn/tutum/centos   latest              e90ef4c35b09        2 weeks ago         297.3 MB\n```\n\n-----\n\n\n*观点仅代表自己，期待你的留言。*\n","slug":"docker-install-issue","published":1,"updated":"2021-08-31T14:23:11.539Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cku52dymg0014bbinea6nhs91","content":"<h3 id=\"测试环境\"><a href=\"#测试环境\" class=\"headerlink\" title=\"测试环境\"></a>测试环境</h3><p>Centos7_x86_64</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@localhost ~]<span class=\"comment\"># uname -a</span></span><br><span class=\"line\">Linux localhost.localdomain 3.10.0-123.el7.x86_64 <span class=\"comment\">#1 SMP Mon Jun 30 12:09:22 UTC 2014 x86_64 x86_64 x86_64 GNU/Linux</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"增加yum源\"><a href=\"#增加yum源\" class=\"headerlink\" title=\"增加yum源\"></a>增加yum源</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@localhost ~]<span class=\"comment\"># sudo tee /etc/yum.repos.d/docker.repo &lt;&lt;-&#x27;EOF&#x27;</span></span><br><span class=\"line\">[dockerrepo]</span><br><span class=\"line\">name=Docker Repository</span><br><span class=\"line\">baseurl=https://yum.dockerproject.org/repo/main/centos/<span class=\"variable\">$releasever</span>/</span><br><span class=\"line\">enabled=1</span><br><span class=\"line\">gpgcheck=1</span><br><span class=\"line\">gpgkey=https://yum.dockerproject.org/gpg</span><br><span class=\"line\">EOF</span><br></pre></td></tr></table></figure>\n<h3 id=\"文件冲突\"><a href=\"#文件冲突\" class=\"headerlink\" title=\"文件冲突\"></a>文件冲突</h3><p>Transaction check error:<br>  file /usr/lib/systemd/system/blk-availability.service from install of device-mapper-7:1.02.107-5.el7_2.1.x86_64 conflicts with file from package lvm2-7:2.02.105-14.el7.x86_64<br>  file /usr/sbin/blkdeactivate from install of device-mapper-7:1.02.107-5.el7_2.1.x86_64 conflicts with file from package lvm2-7:2.02.105-14.el7.x86_64<br>  file /usr/share/man/man8/blkdeactivate.8.gz from install of device-mapper-7:1.02.107-5.el7_2.1.x86_64 conflicts with file from package lvm2-7:2.02.105-14.el7.x86_64</p>\n<p><code>解决方法:</code> 先安装lvm2</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@localhost ~]<span class=\"comment\"># sudo yum install lvm2 -y</span></span><br><span class=\"line\">[root@localhost ~]<span class=\"comment\"># sudo yum install docker -y</span></span><br><span class=\"line\">[root@localhost ~]<span class=\"comment\"># docker -v</span></span><br><span class=\"line\">Docker version 1.10.3, build 20f81d</span><br></pre></td></tr></table></figure>\n<h3 id=\"Docker-daemon未运行\"><a href=\"#Docker-daemon未运行\" class=\"headerlink\" title=\"Docker daemon未运行\"></a>Docker daemon未运行</h3><p>[root@localhost ~]# docker pull ubuntu<br>Using default tag: latest<br>Warning: failed to get default registry endpoint from daemon (Cannot connect to the Docker daemon. Is the docker daemon running on this host?). Using system default: <a href=\"https://index.docker.io/v1/\">https://index.docker.io/v1/</a><br>Cannot connect to the Docker daemon. Is the docker daemon running on this host?<br><code>解决方法:</code> 重启docker服务</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@localhost ~]<span class=\"comment\"># service docker restart</span></span><br><span class=\"line\">Redirecting to /bin/systemctl restart  docker.service</span><br></pre></td></tr></table></figure>\n<h3 id=\"Docker被墙\"><a href=\"#Docker被墙\" class=\"headerlink\" title=\"Docker被墙\"></a>Docker被墙</h3><p>[root@localhost ~]# docker pull centos<br>Using default tag: latest<br>Pulling repository docker.io/library/centos<br>Error while pulling image: Get <a href=\"https://index.docker.io/v1/repositories/library/centos/images\">https://index.docker.io/v1/repositories/library/centos/images</a>: dial tcp: lookup index.docker.io on 10.28.10.166:53: no such host</p>\n<p>由于docker镜像站被墙，推荐使用<a href=\"https://hub.alauda.cn/\">灵雀云镜像</a><br><code>解决方法:</code> pull的时候使用国内镜像地址</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@localhost ~]<span class=\"comment\"># docker pull index.alauda.cn/tutum/centos</span></span><br><span class=\"line\">Using default tag: latest</span><br><span class=\"line\">latest: Pulling from tutum/centos</span><br><span class=\"line\">a3ed95caeb02: Pull complete </span><br><span class=\"line\">196355c4b639: Pull complete </span><br><span class=\"line\">edd0a8ebcd9d: Pull complete </span><br><span class=\"line\">8ba44ed17115: Pull complete </span><br><span class=\"line\">69f7e70c0063: Pull complete </span><br><span class=\"line\">54abd94c9217: Pull complete </span><br><span class=\"line\">Digest: sha256:11bc5863ca1643f1de49962c2741c3d1feca37ef258d5dd91baa2cca9a82b5b5</span><br><span class=\"line\">Status: Downloaded newer image <span class=\"keyword\">for</span> index.alauda.cn/tutum/centos:latest</span><br><span class=\"line\">[root@localhost ~]<span class=\"comment\"># docker images</span></span><br><span class=\"line\">REPOSITORY                     TAG                 IMAGE ID            CREATED             SIZE</span><br><span class=\"line\">index.alauda.cn/tutum/centos   latest              e90ef4c35b09        2 weeks ago         297.3 MB</span><br></pre></td></tr></table></figure>\n\n<hr>\n<p><em>观点仅代表自己，期待你的留言。</em></p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"测试环境\"><a href=\"#测试环境\" class=\"headerlink\" title=\"测试环境\"></a>测试环境</h3><p>Centos7_x86_64</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@localhost ~]<span class=\"comment\"># uname -a</span></span><br><span class=\"line\">Linux localhost.localdomain 3.10.0-123.el7.x86_64 <span class=\"comment\">#1 SMP Mon Jun 30 12:09:22 UTC 2014 x86_64 x86_64 x86_64 GNU/Linux</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"增加yum源\"><a href=\"#增加yum源\" class=\"headerlink\" title=\"增加yum源\"></a>增加yum源</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@localhost ~]<span class=\"comment\"># sudo tee /etc/yum.repos.d/docker.repo &lt;&lt;-&#x27;EOF&#x27;</span></span><br><span class=\"line\">[dockerrepo]</span><br><span class=\"line\">name=Docker Repository</span><br><span class=\"line\">baseurl=https://yum.dockerproject.org/repo/main/centos/<span class=\"variable\">$releasever</span>/</span><br><span class=\"line\">enabled=1</span><br><span class=\"line\">gpgcheck=1</span><br><span class=\"line\">gpgkey=https://yum.dockerproject.org/gpg</span><br><span class=\"line\">EOF</span><br></pre></td></tr></table></figure>\n<h3 id=\"文件冲突\"><a href=\"#文件冲突\" class=\"headerlink\" title=\"文件冲突\"></a>文件冲突</h3><p>Transaction check error:<br>  file /usr/lib/systemd/system/blk-availability.service from install of device-mapper-7:1.02.107-5.el7_2.1.x86_64 conflicts with file from package lvm2-7:2.02.105-14.el7.x86_64<br>  file /usr/sbin/blkdeactivate from install of device-mapper-7:1.02.107-5.el7_2.1.x86_64 conflicts with file from package lvm2-7:2.02.105-14.el7.x86_64<br>  file /usr/share/man/man8/blkdeactivate.8.gz from install of device-mapper-7:1.02.107-5.el7_2.1.x86_64 conflicts with file from package lvm2-7:2.02.105-14.el7.x86_64</p>\n<p><code>解决方法:</code> 先安装lvm2</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@localhost ~]<span class=\"comment\"># sudo yum install lvm2 -y</span></span><br><span class=\"line\">[root@localhost ~]<span class=\"comment\"># sudo yum install docker -y</span></span><br><span class=\"line\">[root@localhost ~]<span class=\"comment\"># docker -v</span></span><br><span class=\"line\">Docker version 1.10.3, build 20f81d</span><br></pre></td></tr></table></figure>\n<h3 id=\"Docker-daemon未运行\"><a href=\"#Docker-daemon未运行\" class=\"headerlink\" title=\"Docker daemon未运行\"></a>Docker daemon未运行</h3><p>[root@localhost ~]# docker pull ubuntu<br>Using default tag: latest<br>Warning: failed to get default registry endpoint from daemon (Cannot connect to the Docker daemon. Is the docker daemon running on this host?). Using system default: <a href=\"https://index.docker.io/v1/\">https://index.docker.io/v1/</a><br>Cannot connect to the Docker daemon. Is the docker daemon running on this host?<br><code>解决方法:</code> 重启docker服务</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@localhost ~]<span class=\"comment\"># service docker restart</span></span><br><span class=\"line\">Redirecting to /bin/systemctl restart  docker.service</span><br></pre></td></tr></table></figure>\n<h3 id=\"Docker被墙\"><a href=\"#Docker被墙\" class=\"headerlink\" title=\"Docker被墙\"></a>Docker被墙</h3><p>[root@localhost ~]# docker pull centos<br>Using default tag: latest<br>Pulling repository docker.io/library/centos<br>Error while pulling image: Get <a href=\"https://index.docker.io/v1/repositories/library/centos/images\">https://index.docker.io/v1/repositories/library/centos/images</a>: dial tcp: lookup index.docker.io on 10.28.10.166:53: no such host</p>\n<p>由于docker镜像站被墙，推荐使用<a href=\"https://hub.alauda.cn/\">灵雀云镜像</a><br><code>解决方法:</code> pull的时候使用国内镜像地址</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@localhost ~]<span class=\"comment\"># docker pull index.alauda.cn/tutum/centos</span></span><br><span class=\"line\">Using default tag: latest</span><br><span class=\"line\">latest: Pulling from tutum/centos</span><br><span class=\"line\">a3ed95caeb02: Pull complete </span><br><span class=\"line\">196355c4b639: Pull complete </span><br><span class=\"line\">edd0a8ebcd9d: Pull complete </span><br><span class=\"line\">8ba44ed17115: Pull complete </span><br><span class=\"line\">69f7e70c0063: Pull complete </span><br><span class=\"line\">54abd94c9217: Pull complete </span><br><span class=\"line\">Digest: sha256:11bc5863ca1643f1de49962c2741c3d1feca37ef258d5dd91baa2cca9a82b5b5</span><br><span class=\"line\">Status: Downloaded newer image <span class=\"keyword\">for</span> index.alauda.cn/tutum/centos:latest</span><br><span class=\"line\">[root@localhost ~]<span class=\"comment\"># docker images</span></span><br><span class=\"line\">REPOSITORY                     TAG                 IMAGE ID            CREATED             SIZE</span><br><span class=\"line\">index.alauda.cn/tutum/centos   latest              e90ef4c35b09        2 weeks ago         297.3 MB</span><br></pre></td></tr></table></figure>\n\n<hr>\n<p><em>观点仅代表自己，期待你的留言。</em></p>\n"},{"title":"分布式事务最终一致性解决方案-DTCS","date":"2017-10-27T14:57:55.000Z","_content":"\n## 简介\nDTCS（Data Transfer Consistency Service）：数据一致性传输服务，通过MQ+一致性保障所实现的数据一致性传输服务。为全方面保障数据传输的一致性，增加运维人员人工介入纠正未及时实现数据一致性的处理方式。\n## 业务调用时序\n![业务调用时序](/images/dtcs-seq.jpg)\n\n## 后续\n__表决心:__ 此方案后续坚持实现后，必将开源于Github，届时请同行不吝指正。\n\n-----\n\n*观点仅代表自己，期待你的留言。*\n","source":"_posts/dtcs-seq.md","raw":"---\ntitle: 分布式事务最终一致性解决方案-DTCS\ntags:\n  - 原创\n  - 分布式事务\ndate: 2017-10-27 22:57:55\n---\n\n## 简介\nDTCS（Data Transfer Consistency Service）：数据一致性传输服务，通过MQ+一致性保障所实现的数据一致性传输服务。为全方面保障数据传输的一致性，增加运维人员人工介入纠正未及时实现数据一致性的处理方式。\n## 业务调用时序\n![业务调用时序](/images/dtcs-seq.jpg)\n\n## 后续\n__表决心:__ 此方案后续坚持实现后，必将开源于Github，届时请同行不吝指正。\n\n-----\n\n*观点仅代表自己，期待你的留言。*\n","slug":"dtcs-seq","published":1,"updated":"2021-08-31T14:23:11.540Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cku52dymh0017bbin00au8z3q","content":"<h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><p>DTCS（Data Transfer Consistency Service）：数据一致性传输服务，通过MQ+一致性保障所实现的数据一致性传输服务。为全方面保障数据传输的一致性，增加运维人员人工介入纠正未及时实现数据一致性的处理方式。</p>\n<h2 id=\"业务调用时序\"><a href=\"#业务调用时序\" class=\"headerlink\" title=\"业务调用时序\"></a>业务调用时序</h2><p><img src=\"/images/dtcs-seq.jpg\" alt=\"业务调用时序\"></p>\n<h2 id=\"后续\"><a href=\"#后续\" class=\"headerlink\" title=\"后续\"></a>后续</h2><p><strong>表决心:</strong> 此方案后续坚持实现后，必将开源于Github，届时请同行不吝指正。</p>\n<hr>\n<p><em>观点仅代表自己，期待你的留言。</em></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><p>DTCS（Data Transfer Consistency Service）：数据一致性传输服务，通过MQ+一致性保障所实现的数据一致性传输服务。为全方面保障数据传输的一致性，增加运维人员人工介入纠正未及时实现数据一致性的处理方式。</p>\n<h2 id=\"业务调用时序\"><a href=\"#业务调用时序\" class=\"headerlink\" title=\"业务调用时序\"></a>业务调用时序</h2><p><img src=\"/images/dtcs-seq.jpg\" alt=\"业务调用时序\"></p>\n<h2 id=\"后续\"><a href=\"#后续\" class=\"headerlink\" title=\"后续\"></a>后续</h2><p><strong>表决心:</strong> 此方案后续坚持实现后，必将开源于Github，届时请同行不吝指正。</p>\n<hr>\n<p><em>观点仅代表自己，期待你的留言。</em></p>\n"},{"title":"工具_源代码生成器GGCode","keywords":["生成器","GGCode"],"date":"2016-08-22T10:15:58.000Z","_content":"\n## 简介\n通过近期的努力，将编写的源代码生成器进行0.0.1版本的封版，代码生成器按数据表自动生成源代码包含简单业务的（增，删，改，查，分页等）。\n部分集成的开源框架已通过配置文件进行开关配置，方便按业务进行开启和关闭。欢迎大家使用。\nGithub地址：https://github.com/stotem/GGCode\n\n### 基础框架\n源代码生成框架: [rapid-framework](https://code.google.com/archive/p/rapid-framework/)\n\nUI框架: [sb-admin-2](https://startbootstrap.com/template-overviews/sb-admin-2/) \n\n代码框架: SpringMVC + mybatis + Velocity。\n\n代码架构: 经典三层架构(MVC), 增加rpc模块做为调用三方api模块, 增加manager模块设置为缓存层与事务层。\n\n主要转换规则:\n\n1. 数据表与数据列的注释做为UI展示title。\n2. 数据列的为空性、数据长度和是否可为空等属性转换为javax.validation的判断规则。\n3. 数据列的数据类型转换为实体对象属性的数据类型。\n\n### 集成功能\n1. 增加shiro做为权限管理框架。\n2. 为文档数据存储添加MongoDB支持。\n3. 为缓存增加Redis支持, 且自动配置Spring Cache为Redis缓存。\n4. 以Velocity做为页面模板语言。\n5. 增加javax.validation为服务端验证框架。且Controller自动验证传入参数。\n6. 采用bonecp对数据库连接池化管理。\n7. spring的响应数据采用多视图配置。\n\n### 如何使用?\n在bin目录中通过配置generator.xml后直接`java -jar GGCode-0.0.1.jar`\n\n### generator.xml配置说明\n详见generator.xml注释\n\n### 数据库设计要求\n为了规范生成的Code，针对数据表的设计，需要满足每张表包含以下字段，请使用者遵守：\n```\ndata_id bigint PRIMARY KEY COMMENT '数据主键(与业务主键区分)', \ndel_flag tinyint(1) DEFAULT 1 COMMENT '数据删除标识(1: 有效，2: 失效)',\ncreate_time timestamp COMMENT '数据创建时间',\nupdate_time timestamp COMMENT '数据最后update时间',\n```\n### 其它说明\n1. controller的访问URI不带后缀.\n2. 所有的页面文件后缀为view.\n\n### 生成后程序截图\n![](/images/list.png)\n\n![](/images/add.png)\n\n![](/images/update.png)\n\n![](/images/show.png)\n\n![](/images/delete.png)\n\n-----\n\n*观点仅代表自己，期待你的留言。*","source":"_posts/ggcode-lib.md","raw":"---\ntitle: 工具_源代码生成器GGCode\nkeywords: \n  - 生成器\n  - GGCode\ntags:\n  - 原创\ndate: 2016-08-22 18:15:58\n---\n\n## 简介\n通过近期的努力，将编写的源代码生成器进行0.0.1版本的封版，代码生成器按数据表自动生成源代码包含简单业务的（增，删，改，查，分页等）。\n部分集成的开源框架已通过配置文件进行开关配置，方便按业务进行开启和关闭。欢迎大家使用。\nGithub地址：https://github.com/stotem/GGCode\n\n### 基础框架\n源代码生成框架: [rapid-framework](https://code.google.com/archive/p/rapid-framework/)\n\nUI框架: [sb-admin-2](https://startbootstrap.com/template-overviews/sb-admin-2/) \n\n代码框架: SpringMVC + mybatis + Velocity。\n\n代码架构: 经典三层架构(MVC), 增加rpc模块做为调用三方api模块, 增加manager模块设置为缓存层与事务层。\n\n主要转换规则:\n\n1. 数据表与数据列的注释做为UI展示title。\n2. 数据列的为空性、数据长度和是否可为空等属性转换为javax.validation的判断规则。\n3. 数据列的数据类型转换为实体对象属性的数据类型。\n\n### 集成功能\n1. 增加shiro做为权限管理框架。\n2. 为文档数据存储添加MongoDB支持。\n3. 为缓存增加Redis支持, 且自动配置Spring Cache为Redis缓存。\n4. 以Velocity做为页面模板语言。\n5. 增加javax.validation为服务端验证框架。且Controller自动验证传入参数。\n6. 采用bonecp对数据库连接池化管理。\n7. spring的响应数据采用多视图配置。\n\n### 如何使用?\n在bin目录中通过配置generator.xml后直接`java -jar GGCode-0.0.1.jar`\n\n### generator.xml配置说明\n详见generator.xml注释\n\n### 数据库设计要求\n为了规范生成的Code，针对数据表的设计，需要满足每张表包含以下字段，请使用者遵守：\n```\ndata_id bigint PRIMARY KEY COMMENT '数据主键(与业务主键区分)', \ndel_flag tinyint(1) DEFAULT 1 COMMENT '数据删除标识(1: 有效，2: 失效)',\ncreate_time timestamp COMMENT '数据创建时间',\nupdate_time timestamp COMMENT '数据最后update时间',\n```\n### 其它说明\n1. controller的访问URI不带后缀.\n2. 所有的页面文件后缀为view.\n\n### 生成后程序截图\n![](/images/list.png)\n\n![](/images/add.png)\n\n![](/images/update.png)\n\n![](/images/show.png)\n\n![](/images/delete.png)\n\n-----\n\n*观点仅代表自己，期待你的留言。*","slug":"ggcode-lib","published":1,"updated":"2021-08-31T14:23:11.540Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cku52dymi0019bbin0b566tcv","content":"<h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><p>通过近期的努力，将编写的源代码生成器进行0.0.1版本的封版，代码生成器按数据表自动生成源代码包含简单业务的（增，删，改，查，分页等）。<br>部分集成的开源框架已通过配置文件进行开关配置，方便按业务进行开启和关闭。欢迎大家使用。<br>Github地址：<a href=\"https://github.com/stotem/GGCode\">https://github.com/stotem/GGCode</a></p>\n<h3 id=\"基础框架\"><a href=\"#基础框架\" class=\"headerlink\" title=\"基础框架\"></a>基础框架</h3><p>源代码生成框架: <a href=\"https://code.google.com/archive/p/rapid-framework/\">rapid-framework</a></p>\n<p>UI框架: <a href=\"https://startbootstrap.com/template-overviews/sb-admin-2/\">sb-admin-2</a> </p>\n<p>代码框架: SpringMVC + mybatis + Velocity。</p>\n<p>代码架构: 经典三层架构(MVC), 增加rpc模块做为调用三方api模块, 增加manager模块设置为缓存层与事务层。</p>\n<p>主要转换规则:</p>\n<ol>\n<li>数据表与数据列的注释做为UI展示title。</li>\n<li>数据列的为空性、数据长度和是否可为空等属性转换为javax.validation的判断规则。</li>\n<li>数据列的数据类型转换为实体对象属性的数据类型。</li>\n</ol>\n<h3 id=\"集成功能\"><a href=\"#集成功能\" class=\"headerlink\" title=\"集成功能\"></a>集成功能</h3><ol>\n<li>增加shiro做为权限管理框架。</li>\n<li>为文档数据存储添加MongoDB支持。</li>\n<li>为缓存增加Redis支持, 且自动配置Spring Cache为Redis缓存。</li>\n<li>以Velocity做为页面模板语言。</li>\n<li>增加javax.validation为服务端验证框架。且Controller自动验证传入参数。</li>\n<li>采用bonecp对数据库连接池化管理。</li>\n<li>spring的响应数据采用多视图配置。</li>\n</ol>\n<h3 id=\"如何使用\"><a href=\"#如何使用\" class=\"headerlink\" title=\"如何使用?\"></a>如何使用?</h3><p>在bin目录中通过配置generator.xml后直接<code>java -jar GGCode-0.0.1.jar</code></p>\n<h3 id=\"generator-xml配置说明\"><a href=\"#generator-xml配置说明\" class=\"headerlink\" title=\"generator.xml配置说明\"></a>generator.xml配置说明</h3><p>详见generator.xml注释</p>\n<h3 id=\"数据库设计要求\"><a href=\"#数据库设计要求\" class=\"headerlink\" title=\"数据库设计要求\"></a>数据库设计要求</h3><p>为了规范生成的Code，针对数据表的设计，需要满足每张表包含以下字段，请使用者遵守：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">data_id bigint PRIMARY KEY COMMENT &#x27;数据主键(与业务主键区分)&#x27;, </span><br><span class=\"line\">del_flag tinyint(1) DEFAULT 1 COMMENT &#x27;数据删除标识(1: 有效，2: 失效)&#x27;,</span><br><span class=\"line\">create_time timestamp COMMENT &#x27;数据创建时间&#x27;,</span><br><span class=\"line\">update_time timestamp COMMENT &#x27;数据最后update时间&#x27;,</span><br></pre></td></tr></table></figure>\n<h3 id=\"其它说明\"><a href=\"#其它说明\" class=\"headerlink\" title=\"其它说明\"></a>其它说明</h3><ol>\n<li>controller的访问URI不带后缀.</li>\n<li>所有的页面文件后缀为view.</li>\n</ol>\n<h3 id=\"生成后程序截图\"><a href=\"#生成后程序截图\" class=\"headerlink\" title=\"生成后程序截图\"></a>生成后程序截图</h3><p><img src=\"/images/list.png\"></p>\n<p><img src=\"/images/add.png\"></p>\n<p><img src=\"/images/update.png\"></p>\n<p><img src=\"/images/show.png\"></p>\n<p><img src=\"/images/delete.png\"></p>\n<hr>\n<p><em>观点仅代表自己，期待你的留言。</em></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><p>通过近期的努力，将编写的源代码生成器进行0.0.1版本的封版，代码生成器按数据表自动生成源代码包含简单业务的（增，删，改，查，分页等）。<br>部分集成的开源框架已通过配置文件进行开关配置，方便按业务进行开启和关闭。欢迎大家使用。<br>Github地址：<a href=\"https://github.com/stotem/GGCode\">https://github.com/stotem/GGCode</a></p>\n<h3 id=\"基础框架\"><a href=\"#基础框架\" class=\"headerlink\" title=\"基础框架\"></a>基础框架</h3><p>源代码生成框架: <a href=\"https://code.google.com/archive/p/rapid-framework/\">rapid-framework</a></p>\n<p>UI框架: <a href=\"https://startbootstrap.com/template-overviews/sb-admin-2/\">sb-admin-2</a> </p>\n<p>代码框架: SpringMVC + mybatis + Velocity。</p>\n<p>代码架构: 经典三层架构(MVC), 增加rpc模块做为调用三方api模块, 增加manager模块设置为缓存层与事务层。</p>\n<p>主要转换规则:</p>\n<ol>\n<li>数据表与数据列的注释做为UI展示title。</li>\n<li>数据列的为空性、数据长度和是否可为空等属性转换为javax.validation的判断规则。</li>\n<li>数据列的数据类型转换为实体对象属性的数据类型。</li>\n</ol>\n<h3 id=\"集成功能\"><a href=\"#集成功能\" class=\"headerlink\" title=\"集成功能\"></a>集成功能</h3><ol>\n<li>增加shiro做为权限管理框架。</li>\n<li>为文档数据存储添加MongoDB支持。</li>\n<li>为缓存增加Redis支持, 且自动配置Spring Cache为Redis缓存。</li>\n<li>以Velocity做为页面模板语言。</li>\n<li>增加javax.validation为服务端验证框架。且Controller自动验证传入参数。</li>\n<li>采用bonecp对数据库连接池化管理。</li>\n<li>spring的响应数据采用多视图配置。</li>\n</ol>\n<h3 id=\"如何使用\"><a href=\"#如何使用\" class=\"headerlink\" title=\"如何使用?\"></a>如何使用?</h3><p>在bin目录中通过配置generator.xml后直接<code>java -jar GGCode-0.0.1.jar</code></p>\n<h3 id=\"generator-xml配置说明\"><a href=\"#generator-xml配置说明\" class=\"headerlink\" title=\"generator.xml配置说明\"></a>generator.xml配置说明</h3><p>详见generator.xml注释</p>\n<h3 id=\"数据库设计要求\"><a href=\"#数据库设计要求\" class=\"headerlink\" title=\"数据库设计要求\"></a>数据库设计要求</h3><p>为了规范生成的Code，针对数据表的设计，需要满足每张表包含以下字段，请使用者遵守：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">data_id bigint PRIMARY KEY COMMENT &#x27;数据主键(与业务主键区分)&#x27;, </span><br><span class=\"line\">del_flag tinyint(1) DEFAULT 1 COMMENT &#x27;数据删除标识(1: 有效，2: 失效)&#x27;,</span><br><span class=\"line\">create_time timestamp COMMENT &#x27;数据创建时间&#x27;,</span><br><span class=\"line\">update_time timestamp COMMENT &#x27;数据最后update时间&#x27;,</span><br></pre></td></tr></table></figure>\n<h3 id=\"其它说明\"><a href=\"#其它说明\" class=\"headerlink\" title=\"其它说明\"></a>其它说明</h3><ol>\n<li>controller的访问URI不带后缀.</li>\n<li>所有的页面文件后缀为view.</li>\n</ol>\n<h3 id=\"生成后程序截图\"><a href=\"#生成后程序截图\" class=\"headerlink\" title=\"生成后程序截图\"></a>生成后程序截图</h3><p><img src=\"/images/list.png\"></p>\n<p><img src=\"/images/add.png\"></p>\n<p><img src=\"/images/update.png\"></p>\n<p><img src=\"/images/show.png\"></p>\n<p><img src=\"/images/delete.png\"></p>\n<hr>\n<p><em>观点仅代表自己，期待你的留言。</em></p>\n"},{"title":"关于电商系统业务模块猜想","date":"2016-03-11T07:30:07.000Z","_content":"\n##### 电商四大体系\n - 企业信息化\n - 电商网络体系\n - 线上监控体系\n - 数据分析体系\n\n![电商四大体系](/images/四大体系.png)\n\n##### 电商业务模块\n\n经过与朋友们的讨论，笔者着手总结电商应包含的模块如下：\n\n![电商业务模块总览](/images/电商业务模块总览.png)\n\n\n\n笔者认为电商门户建设应从企业信息化建设入手，逐步加入电商元素，最终形成企业电商。\n\n\n\n\n-----\n\n\n*观点仅代表自己，期待你的留言。*\n","source":"_posts/e-bussiness-architecture.md","raw":"---\ntitle: 关于电商系统业务模块猜想\ntags:\n  - 原创\n  - 电商\n  - 架构\ndate: 2016-03-11 15:30:07\n---\n\n##### 电商四大体系\n - 企业信息化\n - 电商网络体系\n - 线上监控体系\n - 数据分析体系\n\n![电商四大体系](/images/四大体系.png)\n\n##### 电商业务模块\n\n经过与朋友们的讨论，笔者着手总结电商应包含的模块如下：\n\n![电商业务模块总览](/images/电商业务模块总览.png)\n\n\n\n笔者认为电商门户建设应从企业信息化建设入手，逐步加入电商元素，最终形成企业电商。\n\n\n\n\n-----\n\n\n*观点仅代表自己，期待你的留言。*\n","slug":"e-bussiness-architecture","published":1,"updated":"2021-08-31T14:23:11.540Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cku52dymj001cbbin023qh89d","content":"<h5 id=\"电商四大体系\"><a href=\"#电商四大体系\" class=\"headerlink\" title=\"电商四大体系\"></a>电商四大体系</h5><ul>\n<li>企业信息化</li>\n<li>电商网络体系</li>\n<li>线上监控体系</li>\n<li>数据分析体系</li>\n</ul>\n<p><img src=\"/images/%E5%9B%9B%E5%A4%A7%E4%BD%93%E7%B3%BB.png\" alt=\"电商四大体系\"></p>\n<h5 id=\"电商业务模块\"><a href=\"#电商业务模块\" class=\"headerlink\" title=\"电商业务模块\"></a>电商业务模块</h5><p>经过与朋友们的讨论，笔者着手总结电商应包含的模块如下：</p>\n<p><img src=\"/images/%E7%94%B5%E5%95%86%E4%B8%9A%E5%8A%A1%E6%A8%A1%E5%9D%97%E6%80%BB%E8%A7%88.png\" alt=\"电商业务模块总览\"></p>\n<p>笔者认为电商门户建设应从企业信息化建设入手，逐步加入电商元素，最终形成企业电商。</p>\n<hr>\n<p><em>观点仅代表自己，期待你的留言。</em></p>\n","site":{"data":{}},"excerpt":"","more":"<h5 id=\"电商四大体系\"><a href=\"#电商四大体系\" class=\"headerlink\" title=\"电商四大体系\"></a>电商四大体系</h5><ul>\n<li>企业信息化</li>\n<li>电商网络体系</li>\n<li>线上监控体系</li>\n<li>数据分析体系</li>\n</ul>\n<p><img src=\"/images/%E5%9B%9B%E5%A4%A7%E4%BD%93%E7%B3%BB.png\" alt=\"电商四大体系\"></p>\n<h5 id=\"电商业务模块\"><a href=\"#电商业务模块\" class=\"headerlink\" title=\"电商业务模块\"></a>电商业务模块</h5><p>经过与朋友们的讨论，笔者着手总结电商应包含的模块如下：</p>\n<p><img src=\"/images/%E7%94%B5%E5%95%86%E4%B8%9A%E5%8A%A1%E6%A8%A1%E5%9D%97%E6%80%BB%E8%A7%88.png\" alt=\"电商业务模块总览\"></p>\n<p>笔者认为电商门户建设应从企业信息化建设入手，逐步加入电商元素，最终形成企业电商。</p>\n<hr>\n<p><em>观点仅代表自己，期待你的留言。</em></p>\n"},{"title":"类Google分页算法","keywords":["类似Google分页算法"],"date":"2016-07-12T08:08:37.000Z","_content":"\n```\npublic class Pagination {\n\n    @Test\n    public void getPagination() {\n        final int[] paginationRegion = getPaginationRegion(6, 5, 10);\n        // 进行页码输出\n        System.out.println(Arrays.toString(paginationRegion));\n        for (int i=paginationRegion[0]; i<= paginationRegion[1];i++) {\n            //....\n        }\n    }\n\n    /**\n     * 类Google分页 - 获取需要显示的闭区间页码范围\n     * @param currPage 当前页码\n     * @param showNum 显示条数，为保持当前页码居中，建议为单数值\n     * @param totalPage 总页数\n     * @return 闭区间 页码范围\n     */\n    private static int[] getPaginationRegion(int currPage, int showNum, int totalPage) {\n        // 先进行基础运算\n        int startNum = currPage - showNum/2;\n        int endNum = currPage + showNum/2;\n        if (endNum > totalPage) {\n            endNum = totalPage;\n        }\n        if (startNum < 1) {\n            startNum = 1;\n        }\n        // 如果显示页码数量不够则进行补数\n        if(endNum - startNum < showNum) {\n            int tmp;\n            if ((tmp = endNum - showNum + 1) > 0) {\n                startNum = tmp;\n            }\n            else if((tmp = startNum + showNum - 1) < totalPage) {\n                endNum = tmp;\n            }\n        }\n        return new int[]{startNum, endNum};\n    }\n}\n```\n\n`注意：`输入的为闭区间(包含两端页码值)范围。\n\n-----\n\n*观点仅代表自己，期待你的留言。*","source":"_posts/google-pagination-note.md","raw":"---\ntitle: 类Google分页算法\nkeywords:\n  - 类似Google分页算法\ntags:\n  - 原创\ndate: 2016-07-12 16:08:37\n---\n\n```\npublic class Pagination {\n\n    @Test\n    public void getPagination() {\n        final int[] paginationRegion = getPaginationRegion(6, 5, 10);\n        // 进行页码输出\n        System.out.println(Arrays.toString(paginationRegion));\n        for (int i=paginationRegion[0]; i<= paginationRegion[1];i++) {\n            //....\n        }\n    }\n\n    /**\n     * 类Google分页 - 获取需要显示的闭区间页码范围\n     * @param currPage 当前页码\n     * @param showNum 显示条数，为保持当前页码居中，建议为单数值\n     * @param totalPage 总页数\n     * @return 闭区间 页码范围\n     */\n    private static int[] getPaginationRegion(int currPage, int showNum, int totalPage) {\n        // 先进行基础运算\n        int startNum = currPage - showNum/2;\n        int endNum = currPage + showNum/2;\n        if (endNum > totalPage) {\n            endNum = totalPage;\n        }\n        if (startNum < 1) {\n            startNum = 1;\n        }\n        // 如果显示页码数量不够则进行补数\n        if(endNum - startNum < showNum) {\n            int tmp;\n            if ((tmp = endNum - showNum + 1) > 0) {\n                startNum = tmp;\n            }\n            else if((tmp = startNum + showNum - 1) < totalPage) {\n                endNum = tmp;\n            }\n        }\n        return new int[]{startNum, endNum};\n    }\n}\n```\n\n`注意：`输入的为闭区间(包含两端页码值)范围。\n\n-----\n\n*观点仅代表自己，期待你的留言。*","slug":"google-pagination-note","published":1,"updated":"2021-08-31T14:23:11.541Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cku52dymu001ebbinbogecn5q","content":"<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class Pagination &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Test</span><br><span class=\"line\">    public void getPagination() &#123;</span><br><span class=\"line\">        final int[] paginationRegion = getPaginationRegion(6, 5, 10);</span><br><span class=\"line\">        // 进行页码输出</span><br><span class=\"line\">        System.out.println(Arrays.toString(paginationRegion));</span><br><span class=\"line\">        for (int i=paginationRegion[0]; i&lt;= paginationRegion[1];i++) &#123;</span><br><span class=\"line\">            //....</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * 类Google分页 - 获取需要显示的闭区间页码范围</span><br><span class=\"line\">     * @param currPage 当前页码</span><br><span class=\"line\">     * @param showNum 显示条数，为保持当前页码居中，建议为单数值</span><br><span class=\"line\">     * @param totalPage 总页数</span><br><span class=\"line\">     * @return 闭区间 页码范围</span><br><span class=\"line\">     */</span><br><span class=\"line\">    private static int[] getPaginationRegion(int currPage, int showNum, int totalPage) &#123;</span><br><span class=\"line\">        // 先进行基础运算</span><br><span class=\"line\">        int startNum = currPage - showNum/2;</span><br><span class=\"line\">        int endNum = currPage + showNum/2;</span><br><span class=\"line\">        if (endNum &gt; totalPage) &#123;</span><br><span class=\"line\">            endNum = totalPage;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        if (startNum &lt; 1) &#123;</span><br><span class=\"line\">            startNum = 1;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        // 如果显示页码数量不够则进行补数</span><br><span class=\"line\">        if(endNum - startNum &lt; showNum) &#123;</span><br><span class=\"line\">            int tmp;</span><br><span class=\"line\">            if ((tmp = endNum - showNum + 1) &gt; 0) &#123;</span><br><span class=\"line\">                startNum = tmp;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            else if((tmp = startNum + showNum - 1) &lt; totalPage) &#123;</span><br><span class=\"line\">                endNum = tmp;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return new int[]&#123;startNum, endNum&#125;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>注意：</code>输入的为闭区间(包含两端页码值)范围。</p>\n<hr>\n<p><em>观点仅代表自己，期待你的留言。</em></p>\n","site":{"data":{}},"excerpt":"","more":"<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class Pagination &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Test</span><br><span class=\"line\">    public void getPagination() &#123;</span><br><span class=\"line\">        final int[] paginationRegion = getPaginationRegion(6, 5, 10);</span><br><span class=\"line\">        // 进行页码输出</span><br><span class=\"line\">        System.out.println(Arrays.toString(paginationRegion));</span><br><span class=\"line\">        for (int i=paginationRegion[0]; i&lt;= paginationRegion[1];i++) &#123;</span><br><span class=\"line\">            //....</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * 类Google分页 - 获取需要显示的闭区间页码范围</span><br><span class=\"line\">     * @param currPage 当前页码</span><br><span class=\"line\">     * @param showNum 显示条数，为保持当前页码居中，建议为单数值</span><br><span class=\"line\">     * @param totalPage 总页数</span><br><span class=\"line\">     * @return 闭区间 页码范围</span><br><span class=\"line\">     */</span><br><span class=\"line\">    private static int[] getPaginationRegion(int currPage, int showNum, int totalPage) &#123;</span><br><span class=\"line\">        // 先进行基础运算</span><br><span class=\"line\">        int startNum = currPage - showNum/2;</span><br><span class=\"line\">        int endNum = currPage + showNum/2;</span><br><span class=\"line\">        if (endNum &gt; totalPage) &#123;</span><br><span class=\"line\">            endNum = totalPage;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        if (startNum &lt; 1) &#123;</span><br><span class=\"line\">            startNum = 1;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        // 如果显示页码数量不够则进行补数</span><br><span class=\"line\">        if(endNum - startNum &lt; showNum) &#123;</span><br><span class=\"line\">            int tmp;</span><br><span class=\"line\">            if ((tmp = endNum - showNum + 1) &gt; 0) &#123;</span><br><span class=\"line\">                startNum = tmp;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            else if((tmp = startNum + showNum - 1) &lt; totalPage) &#123;</span><br><span class=\"line\">                endNum = tmp;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return new int[]&#123;startNum, endNum&#125;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>注意：</code>输入的为闭区间(包含两端页码值)范围。</p>\n<hr>\n<p><em>观点仅代表自己，期待你的留言。</em></p>\n"},{"title":"开放平台Api的版本控制方案","date":"2016-03-21T09:02:06.000Z","_content":"\n## 简介\n做开放平台供外部调用的Api理论上变化越少针对调用者来讲越有利，随着开放平台的功能不断完善（优化）不可避免的需要添加新的资源，或者修改现有资源。因此Api的更新升级必不可少，但是，对于开放平台来讲从一开始就应该将对外提供的Api加入版本管理。一个长期稳定可用的开放平台才能被越来越多的用户使用。\n同理，Native的App与服务器Api也存在同样的关系，Native App安装在不同的移动设备上，如果Api变动都需要提示用户进行强制更新来适配新版本的Api接口，那么，App用户将异常烦躁甚至于将App从设备中Uninstall掉。\n\n查看众多论坛与博客，总结出目前实现有三种方式：\n* URI\n在访问Api中增加version段来告诉服务器所使用的Api版本（如：http://xxxx/api/customers/v1.1/1234  ）。 这种方式正是由于在uri中增加了version段，破坏掉了Api的统一访问URL。\n* Request Parameter\n在Api后增加请求参数来告诉服务器所使用的Api版本（如：http://xxxx/api/customers/1234?v=1.1 ）这种方式与第一种URI的方式类似。\n* Request Header\n在请求Api时在Request的请求头中增加Version值来告诉服务器所使用的Api版本。这种方式保留了Api统一访问的URL，版本号传递更隐秘。但需要客户端在请求时增加此参数来完成，所以需要App在开发之初就需要增加版本号的传递。\n\n综上所述，个人认为第三种 Request Header的传递方式具有统一了URL和Version段隐秘的优点，为最适合的传递方式。\n\n## Request Header方式实现版本控制\n说完了客户端传递版本号的方式之后，我们来看一下服务端的处理。按流行的MVC的方式来看，个人觉得应该在控制层之前增加Api的版本控制层来先对客户端的请求Api进行版本的预判。\n\n![](/images/QQ20160321-0.png)\n\n个人总结了一下，有以下几种预判结果：\n1: Api为所有版本提供服务。\n2: Api提供了最低版本，为大于此最低版本的请求提供服务。\n3: Api提供了服务的版本范围，为大于最低版本且小于最高版本的请求提供服务。\n4: Api已过期，由其它的Api代替。\n5: Api已废弃不再提供服务。\n\n按以上思路，按Java实现为例。可以通过 自定义注解（Annotation）+ 过滤器（Filter）实现。\n相似的方案还有：自定义注解 + 拦截器， 自定义注解 + Spring AOP\n同理，其它的语言均有类似技术可以实现。\n\n接下来我将在 https://github.com/stotem/header-version-filter.git 中公布我的Annotation+Filter实现。\n\n-----\n\n*观点仅代表自己，期待你的留言。*","source":"_posts/header-version.md","raw":"---\ntitle: 开放平台Api的版本控制方案\ntags:\n  - 原创\ndate: 2016-03-21 17:02:06\n---\n\n## 简介\n做开放平台供外部调用的Api理论上变化越少针对调用者来讲越有利，随着开放平台的功能不断完善（优化）不可避免的需要添加新的资源，或者修改现有资源。因此Api的更新升级必不可少，但是，对于开放平台来讲从一开始就应该将对外提供的Api加入版本管理。一个长期稳定可用的开放平台才能被越来越多的用户使用。\n同理，Native的App与服务器Api也存在同样的关系，Native App安装在不同的移动设备上，如果Api变动都需要提示用户进行强制更新来适配新版本的Api接口，那么，App用户将异常烦躁甚至于将App从设备中Uninstall掉。\n\n查看众多论坛与博客，总结出目前实现有三种方式：\n* URI\n在访问Api中增加version段来告诉服务器所使用的Api版本（如：http://xxxx/api/customers/v1.1/1234  ）。 这种方式正是由于在uri中增加了version段，破坏掉了Api的统一访问URL。\n* Request Parameter\n在Api后增加请求参数来告诉服务器所使用的Api版本（如：http://xxxx/api/customers/1234?v=1.1 ）这种方式与第一种URI的方式类似。\n* Request Header\n在请求Api时在Request的请求头中增加Version值来告诉服务器所使用的Api版本。这种方式保留了Api统一访问的URL，版本号传递更隐秘。但需要客户端在请求时增加此参数来完成，所以需要App在开发之初就需要增加版本号的传递。\n\n综上所述，个人认为第三种 Request Header的传递方式具有统一了URL和Version段隐秘的优点，为最适合的传递方式。\n\n## Request Header方式实现版本控制\n说完了客户端传递版本号的方式之后，我们来看一下服务端的处理。按流行的MVC的方式来看，个人觉得应该在控制层之前增加Api的版本控制层来先对客户端的请求Api进行版本的预判。\n\n![](/images/QQ20160321-0.png)\n\n个人总结了一下，有以下几种预判结果：\n1: Api为所有版本提供服务。\n2: Api提供了最低版本，为大于此最低版本的请求提供服务。\n3: Api提供了服务的版本范围，为大于最低版本且小于最高版本的请求提供服务。\n4: Api已过期，由其它的Api代替。\n5: Api已废弃不再提供服务。\n\n按以上思路，按Java实现为例。可以通过 自定义注解（Annotation）+ 过滤器（Filter）实现。\n相似的方案还有：自定义注解 + 拦截器， 自定义注解 + Spring AOP\n同理，其它的语言均有类似技术可以实现。\n\n接下来我将在 https://github.com/stotem/header-version-filter.git 中公布我的Annotation+Filter实现。\n\n-----\n\n*观点仅代表自己，期待你的留言。*","slug":"header-version","published":1,"updated":"2021-08-31T14:23:11.541Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cku52dymv001hbbin1c0v1am6","content":"<h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><p>做开放平台供外部调用的Api理论上变化越少针对调用者来讲越有利，随着开放平台的功能不断完善（优化）不可避免的需要添加新的资源，或者修改现有资源。因此Api的更新升级必不可少，但是，对于开放平台来讲从一开始就应该将对外提供的Api加入版本管理。一个长期稳定可用的开放平台才能被越来越多的用户使用。<br>同理，Native的App与服务器Api也存在同样的关系，Native App安装在不同的移动设备上，如果Api变动都需要提示用户进行强制更新来适配新版本的Api接口，那么，App用户将异常烦躁甚至于将App从设备中Uninstall掉。</p>\n<p>查看众多论坛与博客，总结出目前实现有三种方式：</p>\n<ul>\n<li>URI<br>在访问Api中增加version段来告诉服务器所使用的Api版本（如：<a href=\"http://xxxx/api/customers/v1.1/1234\">http://xxxx/api/customers/v1.1/1234</a>  ）。 这种方式正是由于在uri中增加了version段，破坏掉了Api的统一访问URL。</li>\n<li>Request Parameter<br>在Api后增加请求参数来告诉服务器所使用的Api版本（如：<a href=\"http://xxxx/api/customers/1234?v=1.1\">http://xxxx/api/customers/1234?v=1.1</a> ）这种方式与第一种URI的方式类似。</li>\n<li>Request Header<br>在请求Api时在Request的请求头中增加Version值来告诉服务器所使用的Api版本。这种方式保留了Api统一访问的URL，版本号传递更隐秘。但需要客户端在请求时增加此参数来完成，所以需要App在开发之初就需要增加版本号的传递。</li>\n</ul>\n<p>综上所述，个人认为第三种 Request Header的传递方式具有统一了URL和Version段隐秘的优点，为最适合的传递方式。</p>\n<h2 id=\"Request-Header方式实现版本控制\"><a href=\"#Request-Header方式实现版本控制\" class=\"headerlink\" title=\"Request Header方式实现版本控制\"></a>Request Header方式实现版本控制</h2><p>说完了客户端传递版本号的方式之后，我们来看一下服务端的处理。按流行的MVC的方式来看，个人觉得应该在控制层之前增加Api的版本控制层来先对客户端的请求Api进行版本的预判。</p>\n<p><img src=\"/images/QQ20160321-0.png\"></p>\n<p>个人总结了一下，有以下几种预判结果：<br>1: Api为所有版本提供服务。<br>2: Api提供了最低版本，为大于此最低版本的请求提供服务。<br>3: Api提供了服务的版本范围，为大于最低版本且小于最高版本的请求提供服务。<br>4: Api已过期，由其它的Api代替。<br>5: Api已废弃不再提供服务。</p>\n<p>按以上思路，按Java实现为例。可以通过 自定义注解（Annotation）+ 过滤器（Filter）实现。<br>相似的方案还有：自定义注解 + 拦截器， 自定义注解 + Spring AOP<br>同理，其它的语言均有类似技术可以实现。</p>\n<p>接下来我将在 <a href=\"https://github.com/stotem/header-version-filter.git\">https://github.com/stotem/header-version-filter.git</a> 中公布我的Annotation+Filter实现。</p>\n<hr>\n<p><em>观点仅代表自己，期待你的留言。</em></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><p>做开放平台供外部调用的Api理论上变化越少针对调用者来讲越有利，随着开放平台的功能不断完善（优化）不可避免的需要添加新的资源，或者修改现有资源。因此Api的更新升级必不可少，但是，对于开放平台来讲从一开始就应该将对外提供的Api加入版本管理。一个长期稳定可用的开放平台才能被越来越多的用户使用。<br>同理，Native的App与服务器Api也存在同样的关系，Native App安装在不同的移动设备上，如果Api变动都需要提示用户进行强制更新来适配新版本的Api接口，那么，App用户将异常烦躁甚至于将App从设备中Uninstall掉。</p>\n<p>查看众多论坛与博客，总结出目前实现有三种方式：</p>\n<ul>\n<li>URI<br>在访问Api中增加version段来告诉服务器所使用的Api版本（如：<a href=\"http://xxxx/api/customers/v1.1/1234\">http://xxxx/api/customers/v1.1/1234</a>  ）。 这种方式正是由于在uri中增加了version段，破坏掉了Api的统一访问URL。</li>\n<li>Request Parameter<br>在Api后增加请求参数来告诉服务器所使用的Api版本（如：<a href=\"http://xxxx/api/customers/1234?v=1.1\">http://xxxx/api/customers/1234?v=1.1</a> ）这种方式与第一种URI的方式类似。</li>\n<li>Request Header<br>在请求Api时在Request的请求头中增加Version值来告诉服务器所使用的Api版本。这种方式保留了Api统一访问的URL，版本号传递更隐秘。但需要客户端在请求时增加此参数来完成，所以需要App在开发之初就需要增加版本号的传递。</li>\n</ul>\n<p>综上所述，个人认为第三种 Request Header的传递方式具有统一了URL和Version段隐秘的优点，为最适合的传递方式。</p>\n<h2 id=\"Request-Header方式实现版本控制\"><a href=\"#Request-Header方式实现版本控制\" class=\"headerlink\" title=\"Request Header方式实现版本控制\"></a>Request Header方式实现版本控制</h2><p>说完了客户端传递版本号的方式之后，我们来看一下服务端的处理。按流行的MVC的方式来看，个人觉得应该在控制层之前增加Api的版本控制层来先对客户端的请求Api进行版本的预判。</p>\n<p><img src=\"/images/QQ20160321-0.png\"></p>\n<p>个人总结了一下，有以下几种预判结果：<br>1: Api为所有版本提供服务。<br>2: Api提供了最低版本，为大于此最低版本的请求提供服务。<br>3: Api提供了服务的版本范围，为大于最低版本且小于最高版本的请求提供服务。<br>4: Api已过期，由其它的Api代替。<br>5: Api已废弃不再提供服务。</p>\n<p>按以上思路，按Java实现为例。可以通过 自定义注解（Annotation）+ 过滤器（Filter）实现。<br>相似的方案还有：自定义注解 + 拦截器， 自定义注解 + Spring AOP<br>同理，其它的语言均有类似技术可以实现。</p>\n<p>接下来我将在 <a href=\"https://github.com/stotem/header-version-filter.git\">https://github.com/stotem/header-version-filter.git</a> 中公布我的Annotation+Filter实现。</p>\n<hr>\n<p><em>观点仅代表自己，期待你的留言。</em></p>\n"},{"title":"使用openssl与keytool完成https配置实例（转）","keywords":["https","keytool","openssl"],"date":"2018-09-13T02:37:12.000Z","_content":"## keytool单向认证实例\n### 1) 为服务器生成证书\n```bash\nwujianjun@smzc ~ $ keytool -genkey -keyalg RSA -dname \"cn=127.0.0.1,ou=inspur,o=none,l=shandong,st=jinan,c=cn\" -alias server -keypass 111111 -keystore server.keystore -storepass 111111 -validity 3650\n```\n_注：cn=127.0.0.1配置的是服务器IP_\n### 2) 生成csr\n生成csr文件用于提交CA认证生成证书使用。\n```bash\nwujianjun@smzc ~ $ keytool -certReq -alias server -keystore server.keystore -file ca.csr\n```\n### 3) 生成cer\n这个ca.cer是为了解决不信任时要导入的\n```bash\nwujianjun@smzc ~ $ keytool -export -alias server -keystore server.keystore -file ca.cer -storepass 111111\n```\n### 4) tomcat配置ssl\nclientAuth=\"false\"代表单向认证，配置如下：\n```xml\n<Connector SSLEnabled=\"true\" clientAuth=\"false\"\n        maxThreads=\"150\" port=\"8443\"\n        protocol=\"org.apache.coyote.http11.Http11Protocol\"或者HTTP/1.1\n        scheme=\"https\" secure=\"true\" sslProtocol=\"TLS\"\n        keystoreFile=\"/home/server.keystore\" keystorePass=\"111111\"/>\n```\n_注: Http11Protocol支持HTTP/1.1协议，是http1.1协议的ProtocolHandler实现。_\n\n### 5) 常见问题\n* __服务器的证书不受信任__\n  解决方法：\n  1、选择“继续前往（不安全）”，也能访问，但是此时就是以普通的HTTP方式进行信息传输了。\n  2、选择生成的`ca.cer`文件，将证书存储在 __“受信任的证书颁发机构”__ ，就可以通过HTTPS正常访问了。\n* __程序访问Https异常__\n__sun.security.validator.ValidatorException: PKIX path building failed...__\n需要将生成的证书(ca.cer ) 导入到jdk中\n执行以下命令：\n```bash\nwujianjun@smzc ~ $ keytool -import -alias tomcatsso -file \"ca.cer\" -keystore \"D:\\java\\jdk1.6.0_11\\jre\\lib\\security\\cacerts\" -storepass changeit\n```\n_其中`changeit`是jre默认的密码。_\n__No subject alternative names present__，请在生成keystore 注意CN必须要为域名（或机器名称)例如 localhost 不能为IP 。\n__No name matching localhost found__，表示你生成keystore CN的名称和你访问的名称不一致。\n\n## openssl双向认证实例\n_Linux环境下，在home下建立out32dll目录，在此目录下建立ca、client、server三个文件夹。以下命令均在out32dll目录下执行。_\n### 1) 模拟CA生成证书\n* 创建私钥\n```bash\nwujianjun@smzc ~/out32dll $ openssl genrsa -out ca/ca-key.pem 1024\n```\n* 创建证书请求\n```bash\nwujianjun@smzc ~/out32dll $ openssl req -new -out ca/ca-req.csr -key ca/ca-key.pem\n```\n* 自签署证书\n```bash\nwujianjun@smzc ~/out32dll $ openssl x509 -req -in ca/ca-req.csr -out ca/ca-cert.pem -signkey ca/ca-key.pem -days 3650\n```\n* 将证书导出成浏览器支持的.p12格式 (供浏览器不受信任时导入)\n```bash\nwujianjun@smzc ~/out32dll $ openssl pkcs12 -export -clcerts -in ca/ca-cert.pem -inkey ca/ca-key.pem -out ca/ca.p12\n```\n_密码：111111_\n### 2) 生成Server证书\n* 创建私钥\n```bash\nwujianjun@smzc ~/out32dll $ openssl genrsa -out server/server-key.pem 1024\n```\n* 创建Server证书请求\n```bash\nwujianjun@smzc ~/out32dll $ openssl req -new -out server/server-req.csr -key server/server-key.pem\n```\n* 使用CA证书签署Server证书\n```bash\nwujianjun@smzc ~/out32dll $ openssl x509 -req -in server/server-req.csr -out server/server-cert.pem -signkey server/server-key.pem -CA ca/ca-cert.pem -CAkey ca/ca-key.pem -CAcreateserial -days 3650\n```\n* 将证书导出成浏览器支持的.p12格式\n```bash\nwujianjun@smzc ~/out32dll $ openssl pkcs12 -export -clcerts -in server/server-cert.pem -inkey server/server-key.pem -out server/server.p12\n```\n_密码：111111_\n### 3) 生成Clinet证书\n* 创建私钥\n```bash\nwujianjun@smzc ~/out32dll $ openssl genrsa -out client/client-key.pem 1024\n```\n* 创建Client证书请求\n```bash\nwujianjun@smzc ~/out32dll $ openssl req -new -out client/client-req.csr -key client/client-key.pem\n```\n* 使用CA证书签署Client证书\n```bash\nwujianjun@smzc ~/out32dll $ openssl x509 -req -in client/client-req.csr -out client/client-cert.pem -signkey client/client-key.pem -CA ca/ca-cert.pem -CAkey ca/ca-key.pem -CAcreateserial -days 3650  \n```\n* 将证书导出成浏览器支持的.p12格式\n```bash\nwujianjun@smzc ~/out32dll $ openssl pkcs12 -export -clcerts -in client/client-cert.pem -inkey client/client-key.pem -out client/client.p12\n```\n_密码：111111_\n### 4) 根据CA证书生成jks文件\n```bash\nwujianjun@smzc ~/out32dll $ keytool -keystore truststore.jks -keypass 222222 -storepass 222222 -alias ca -import -trustcacerts -file /home/out32dll/ca/ca-cert.pem\n```\n\n### 5) 服务器配置（tomcat6示例）\n修改conf/server.xml。 将keystoreFile、truststoreFile的路径填写为正确的放置路径。\n```xml\n<Connector port=\"8443\" protocol=\"HTTP/1.1\" SSLEnabled=\"true\"\n                maxThreads=\"150\" scheme=\"https\" secure=\"true\"\n                clientAuth=\"true\" sslProtocol=\"TLS\"\n                keystoreFile=\"/home/out32dll/server/server.p12\" keystorePass=\"111111\"  keystoreType=\"PKCS12\"\n                truststoreFile=\"/home/out32dll/truststore.jks\" truststorePass=\"222222\" truststoreType=\"JKS\"/>\n```\n### 6) 导入证书(IE示例)\n将ca.p12，client.p12分别导入到IE中去（打开IE->Internet选项->内容->证书）。 ca.p12导入至 受信任的根证书颁发机构，client.p12导入至个人。\n_进行浏览器访问双向Https时会弹出客户端证书供选择_\n\n-----\n\n*观点仅代表自己，期待你的留言。*\n","source":"_posts/https-cr-demo.md","raw":"---\ntitle: 使用openssl与keytool完成https配置实例（转）\ntags:\n  - 原创\n  - https\nkeywords:\n  - https\n  - keytool\n  - openssl\ndate: 2018-09-13 10:37:12\n---\n## keytool单向认证实例\n### 1) 为服务器生成证书\n```bash\nwujianjun@smzc ~ $ keytool -genkey -keyalg RSA -dname \"cn=127.0.0.1,ou=inspur,o=none,l=shandong,st=jinan,c=cn\" -alias server -keypass 111111 -keystore server.keystore -storepass 111111 -validity 3650\n```\n_注：cn=127.0.0.1配置的是服务器IP_\n### 2) 生成csr\n生成csr文件用于提交CA认证生成证书使用。\n```bash\nwujianjun@smzc ~ $ keytool -certReq -alias server -keystore server.keystore -file ca.csr\n```\n### 3) 生成cer\n这个ca.cer是为了解决不信任时要导入的\n```bash\nwujianjun@smzc ~ $ keytool -export -alias server -keystore server.keystore -file ca.cer -storepass 111111\n```\n### 4) tomcat配置ssl\nclientAuth=\"false\"代表单向认证，配置如下：\n```xml\n<Connector SSLEnabled=\"true\" clientAuth=\"false\"\n        maxThreads=\"150\" port=\"8443\"\n        protocol=\"org.apache.coyote.http11.Http11Protocol\"或者HTTP/1.1\n        scheme=\"https\" secure=\"true\" sslProtocol=\"TLS\"\n        keystoreFile=\"/home/server.keystore\" keystorePass=\"111111\"/>\n```\n_注: Http11Protocol支持HTTP/1.1协议，是http1.1协议的ProtocolHandler实现。_\n\n### 5) 常见问题\n* __服务器的证书不受信任__\n  解决方法：\n  1、选择“继续前往（不安全）”，也能访问，但是此时就是以普通的HTTP方式进行信息传输了。\n  2、选择生成的`ca.cer`文件，将证书存储在 __“受信任的证书颁发机构”__ ，就可以通过HTTPS正常访问了。\n* __程序访问Https异常__\n__sun.security.validator.ValidatorException: PKIX path building failed...__\n需要将生成的证书(ca.cer ) 导入到jdk中\n执行以下命令：\n```bash\nwujianjun@smzc ~ $ keytool -import -alias tomcatsso -file \"ca.cer\" -keystore \"D:\\java\\jdk1.6.0_11\\jre\\lib\\security\\cacerts\" -storepass changeit\n```\n_其中`changeit`是jre默认的密码。_\n__No subject alternative names present__，请在生成keystore 注意CN必须要为域名（或机器名称)例如 localhost 不能为IP 。\n__No name matching localhost found__，表示你生成keystore CN的名称和你访问的名称不一致。\n\n## openssl双向认证实例\n_Linux环境下，在home下建立out32dll目录，在此目录下建立ca、client、server三个文件夹。以下命令均在out32dll目录下执行。_\n### 1) 模拟CA生成证书\n* 创建私钥\n```bash\nwujianjun@smzc ~/out32dll $ openssl genrsa -out ca/ca-key.pem 1024\n```\n* 创建证书请求\n```bash\nwujianjun@smzc ~/out32dll $ openssl req -new -out ca/ca-req.csr -key ca/ca-key.pem\n```\n* 自签署证书\n```bash\nwujianjun@smzc ~/out32dll $ openssl x509 -req -in ca/ca-req.csr -out ca/ca-cert.pem -signkey ca/ca-key.pem -days 3650\n```\n* 将证书导出成浏览器支持的.p12格式 (供浏览器不受信任时导入)\n```bash\nwujianjun@smzc ~/out32dll $ openssl pkcs12 -export -clcerts -in ca/ca-cert.pem -inkey ca/ca-key.pem -out ca/ca.p12\n```\n_密码：111111_\n### 2) 生成Server证书\n* 创建私钥\n```bash\nwujianjun@smzc ~/out32dll $ openssl genrsa -out server/server-key.pem 1024\n```\n* 创建Server证书请求\n```bash\nwujianjun@smzc ~/out32dll $ openssl req -new -out server/server-req.csr -key server/server-key.pem\n```\n* 使用CA证书签署Server证书\n```bash\nwujianjun@smzc ~/out32dll $ openssl x509 -req -in server/server-req.csr -out server/server-cert.pem -signkey server/server-key.pem -CA ca/ca-cert.pem -CAkey ca/ca-key.pem -CAcreateserial -days 3650\n```\n* 将证书导出成浏览器支持的.p12格式\n```bash\nwujianjun@smzc ~/out32dll $ openssl pkcs12 -export -clcerts -in server/server-cert.pem -inkey server/server-key.pem -out server/server.p12\n```\n_密码：111111_\n### 3) 生成Clinet证书\n* 创建私钥\n```bash\nwujianjun@smzc ~/out32dll $ openssl genrsa -out client/client-key.pem 1024\n```\n* 创建Client证书请求\n```bash\nwujianjun@smzc ~/out32dll $ openssl req -new -out client/client-req.csr -key client/client-key.pem\n```\n* 使用CA证书签署Client证书\n```bash\nwujianjun@smzc ~/out32dll $ openssl x509 -req -in client/client-req.csr -out client/client-cert.pem -signkey client/client-key.pem -CA ca/ca-cert.pem -CAkey ca/ca-key.pem -CAcreateserial -days 3650  \n```\n* 将证书导出成浏览器支持的.p12格式\n```bash\nwujianjun@smzc ~/out32dll $ openssl pkcs12 -export -clcerts -in client/client-cert.pem -inkey client/client-key.pem -out client/client.p12\n```\n_密码：111111_\n### 4) 根据CA证书生成jks文件\n```bash\nwujianjun@smzc ~/out32dll $ keytool -keystore truststore.jks -keypass 222222 -storepass 222222 -alias ca -import -trustcacerts -file /home/out32dll/ca/ca-cert.pem\n```\n\n### 5) 服务器配置（tomcat6示例）\n修改conf/server.xml。 将keystoreFile、truststoreFile的路径填写为正确的放置路径。\n```xml\n<Connector port=\"8443\" protocol=\"HTTP/1.1\" SSLEnabled=\"true\"\n                maxThreads=\"150\" scheme=\"https\" secure=\"true\"\n                clientAuth=\"true\" sslProtocol=\"TLS\"\n                keystoreFile=\"/home/out32dll/server/server.p12\" keystorePass=\"111111\"  keystoreType=\"PKCS12\"\n                truststoreFile=\"/home/out32dll/truststore.jks\" truststorePass=\"222222\" truststoreType=\"JKS\"/>\n```\n### 6) 导入证书(IE示例)\n将ca.p12，client.p12分别导入到IE中去（打开IE->Internet选项->内容->证书）。 ca.p12导入至 受信任的根证书颁发机构，client.p12导入至个人。\n_进行浏览器访问双向Https时会弹出客户端证书供选择_\n\n-----\n\n*观点仅代表自己，期待你的留言。*\n","slug":"https-cr-demo","published":1,"updated":"2021-08-31T14:23:11.541Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cku52dymw001jbbinec2hhiyy","content":"<h2 id=\"keytool单向认证实例\"><a href=\"#keytool单向认证实例\" class=\"headerlink\" title=\"keytool单向认证实例\"></a>keytool单向认证实例</h2><h3 id=\"1-为服务器生成证书\"><a href=\"#1-为服务器生成证书\" class=\"headerlink\" title=\"1) 为服务器生成证书\"></a>1) 为服务器生成证书</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wujianjun@smzc ~ $ keytool -genkey -keyalg RSA -dname <span class=\"string\">&quot;cn=127.0.0.1,ou=inspur,o=none,l=shandong,st=jinan,c=cn&quot;</span> -<span class=\"built_in\">alias</span> server -keypass 111111 -keystore server.keystore -storepass 111111 -validity 3650</span><br></pre></td></tr></table></figure>\n<p><em>注：cn=127.0.0.1配置的是服务器IP</em></p>\n<h3 id=\"2-生成csr\"><a href=\"#2-生成csr\" class=\"headerlink\" title=\"2) 生成csr\"></a>2) 生成csr</h3><p>生成csr文件用于提交CA认证生成证书使用。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wujianjun@smzc ~ $ keytool -certReq -<span class=\"built_in\">alias</span> server -keystore server.keystore -file ca.csr</span><br></pre></td></tr></table></figure>\n<h3 id=\"3-生成cer\"><a href=\"#3-生成cer\" class=\"headerlink\" title=\"3) 生成cer\"></a>3) 生成cer</h3><p>这个ca.cer是为了解决不信任时要导入的</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wujianjun@smzc ~ $ keytool -<span class=\"built_in\">export</span> -<span class=\"built_in\">alias</span> server -keystore server.keystore -file ca.cer -storepass 111111</span><br></pre></td></tr></table></figure>\n<h3 id=\"4-tomcat配置ssl\"><a href=\"#4-tomcat配置ssl\" class=\"headerlink\" title=\"4) tomcat配置ssl\"></a>4) tomcat配置ssl</h3><p>clientAuth=”false”代表单向认证，配置如下：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">Connector</span> <span class=\"attr\">SSLEnabled</span>=<span class=\"string\">&quot;true&quot;</span> <span class=\"attr\">clientAuth</span>=<span class=\"string\">&quot;false&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">maxThreads</span>=<span class=\"string\">&quot;150&quot;</span> <span class=\"attr\">port</span>=<span class=\"string\">&quot;8443&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">protocol</span>=<span class=\"string\">&quot;org.apache.coyote.http11.Http11Protocol&quot;</span>或者<span class=\"attr\">HTTP</span>/<span class=\"attr\">1.1</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">scheme</span>=<span class=\"string\">&quot;https&quot;</span> <span class=\"attr\">secure</span>=<span class=\"string\">&quot;true&quot;</span> <span class=\"attr\">sslProtocol</span>=<span class=\"string\">&quot;TLS&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">keystoreFile</span>=<span class=\"string\">&quot;/home/server.keystore&quot;</span> <span class=\"attr\">keystorePass</span>=<span class=\"string\">&quot;111111&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>\n<p><em>注: Http11Protocol支持HTTP/1.1协议，是http1.1协议的ProtocolHandler实现。</em></p>\n<h3 id=\"5-常见问题\"><a href=\"#5-常见问题\" class=\"headerlink\" title=\"5) 常见问题\"></a>5) 常见问题</h3><ul>\n<li><strong>服务器的证书不受信任</strong><br>解决方法：<br>1、选择“继续前往（不安全）”，也能访问，但是此时就是以普通的HTTP方式进行信息传输了。<br>2、选择生成的<code>ca.cer</code>文件，将证书存储在 <strong>“受信任的证书颁发机构”</strong> ，就可以通过HTTPS正常访问了。</li>\n<li><strong>程序访问Https异常</strong><br><strong>sun.security.validator.ValidatorException: PKIX path building failed…</strong><br>需要将生成的证书(ca.cer ) 导入到jdk中<br>执行以下命令：<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wujianjun@smzc ~ $ keytool -import -<span class=\"built_in\">alias</span> tomcatsso -file <span class=\"string\">&quot;ca.cer&quot;</span> -keystore <span class=\"string\">&quot;D:\\java\\jdk1.6.0_11\\jre\\lib\\security\\cacerts&quot;</span> -storepass changeit</span><br></pre></td></tr></table></figure>\n<em>其中<code>changeit</code>是jre默认的密码。</em><br>__No subject alternative names present__，请在生成keystore 注意CN必须要为域名（或机器名称)例如 localhost 不能为IP 。<br>__No name matching localhost found__，表示你生成keystore CN的名称和你访问的名称不一致。</li>\n</ul>\n<h2 id=\"openssl双向认证实例\"><a href=\"#openssl双向认证实例\" class=\"headerlink\" title=\"openssl双向认证实例\"></a>openssl双向认证实例</h2><p><em>Linux环境下，在home下建立out32dll目录，在此目录下建立ca、client、server三个文件夹。以下命令均在out32dll目录下执行。</em></p>\n<h3 id=\"1-模拟CA生成证书\"><a href=\"#1-模拟CA生成证书\" class=\"headerlink\" title=\"1) 模拟CA生成证书\"></a>1) 模拟CA生成证书</h3><ul>\n<li>创建私钥<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wujianjun@smzc ~/out32dll $ openssl genrsa -out ca/ca-key.pem 1024</span><br></pre></td></tr></table></figure></li>\n<li>创建证书请求<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wujianjun@smzc ~/out32dll $ openssl req -new -out ca/ca-req.csr -key ca/ca-key.pem</span><br></pre></td></tr></table></figure></li>\n<li>自签署证书<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wujianjun@smzc ~/out32dll $ openssl x509 -req -<span class=\"keyword\">in</span> ca/ca-req.csr -out ca/ca-cert.pem -signkey ca/ca-key.pem -days 3650</span><br></pre></td></tr></table></figure></li>\n<li>将证书导出成浏览器支持的.p12格式 (供浏览器不受信任时导入)<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wujianjun@smzc ~/out32dll $ openssl pkcs12 -<span class=\"built_in\">export</span> -clcerts -<span class=\"keyword\">in</span> ca/ca-cert.pem -inkey ca/ca-key.pem -out ca/ca.p12</span><br></pre></td></tr></table></figure>\n<em>密码：111111</em><h3 id=\"2-生成Server证书\"><a href=\"#2-生成Server证书\" class=\"headerlink\" title=\"2) 生成Server证书\"></a>2) 生成Server证书</h3></li>\n<li>创建私钥<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wujianjun@smzc ~/out32dll $ openssl genrsa -out server/server-key.pem 1024</span><br></pre></td></tr></table></figure></li>\n<li>创建Server证书请求<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wujianjun@smzc ~/out32dll $ openssl req -new -out server/server-req.csr -key server/server-key.pem</span><br></pre></td></tr></table></figure></li>\n<li>使用CA证书签署Server证书<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wujianjun@smzc ~/out32dll $ openssl x509 -req -<span class=\"keyword\">in</span> server/server-req.csr -out server/server-cert.pem -signkey server/server-key.pem -CA ca/ca-cert.pem -CAkey ca/ca-key.pem -CAcreateserial -days 3650</span><br></pre></td></tr></table></figure></li>\n<li>将证书导出成浏览器支持的.p12格式<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wujianjun@smzc ~/out32dll $ openssl pkcs12 -<span class=\"built_in\">export</span> -clcerts -<span class=\"keyword\">in</span> server/server-cert.pem -inkey server/server-key.pem -out server/server.p12</span><br></pre></td></tr></table></figure>\n<em>密码：111111</em><h3 id=\"3-生成Clinet证书\"><a href=\"#3-生成Clinet证书\" class=\"headerlink\" title=\"3) 生成Clinet证书\"></a>3) 生成Clinet证书</h3></li>\n<li>创建私钥<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wujianjun@smzc ~/out32dll $ openssl genrsa -out client/client-key.pem 1024</span><br></pre></td></tr></table></figure></li>\n<li>创建Client证书请求<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wujianjun@smzc ~/out32dll $ openssl req -new -out client/client-req.csr -key client/client-key.pem</span><br></pre></td></tr></table></figure></li>\n<li>使用CA证书签署Client证书<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wujianjun@smzc ~/out32dll $ openssl x509 -req -<span class=\"keyword\">in</span> client/client-req.csr -out client/client-cert.pem -signkey client/client-key.pem -CA ca/ca-cert.pem -CAkey ca/ca-key.pem -CAcreateserial -days 3650  </span><br></pre></td></tr></table></figure></li>\n<li>将证书导出成浏览器支持的.p12格式<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wujianjun@smzc ~/out32dll $ openssl pkcs12 -<span class=\"built_in\">export</span> -clcerts -<span class=\"keyword\">in</span> client/client-cert.pem -inkey client/client-key.pem -out client/client.p12</span><br></pre></td></tr></table></figure>\n<em>密码：111111</em><h3 id=\"4-根据CA证书生成jks文件\"><a href=\"#4-根据CA证书生成jks文件\" class=\"headerlink\" title=\"4) 根据CA证书生成jks文件\"></a>4) 根据CA证书生成jks文件</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wujianjun@smzc ~/out32dll $ keytool -keystore truststore.jks -keypass 222222 -storepass 222222 -<span class=\"built_in\">alias</span> ca -import -trustcacerts -file /home/out32dll/ca/ca-cert.pem</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"5-服务器配置（tomcat6示例）\"><a href=\"#5-服务器配置（tomcat6示例）\" class=\"headerlink\" title=\"5) 服务器配置（tomcat6示例）\"></a>5) 服务器配置（tomcat6示例）</h3><p>修改conf/server.xml。 将keystoreFile、truststoreFile的路径填写为正确的放置路径。</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">Connector</span> <span class=\"attr\">port</span>=<span class=\"string\">&quot;8443&quot;</span> <span class=\"attr\">protocol</span>=<span class=\"string\">&quot;HTTP/1.1&quot;</span> <span class=\"attr\">SSLEnabled</span>=<span class=\"string\">&quot;true&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">                <span class=\"attr\">maxThreads</span>=<span class=\"string\">&quot;150&quot;</span> <span class=\"attr\">scheme</span>=<span class=\"string\">&quot;https&quot;</span> <span class=\"attr\">secure</span>=<span class=\"string\">&quot;true&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">                <span class=\"attr\">clientAuth</span>=<span class=\"string\">&quot;true&quot;</span> <span class=\"attr\">sslProtocol</span>=<span class=\"string\">&quot;TLS&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">                <span class=\"attr\">keystoreFile</span>=<span class=\"string\">&quot;/home/out32dll/server/server.p12&quot;</span> <span class=\"attr\">keystorePass</span>=<span class=\"string\">&quot;111111&quot;</span>  <span class=\"attr\">keystoreType</span>=<span class=\"string\">&quot;PKCS12&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">                <span class=\"attr\">truststoreFile</span>=<span class=\"string\">&quot;/home/out32dll/truststore.jks&quot;</span> <span class=\"attr\">truststorePass</span>=<span class=\"string\">&quot;222222&quot;</span> <span class=\"attr\">truststoreType</span>=<span class=\"string\">&quot;JKS&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"6-导入证书-IE示例\"><a href=\"#6-导入证书-IE示例\" class=\"headerlink\" title=\"6) 导入证书(IE示例)\"></a>6) 导入证书(IE示例)</h3><p>将ca.p12，client.p12分别导入到IE中去（打开IE-&gt;Internet选项-&gt;内容-&gt;证书）。 ca.p12导入至 受信任的根证书颁发机构，client.p12导入至个人。<br><em>进行浏览器访问双向Https时会弹出客户端证书供选择</em></p>\n<hr>\n<p><em>观点仅代表自己，期待你的留言。</em></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"keytool单向认证实例\"><a href=\"#keytool单向认证实例\" class=\"headerlink\" title=\"keytool单向认证实例\"></a>keytool单向认证实例</h2><h3 id=\"1-为服务器生成证书\"><a href=\"#1-为服务器生成证书\" class=\"headerlink\" title=\"1) 为服务器生成证书\"></a>1) 为服务器生成证书</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wujianjun@smzc ~ $ keytool -genkey -keyalg RSA -dname <span class=\"string\">&quot;cn=127.0.0.1,ou=inspur,o=none,l=shandong,st=jinan,c=cn&quot;</span> -<span class=\"built_in\">alias</span> server -keypass 111111 -keystore server.keystore -storepass 111111 -validity 3650</span><br></pre></td></tr></table></figure>\n<p><em>注：cn=127.0.0.1配置的是服务器IP</em></p>\n<h3 id=\"2-生成csr\"><a href=\"#2-生成csr\" class=\"headerlink\" title=\"2) 生成csr\"></a>2) 生成csr</h3><p>生成csr文件用于提交CA认证生成证书使用。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wujianjun@smzc ~ $ keytool -certReq -<span class=\"built_in\">alias</span> server -keystore server.keystore -file ca.csr</span><br></pre></td></tr></table></figure>\n<h3 id=\"3-生成cer\"><a href=\"#3-生成cer\" class=\"headerlink\" title=\"3) 生成cer\"></a>3) 生成cer</h3><p>这个ca.cer是为了解决不信任时要导入的</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wujianjun@smzc ~ $ keytool -<span class=\"built_in\">export</span> -<span class=\"built_in\">alias</span> server -keystore server.keystore -file ca.cer -storepass 111111</span><br></pre></td></tr></table></figure>\n<h3 id=\"4-tomcat配置ssl\"><a href=\"#4-tomcat配置ssl\" class=\"headerlink\" title=\"4) tomcat配置ssl\"></a>4) tomcat配置ssl</h3><p>clientAuth=”false”代表单向认证，配置如下：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">Connector</span> <span class=\"attr\">SSLEnabled</span>=<span class=\"string\">&quot;true&quot;</span> <span class=\"attr\">clientAuth</span>=<span class=\"string\">&quot;false&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">maxThreads</span>=<span class=\"string\">&quot;150&quot;</span> <span class=\"attr\">port</span>=<span class=\"string\">&quot;8443&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">protocol</span>=<span class=\"string\">&quot;org.apache.coyote.http11.Http11Protocol&quot;</span>或者<span class=\"attr\">HTTP</span>/<span class=\"attr\">1.1</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">scheme</span>=<span class=\"string\">&quot;https&quot;</span> <span class=\"attr\">secure</span>=<span class=\"string\">&quot;true&quot;</span> <span class=\"attr\">sslProtocol</span>=<span class=\"string\">&quot;TLS&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">keystoreFile</span>=<span class=\"string\">&quot;/home/server.keystore&quot;</span> <span class=\"attr\">keystorePass</span>=<span class=\"string\">&quot;111111&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>\n<p><em>注: Http11Protocol支持HTTP/1.1协议，是http1.1协议的ProtocolHandler实现。</em></p>\n<h3 id=\"5-常见问题\"><a href=\"#5-常见问题\" class=\"headerlink\" title=\"5) 常见问题\"></a>5) 常见问题</h3><ul>\n<li><strong>服务器的证书不受信任</strong><br>解决方法：<br>1、选择“继续前往（不安全）”，也能访问，但是此时就是以普通的HTTP方式进行信息传输了。<br>2、选择生成的<code>ca.cer</code>文件，将证书存储在 <strong>“受信任的证书颁发机构”</strong> ，就可以通过HTTPS正常访问了。</li>\n<li><strong>程序访问Https异常</strong><br><strong>sun.security.validator.ValidatorException: PKIX path building failed…</strong><br>需要将生成的证书(ca.cer ) 导入到jdk中<br>执行以下命令：<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wujianjun@smzc ~ $ keytool -import -<span class=\"built_in\">alias</span> tomcatsso -file <span class=\"string\">&quot;ca.cer&quot;</span> -keystore <span class=\"string\">&quot;D:\\java\\jdk1.6.0_11\\jre\\lib\\security\\cacerts&quot;</span> -storepass changeit</span><br></pre></td></tr></table></figure>\n<em>其中<code>changeit</code>是jre默认的密码。</em><br>__No subject alternative names present__，请在生成keystore 注意CN必须要为域名（或机器名称)例如 localhost 不能为IP 。<br>__No name matching localhost found__，表示你生成keystore CN的名称和你访问的名称不一致。</li>\n</ul>\n<h2 id=\"openssl双向认证实例\"><a href=\"#openssl双向认证实例\" class=\"headerlink\" title=\"openssl双向认证实例\"></a>openssl双向认证实例</h2><p><em>Linux环境下，在home下建立out32dll目录，在此目录下建立ca、client、server三个文件夹。以下命令均在out32dll目录下执行。</em></p>\n<h3 id=\"1-模拟CA生成证书\"><a href=\"#1-模拟CA生成证书\" class=\"headerlink\" title=\"1) 模拟CA生成证书\"></a>1) 模拟CA生成证书</h3><ul>\n<li>创建私钥<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wujianjun@smzc ~/out32dll $ openssl genrsa -out ca/ca-key.pem 1024</span><br></pre></td></tr></table></figure></li>\n<li>创建证书请求<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wujianjun@smzc ~/out32dll $ openssl req -new -out ca/ca-req.csr -key ca/ca-key.pem</span><br></pre></td></tr></table></figure></li>\n<li>自签署证书<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wujianjun@smzc ~/out32dll $ openssl x509 -req -<span class=\"keyword\">in</span> ca/ca-req.csr -out ca/ca-cert.pem -signkey ca/ca-key.pem -days 3650</span><br></pre></td></tr></table></figure></li>\n<li>将证书导出成浏览器支持的.p12格式 (供浏览器不受信任时导入)<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wujianjun@smzc ~/out32dll $ openssl pkcs12 -<span class=\"built_in\">export</span> -clcerts -<span class=\"keyword\">in</span> ca/ca-cert.pem -inkey ca/ca-key.pem -out ca/ca.p12</span><br></pre></td></tr></table></figure>\n<em>密码：111111</em><h3 id=\"2-生成Server证书\"><a href=\"#2-生成Server证书\" class=\"headerlink\" title=\"2) 生成Server证书\"></a>2) 生成Server证书</h3></li>\n<li>创建私钥<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wujianjun@smzc ~/out32dll $ openssl genrsa -out server/server-key.pem 1024</span><br></pre></td></tr></table></figure></li>\n<li>创建Server证书请求<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wujianjun@smzc ~/out32dll $ openssl req -new -out server/server-req.csr -key server/server-key.pem</span><br></pre></td></tr></table></figure></li>\n<li>使用CA证书签署Server证书<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wujianjun@smzc ~/out32dll $ openssl x509 -req -<span class=\"keyword\">in</span> server/server-req.csr -out server/server-cert.pem -signkey server/server-key.pem -CA ca/ca-cert.pem -CAkey ca/ca-key.pem -CAcreateserial -days 3650</span><br></pre></td></tr></table></figure></li>\n<li>将证书导出成浏览器支持的.p12格式<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wujianjun@smzc ~/out32dll $ openssl pkcs12 -<span class=\"built_in\">export</span> -clcerts -<span class=\"keyword\">in</span> server/server-cert.pem -inkey server/server-key.pem -out server/server.p12</span><br></pre></td></tr></table></figure>\n<em>密码：111111</em><h3 id=\"3-生成Clinet证书\"><a href=\"#3-生成Clinet证书\" class=\"headerlink\" title=\"3) 生成Clinet证书\"></a>3) 生成Clinet证书</h3></li>\n<li>创建私钥<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wujianjun@smzc ~/out32dll $ openssl genrsa -out client/client-key.pem 1024</span><br></pre></td></tr></table></figure></li>\n<li>创建Client证书请求<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wujianjun@smzc ~/out32dll $ openssl req -new -out client/client-req.csr -key client/client-key.pem</span><br></pre></td></tr></table></figure></li>\n<li>使用CA证书签署Client证书<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wujianjun@smzc ~/out32dll $ openssl x509 -req -<span class=\"keyword\">in</span> client/client-req.csr -out client/client-cert.pem -signkey client/client-key.pem -CA ca/ca-cert.pem -CAkey ca/ca-key.pem -CAcreateserial -days 3650  </span><br></pre></td></tr></table></figure></li>\n<li>将证书导出成浏览器支持的.p12格式<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wujianjun@smzc ~/out32dll $ openssl pkcs12 -<span class=\"built_in\">export</span> -clcerts -<span class=\"keyword\">in</span> client/client-cert.pem -inkey client/client-key.pem -out client/client.p12</span><br></pre></td></tr></table></figure>\n<em>密码：111111</em><h3 id=\"4-根据CA证书生成jks文件\"><a href=\"#4-根据CA证书生成jks文件\" class=\"headerlink\" title=\"4) 根据CA证书生成jks文件\"></a>4) 根据CA证书生成jks文件</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wujianjun@smzc ~/out32dll $ keytool -keystore truststore.jks -keypass 222222 -storepass 222222 -<span class=\"built_in\">alias</span> ca -import -trustcacerts -file /home/out32dll/ca/ca-cert.pem</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"5-服务器配置（tomcat6示例）\"><a href=\"#5-服务器配置（tomcat6示例）\" class=\"headerlink\" title=\"5) 服务器配置（tomcat6示例）\"></a>5) 服务器配置（tomcat6示例）</h3><p>修改conf/server.xml。 将keystoreFile、truststoreFile的路径填写为正确的放置路径。</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">Connector</span> <span class=\"attr\">port</span>=<span class=\"string\">&quot;8443&quot;</span> <span class=\"attr\">protocol</span>=<span class=\"string\">&quot;HTTP/1.1&quot;</span> <span class=\"attr\">SSLEnabled</span>=<span class=\"string\">&quot;true&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">                <span class=\"attr\">maxThreads</span>=<span class=\"string\">&quot;150&quot;</span> <span class=\"attr\">scheme</span>=<span class=\"string\">&quot;https&quot;</span> <span class=\"attr\">secure</span>=<span class=\"string\">&quot;true&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">                <span class=\"attr\">clientAuth</span>=<span class=\"string\">&quot;true&quot;</span> <span class=\"attr\">sslProtocol</span>=<span class=\"string\">&quot;TLS&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">                <span class=\"attr\">keystoreFile</span>=<span class=\"string\">&quot;/home/out32dll/server/server.p12&quot;</span> <span class=\"attr\">keystorePass</span>=<span class=\"string\">&quot;111111&quot;</span>  <span class=\"attr\">keystoreType</span>=<span class=\"string\">&quot;PKCS12&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">                <span class=\"attr\">truststoreFile</span>=<span class=\"string\">&quot;/home/out32dll/truststore.jks&quot;</span> <span class=\"attr\">truststorePass</span>=<span class=\"string\">&quot;222222&quot;</span> <span class=\"attr\">truststoreType</span>=<span class=\"string\">&quot;JKS&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"6-导入证书-IE示例\"><a href=\"#6-导入证书-IE示例\" class=\"headerlink\" title=\"6) 导入证书(IE示例)\"></a>6) 导入证书(IE示例)</h3><p>将ca.p12，client.p12分别导入到IE中去（打开IE-&gt;Internet选项-&gt;内容-&gt;证书）。 ca.p12导入至 受信任的根证书颁发机构，client.p12导入至个人。<br><em>进行浏览器访问双向Https时会弹出客户端证书供选择</em></p>\n<hr>\n<p><em>观点仅代表自己，期待你的留言。</em></p>\n"},{"title":"https交互流程","keywords":["https"],"date":"2018-09-11T10:46:47.000Z","_content":"\n## 单向Https\n![单向Https](/images/one-way-https.jpg)\n\n## 双向Https\n![双向Https](/images/two-way-https.jpg)\n\n-----\n\n*观点仅代表自己，期待你的留言。*\n","source":"_posts/https-flow.md","raw":"---\ntitle: https交互流程\ntags:\n  - 原创\nkeywords:\n  - https\ndate: 2018-09-11 18:46:47\n---\n\n## 单向Https\n![单向Https](/images/one-way-https.jpg)\n\n## 双向Https\n![双向Https](/images/two-way-https.jpg)\n\n-----\n\n*观点仅代表自己，期待你的留言。*\n","slug":"https-flow","published":1,"updated":"2021-08-31T14:23:11.541Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cku52dymx001mbbincihz0n73","content":"<h2 id=\"单向Https\"><a href=\"#单向Https\" class=\"headerlink\" title=\"单向Https\"></a>单向Https</h2><p><img src=\"/images/one-way-https.jpg\" alt=\"单向Https\"></p>\n<h2 id=\"双向Https\"><a href=\"#双向Https\" class=\"headerlink\" title=\"双向Https\"></a>双向Https</h2><p><img src=\"/images/two-way-https.jpg\" alt=\"双向Https\"></p>\n<hr>\n<p><em>观点仅代表自己，期待你的留言。</em></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"单向Https\"><a href=\"#单向Https\" class=\"headerlink\" title=\"单向Https\"></a>单向Https</h2><p><img src=\"/images/one-way-https.jpg\" alt=\"单向Https\"></p>\n<h2 id=\"双向Https\"><a href=\"#双向Https\" class=\"headerlink\" title=\"双向Https\"></a>双向Https</h2><p><img src=\"/images/two-way-https.jpg\" alt=\"双向Https\"></p>\n<hr>\n<p><em>观点仅代表自己，期待你的留言。</em></p>\n"},{"title":"iOS-hitTest:withEvent与pointInside:withEvent","date":"2016-03-24T02:45:13.000Z","_content":"\n## 简介\n对于触摸事件的响应，首先要找到能够响应该事件的对象，iOS是用hit-testing 来找到哪个视图被触摸了（hit-test view），也就是以keyWindow为起点，hit-test view为终点,逐级调用hitTest:withEvent。\n\n![](/images/1452221174578074.png)\n\n## hitTest:withEvent:方法的处理流程:\n\n先调用pointInside:withEvent:判断触摸点是否在当前视图内\n1.如果返回YES，那么该视图的所有子视图调用hitTest:withEvent,调用顺序由层级低到高（top->bottom）依次调用。\n\n2.如果返回NO，那么hitTest:withEvent返回nil，该视图的所有子视图的分支全部被忽略\n\n如果某视图的pointInside:withEvent:返回YES，并且他的所有子视图hitTest:withEvent:都返回nil，或者该视图没有子视图，那么该视图的hitTest:withEvent:返回自己。\n如果子视图的hitTest:withEvent:返回非空对象，那么当前视图的hitTest:withEvent:也返回这个对象，也就是沿原路回推，最终将hit-test view传递给keyWindow\n以下视图的hitTest:withEvent:方法会返回nil，导致自身和其所有子视图不能被hit-testing发现，无法响应触摸事件：\n 1.隐藏(hidden=YES)的视图\n 2.禁止用户操作(userInteractionEnabled=NO)的视图\n 3.alpha<0.01的视图\n 4.视图超出父视图的区域\n\n\n\n-----\n\n*观点仅代表自己，期待你的留言。*\n","source":"_posts/ios-hitTest.md","raw":"---\ntitle: iOS-hitTest:withEvent与pointInside:withEvent\ntags:\n  - iOS\n  - 转载\ndate: 2016-03-24 10:45:13\n---\n\n## 简介\n对于触摸事件的响应，首先要找到能够响应该事件的对象，iOS是用hit-testing 来找到哪个视图被触摸了（hit-test view），也就是以keyWindow为起点，hit-test view为终点,逐级调用hitTest:withEvent。\n\n![](/images/1452221174578074.png)\n\n## hitTest:withEvent:方法的处理流程:\n\n先调用pointInside:withEvent:判断触摸点是否在当前视图内\n1.如果返回YES，那么该视图的所有子视图调用hitTest:withEvent,调用顺序由层级低到高（top->bottom）依次调用。\n\n2.如果返回NO，那么hitTest:withEvent返回nil，该视图的所有子视图的分支全部被忽略\n\n如果某视图的pointInside:withEvent:返回YES，并且他的所有子视图hitTest:withEvent:都返回nil，或者该视图没有子视图，那么该视图的hitTest:withEvent:返回自己。\n如果子视图的hitTest:withEvent:返回非空对象，那么当前视图的hitTest:withEvent:也返回这个对象，也就是沿原路回推，最终将hit-test view传递给keyWindow\n以下视图的hitTest:withEvent:方法会返回nil，导致自身和其所有子视图不能被hit-testing发现，无法响应触摸事件：\n 1.隐藏(hidden=YES)的视图\n 2.禁止用户操作(userInteractionEnabled=NO)的视图\n 3.alpha<0.01的视图\n 4.视图超出父视图的区域\n\n\n\n-----\n\n*观点仅代表自己，期待你的留言。*\n","slug":"ios-hitTest","published":1,"updated":"2021-08-31T14:23:11.541Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cku52dymy001obbinchauftf3","content":"<h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><p>对于触摸事件的响应，首先要找到能够响应该事件的对象，iOS是用hit-testing 来找到哪个视图被触摸了（hit-test view），也就是以keyWindow为起点，hit-test view为终点,逐级调用hitTest:withEvent。</p>\n<p><img src=\"/images/1452221174578074.png\"></p>\n<h2 id=\"hitTest-withEvent-方法的处理流程\"><a href=\"#hitTest-withEvent-方法的处理流程\" class=\"headerlink\" title=\"hitTest:withEvent:方法的处理流程:\"></a>hitTest:withEvent:方法的处理流程:</h2><p>先调用pointInside:withEvent:判断触摸点是否在当前视图内<br>1.如果返回YES，那么该视图的所有子视图调用hitTest:withEvent,调用顺序由层级低到高（top-&gt;bottom）依次调用。</p>\n<p>2.如果返回NO，那么hitTest:withEvent返回nil，该视图的所有子视图的分支全部被忽略</p>\n<p>如果某视图的pointInside:withEvent:返回YES，并且他的所有子视图hitTest:withEvent:都返回nil，或者该视图没有子视图，那么该视图的hitTest:withEvent:返回自己。<br>如果子视图的hitTest:withEvent:返回非空对象，那么当前视图的hitTest:withEvent:也返回这个对象，也就是沿原路回推，最终将hit-test view传递给keyWindow<br>以下视图的hitTest:withEvent:方法会返回nil，导致自身和其所有子视图不能被hit-testing发现，无法响应触摸事件：<br> 1.隐藏(hidden=YES)的视图<br> 2.禁止用户操作(userInteractionEnabled=NO)的视图<br> 3.alpha&lt;0.01的视图<br> 4.视图超出父视图的区域</p>\n<hr>\n<p><em>观点仅代表自己，期待你的留言。</em></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><p>对于触摸事件的响应，首先要找到能够响应该事件的对象，iOS是用hit-testing 来找到哪个视图被触摸了（hit-test view），也就是以keyWindow为起点，hit-test view为终点,逐级调用hitTest:withEvent。</p>\n<p><img src=\"/images/1452221174578074.png\"></p>\n<h2 id=\"hitTest-withEvent-方法的处理流程\"><a href=\"#hitTest-withEvent-方法的处理流程\" class=\"headerlink\" title=\"hitTest:withEvent:方法的处理流程:\"></a>hitTest:withEvent:方法的处理流程:</h2><p>先调用pointInside:withEvent:判断触摸点是否在当前视图内<br>1.如果返回YES，那么该视图的所有子视图调用hitTest:withEvent,调用顺序由层级低到高（top-&gt;bottom）依次调用。</p>\n<p>2.如果返回NO，那么hitTest:withEvent返回nil，该视图的所有子视图的分支全部被忽略</p>\n<p>如果某视图的pointInside:withEvent:返回YES，并且他的所有子视图hitTest:withEvent:都返回nil，或者该视图没有子视图，那么该视图的hitTest:withEvent:返回自己。<br>如果子视图的hitTest:withEvent:返回非空对象，那么当前视图的hitTest:withEvent:也返回这个对象，也就是沿原路回推，最终将hit-test view传递给keyWindow<br>以下视图的hitTest:withEvent:方法会返回nil，导致自身和其所有子视图不能被hit-testing发现，无法响应触摸事件：<br> 1.隐藏(hidden=YES)的视图<br> 2.禁止用户操作(userInteractionEnabled=NO)的视图<br> 3.alpha&lt;0.01的视图<br> 4.视图超出父视图的区域</p>\n<hr>\n<p><em>观点仅代表自己，期待你的留言。</em></p>\n"},{"title":"UIView的layoutSubviews和drawRect","date":"2016-03-22T03:35:23.000Z","_content":"\nUIView的setNeedsDisplay和setNeedsLayout方法。首先两个方法都是异步执行的。setNeedsDisplay会调用自动调用drawRect方法，这样可以拿到UIGraphicsGetCurrentContext，就可以画画了。而setNeedsLayout会默认调用layoutSubViews，就可以处理子视图中的一些数据。\n综上两个方法都是异步执行的，layoutSubviews方便数据计算，drawRect方便视图重绘。\n \n先大概看下ios layout机制相关的这几个方法：\n- (CGSize)sizeThatFits:(CGSize)size\n- (void)sizeToFit\n——————-\n- (void)layoutSubviews\n- (void)layoutIfNeeded\n- (void)setNeedsLayout\n——————–\n- (void)setNeedsDisplay\n- (void)drawRect\n \n#### 一、layoutSubviews在以下情况下会被调用：\n1、init初始化不会触发layoutSubviews。\n2、addSubview会触发layoutSubviews。\n3、设置view的Frame会触发layoutSubviews，当然前提是frame的值设置前后发生了变化。\n4、滚动一个UIScrollView会触发layoutSubviews。\n5、旋转Screen会触发父UIView上的layoutSubviews事件。\n6、改变一个UIView大小的时候也会触发父UIView上的layoutSubviews事件。\n7、直接调用setLayoutSubviews。\n8、直接调用setNeedsLayout。\n在苹果的官方文档中强调:You should override this method only if the autoresizing behaviors of the subviews do not offer the behavior you want. \nlayoutSubviews, 当我们在某个类的内部调整子视图位置时，需要调用。\n反过来的意思就是说：如果你想要在外部设置subviews的位置，就不要重写。\n \n 刷新子对象布局\n-layoutSubviews方法：这个方法，默认没有做任何事情，需要子类进行重写\n-setNeedsLayout方法： 标记为需要重新布局，异步调用layoutIfNeeded刷新布局，不立即刷新，但layoutSubviews一定会被调用\n-layoutIfNeeded方法：如果，有需要刷新的标记，立即调用layoutSubviews进行布局（如果没有标记，不会调用layoutSubviews）\n如果要立即刷新，要先调用[view setNeedsLayout]，把标记设为需要布局，然后马上调用[view layoutIfNeeded]，实现布局\n在视图第一次显示之前，标记总是“需要刷新”的，可以直接调用[view layoutIfNeeded]\n \n#### 二、drawRect在以下情况下会被调用：\n1、如果在UIView初始化时没有设置rect大小，将直接导致drawRect不被自动调用。drawRect 掉用是在Controller->loadView, Controller->viewDidLoad 两方法之后掉用的.所以不用担心在 控制器中,这些View的drawRect就开始画了.这样可以在控制器中设置一些值给View(如果这些View draw的时候需要用到某些变量 值).\n2、该方法在调用sizeToFit后被调用，所以可以先调用sizeToFit计算出size。然后系统自动调用drawRect:方法。\nsizeToFit会自动调用sizeThatFits方法；\nsizeToFit不应该在子类中被重写，应该重写sizeThatFits\nsizeThatFits传入的参数是receiver当前的size，返回一个适合的size\nsizeToFit可以被手动直接调用\nsizeToFit和sizeThatFits方法都没有递归，对subviews也不负责，只负责自己\n3、通过设置contentMode属性值为UIViewContentModeRedraw。那么将在每次设置或更改frame的时候自动调用drawRect:。\n4、直接调用setNeedsDisplay，或者setNeedsDisplayInRect:触发drawRect:，但是有个前提条件是rect不能为0。\n-setNeedsDisplay方法：标记为需要重绘，异步调用drawRect\n-setNeedsDisplayInRect:(CGRect)invalidRect方法：标记为需要局部重绘\n以上1,2推荐；而3,4不提倡\n \ndrawRect方法使用注意点：\n1、 若使用UIView绘图，只能在drawRect：方法中获取相应的contextRef并绘图。如果在其他方法中获取将获取到一个invalidate 的ref并且不能用于画图。drawRect：方法不能手动显示调用，必须通过调用setNeedsDisplay 或 者 setNeedsDisplayInRect，让系统自动调该方法。\n2、若使用calayer绘图，只能在drawInContext: 中（类似鱼drawRect）绘制，或者在delegate中的相应方法绘制。同样也是调用setNeedDisplay等间接调用以上方法\n3、若要实时画图，不能使用gestureRecognizer，只能使用touchbegan等方法来掉用setNeedsDisplay实时刷新屏幕\n \n#### 三、layoutSubviews对subviews重新布局\nlayoutSubviews方法调用先于drawRect\nsetNeedsLayout在receiver标上一个需要被重新布局的标记，在系统runloop的下一个周期自动调用layoutSubviews\nlayoutIfNeeded方法如其名，UIKit会判断该receiver是否需要layout.根据Apple官方文档,layoutIfNeeded方法应该是这样的\nlayoutIfNeeded遍历的不是superview链，应该是subviews链\ndrawRect是对receiver的重绘，能获得context\nsetNeedDisplay在receiver标上一个需要被重新绘图的标记，在下一个draw周期自动重绘，iphone device的刷新频率是60hz，也就是1/60秒后重绘\n\n\n-----\n原地址：http://justsee.iteye.com/blog/1886463\n","source":"_posts/ios-layoutsubviews.md","raw":"---\ntitle: UIView的layoutSubviews和drawRect\ntags:\n  - iOS\n  - 转载\ndate: 2016-03-22 11:35:23\n---\n\nUIView的setNeedsDisplay和setNeedsLayout方法。首先两个方法都是异步执行的。setNeedsDisplay会调用自动调用drawRect方法，这样可以拿到UIGraphicsGetCurrentContext，就可以画画了。而setNeedsLayout会默认调用layoutSubViews，就可以处理子视图中的一些数据。\n综上两个方法都是异步执行的，layoutSubviews方便数据计算，drawRect方便视图重绘。\n \n先大概看下ios layout机制相关的这几个方法：\n- (CGSize)sizeThatFits:(CGSize)size\n- (void)sizeToFit\n——————-\n- (void)layoutSubviews\n- (void)layoutIfNeeded\n- (void)setNeedsLayout\n——————–\n- (void)setNeedsDisplay\n- (void)drawRect\n \n#### 一、layoutSubviews在以下情况下会被调用：\n1、init初始化不会触发layoutSubviews。\n2、addSubview会触发layoutSubviews。\n3、设置view的Frame会触发layoutSubviews，当然前提是frame的值设置前后发生了变化。\n4、滚动一个UIScrollView会触发layoutSubviews。\n5、旋转Screen会触发父UIView上的layoutSubviews事件。\n6、改变一个UIView大小的时候也会触发父UIView上的layoutSubviews事件。\n7、直接调用setLayoutSubviews。\n8、直接调用setNeedsLayout。\n在苹果的官方文档中强调:You should override this method only if the autoresizing behaviors of the subviews do not offer the behavior you want. \nlayoutSubviews, 当我们在某个类的内部调整子视图位置时，需要调用。\n反过来的意思就是说：如果你想要在外部设置subviews的位置，就不要重写。\n \n 刷新子对象布局\n-layoutSubviews方法：这个方法，默认没有做任何事情，需要子类进行重写\n-setNeedsLayout方法： 标记为需要重新布局，异步调用layoutIfNeeded刷新布局，不立即刷新，但layoutSubviews一定会被调用\n-layoutIfNeeded方法：如果，有需要刷新的标记，立即调用layoutSubviews进行布局（如果没有标记，不会调用layoutSubviews）\n如果要立即刷新，要先调用[view setNeedsLayout]，把标记设为需要布局，然后马上调用[view layoutIfNeeded]，实现布局\n在视图第一次显示之前，标记总是“需要刷新”的，可以直接调用[view layoutIfNeeded]\n \n#### 二、drawRect在以下情况下会被调用：\n1、如果在UIView初始化时没有设置rect大小，将直接导致drawRect不被自动调用。drawRect 掉用是在Controller->loadView, Controller->viewDidLoad 两方法之后掉用的.所以不用担心在 控制器中,这些View的drawRect就开始画了.这样可以在控制器中设置一些值给View(如果这些View draw的时候需要用到某些变量 值).\n2、该方法在调用sizeToFit后被调用，所以可以先调用sizeToFit计算出size。然后系统自动调用drawRect:方法。\nsizeToFit会自动调用sizeThatFits方法；\nsizeToFit不应该在子类中被重写，应该重写sizeThatFits\nsizeThatFits传入的参数是receiver当前的size，返回一个适合的size\nsizeToFit可以被手动直接调用\nsizeToFit和sizeThatFits方法都没有递归，对subviews也不负责，只负责自己\n3、通过设置contentMode属性值为UIViewContentModeRedraw。那么将在每次设置或更改frame的时候自动调用drawRect:。\n4、直接调用setNeedsDisplay，或者setNeedsDisplayInRect:触发drawRect:，但是有个前提条件是rect不能为0。\n-setNeedsDisplay方法：标记为需要重绘，异步调用drawRect\n-setNeedsDisplayInRect:(CGRect)invalidRect方法：标记为需要局部重绘\n以上1,2推荐；而3,4不提倡\n \ndrawRect方法使用注意点：\n1、 若使用UIView绘图，只能在drawRect：方法中获取相应的contextRef并绘图。如果在其他方法中获取将获取到一个invalidate 的ref并且不能用于画图。drawRect：方法不能手动显示调用，必须通过调用setNeedsDisplay 或 者 setNeedsDisplayInRect，让系统自动调该方法。\n2、若使用calayer绘图，只能在drawInContext: 中（类似鱼drawRect）绘制，或者在delegate中的相应方法绘制。同样也是调用setNeedDisplay等间接调用以上方法\n3、若要实时画图，不能使用gestureRecognizer，只能使用touchbegan等方法来掉用setNeedsDisplay实时刷新屏幕\n \n#### 三、layoutSubviews对subviews重新布局\nlayoutSubviews方法调用先于drawRect\nsetNeedsLayout在receiver标上一个需要被重新布局的标记，在系统runloop的下一个周期自动调用layoutSubviews\nlayoutIfNeeded方法如其名，UIKit会判断该receiver是否需要layout.根据Apple官方文档,layoutIfNeeded方法应该是这样的\nlayoutIfNeeded遍历的不是superview链，应该是subviews链\ndrawRect是对receiver的重绘，能获得context\nsetNeedDisplay在receiver标上一个需要被重新绘图的标记，在下一个draw周期自动重绘，iphone device的刷新频率是60hz，也就是1/60秒后重绘\n\n\n-----\n原地址：http://justsee.iteye.com/blog/1886463\n","slug":"ios-layoutsubviews","published":1,"updated":"2021-08-31T14:23:11.542Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cku52dymz001rbbin4dy7hnxr","content":"<p>UIView的setNeedsDisplay和setNeedsLayout方法。首先两个方法都是异步执行的。setNeedsDisplay会调用自动调用drawRect方法，这样可以拿到UIGraphicsGetCurrentContext，就可以画画了。而setNeedsLayout会默认调用layoutSubViews，就可以处理子视图中的一些数据。<br>综上两个方法都是异步执行的，layoutSubviews方便数据计算，drawRect方便视图重绘。</p>\n<p>先大概看下ios layout机制相关的这几个方法：</p>\n<ul>\n<li>(CGSize)sizeThatFits:(CGSize)size</li>\n<li>(void)sizeToFit<br>——————-</li>\n<li>(void)layoutSubviews</li>\n<li>(void)layoutIfNeeded</li>\n<li>(void)setNeedsLayout<br>——————–</li>\n<li>(void)setNeedsDisplay</li>\n<li>(void)drawRect</li>\n</ul>\n<h4 id=\"一、layoutSubviews在以下情况下会被调用：\"><a href=\"#一、layoutSubviews在以下情况下会被调用：\" class=\"headerlink\" title=\"一、layoutSubviews在以下情况下会被调用：\"></a>一、layoutSubviews在以下情况下会被调用：</h4><p>1、init初始化不会触发layoutSubviews。<br>2、addSubview会触发layoutSubviews。<br>3、设置view的Frame会触发layoutSubviews，当然前提是frame的值设置前后发生了变化。<br>4、滚动一个UIScrollView会触发layoutSubviews。<br>5、旋转Screen会触发父UIView上的layoutSubviews事件。<br>6、改变一个UIView大小的时候也会触发父UIView上的layoutSubviews事件。<br>7、直接调用setLayoutSubviews。<br>8、直接调用setNeedsLayout。<br>在苹果的官方文档中强调:You should override this method only if the autoresizing behaviors of the subviews do not offer the behavior you want.<br>layoutSubviews, 当我们在某个类的内部调整子视图位置时，需要调用。<br>反过来的意思就是说：如果你想要在外部设置subviews的位置，就不要重写。</p>\n<p> 刷新子对象布局<br>-layoutSubviews方法：这个方法，默认没有做任何事情，需要子类进行重写<br>-setNeedsLayout方法： 标记为需要重新布局，异步调用layoutIfNeeded刷新布局，不立即刷新，但layoutSubviews一定会被调用<br>-layoutIfNeeded方法：如果，有需要刷新的标记，立即调用layoutSubviews进行布局（如果没有标记，不会调用layoutSubviews）<br>如果要立即刷新，要先调用[view setNeedsLayout]，把标记设为需要布局，然后马上调用[view layoutIfNeeded]，实现布局<br>在视图第一次显示之前，标记总是“需要刷新”的，可以直接调用[view layoutIfNeeded]</p>\n<h4 id=\"二、drawRect在以下情况下会被调用：\"><a href=\"#二、drawRect在以下情况下会被调用：\" class=\"headerlink\" title=\"二、drawRect在以下情况下会被调用：\"></a>二、drawRect在以下情况下会被调用：</h4><p>1、如果在UIView初始化时没有设置rect大小，将直接导致drawRect不被自动调用。drawRect 掉用是在Controller-&gt;loadView, Controller-&gt;viewDidLoad 两方法之后掉用的.所以不用担心在 控制器中,这些View的drawRect就开始画了.这样可以在控制器中设置一些值给View(如果这些View draw的时候需要用到某些变量 值).<br>2、该方法在调用sizeToFit后被调用，所以可以先调用sizeToFit计算出size。然后系统自动调用drawRect:方法。<br>sizeToFit会自动调用sizeThatFits方法；<br>sizeToFit不应该在子类中被重写，应该重写sizeThatFits<br>sizeThatFits传入的参数是receiver当前的size，返回一个适合的size<br>sizeToFit可以被手动直接调用<br>sizeToFit和sizeThatFits方法都没有递归，对subviews也不负责，只负责自己<br>3、通过设置contentMode属性值为UIViewContentModeRedraw。那么将在每次设置或更改frame的时候自动调用drawRect:。<br>4、直接调用setNeedsDisplay，或者setNeedsDisplayInRect:触发drawRect:，但是有个前提条件是rect不能为0。<br>-setNeedsDisplay方法：标记为需要重绘，异步调用drawRect<br>-setNeedsDisplayInRect:(CGRect)invalidRect方法：标记为需要局部重绘<br>以上1,2推荐；而3,4不提倡</p>\n<p>drawRect方法使用注意点：<br>1、 若使用UIView绘图，只能在drawRect：方法中获取相应的contextRef并绘图。如果在其他方法中获取将获取到一个invalidate 的ref并且不能用于画图。drawRect：方法不能手动显示调用，必须通过调用setNeedsDisplay 或 者 setNeedsDisplayInRect，让系统自动调该方法。<br>2、若使用calayer绘图，只能在drawInContext: 中（类似鱼drawRect）绘制，或者在delegate中的相应方法绘制。同样也是调用setNeedDisplay等间接调用以上方法<br>3、若要实时画图，不能使用gestureRecognizer，只能使用touchbegan等方法来掉用setNeedsDisplay实时刷新屏幕</p>\n<h4 id=\"三、layoutSubviews对subviews重新布局\"><a href=\"#三、layoutSubviews对subviews重新布局\" class=\"headerlink\" title=\"三、layoutSubviews对subviews重新布局\"></a>三、layoutSubviews对subviews重新布局</h4><p>layoutSubviews方法调用先于drawRect<br>setNeedsLayout在receiver标上一个需要被重新布局的标记，在系统runloop的下一个周期自动调用layoutSubviews<br>layoutIfNeeded方法如其名，UIKit会判断该receiver是否需要layout.根据Apple官方文档,layoutIfNeeded方法应该是这样的<br>layoutIfNeeded遍历的不是superview链，应该是subviews链<br>drawRect是对receiver的重绘，能获得context<br>setNeedDisplay在receiver标上一个需要被重新绘图的标记，在下一个draw周期自动重绘，iphone device的刷新频率是60hz，也就是1/60秒后重绘</p>\n<hr>\n<p>原地址：<a href=\"http://justsee.iteye.com/blog/1886463\">http://justsee.iteye.com/blog/1886463</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>UIView的setNeedsDisplay和setNeedsLayout方法。首先两个方法都是异步执行的。setNeedsDisplay会调用自动调用drawRect方法，这样可以拿到UIGraphicsGetCurrentContext，就可以画画了。而setNeedsLayout会默认调用layoutSubViews，就可以处理子视图中的一些数据。<br>综上两个方法都是异步执行的，layoutSubviews方便数据计算，drawRect方便视图重绘。</p>\n<p>先大概看下ios layout机制相关的这几个方法：</p>\n<ul>\n<li>(CGSize)sizeThatFits:(CGSize)size</li>\n<li>(void)sizeToFit<br>——————-</li>\n<li>(void)layoutSubviews</li>\n<li>(void)layoutIfNeeded</li>\n<li>(void)setNeedsLayout<br>——————–</li>\n<li>(void)setNeedsDisplay</li>\n<li>(void)drawRect</li>\n</ul>\n<h4 id=\"一、layoutSubviews在以下情况下会被调用：\"><a href=\"#一、layoutSubviews在以下情况下会被调用：\" class=\"headerlink\" title=\"一、layoutSubviews在以下情况下会被调用：\"></a>一、layoutSubviews在以下情况下会被调用：</h4><p>1、init初始化不会触发layoutSubviews。<br>2、addSubview会触发layoutSubviews。<br>3、设置view的Frame会触发layoutSubviews，当然前提是frame的值设置前后发生了变化。<br>4、滚动一个UIScrollView会触发layoutSubviews。<br>5、旋转Screen会触发父UIView上的layoutSubviews事件。<br>6、改变一个UIView大小的时候也会触发父UIView上的layoutSubviews事件。<br>7、直接调用setLayoutSubviews。<br>8、直接调用setNeedsLayout。<br>在苹果的官方文档中强调:You should override this method only if the autoresizing behaviors of the subviews do not offer the behavior you want.<br>layoutSubviews, 当我们在某个类的内部调整子视图位置时，需要调用。<br>反过来的意思就是说：如果你想要在外部设置subviews的位置，就不要重写。</p>\n<p> 刷新子对象布局<br>-layoutSubviews方法：这个方法，默认没有做任何事情，需要子类进行重写<br>-setNeedsLayout方法： 标记为需要重新布局，异步调用layoutIfNeeded刷新布局，不立即刷新，但layoutSubviews一定会被调用<br>-layoutIfNeeded方法：如果，有需要刷新的标记，立即调用layoutSubviews进行布局（如果没有标记，不会调用layoutSubviews）<br>如果要立即刷新，要先调用[view setNeedsLayout]，把标记设为需要布局，然后马上调用[view layoutIfNeeded]，实现布局<br>在视图第一次显示之前，标记总是“需要刷新”的，可以直接调用[view layoutIfNeeded]</p>\n<h4 id=\"二、drawRect在以下情况下会被调用：\"><a href=\"#二、drawRect在以下情况下会被调用：\" class=\"headerlink\" title=\"二、drawRect在以下情况下会被调用：\"></a>二、drawRect在以下情况下会被调用：</h4><p>1、如果在UIView初始化时没有设置rect大小，将直接导致drawRect不被自动调用。drawRect 掉用是在Controller-&gt;loadView, Controller-&gt;viewDidLoad 两方法之后掉用的.所以不用担心在 控制器中,这些View的drawRect就开始画了.这样可以在控制器中设置一些值给View(如果这些View draw的时候需要用到某些变量 值).<br>2、该方法在调用sizeToFit后被调用，所以可以先调用sizeToFit计算出size。然后系统自动调用drawRect:方法。<br>sizeToFit会自动调用sizeThatFits方法；<br>sizeToFit不应该在子类中被重写，应该重写sizeThatFits<br>sizeThatFits传入的参数是receiver当前的size，返回一个适合的size<br>sizeToFit可以被手动直接调用<br>sizeToFit和sizeThatFits方法都没有递归，对subviews也不负责，只负责自己<br>3、通过设置contentMode属性值为UIViewContentModeRedraw。那么将在每次设置或更改frame的时候自动调用drawRect:。<br>4、直接调用setNeedsDisplay，或者setNeedsDisplayInRect:触发drawRect:，但是有个前提条件是rect不能为0。<br>-setNeedsDisplay方法：标记为需要重绘，异步调用drawRect<br>-setNeedsDisplayInRect:(CGRect)invalidRect方法：标记为需要局部重绘<br>以上1,2推荐；而3,4不提倡</p>\n<p>drawRect方法使用注意点：<br>1、 若使用UIView绘图，只能在drawRect：方法中获取相应的contextRef并绘图。如果在其他方法中获取将获取到一个invalidate 的ref并且不能用于画图。drawRect：方法不能手动显示调用，必须通过调用setNeedsDisplay 或 者 setNeedsDisplayInRect，让系统自动调该方法。<br>2、若使用calayer绘图，只能在drawInContext: 中（类似鱼drawRect）绘制，或者在delegate中的相应方法绘制。同样也是调用setNeedDisplay等间接调用以上方法<br>3、若要实时画图，不能使用gestureRecognizer，只能使用touchbegan等方法来掉用setNeedsDisplay实时刷新屏幕</p>\n<h4 id=\"三、layoutSubviews对subviews重新布局\"><a href=\"#三、layoutSubviews对subviews重新布局\" class=\"headerlink\" title=\"三、layoutSubviews对subviews重新布局\"></a>三、layoutSubviews对subviews重新布局</h4><p>layoutSubviews方法调用先于drawRect<br>setNeedsLayout在receiver标上一个需要被重新布局的标记，在系统runloop的下一个周期自动调用layoutSubviews<br>layoutIfNeeded方法如其名，UIKit会判断该receiver是否需要layout.根据Apple官方文档,layoutIfNeeded方法应该是这样的<br>layoutIfNeeded遍历的不是superview链，应该是subviews链<br>drawRect是对receiver的重绘，能获得context<br>setNeedDisplay在receiver标上一个需要被重新绘图的标记，在下一个draw周期自动重绘，iphone device的刷新频率是60hz，也就是1/60秒后重绘</p>\n<hr>\n<p>原地址：<a href=\"http://justsee.iteye.com/blog/1886463\">http://justsee.iteye.com/blog/1886463</a></p>\n"},{"title":"NSObject的+load与+initialize方法的区别","date":"2016-03-29T07:42:47.000Z","_content":"\n先来看看NSObject Class Reference里对这两个方法说明：\n+(void)initialize\n\nThe runtime sends initialize to each class in a program exactly one time just before the class, or any class that inherits from it, is sent its first message from within the program. (Thus the method may never be invoked if the class is not used.) The runtime sends the initialize message to classes in a thread-safe manner. Superclasses receive this message before their subclasses.\n\n+(void)load\nThe load message is sent to classes and categories that are both dynamically loaded and statically linked, but only if the newly loaded class or category implements a method that can respond.\nThe order of initialization is as follows:\n\nAll initializers in any framework you link to.\nAll +load methods in your image.\nAll C++ static initializers and C/C++ __attribute__(constructor) functions in your image.\nAll initializers in frameworks that link to you.\nIn addition:\n\nA class’s +load method is called after all of its superclasses’ +load methods.\nA category +load method is called after the class’s own +load method.\nIn a custom implementation of load you can therefore safely message other unrelated classes from the same image, but any load methods implemented by those classes may not have run yet.\n\nApple的文档很清楚地说明了initialize和load的区别在于：load是只要类所在文件被引用就会被调用，而initialize是在类或者其子类的第一个方法被调用前调用。所以如果类没有被引用进项目，就不会有load调用；但即使类文件被引用进来，但是没有使用，那么initialize也不会被调用。\n\n它们的相同点在于：方法只会被调用一次。（其实这是相对runtime来说的，后边会做进一步解释）。\n\n文档也明确阐述了方法调用的顺序：父类(Superclass)的方法优先于子类(Subclass)的方法，类中的方法优先于类别(Category)中的方法。\n\n__总结：__\n\n|-\t \t\t\t\t\t\t\t|+(void)load \t\t\t|+(void)initialize\n|:- |:- |:-\n|执行时机 \t\t\t\t\t\t|在程序运行后立即执行\t \t|在类的方法第一次被调时执行\n|若自身未定义，是否沿用父类的方法？\t|否 \t\t\t\t\t\t|是\n|类别中的定义 \t\t\t\t\t|全都执行，但后于类中的方法\t|覆盖类中的方法，只执行一个\n\n-----\n\n*观点仅代表自己，期待你的留言。*\n","source":"_posts/ios-load-initialize.md","raw":"---\ntitle: NSObject的+load与+initialize方法的区别\ntags:\n  - iOS\n  - 转载\ndate: 2016-03-29 15:42:47\n---\n\n先来看看NSObject Class Reference里对这两个方法说明：\n+(void)initialize\n\nThe runtime sends initialize to each class in a program exactly one time just before the class, or any class that inherits from it, is sent its first message from within the program. (Thus the method may never be invoked if the class is not used.) The runtime sends the initialize message to classes in a thread-safe manner. Superclasses receive this message before their subclasses.\n\n+(void)load\nThe load message is sent to classes and categories that are both dynamically loaded and statically linked, but only if the newly loaded class or category implements a method that can respond.\nThe order of initialization is as follows:\n\nAll initializers in any framework you link to.\nAll +load methods in your image.\nAll C++ static initializers and C/C++ __attribute__(constructor) functions in your image.\nAll initializers in frameworks that link to you.\nIn addition:\n\nA class’s +load method is called after all of its superclasses’ +load methods.\nA category +load method is called after the class’s own +load method.\nIn a custom implementation of load you can therefore safely message other unrelated classes from the same image, but any load methods implemented by those classes may not have run yet.\n\nApple的文档很清楚地说明了initialize和load的区别在于：load是只要类所在文件被引用就会被调用，而initialize是在类或者其子类的第一个方法被调用前调用。所以如果类没有被引用进项目，就不会有load调用；但即使类文件被引用进来，但是没有使用，那么initialize也不会被调用。\n\n它们的相同点在于：方法只会被调用一次。（其实这是相对runtime来说的，后边会做进一步解释）。\n\n文档也明确阐述了方法调用的顺序：父类(Superclass)的方法优先于子类(Subclass)的方法，类中的方法优先于类别(Category)中的方法。\n\n__总结：__\n\n|-\t \t\t\t\t\t\t\t|+(void)load \t\t\t|+(void)initialize\n|:- |:- |:-\n|执行时机 \t\t\t\t\t\t|在程序运行后立即执行\t \t|在类的方法第一次被调时执行\n|若自身未定义，是否沿用父类的方法？\t|否 \t\t\t\t\t\t|是\n|类别中的定义 \t\t\t\t\t|全都执行，但后于类中的方法\t|覆盖类中的方法，只执行一个\n\n-----\n\n*观点仅代表自己，期待你的留言。*\n","slug":"ios-load-initialize","published":1,"updated":"2021-09-18T03:02:52.742Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cku52dyn0001tbbinb5ygdqqw","content":"<p>先来看看NSObject Class Reference里对这两个方法说明：<br>+(void)initialize</p>\n<p>The runtime sends initialize to each class in a program exactly one time just before the class, or any class that inherits from it, is sent its first message from within the program. (Thus the method may never be invoked if the class is not used.) The runtime sends the initialize message to classes in a thread-safe manner. Superclasses receive this message before their subclasses.</p>\n<p>+(void)load<br>The load message is sent to classes and categories that are both dynamically loaded and statically linked, but only if the newly loaded class or category implements a method that can respond.<br>The order of initialization is as follows:</p>\n<p>All initializers in any framework you link to.<br>All +load methods in your image.<br>All C++ static initializers and C/C++ <strong>attribute</strong>(constructor) functions in your image.<br>All initializers in frameworks that link to you.<br>In addition:</p>\n<p>A class’s +load method is called after all of its superclasses’ +load methods.<br>A category +load method is called after the class’s own +load method.<br>In a custom implementation of load you can therefore safely message other unrelated classes from the same image, but any load methods implemented by those classes may not have run yet.</p>\n<p>Apple的文档很清楚地说明了initialize和load的区别在于：load是只要类所在文件被引用就会被调用，而initialize是在类或者其子类的第一个方法被调用前调用。所以如果类没有被引用进项目，就不会有load调用；但即使类文件被引用进来，但是没有使用，那么initialize也不会被调用。</p>\n<p>它们的相同点在于：方法只会被调用一次。（其实这是相对runtime来说的，后边会做进一步解释）。</p>\n<p>文档也明确阐述了方法调用的顺序：父类(Superclass)的方法优先于子类(Subclass)的方法，类中的方法优先于类别(Category)中的方法。</p>\n<p><strong>总结：</strong></p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">-</th>\n<th align=\"left\">+(void)load</th>\n<th align=\"left\">+(void)initialize</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">执行时机</td>\n<td align=\"left\">在程序运行后立即执行</td>\n<td align=\"left\">在类的方法第一次被调时执行</td>\n</tr>\n<tr>\n<td align=\"left\">若自身未定义，是否沿用父类的方法？</td>\n<td align=\"left\">否</td>\n<td align=\"left\">是</td>\n</tr>\n<tr>\n<td align=\"left\">类别中的定义</td>\n<td align=\"left\">全都执行，但后于类中的方法</td>\n<td align=\"left\">覆盖类中的方法，只执行一个</td>\n</tr>\n</tbody></table>\n<hr>\n<p><em>观点仅代表自己，期待你的留言。</em></p>\n","site":{"data":{}},"excerpt":"","more":"<p>先来看看NSObject Class Reference里对这两个方法说明：<br>+(void)initialize</p>\n<p>The runtime sends initialize to each class in a program exactly one time just before the class, or any class that inherits from it, is sent its first message from within the program. (Thus the method may never be invoked if the class is not used.) The runtime sends the initialize message to classes in a thread-safe manner. Superclasses receive this message before their subclasses.</p>\n<p>+(void)load<br>The load message is sent to classes and categories that are both dynamically loaded and statically linked, but only if the newly loaded class or category implements a method that can respond.<br>The order of initialization is as follows:</p>\n<p>All initializers in any framework you link to.<br>All +load methods in your image.<br>All C++ static initializers and C/C++ <strong>attribute</strong>(constructor) functions in your image.<br>All initializers in frameworks that link to you.<br>In addition:</p>\n<p>A class’s +load method is called after all of its superclasses’ +load methods.<br>A category +load method is called after the class’s own +load method.<br>In a custom implementation of load you can therefore safely message other unrelated classes from the same image, but any load methods implemented by those classes may not have run yet.</p>\n<p>Apple的文档很清楚地说明了initialize和load的区别在于：load是只要类所在文件被引用就会被调用，而initialize是在类或者其子类的第一个方法被调用前调用。所以如果类没有被引用进项目，就不会有load调用；但即使类文件被引用进来，但是没有使用，那么initialize也不会被调用。</p>\n<p>它们的相同点在于：方法只会被调用一次。（其实这是相对runtime来说的，后边会做进一步解释）。</p>\n<p>文档也明确阐述了方法调用的顺序：父类(Superclass)的方法优先于子类(Subclass)的方法，类中的方法优先于类别(Category)中的方法。</p>\n<p><strong>总结：</strong></p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">-</th>\n<th align=\"left\">+(void)load</th>\n<th align=\"left\">+(void)initialize</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">执行时机</td>\n<td align=\"left\">在程序运行后立即执行</td>\n<td align=\"left\">在类的方法第一次被调时执行</td>\n</tr>\n<tr>\n<td align=\"left\">若自身未定义，是否沿用父类的方法？</td>\n<td align=\"left\">否</td>\n<td align=\"left\">是</td>\n</tr>\n<tr>\n<td align=\"left\">类别中的定义</td>\n<td align=\"left\">全都执行，但后于类中的方法</td>\n<td align=\"left\">覆盖类中的方法，只执行一个</td>\n</tr>\n</tbody></table>\n<hr>\n<p><em>观点仅代表自己，期待你的留言。</em></p>\n"},{"title":"iOS中UIViewController初始化过程及LoadView默认实现","date":"2016-03-29T07:41:52.000Z","_content":"\n\n## Xib或者Storyboard方式初始化UIViewController\n1、系统会通过 (instancetype)initWithCoder:(NSCoder *)aDecoder创建Controller对象实例。\n2、当需要将UIController的View添加到父级View时则会通过loadViewIfRequired方法来先判断self.view对象是否为nil\n\t如果为nil则会调用 (void)loadView进行view的初始化。然后会调用viewDidLoad方法\n\n![](/images/xib_init.png)\n\n## 编码的方式初始化UIViewController\n[[UIViewController alloc] init]，系统会调用[[UIViewController alloc] initWithNibName:(NSString *)nibNameOrNil bundle:(NSBundle *)nibBundleOrNil]创建实例对象\n![](/images/code_init.png)\n\n\n## 系统默认loadView实现\n通过initWithNibName保存的nibName来加载对应的nib资源并赋值于self.view, 如果nibName为空，则创建一个空的UIView实例赋值。\n\n![](/images/def_loadview.png)\n\n__注意：__在loadView方法自定义实现中由于view未进行初始化，如果使用self.view获取值，由会再次触发调用loadView方法造成loadView的递归调用。在ios9.3环境下通过self.view进行赋值则不存在此情况。\n\n\n附一张UIViewController生命周期图：\n![](/images/uiviewcontroller-lifecycle.jpg)\n\n-----\n\n*观点仅代表自己，期待你的留言。*\n","source":"_posts/ios-loadview.md","raw":"---\ntitle: iOS中UIViewController初始化过程及LoadView默认实现\ntags:\n  - iOS\n  - 原创\ndate: 2016-03-29 15:41:52\n---\n\n\n## Xib或者Storyboard方式初始化UIViewController\n1、系统会通过 (instancetype)initWithCoder:(NSCoder *)aDecoder创建Controller对象实例。\n2、当需要将UIController的View添加到父级View时则会通过loadViewIfRequired方法来先判断self.view对象是否为nil\n\t如果为nil则会调用 (void)loadView进行view的初始化。然后会调用viewDidLoad方法\n\n![](/images/xib_init.png)\n\n## 编码的方式初始化UIViewController\n[[UIViewController alloc] init]，系统会调用[[UIViewController alloc] initWithNibName:(NSString *)nibNameOrNil bundle:(NSBundle *)nibBundleOrNil]创建实例对象\n![](/images/code_init.png)\n\n\n## 系统默认loadView实现\n通过initWithNibName保存的nibName来加载对应的nib资源并赋值于self.view, 如果nibName为空，则创建一个空的UIView实例赋值。\n\n![](/images/def_loadview.png)\n\n__注意：__在loadView方法自定义实现中由于view未进行初始化，如果使用self.view获取值，由会再次触发调用loadView方法造成loadView的递归调用。在ios9.3环境下通过self.view进行赋值则不存在此情况。\n\n\n附一张UIViewController生命周期图：\n![](/images/uiviewcontroller-lifecycle.jpg)\n\n-----\n\n*观点仅代表自己，期待你的留言。*\n","slug":"ios-loadview","published":1,"updated":"2021-08-31T14:23:11.542Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cku52dyn2001wbbin7kpw3gq6","content":"<h2 id=\"Xib或者Storyboard方式初始化UIViewController\"><a href=\"#Xib或者Storyboard方式初始化UIViewController\" class=\"headerlink\" title=\"Xib或者Storyboard方式初始化UIViewController\"></a>Xib或者Storyboard方式初始化UIViewController</h2><p>1、系统会通过 (instancetype)initWithCoder:(NSCoder *)aDecoder创建Controller对象实例。<br>2、当需要将UIController的View添加到父级View时则会通过loadViewIfRequired方法来先判断self.view对象是否为nil<br>    如果为nil则会调用 (void)loadView进行view的初始化。然后会调用viewDidLoad方法</p>\n<p><img src=\"/images/xib_init.png\"></p>\n<h2 id=\"编码的方式初始化UIViewController\"><a href=\"#编码的方式初始化UIViewController\" class=\"headerlink\" title=\"编码的方式初始化UIViewController\"></a>编码的方式初始化UIViewController</h2><p>[[UIViewController alloc] init]，系统会调用[[UIViewController alloc] initWithNibName:(NSString *)nibNameOrNil bundle:(NSBundle *)nibBundleOrNil]创建实例对象<br><img src=\"/images/code_init.png\"></p>\n<h2 id=\"系统默认loadView实现\"><a href=\"#系统默认loadView实现\" class=\"headerlink\" title=\"系统默认loadView实现\"></a>系统默认loadView实现</h2><p>通过initWithNibName保存的nibName来加载对应的nib资源并赋值于self.view, 如果nibName为空，则创建一个空的UIView实例赋值。</p>\n<p><img src=\"/images/def_loadview.png\"></p>\n<p>__注意：__在loadView方法自定义实现中由于view未进行初始化，如果使用self.view获取值，由会再次触发调用loadView方法造成loadView的递归调用。在ios9.3环境下通过self.view进行赋值则不存在此情况。</p>\n<p>附一张UIViewController生命周期图：<br><img src=\"/images/uiviewcontroller-lifecycle.jpg\"></p>\n<hr>\n<p><em>观点仅代表自己，期待你的留言。</em></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"Xib或者Storyboard方式初始化UIViewController\"><a href=\"#Xib或者Storyboard方式初始化UIViewController\" class=\"headerlink\" title=\"Xib或者Storyboard方式初始化UIViewController\"></a>Xib或者Storyboard方式初始化UIViewController</h2><p>1、系统会通过 (instancetype)initWithCoder:(NSCoder *)aDecoder创建Controller对象实例。<br>2、当需要将UIController的View添加到父级View时则会通过loadViewIfRequired方法来先判断self.view对象是否为nil<br>    如果为nil则会调用 (void)loadView进行view的初始化。然后会调用viewDidLoad方法</p>\n<p><img src=\"/images/xib_init.png\"></p>\n<h2 id=\"编码的方式初始化UIViewController\"><a href=\"#编码的方式初始化UIViewController\" class=\"headerlink\" title=\"编码的方式初始化UIViewController\"></a>编码的方式初始化UIViewController</h2><p>[[UIViewController alloc] init]，系统会调用[[UIViewController alloc] initWithNibName:(NSString *)nibNameOrNil bundle:(NSBundle *)nibBundleOrNil]创建实例对象<br><img src=\"/images/code_init.png\"></p>\n<h2 id=\"系统默认loadView实现\"><a href=\"#系统默认loadView实现\" class=\"headerlink\" title=\"系统默认loadView实现\"></a>系统默认loadView实现</h2><p>通过initWithNibName保存的nibName来加载对应的nib资源并赋值于self.view, 如果nibName为空，则创建一个空的UIView实例赋值。</p>\n<p><img src=\"/images/def_loadview.png\"></p>\n<p>__注意：__在loadView方法自定义实现中由于view未进行初始化，如果使用self.view获取值，由会再次触发调用loadView方法造成loadView的递归调用。在ios9.3环境下通过self.view进行赋值则不存在此情况。</p>\n<p>附一张UIViewController生命周期图：<br><img src=\"/images/uiviewcontroller-lifecycle.jpg\"></p>\n<hr>\n<p><em>观点仅代表自己，期待你的留言。</em></p>\n"},{"title":"iOS 本地通知","date":"2016-04-05T07:16:53.000Z","_content":"\n为了提高用户的关注度，我们经常会推送一些新的内容给用户。ios中主要有两种推送，一种是远程通知，一种是本地通知，远程通知是和服务器端配合完成的，这里暂不说明，这篇文章主要说下本地通知。 \n本地通知是在ios4.0之后添加的，但是在ios8之后，在设置通知之前，需要先对通知进行注册，注册需要的通知类型，否则收不到响应类型的通知消息。\n```objectivec\n//ios8需要注册推送\nif ([UIApplication instancesRespondToSelector:@selector(registerUserNotificationSettings:)]){\n    //通知类型\n    UIUserNotificationType types = UIUserNotificationTypeBadge |\n    UIUserNotificationTypeSound | UIUserNotificationTypeAlert;\n    //设置通知类型和动画\n    UIUserNotificationSettings *mySettings =\n    [UIUserNotificationSettings settingsForTypes:types categories:nil];\n    //注册\n    [[UIApplication sharedApplication] registerUserNotificationSettings:mySettings];\n}\n```\n上边注册了Icon角标，声音，和警告通知，当程序第一次调用`registerUserNotificationSettings`的时候，程序会询问用户是否允许程序发送通知，在用户选择之后(不管是同意与否)，程序会异步调用`- (void)application:(UIApplication *)application didRegisterUserNotificationSettings:(UIUserNotificationSettings *)`函数。所有的注册类型都会可通过`currentUserNotificationSettings`变量获得。\n```objectivec\nUILocalNotification *notification = [[UILocalNotification alloc] init];\nif (notification) {\n    //设置时区\n    notification.timeZone=[NSTimeZone defaultTimeZone];\n    //设置推送的时间点\n    NSDateFormatter *formatter = [[NSDateFormatter alloc] init];\n    [formatter setDateFormat:@\"HH:mm:ss\"];\n    NSDate *date = [formatter dateFromString:@\"09:00:00\"];\n    notification.fireDate=date;\n    //通知重复提示的单位，可以是天、周、月\n    notification.repeatInterval = kCFCalendarUnitDay;\n    //推送的内容\n    notification.alertBody = @\"this is a notificaiton\";\n    //推送声音\n    notification.soundName = UILocalNotificationDefaultSoundName;\n    //应用右上角红色图标数字\n    notification.applicationIconBadgeNumber = 1;\n    //自定义信息\n    NSDictionary *infoDict = [NSDictionary dictionaryWithObject:@\"two\" forKey:@\"one\"];\n    notification.userInfo = infoDict;\n}\n\nUIApplication *app = [UIApplication sharedApplication];\n[app scheduleLocalNotification:notification];\n```\n本地通知是通过`UILocalNotification`类来完成的，首先需要通过fireDate设置通知的时间点，还可设置通知的内容，声音，角标数等。除此之外，用户还可通过userInfo设置自定义数据。具体可参考[UILocalNotification官方文档](https://developer.apple.com/library/ios/documentation/iPhone/Reference/UILocalNotification_Class/index.html#//apple_ref/occ/cl/UILocalNotification)\n当程序正在运行时，收到通知时，会调用`application:didReceiveLocalNotification`方法。\n```objectivec\n- (void)application:(UIApplication *)application didReceiveLocalNotification:(UILocalNotification *)notification\n{\n    NSDictionary *infoDict = notification.userInfo;\n    NSString *str = [infoDict objectForKey:@\"one\"];\n    if ([str isEqualToString:@\"two\"]) {\n        NSLog(@\"--------yes  equal\");\n    } else {\n        NSLog(@\"--------no \");\n    }\n}\n```\n取消通知时，可以使用`cancelLocalNotification`取消具体某个通知或者通过`cancelAllLocalNotifications`取消全部通知。\n```objectivec\n[[UIApplication sharedApplication] cancelAllLocalNotifications];\n```\n如果我们添加了角标，在通知之后，角标会一直存在，当需要取消角标时，可利用下边语句\n```objectivec\n[[UIApplication sharedApplication] setApplicationIconBadgeNumber:0];\n```\n从ios8开始，通知添加了通知动作事件，如果有注意到，我们上边的进行注册的时候categories赋值为nil，此变量就是用来添加动作事件的。\n```objectivec\n//ios8需要注册推送\nif ([UIApplication instancesRespondToSelector:@selector(registerUserNotificationSettings:)]){\n    UIMutableUserNotificationAction *acceptAction =\n    [[UIMutableUserNotificationAction alloc] init];\n    acceptAction.identifier = @\"accept_action\"; //ID\n    acceptAction.title = @\"Accept\";             //按钮内容\n    acceptAction.activationMode = UIUserNotificationActivationModeBackground;\n    acceptAction.destructive = NO;\n    acceptAction.authenticationRequired = NO;\n\n    UIMutableUserNotificationAction *cancelAction =\n    [[UIMutableUserNotificationAction alloc] init];\n    cancelAction.identifier = @\"cancel_action\";\n    cancelAction.title=@\"Cancel\";\n    cancelAction.activationMode = UIUserNotificationActivationModeBackground;\n    cancelAction.destructive = NO;\n    cancelAction.authenticationRequired = NO;\n\n    // First create the category\n    UIMutableUserNotificationCategory *inviteCategory =\n    [[UIMutableUserNotificationCategory alloc] init];\n    inviteCategory.identifier = @\"INVITE_CATEGORY\";\n    [inviteCategory setActions:@[acceptAction, cancelAction]\n                    forContext:UIUserNotificationActionContextDefault];\n    NSSet *categories = [NSSet setWithObject:inviteCategory];\n\n    //通知类型\n    UIUserNotificationType types = UIUserNotificationTypeBadge |\n    UIUserNotificationTypeSound | UIUserNotificationTypeAlert;\n    UIUserNotificationSettings *mySettings =\n    [UIUserNotificationSettings settingsForTypes:types categories:categories];\n    //注册\n    [[UIApplication sharedApplication] registerUserNotificationSettings:mySettings];\n}\n\nUILocalNotification *notification = [[UILocalNotification alloc] init];\nif (notification) {\n    //时区\n    notification.timeZone=[NSTimeZone defaultTimeZone];\n    NSDateFormatter *formatter = [[NSDateFormatter alloc] init];\n    [formatter setDateFormat:@\"ss\"];\n    NSDate *date = [formatter dateFromString:@\"10\"];\n    notification.alertBody = @\"haha\";\n    notification.fireDate=date;\n    //通知重复提示的单位，可以是天、周、月\n    notification.repeatInterval = kCFCalendarUnitMinute;\n    //推送声音\n    notification.soundName = UILocalNotificationDefaultSoundName;\n    //应用右上角红色图标数字\n    notification.applicationIconBadgeNumber = 1;\n    notification.category = @\"INVITE_CATEGORY\";\n\n    NSDictionary *infoDict = [NSDictionary dictionaryWithObject:@\"two\" forKey:@\"one\"];\n    notification.userInfo = infoDict;\n\n}\n\nUIApplication *app = [UIApplication sharedApplication];\n[app scheduleLocalNotification:notification];\n```\n以上就是一个动作的事件的注册过程，其中用到了`UIMutableUserNotificationAction`和`UIMutableUserNotificationCategory`具体用法可参考官方文档 \n[UIMutableUserNotificationAction](https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIMutableUserNotificationAction_class/index.html#//apple_ref/occ/cl/UIMutableUserNotificationAction) \n[UIMutableUserNotificationCategory](https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIMutableUserNotificationCategory_class/index.html#//apple_ref/occ/cl/UIMutableUserNotificationCategory) \n这两个类，注册完之后，特别需要主意，要在本地通知中进行设置，否则没有效果。值为注册时category指定的ID\n```objectivec\nnotification.category = @\"INVITE_CATEGORY\";\n```\n这样当我们收到通知，下拉一下就可看到动作事件，有事件，就有事件的回调函数\n```objectivec\n- (void)application:(UIApplication *)application handleActionWithIdentifier:(NSString *)identifier forLocalNotification:(UILocalNotification *)notification completionHandler:(void (^)())completionHandler\n{\n    if ([identifier isEqualToString:@\"accept_action\"]) {\n        NSLog(@\"-----accept action\");\n    } else if ([identifier isEqualToString:@\"cancel_action\"]) {\n        NSLog(@\"-----cancel action\");\n    }\n\n    if (completionHandler) {\n        completionHandler();\n    }\n}\n```\n通过id我们就可以区分不同的动作，然后对其进行相应处理，最后调用`completionHandler()`;\n\n-----\n\n*观点仅代表自己，期待你的留言。*\nhttp://zuolun.me/blog/2015/01/08/ios-ben-di-tui-song/\n","source":"_posts/ios-local-notification.md","raw":"---\ntitle: iOS 本地通知\ntags:\n  - iOS\n  - 转载\ndate: 2016-04-05 15:16:53\n---\n\n为了提高用户的关注度，我们经常会推送一些新的内容给用户。ios中主要有两种推送，一种是远程通知，一种是本地通知，远程通知是和服务器端配合完成的，这里暂不说明，这篇文章主要说下本地通知。 \n本地通知是在ios4.0之后添加的，但是在ios8之后，在设置通知之前，需要先对通知进行注册，注册需要的通知类型，否则收不到响应类型的通知消息。\n```objectivec\n//ios8需要注册推送\nif ([UIApplication instancesRespondToSelector:@selector(registerUserNotificationSettings:)]){\n    //通知类型\n    UIUserNotificationType types = UIUserNotificationTypeBadge |\n    UIUserNotificationTypeSound | UIUserNotificationTypeAlert;\n    //设置通知类型和动画\n    UIUserNotificationSettings *mySettings =\n    [UIUserNotificationSettings settingsForTypes:types categories:nil];\n    //注册\n    [[UIApplication sharedApplication] registerUserNotificationSettings:mySettings];\n}\n```\n上边注册了Icon角标，声音，和警告通知，当程序第一次调用`registerUserNotificationSettings`的时候，程序会询问用户是否允许程序发送通知，在用户选择之后(不管是同意与否)，程序会异步调用`- (void)application:(UIApplication *)application didRegisterUserNotificationSettings:(UIUserNotificationSettings *)`函数。所有的注册类型都会可通过`currentUserNotificationSettings`变量获得。\n```objectivec\nUILocalNotification *notification = [[UILocalNotification alloc] init];\nif (notification) {\n    //设置时区\n    notification.timeZone=[NSTimeZone defaultTimeZone];\n    //设置推送的时间点\n    NSDateFormatter *formatter = [[NSDateFormatter alloc] init];\n    [formatter setDateFormat:@\"HH:mm:ss\"];\n    NSDate *date = [formatter dateFromString:@\"09:00:00\"];\n    notification.fireDate=date;\n    //通知重复提示的单位，可以是天、周、月\n    notification.repeatInterval = kCFCalendarUnitDay;\n    //推送的内容\n    notification.alertBody = @\"this is a notificaiton\";\n    //推送声音\n    notification.soundName = UILocalNotificationDefaultSoundName;\n    //应用右上角红色图标数字\n    notification.applicationIconBadgeNumber = 1;\n    //自定义信息\n    NSDictionary *infoDict = [NSDictionary dictionaryWithObject:@\"two\" forKey:@\"one\"];\n    notification.userInfo = infoDict;\n}\n\nUIApplication *app = [UIApplication sharedApplication];\n[app scheduleLocalNotification:notification];\n```\n本地通知是通过`UILocalNotification`类来完成的，首先需要通过fireDate设置通知的时间点，还可设置通知的内容，声音，角标数等。除此之外，用户还可通过userInfo设置自定义数据。具体可参考[UILocalNotification官方文档](https://developer.apple.com/library/ios/documentation/iPhone/Reference/UILocalNotification_Class/index.html#//apple_ref/occ/cl/UILocalNotification)\n当程序正在运行时，收到通知时，会调用`application:didReceiveLocalNotification`方法。\n```objectivec\n- (void)application:(UIApplication *)application didReceiveLocalNotification:(UILocalNotification *)notification\n{\n    NSDictionary *infoDict = notification.userInfo;\n    NSString *str = [infoDict objectForKey:@\"one\"];\n    if ([str isEqualToString:@\"two\"]) {\n        NSLog(@\"--------yes  equal\");\n    } else {\n        NSLog(@\"--------no \");\n    }\n}\n```\n取消通知时，可以使用`cancelLocalNotification`取消具体某个通知或者通过`cancelAllLocalNotifications`取消全部通知。\n```objectivec\n[[UIApplication sharedApplication] cancelAllLocalNotifications];\n```\n如果我们添加了角标，在通知之后，角标会一直存在，当需要取消角标时，可利用下边语句\n```objectivec\n[[UIApplication sharedApplication] setApplicationIconBadgeNumber:0];\n```\n从ios8开始，通知添加了通知动作事件，如果有注意到，我们上边的进行注册的时候categories赋值为nil，此变量就是用来添加动作事件的。\n```objectivec\n//ios8需要注册推送\nif ([UIApplication instancesRespondToSelector:@selector(registerUserNotificationSettings:)]){\n    UIMutableUserNotificationAction *acceptAction =\n    [[UIMutableUserNotificationAction alloc] init];\n    acceptAction.identifier = @\"accept_action\"; //ID\n    acceptAction.title = @\"Accept\";             //按钮内容\n    acceptAction.activationMode = UIUserNotificationActivationModeBackground;\n    acceptAction.destructive = NO;\n    acceptAction.authenticationRequired = NO;\n\n    UIMutableUserNotificationAction *cancelAction =\n    [[UIMutableUserNotificationAction alloc] init];\n    cancelAction.identifier = @\"cancel_action\";\n    cancelAction.title=@\"Cancel\";\n    cancelAction.activationMode = UIUserNotificationActivationModeBackground;\n    cancelAction.destructive = NO;\n    cancelAction.authenticationRequired = NO;\n\n    // First create the category\n    UIMutableUserNotificationCategory *inviteCategory =\n    [[UIMutableUserNotificationCategory alloc] init];\n    inviteCategory.identifier = @\"INVITE_CATEGORY\";\n    [inviteCategory setActions:@[acceptAction, cancelAction]\n                    forContext:UIUserNotificationActionContextDefault];\n    NSSet *categories = [NSSet setWithObject:inviteCategory];\n\n    //通知类型\n    UIUserNotificationType types = UIUserNotificationTypeBadge |\n    UIUserNotificationTypeSound | UIUserNotificationTypeAlert;\n    UIUserNotificationSettings *mySettings =\n    [UIUserNotificationSettings settingsForTypes:types categories:categories];\n    //注册\n    [[UIApplication sharedApplication] registerUserNotificationSettings:mySettings];\n}\n\nUILocalNotification *notification = [[UILocalNotification alloc] init];\nif (notification) {\n    //时区\n    notification.timeZone=[NSTimeZone defaultTimeZone];\n    NSDateFormatter *formatter = [[NSDateFormatter alloc] init];\n    [formatter setDateFormat:@\"ss\"];\n    NSDate *date = [formatter dateFromString:@\"10\"];\n    notification.alertBody = @\"haha\";\n    notification.fireDate=date;\n    //通知重复提示的单位，可以是天、周、月\n    notification.repeatInterval = kCFCalendarUnitMinute;\n    //推送声音\n    notification.soundName = UILocalNotificationDefaultSoundName;\n    //应用右上角红色图标数字\n    notification.applicationIconBadgeNumber = 1;\n    notification.category = @\"INVITE_CATEGORY\";\n\n    NSDictionary *infoDict = [NSDictionary dictionaryWithObject:@\"two\" forKey:@\"one\"];\n    notification.userInfo = infoDict;\n\n}\n\nUIApplication *app = [UIApplication sharedApplication];\n[app scheduleLocalNotification:notification];\n```\n以上就是一个动作的事件的注册过程，其中用到了`UIMutableUserNotificationAction`和`UIMutableUserNotificationCategory`具体用法可参考官方文档 \n[UIMutableUserNotificationAction](https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIMutableUserNotificationAction_class/index.html#//apple_ref/occ/cl/UIMutableUserNotificationAction) \n[UIMutableUserNotificationCategory](https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIMutableUserNotificationCategory_class/index.html#//apple_ref/occ/cl/UIMutableUserNotificationCategory) \n这两个类，注册完之后，特别需要主意，要在本地通知中进行设置，否则没有效果。值为注册时category指定的ID\n```objectivec\nnotification.category = @\"INVITE_CATEGORY\";\n```\n这样当我们收到通知，下拉一下就可看到动作事件，有事件，就有事件的回调函数\n```objectivec\n- (void)application:(UIApplication *)application handleActionWithIdentifier:(NSString *)identifier forLocalNotification:(UILocalNotification *)notification completionHandler:(void (^)())completionHandler\n{\n    if ([identifier isEqualToString:@\"accept_action\"]) {\n        NSLog(@\"-----accept action\");\n    } else if ([identifier isEqualToString:@\"cancel_action\"]) {\n        NSLog(@\"-----cancel action\");\n    }\n\n    if (completionHandler) {\n        completionHandler();\n    }\n}\n```\n通过id我们就可以区分不同的动作，然后对其进行相应处理，最后调用`completionHandler()`;\n\n-----\n\n*观点仅代表自己，期待你的留言。*\nhttp://zuolun.me/blog/2015/01/08/ios-ben-di-tui-song/\n","slug":"ios-local-notification","published":1,"updated":"2021-08-31T14:23:11.542Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cku52dyn2001ybbinecmo8zbi","content":"<p>为了提高用户的关注度，我们经常会推送一些新的内容给用户。ios中主要有两种推送，一种是远程通知，一种是本地通知，远程通知是和服务器端配合完成的，这里暂不说明，这篇文章主要说下本地通知。<br>本地通知是在ios4.0之后添加的，但是在ios8之后，在设置通知之前，需要先对通知进行注册，注册需要的通知类型，否则收不到响应类型的通知消息。</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//ios8需要注册推送</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> ([<span class=\"built_in\">UIApplication</span> instancesRespondToSelector:<span class=\"keyword\">@selector</span>(registerUserNotificationSettings:)])&#123;</span><br><span class=\"line\">    <span class=\"comment\">//通知类型</span></span><br><span class=\"line\">    <span class=\"built_in\">UIUserNotificationType</span> types = <span class=\"built_in\">UIUserNotificationTypeBadge</span> |</span><br><span class=\"line\">    <span class=\"built_in\">UIUserNotificationTypeSound</span> | <span class=\"built_in\">UIUserNotificationTypeAlert</span>;</span><br><span class=\"line\">    <span class=\"comment\">//设置通知类型和动画</span></span><br><span class=\"line\">    <span class=\"built_in\">UIUserNotificationSettings</span> *mySettings =</span><br><span class=\"line\">    [<span class=\"built_in\">UIUserNotificationSettings</span> settingsForTypes:types categories:<span class=\"literal\">nil</span>];</span><br><span class=\"line\">    <span class=\"comment\">//注册</span></span><br><span class=\"line\">    [[<span class=\"built_in\">UIApplication</span> sharedApplication] registerUserNotificationSettings:mySettings];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上边注册了Icon角标，声音，和警告通知，当程序第一次调用<code>registerUserNotificationSettings</code>的时候，程序会询问用户是否允许程序发送通知，在用户选择之后(不管是同意与否)，程序会异步调用<code>- (void)application:(UIApplication *)application didRegisterUserNotificationSettings:(UIUserNotificationSettings *)</code>函数。所有的注册类型都会可通过<code>currentUserNotificationSettings</code>变量获得。</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">UILocalNotification</span> *notification = [[<span class=\"built_in\">UILocalNotification</span> alloc] init];</span><br><span class=\"line\"><span class=\"keyword\">if</span> (notification) &#123;</span><br><span class=\"line\">    <span class=\"comment\">//设置时区</span></span><br><span class=\"line\">    notification.timeZone=[<span class=\"built_in\">NSTimeZone</span> defaultTimeZone];</span><br><span class=\"line\">    <span class=\"comment\">//设置推送的时间点</span></span><br><span class=\"line\">    <span class=\"built_in\">NSDateFormatter</span> *formatter = [[<span class=\"built_in\">NSDateFormatter</span> alloc] init];</span><br><span class=\"line\">    [formatter setDateFormat:<span class=\"string\">@&quot;HH:mm:ss&quot;</span>];</span><br><span class=\"line\">    <span class=\"built_in\">NSDate</span> *date = [formatter dateFromString:<span class=\"string\">@&quot;09:00:00&quot;</span>];</span><br><span class=\"line\">    notification.fireDate=date;</span><br><span class=\"line\">    <span class=\"comment\">//通知重复提示的单位，可以是天、周、月</span></span><br><span class=\"line\">    notification.repeatInterval = kCFCalendarUnitDay;</span><br><span class=\"line\">    <span class=\"comment\">//推送的内容</span></span><br><span class=\"line\">    notification.alertBody = <span class=\"string\">@&quot;this is a notificaiton&quot;</span>;</span><br><span class=\"line\">    <span class=\"comment\">//推送声音</span></span><br><span class=\"line\">    notification.soundName = <span class=\"built_in\">UILocalNotificationDefaultSoundName</span>;</span><br><span class=\"line\">    <span class=\"comment\">//应用右上角红色图标数字</span></span><br><span class=\"line\">    notification.applicationIconBadgeNumber = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"comment\">//自定义信息</span></span><br><span class=\"line\">    <span class=\"built_in\">NSDictionary</span> *infoDict = [<span class=\"built_in\">NSDictionary</span> dictionaryWithObject:<span class=\"string\">@&quot;two&quot;</span> forKey:<span class=\"string\">@&quot;one&quot;</span>];</span><br><span class=\"line\">    notification.userInfo = infoDict;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">UIApplication</span> *app = [<span class=\"built_in\">UIApplication</span> sharedApplication];</span><br><span class=\"line\">[app scheduleLocalNotification:notification];</span><br></pre></td></tr></table></figure>\n<p>本地通知是通过<code>UILocalNotification</code>类来完成的，首先需要通过fireDate设置通知的时间点，还可设置通知的内容，声音，角标数等。除此之外，用户还可通过userInfo设置自定义数据。具体可参考<a href=\"https://developer.apple.com/library/ios/documentation/iPhone/Reference/UILocalNotification_Class/index.html#//apple_ref/occ/cl/UILocalNotification\">UILocalNotification官方文档</a><br>当程序正在运行时，收到通知时，会调用<code>application:didReceiveLocalNotification</code>方法。</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)application:(<span class=\"built_in\">UIApplication</span> *)application didReceiveLocalNotification:(<span class=\"built_in\">UILocalNotification</span> *)notification</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSDictionary</span> *infoDict = notification.userInfo;</span><br><span class=\"line\">    <span class=\"built_in\">NSString</span> *str = [infoDict objectForKey:<span class=\"string\">@&quot;one&quot;</span>];</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ([str isEqualToString:<span class=\"string\">@&quot;two&quot;</span>]) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@&quot;--------yes  equal&quot;</span>);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@&quot;--------no &quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>取消通知时，可以使用<code>cancelLocalNotification</code>取消具体某个通知或者通过<code>cancelAllLocalNotifications</code>取消全部通知。</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[[<span class=\"built_in\">UIApplication</span> sharedApplication] cancelAllLocalNotifications];</span><br></pre></td></tr></table></figure>\n<p>如果我们添加了角标，在通知之后，角标会一直存在，当需要取消角标时，可利用下边语句</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[[<span class=\"built_in\">UIApplication</span> sharedApplication] setApplicationIconBadgeNumber:<span class=\"number\">0</span>];</span><br></pre></td></tr></table></figure>\n<p>从ios8开始，通知添加了通知动作事件，如果有注意到，我们上边的进行注册的时候categories赋值为nil，此变量就是用来添加动作事件的。</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//ios8需要注册推送</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> ([<span class=\"built_in\">UIApplication</span> instancesRespondToSelector:<span class=\"keyword\">@selector</span>(registerUserNotificationSettings:)])&#123;</span><br><span class=\"line\">    <span class=\"built_in\">UIMutableUserNotificationAction</span> *acceptAction =</span><br><span class=\"line\">    [[<span class=\"built_in\">UIMutableUserNotificationAction</span> alloc] init];</span><br><span class=\"line\">    acceptAction.identifier = <span class=\"string\">@&quot;accept_action&quot;</span>; <span class=\"comment\">//ID</span></span><br><span class=\"line\">    acceptAction.title = <span class=\"string\">@&quot;Accept&quot;</span>;             <span class=\"comment\">//按钮内容</span></span><br><span class=\"line\">    acceptAction.activationMode = <span class=\"built_in\">UIUserNotificationActivationModeBackground</span>;</span><br><span class=\"line\">    acceptAction.destructive = <span class=\"literal\">NO</span>;</span><br><span class=\"line\">    acceptAction.authenticationRequired = <span class=\"literal\">NO</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">UIMutableUserNotificationAction</span> *cancelAction =</span><br><span class=\"line\">    [[<span class=\"built_in\">UIMutableUserNotificationAction</span> alloc] init];</span><br><span class=\"line\">    cancelAction.identifier = <span class=\"string\">@&quot;cancel_action&quot;</span>;</span><br><span class=\"line\">    cancelAction.title=<span class=\"string\">@&quot;Cancel&quot;</span>;</span><br><span class=\"line\">    cancelAction.activationMode = <span class=\"built_in\">UIUserNotificationActivationModeBackground</span>;</span><br><span class=\"line\">    cancelAction.destructive = <span class=\"literal\">NO</span>;</span><br><span class=\"line\">    cancelAction.authenticationRequired = <span class=\"literal\">NO</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// First create the category</span></span><br><span class=\"line\">    <span class=\"built_in\">UIMutableUserNotificationCategory</span> *inviteCategory =</span><br><span class=\"line\">    [[<span class=\"built_in\">UIMutableUserNotificationCategory</span> alloc] init];</span><br><span class=\"line\">    inviteCategory.identifier = <span class=\"string\">@&quot;INVITE_CATEGORY&quot;</span>;</span><br><span class=\"line\">    [inviteCategory setActions:@[acceptAction, cancelAction]</span><br><span class=\"line\">                    forContext:<span class=\"built_in\">UIUserNotificationActionContextDefault</span>];</span><br><span class=\"line\">    <span class=\"built_in\">NSSet</span> *categories = [<span class=\"built_in\">NSSet</span> setWithObject:inviteCategory];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//通知类型</span></span><br><span class=\"line\">    <span class=\"built_in\">UIUserNotificationType</span> types = <span class=\"built_in\">UIUserNotificationTypeBadge</span> |</span><br><span class=\"line\">    <span class=\"built_in\">UIUserNotificationTypeSound</span> | <span class=\"built_in\">UIUserNotificationTypeAlert</span>;</span><br><span class=\"line\">    <span class=\"built_in\">UIUserNotificationSettings</span> *mySettings =</span><br><span class=\"line\">    [<span class=\"built_in\">UIUserNotificationSettings</span> settingsForTypes:types categories:categories];</span><br><span class=\"line\">    <span class=\"comment\">//注册</span></span><br><span class=\"line\">    [[<span class=\"built_in\">UIApplication</span> sharedApplication] registerUserNotificationSettings:mySettings];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">UILocalNotification</span> *notification = [[<span class=\"built_in\">UILocalNotification</span> alloc] init];</span><br><span class=\"line\"><span class=\"keyword\">if</span> (notification) &#123;</span><br><span class=\"line\">    <span class=\"comment\">//时区</span></span><br><span class=\"line\">    notification.timeZone=[<span class=\"built_in\">NSTimeZone</span> defaultTimeZone];</span><br><span class=\"line\">    <span class=\"built_in\">NSDateFormatter</span> *formatter = [[<span class=\"built_in\">NSDateFormatter</span> alloc] init];</span><br><span class=\"line\">    [formatter setDateFormat:<span class=\"string\">@&quot;ss&quot;</span>];</span><br><span class=\"line\">    <span class=\"built_in\">NSDate</span> *date = [formatter dateFromString:<span class=\"string\">@&quot;10&quot;</span>];</span><br><span class=\"line\">    notification.alertBody = <span class=\"string\">@&quot;haha&quot;</span>;</span><br><span class=\"line\">    notification.fireDate=date;</span><br><span class=\"line\">    <span class=\"comment\">//通知重复提示的单位，可以是天、周、月</span></span><br><span class=\"line\">    notification.repeatInterval = kCFCalendarUnitMinute;</span><br><span class=\"line\">    <span class=\"comment\">//推送声音</span></span><br><span class=\"line\">    notification.soundName = <span class=\"built_in\">UILocalNotificationDefaultSoundName</span>;</span><br><span class=\"line\">    <span class=\"comment\">//应用右上角红色图标数字</span></span><br><span class=\"line\">    notification.applicationIconBadgeNumber = <span class=\"number\">1</span>;</span><br><span class=\"line\">    notification.category = <span class=\"string\">@&quot;INVITE_CATEGORY&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">NSDictionary</span> *infoDict = [<span class=\"built_in\">NSDictionary</span> dictionaryWithObject:<span class=\"string\">@&quot;two&quot;</span> forKey:<span class=\"string\">@&quot;one&quot;</span>];</span><br><span class=\"line\">    notification.userInfo = infoDict;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">UIApplication</span> *app = [<span class=\"built_in\">UIApplication</span> sharedApplication];</span><br><span class=\"line\">[app scheduleLocalNotification:notification];</span><br></pre></td></tr></table></figure>\n<p>以上就是一个动作的事件的注册过程，其中用到了<code>UIMutableUserNotificationAction</code>和<code>UIMutableUserNotificationCategory</code>具体用法可参考官方文档<br><a href=\"https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIMutableUserNotificationAction_class/index.html#//apple_ref/occ/cl/UIMutableUserNotificationAction\">UIMutableUserNotificationAction</a><br><a href=\"https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIMutableUserNotificationCategory_class/index.html#//apple_ref/occ/cl/UIMutableUserNotificationCategory\">UIMutableUserNotificationCategory</a><br>这两个类，注册完之后，特别需要主意，要在本地通知中进行设置，否则没有效果。值为注册时category指定的ID</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">notification.category = <span class=\"string\">@&quot;INVITE_CATEGORY&quot;</span>;</span><br></pre></td></tr></table></figure>\n<p>这样当我们收到通知，下拉一下就可看到动作事件，有事件，就有事件的回调函数</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)application:(<span class=\"built_in\">UIApplication</span> *)application handleActionWithIdentifier:(<span class=\"built_in\">NSString</span> *)identifier forLocalNotification:(<span class=\"built_in\">UILocalNotification</span> *)notification completionHandler:(<span class=\"keyword\">void</span> (^)())completionHandler</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ([identifier isEqualToString:<span class=\"string\">@&quot;accept_action&quot;</span>]) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@&quot;-----accept action&quot;</span>);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ([identifier isEqualToString:<span class=\"string\">@&quot;cancel_action&quot;</span>]) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@&quot;-----cancel action&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (completionHandler) &#123;</span><br><span class=\"line\">        completionHandler();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>通过id我们就可以区分不同的动作，然后对其进行相应处理，最后调用<code>completionHandler()</code>;</p>\n<hr>\n<p><em>观点仅代表自己，期待你的留言。</em><br><a href=\"http://zuolun.me/blog/2015/01/08/ios-ben-di-tui-song/\">http://zuolun.me/blog/2015/01/08/ios-ben-di-tui-song/</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>为了提高用户的关注度，我们经常会推送一些新的内容给用户。ios中主要有两种推送，一种是远程通知，一种是本地通知，远程通知是和服务器端配合完成的，这里暂不说明，这篇文章主要说下本地通知。<br>本地通知是在ios4.0之后添加的，但是在ios8之后，在设置通知之前，需要先对通知进行注册，注册需要的通知类型，否则收不到响应类型的通知消息。</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//ios8需要注册推送</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> ([<span class=\"built_in\">UIApplication</span> instancesRespondToSelector:<span class=\"keyword\">@selector</span>(registerUserNotificationSettings:)])&#123;</span><br><span class=\"line\">    <span class=\"comment\">//通知类型</span></span><br><span class=\"line\">    <span class=\"built_in\">UIUserNotificationType</span> types = <span class=\"built_in\">UIUserNotificationTypeBadge</span> |</span><br><span class=\"line\">    <span class=\"built_in\">UIUserNotificationTypeSound</span> | <span class=\"built_in\">UIUserNotificationTypeAlert</span>;</span><br><span class=\"line\">    <span class=\"comment\">//设置通知类型和动画</span></span><br><span class=\"line\">    <span class=\"built_in\">UIUserNotificationSettings</span> *mySettings =</span><br><span class=\"line\">    [<span class=\"built_in\">UIUserNotificationSettings</span> settingsForTypes:types categories:<span class=\"literal\">nil</span>];</span><br><span class=\"line\">    <span class=\"comment\">//注册</span></span><br><span class=\"line\">    [[<span class=\"built_in\">UIApplication</span> sharedApplication] registerUserNotificationSettings:mySettings];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上边注册了Icon角标，声音，和警告通知，当程序第一次调用<code>registerUserNotificationSettings</code>的时候，程序会询问用户是否允许程序发送通知，在用户选择之后(不管是同意与否)，程序会异步调用<code>- (void)application:(UIApplication *)application didRegisterUserNotificationSettings:(UIUserNotificationSettings *)</code>函数。所有的注册类型都会可通过<code>currentUserNotificationSettings</code>变量获得。</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">UILocalNotification</span> *notification = [[<span class=\"built_in\">UILocalNotification</span> alloc] init];</span><br><span class=\"line\"><span class=\"keyword\">if</span> (notification) &#123;</span><br><span class=\"line\">    <span class=\"comment\">//设置时区</span></span><br><span class=\"line\">    notification.timeZone=[<span class=\"built_in\">NSTimeZone</span> defaultTimeZone];</span><br><span class=\"line\">    <span class=\"comment\">//设置推送的时间点</span></span><br><span class=\"line\">    <span class=\"built_in\">NSDateFormatter</span> *formatter = [[<span class=\"built_in\">NSDateFormatter</span> alloc] init];</span><br><span class=\"line\">    [formatter setDateFormat:<span class=\"string\">@&quot;HH:mm:ss&quot;</span>];</span><br><span class=\"line\">    <span class=\"built_in\">NSDate</span> *date = [formatter dateFromString:<span class=\"string\">@&quot;09:00:00&quot;</span>];</span><br><span class=\"line\">    notification.fireDate=date;</span><br><span class=\"line\">    <span class=\"comment\">//通知重复提示的单位，可以是天、周、月</span></span><br><span class=\"line\">    notification.repeatInterval = kCFCalendarUnitDay;</span><br><span class=\"line\">    <span class=\"comment\">//推送的内容</span></span><br><span class=\"line\">    notification.alertBody = <span class=\"string\">@&quot;this is a notificaiton&quot;</span>;</span><br><span class=\"line\">    <span class=\"comment\">//推送声音</span></span><br><span class=\"line\">    notification.soundName = <span class=\"built_in\">UILocalNotificationDefaultSoundName</span>;</span><br><span class=\"line\">    <span class=\"comment\">//应用右上角红色图标数字</span></span><br><span class=\"line\">    notification.applicationIconBadgeNumber = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"comment\">//自定义信息</span></span><br><span class=\"line\">    <span class=\"built_in\">NSDictionary</span> *infoDict = [<span class=\"built_in\">NSDictionary</span> dictionaryWithObject:<span class=\"string\">@&quot;two&quot;</span> forKey:<span class=\"string\">@&quot;one&quot;</span>];</span><br><span class=\"line\">    notification.userInfo = infoDict;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">UIApplication</span> *app = [<span class=\"built_in\">UIApplication</span> sharedApplication];</span><br><span class=\"line\">[app scheduleLocalNotification:notification];</span><br></pre></td></tr></table></figure>\n<p>本地通知是通过<code>UILocalNotification</code>类来完成的，首先需要通过fireDate设置通知的时间点，还可设置通知的内容，声音，角标数等。除此之外，用户还可通过userInfo设置自定义数据。具体可参考<a href=\"https://developer.apple.com/library/ios/documentation/iPhone/Reference/UILocalNotification_Class/index.html#//apple_ref/occ/cl/UILocalNotification\">UILocalNotification官方文档</a><br>当程序正在运行时，收到通知时，会调用<code>application:didReceiveLocalNotification</code>方法。</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)application:(<span class=\"built_in\">UIApplication</span> *)application didReceiveLocalNotification:(<span class=\"built_in\">UILocalNotification</span> *)notification</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSDictionary</span> *infoDict = notification.userInfo;</span><br><span class=\"line\">    <span class=\"built_in\">NSString</span> *str = [infoDict objectForKey:<span class=\"string\">@&quot;one&quot;</span>];</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ([str isEqualToString:<span class=\"string\">@&quot;two&quot;</span>]) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@&quot;--------yes  equal&quot;</span>);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@&quot;--------no &quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>取消通知时，可以使用<code>cancelLocalNotification</code>取消具体某个通知或者通过<code>cancelAllLocalNotifications</code>取消全部通知。</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[[<span class=\"built_in\">UIApplication</span> sharedApplication] cancelAllLocalNotifications];</span><br></pre></td></tr></table></figure>\n<p>如果我们添加了角标，在通知之后，角标会一直存在，当需要取消角标时，可利用下边语句</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[[<span class=\"built_in\">UIApplication</span> sharedApplication] setApplicationIconBadgeNumber:<span class=\"number\">0</span>];</span><br></pre></td></tr></table></figure>\n<p>从ios8开始，通知添加了通知动作事件，如果有注意到，我们上边的进行注册的时候categories赋值为nil，此变量就是用来添加动作事件的。</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//ios8需要注册推送</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> ([<span class=\"built_in\">UIApplication</span> instancesRespondToSelector:<span class=\"keyword\">@selector</span>(registerUserNotificationSettings:)])&#123;</span><br><span class=\"line\">    <span class=\"built_in\">UIMutableUserNotificationAction</span> *acceptAction =</span><br><span class=\"line\">    [[<span class=\"built_in\">UIMutableUserNotificationAction</span> alloc] init];</span><br><span class=\"line\">    acceptAction.identifier = <span class=\"string\">@&quot;accept_action&quot;</span>; <span class=\"comment\">//ID</span></span><br><span class=\"line\">    acceptAction.title = <span class=\"string\">@&quot;Accept&quot;</span>;             <span class=\"comment\">//按钮内容</span></span><br><span class=\"line\">    acceptAction.activationMode = <span class=\"built_in\">UIUserNotificationActivationModeBackground</span>;</span><br><span class=\"line\">    acceptAction.destructive = <span class=\"literal\">NO</span>;</span><br><span class=\"line\">    acceptAction.authenticationRequired = <span class=\"literal\">NO</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">UIMutableUserNotificationAction</span> *cancelAction =</span><br><span class=\"line\">    [[<span class=\"built_in\">UIMutableUserNotificationAction</span> alloc] init];</span><br><span class=\"line\">    cancelAction.identifier = <span class=\"string\">@&quot;cancel_action&quot;</span>;</span><br><span class=\"line\">    cancelAction.title=<span class=\"string\">@&quot;Cancel&quot;</span>;</span><br><span class=\"line\">    cancelAction.activationMode = <span class=\"built_in\">UIUserNotificationActivationModeBackground</span>;</span><br><span class=\"line\">    cancelAction.destructive = <span class=\"literal\">NO</span>;</span><br><span class=\"line\">    cancelAction.authenticationRequired = <span class=\"literal\">NO</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// First create the category</span></span><br><span class=\"line\">    <span class=\"built_in\">UIMutableUserNotificationCategory</span> *inviteCategory =</span><br><span class=\"line\">    [[<span class=\"built_in\">UIMutableUserNotificationCategory</span> alloc] init];</span><br><span class=\"line\">    inviteCategory.identifier = <span class=\"string\">@&quot;INVITE_CATEGORY&quot;</span>;</span><br><span class=\"line\">    [inviteCategory setActions:@[acceptAction, cancelAction]</span><br><span class=\"line\">                    forContext:<span class=\"built_in\">UIUserNotificationActionContextDefault</span>];</span><br><span class=\"line\">    <span class=\"built_in\">NSSet</span> *categories = [<span class=\"built_in\">NSSet</span> setWithObject:inviteCategory];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//通知类型</span></span><br><span class=\"line\">    <span class=\"built_in\">UIUserNotificationType</span> types = <span class=\"built_in\">UIUserNotificationTypeBadge</span> |</span><br><span class=\"line\">    <span class=\"built_in\">UIUserNotificationTypeSound</span> | <span class=\"built_in\">UIUserNotificationTypeAlert</span>;</span><br><span class=\"line\">    <span class=\"built_in\">UIUserNotificationSettings</span> *mySettings =</span><br><span class=\"line\">    [<span class=\"built_in\">UIUserNotificationSettings</span> settingsForTypes:types categories:categories];</span><br><span class=\"line\">    <span class=\"comment\">//注册</span></span><br><span class=\"line\">    [[<span class=\"built_in\">UIApplication</span> sharedApplication] registerUserNotificationSettings:mySettings];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">UILocalNotification</span> *notification = [[<span class=\"built_in\">UILocalNotification</span> alloc] init];</span><br><span class=\"line\"><span class=\"keyword\">if</span> (notification) &#123;</span><br><span class=\"line\">    <span class=\"comment\">//时区</span></span><br><span class=\"line\">    notification.timeZone=[<span class=\"built_in\">NSTimeZone</span> defaultTimeZone];</span><br><span class=\"line\">    <span class=\"built_in\">NSDateFormatter</span> *formatter = [[<span class=\"built_in\">NSDateFormatter</span> alloc] init];</span><br><span class=\"line\">    [formatter setDateFormat:<span class=\"string\">@&quot;ss&quot;</span>];</span><br><span class=\"line\">    <span class=\"built_in\">NSDate</span> *date = [formatter dateFromString:<span class=\"string\">@&quot;10&quot;</span>];</span><br><span class=\"line\">    notification.alertBody = <span class=\"string\">@&quot;haha&quot;</span>;</span><br><span class=\"line\">    notification.fireDate=date;</span><br><span class=\"line\">    <span class=\"comment\">//通知重复提示的单位，可以是天、周、月</span></span><br><span class=\"line\">    notification.repeatInterval = kCFCalendarUnitMinute;</span><br><span class=\"line\">    <span class=\"comment\">//推送声音</span></span><br><span class=\"line\">    notification.soundName = <span class=\"built_in\">UILocalNotificationDefaultSoundName</span>;</span><br><span class=\"line\">    <span class=\"comment\">//应用右上角红色图标数字</span></span><br><span class=\"line\">    notification.applicationIconBadgeNumber = <span class=\"number\">1</span>;</span><br><span class=\"line\">    notification.category = <span class=\"string\">@&quot;INVITE_CATEGORY&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">NSDictionary</span> *infoDict = [<span class=\"built_in\">NSDictionary</span> dictionaryWithObject:<span class=\"string\">@&quot;two&quot;</span> forKey:<span class=\"string\">@&quot;one&quot;</span>];</span><br><span class=\"line\">    notification.userInfo = infoDict;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">UIApplication</span> *app = [<span class=\"built_in\">UIApplication</span> sharedApplication];</span><br><span class=\"line\">[app scheduleLocalNotification:notification];</span><br></pre></td></tr></table></figure>\n<p>以上就是一个动作的事件的注册过程，其中用到了<code>UIMutableUserNotificationAction</code>和<code>UIMutableUserNotificationCategory</code>具体用法可参考官方文档<br><a href=\"https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIMutableUserNotificationAction_class/index.html#//apple_ref/occ/cl/UIMutableUserNotificationAction\">UIMutableUserNotificationAction</a><br><a href=\"https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIMutableUserNotificationCategory_class/index.html#//apple_ref/occ/cl/UIMutableUserNotificationCategory\">UIMutableUserNotificationCategory</a><br>这两个类，注册完之后，特别需要主意，要在本地通知中进行设置，否则没有效果。值为注册时category指定的ID</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">notification.category = <span class=\"string\">@&quot;INVITE_CATEGORY&quot;</span>;</span><br></pre></td></tr></table></figure>\n<p>这样当我们收到通知，下拉一下就可看到动作事件，有事件，就有事件的回调函数</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)application:(<span class=\"built_in\">UIApplication</span> *)application handleActionWithIdentifier:(<span class=\"built_in\">NSString</span> *)identifier forLocalNotification:(<span class=\"built_in\">UILocalNotification</span> *)notification completionHandler:(<span class=\"keyword\">void</span> (^)())completionHandler</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ([identifier isEqualToString:<span class=\"string\">@&quot;accept_action&quot;</span>]) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@&quot;-----accept action&quot;</span>);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ([identifier isEqualToString:<span class=\"string\">@&quot;cancel_action&quot;</span>]) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@&quot;-----cancel action&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (completionHandler) &#123;</span><br><span class=\"line\">        completionHandler();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>通过id我们就可以区分不同的动作，然后对其进行相应处理，最后调用<code>completionHandler()</code>;</p>\n<hr>\n<p><em>观点仅代表自己，期待你的留言。</em><br><a href=\"http://zuolun.me/blog/2015/01/08/ios-ben-di-tui-song/\">http://zuolun.me/blog/2015/01/08/ios-ben-di-tui-song/</a></p>\n"},{"title":"iOS开发过程中几种消息传递机制的理解","date":"2016-03-30T09:39:24.000Z","_content":"\n\n## 几种消息传递机制\n首先我们来看看每种机制的具体特点。在这个基础上，下一节我们会画一个流程图来帮我们在具体情况下正确选择应该使用的机制。最后，我们会介绍一些苹果框架里的例子并且解释为什么在那些用例中会选择这样的机制。\n\n### KVO\nKVO 是提供对象属性被改变时的通知的机制。KVO 的实现在 Foundation 中，很多基于 Foundation 的框架都依赖它。\n\n如果只对某个对象的值的改变感兴趣的话，就可以使用 KVO 消息传递。不过有一些前提：第一，接收者（接收对象改变的通知的对象）需要知道发送者 （值会改变的对象）；第二，接收者需要知道发送者的生命周期，因为它需要在发送者被销毁前注销观察者身份。如果这两个要去符合的话，这个消息传递机制可以一对多（多个观察者可以注册观察同一个对象的变化）\n\n如果要在 Core Data 上使用 KVO 的话，方法会有些许差别。这和 Core Data 的惰性加载 (faulting) 机制有关。一旦一个 managed object 被惰性加载处理的话，即使它的属性没有被改变，它还是会触发相应的观察者。\n\n__编者注__ 把属性值先取入缓存中，在对象需要的时候再进行一次访问，这在 Core Data 中是默认行为，这种技术称为 Faulting。这么做可以避免降低内存开销，但是如果你确定将访问结果对象的具体属性值时，可以禁用 Faults 以提高获取性能。关于这个技术更多的情况，请移步[官方文档](https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/CoreData/Articles/cdFaultingUniquing.html)\n### 通知\n要在代码中的两个不相关的模块中传递消息时，通知机制是非常好的工具。通知机制广播消息，当消息内容丰富而且无需指望接收者一定要关注的话这一招特别有用。\n\n通知可以用来发送任意消息，甚至可以包含一个 userInfo 字典。你也可以继承 NSNotification 写一个自己的通知类来自定义行为。通知的独特之处在于，发送者和接收者不需要相互知道对方，所以通知可以被用来在不同的相隔很远的模块之间传递消息。这就意味着这种消息传递是单向的，我们不能回复一个通知。\n### 委托 (Delegation)\nDelegation 在苹果的框架中广泛存在。它让我们能自定义对象的行为，并收到一些触发的事件。要使用 delegation 模式的话，发送者需要知道接收者，但是反过来没有要求。因为发送者只需要知道接收者符合一定的协议，所以它们两者结合的很松。\n\n因为 delegate 协议可以定义任何的方法，我们可以照着自己的需求来传递消息。可以用方法参数来传递消息内容，delegate 可以通过返回值的形式来给发送者作出回应。如果只要在相对接近的两个模块间传递消息，delgation 是很灵活很直接的消息传递机制。\n\n过度使用 delegation 也会带来风险。如果两个对象结合得很紧密，任何其中一个对象都不能单独运转，那么就不需要用 delegate 协议了。这些情况下，对象已经知道各自的类型，可以直接交流。两个比较新的例子是 UICollectionViewLayout 和 NSURLSessionConfiguration。\n### Block\nBlock 是最近才加入 Objective-C 的，首次出现在 OS X 10.6 和 iOS 4 平台上。Block 通常可以完全替代 delegation 消息传递机制的角色。不过这两种机制都有它们自己的独特需求和优势。\n\n一个不使用 block 的理由通常是 block 会存在导致 retain 环 (retain cycles) 的风险。如果发送者需要 retain block 但又不能确保引用在什么时候被赋值为 nil， 那么所有在 block 内对 self 的引用就会发生潜在的 retain 环。\n\n假设我们要实现一个用 block 回调而不是 delegate 机制的 table view 里的选择方法，如下所示：\n```\nself.myTableView.selectionHandler = ^void(NSIndexPath *selectedIndexPath) {\n    // 处理选择\n};\n```\n这儿的问题是，self 会 retain table view，table view 为了让 block 之后可以使用而又需要 retain 这个 block。然而 table view 不能把这个引用设为 nil，因为它不知道什么时候不需要这个 block 了。如果我们不能保证打破 retain 环并且我们需要 retain 发送者，那么 block 就不是一个的好选择。\n\nNSOperation 是使用 block 的一个好范例。因为它在一定的地方打破了 retain 环，解决了上述的问题。\n```\nself.queue = [[NSOperationQueue alloc] init];\nMyOperation *operation = [[MyOperation alloc] init];\noperation.completionBlock = ^{\n    [self finishedOperation];\n};\n[self.queue addOperation:operation];\n```\n一眼看来好像上面的代码有一个 retain 环：self retain 了 queue，queue retain 了 operation， operation retain 了 completionBlock， 而 completionBlock retain 了 self。然而，把 operation 加入 queue 中会使 operation 在某个时间被执行，然后被从 queue 中移除。（如果没被执行，问题就大了。）一旦 queue 把 operation 移除，retain 环就被打破了。\n\n另一个例子是：我们在写一个视频编码器的类，在类里面我们会调用一个 encodeWithCompletionHandler: 的方法。为了不出问题，我们需要保证编码器对象在某个时间点会释放对 block 的引用。其代码如下所示：\n```\n@interface Encoder ()\n@property (nonatomic, copy) void (^completionHandler)();\n@end\n\n@implementation Encoder\n\n- (void)encodeWithCompletionHandler:(void (^)())handler\n{\n    self.completionHandler = handler;\n    // 进行异步处理...\n}\n\n// 这个方法会在完成后被调用一次\n- (void)finishedEncoding\n{\n    self.completionHandler();\n    self.completionHandler = nil; // <- 不要忘了这个!\n}\n\n@end\n```\n一旦任务完成，completion block 调用过了以后，我们就应该把它设为 nil。\n\n如果一个被调用的方法需要发送一个一次性的消息作为回复，那么使用 block 是很好的选择， 因为这样做我们可以打破潜在的 retain 环。另外，如果将处理的消息和对消息的调用放在一起可以增强可读性的话，我们也很难拒绝使用 block 来进行处理。在用例之中，使用 block 来做完成的回调，错误的回调，或者类似的事情，是很常见的情况。\n### Target-Action\nTarget-Action 是回应 UI 事件时典型的消息传递方式。iOS 上的 UIControl 和 Mac 上的 NSControl/NSCell 都支持这个机制。Target-Action 在消息的发送者和接收者之间建立了一个松散的关系。消息的接收者不知道发送者，甚至消息的发送者也不知道消息的接收者会是什么。如果 target 是 nil，action 会在[响应链 (responder chain) ](https://developer.apple.com/library/ios/documentation/general/conceptual/Devpedia-CocoaApp/Responder.html)中被传递下去，直到找到一个响应它的对象。在 iOS 中，每个控件甚至可以和多个 target-action 关联。\n\n基于 target-action 传递机制的一个局限是，发送的消息不能携带自定义的信息。在 Mac 平台上 action 方法的第一个参数永远接收者。iOS 中，可以选择性的把发送者和触发 action 的事件作为参数。除此之外就没有别的控制 action 消息内容的方法了。\n### 做出正确的选择\n基于上述对不同消息传递机制的特点，我们画了一个流程图来帮助我们在不同情境下做出不同的选择。一句忠告：流程图的建议不代表最终答案。有些时候别的选择依然能达到应有的效果。只不过大多数情况下这张图能引导你做出正确的决定。\n![](/images/communication-patterns-flow-chart.png)\n图中有些细节值得深究：\n\n有个框中说到： 发送者支持 KVO。这不仅仅是说发送者会在值改变的时候发送 KVO 通知，而且说明观察者需要知道发送者的生命周期。如果发送者被存在一个 weak 属性中，那么发送者有可能会自己变成 nil，那时观察者会导致内存泄露。\n\n一个在最后一行的框里说，消息直接响应方法调用。也就是说方法调用的接收者需要给调用者一个消息作为方法调用的直接反馈。这也就是说处理消息的代码和调用方法的代码必须在同一个地方。\n\n最后在右下角的地方，一个选择分支这样说：发送者能确保释放对 block 的引用吗？这涉及到了我们之前讨论 block 的 API 存在潜在的 retain 环的问题。如果发送者不能保证在某个时间点会释放对 block 的引用，那么你会惹上 retain 环的麻烦。\n\n## Framework 示例\n本节我们通过一些苹果框架里的例子来验证流程图的选择是否有道理，同时解释为什么苹果会选择用这些机制。\n### KVO\nNSOperationQueue 用了 KVO 观察队列中的 operation 状态属性的改变情况 (isFinished，isExecuting，isCancelled)。当状态改变的时候，队列会收到 KVO 通知。为什么 operation 队列要用 KVO 呢？\n\n消息的接收者（operation 队列）知道消息的发送者（operation），并 retain 它并控制后者的生命周期。另外，在这种情况下只需要单向的消息传递机制。当然如果考虑到 oepration 队列只关心那些改变 operation 的值的改变情况的话，就还不足以说服大家使用 KVO 了。但我们可以这么理解：被传递的消息可以被当成值的改变来处理。因为 state 属性在 operation 队列以外也是有用的，所以这里适合用 KVO。\n![](/images/kvo-flow-chart.png)\n当然 KVO 不是唯一的选择。我们也可以将 operation 队列作为 operation 的 delegate 来使用，operation 会调用类似 operationDidFinish: 或者 operationDidBeginExecuting: 等方法把它的 state 传递给 queue。这样就不太方便了，因为 operation 要保存 state 属性，以便于调用这些 delegate 方法。另外，由于 queue 不能主动获取 state 信息，所以 queue 也必须保存所有 operation 的 state。\n### Notifications\nCore Data 使用 notification 传递事件（例如一个 managed object context 中的改变————NSManagedObjectContextObjectsDidChangeNotification）\n\n发生改变时触发的 notification 是由 managed object contexts 发出的，所以我们不能假定消息的接收者知道消息的发送者。因为消息的源头不是一个 UI 事件，很多接收者可能在关注着此消息，并且消息传递是单向的，所以 notification 是唯一可行的选择。\n![](/images/notification-flow-chart.png)\n### Delegation\nTable view 的 delegate 有多重功能，它可以从管理 accessory view，直到追踪在屏幕上显示的 cell。例如我们可以看看 tableView:didSelectRowAtIndexPath: 方法。为什么用 delegate 实现而不是 target-action 机制？\n\n正如我们在上述流程图中看到的，用 target-action 时，不能传递自定义的数据。而选中 table view 的某个 cell 时，collection view 不仅需要告诉我们一个 cell 被选中了，也要通过 index path 告诉我们哪个 cell 被选中了。如果我们照着这个思路，流程图会引导我们使用 delegation 机制。\n![](/images/delegation-flow-chart.png)\n如果不在消息传递中包含选中 cell 的 index path，而是让选中项改变时我们像 table view 主动询问并获取选中 cell 的相关信息，会怎样呢？这会非常不方便，因为我们必须记住当前选中项的数据，这样才能在多选择中知道哪些 cell 是被新选中的。\n\n同理，我们可以想象通过观察 table view 选中项的 index path 属性，当该值发生改变的时候，获得一个选中项改变的通知。不过我们会遇到上述相似问题：不做记录的话我们就不能分辨哪一个 cell 被选择或取消选择了。\n### Block\n我们用 -[NSURLSession dataTaskWithURL:completionHandler:] 来作为一个 block API 的介绍。那么从 URL 加载部分返回给调用者是怎么传递消息的呢？首先，作为 API 的调用者，我们知道消息的发送者，但是我们并没有 retain 它。另外，这是个单向的消息传递————它直接调用 dataTaskWithURL: 的方法。如果我们对照流程图，会发现这属于 block 消息传递机制。\n![](/images/block-flow-chart.png)\n有其他的选项吗？当然，苹果自己的 NSURLConnection 就是最好的例子。NSURLConnection在 block 问世之前就存在了，所以它并没有用 block 来实现消息传递，而是使用 delegation 来完成。当 block 出现以后，苹果就在 OS X 10.7 和 iOS 5 平台上的 NSURLConnection 中加了 sendAsynchronousRequest:queue:completionHandler:，所以我们不再在简单的任务中使用 delegate 了。\n\n因为 NSURLSession 是个最近在 OS X 10.9 和 iOS 7 才出现的 API，所以它们使用 block 来实现消息传递机制（NSURLSession 有一个 delegate，但是是用于其他目的）。\n### Target-Action\n一个明显的 target-action 用例是按钮。按钮在不被按下的时候不需要发送任何的信息。为了这个目的，target-action 是 UI 中消息传递的最佳选择。\n![](/images/target-action-flow-chart.png)\n如果 target 是明确指定的，那么 action 消息会发送给指定的对象。如果 target 是 nil， action 消息会一直在响应链中被传递下去，直到找到一个能处理它的对象。在这种情况下，我们有一个完全解耦的消息传递机制：发送者不需要知道接收者，反之亦然。\n\nTarget-action 机制非常适合响应 UI 的事件。没有其他的消息传递机制能够提供相同的功能。虽然 notification 在发送者和接收者的松散关系上最接近它，但是 target-action 可以用于响应链——只有一个对象获得 action 并响应，action 在响应链中传递，直到能遇到响应这个 action 的对象。\n## 总结\n一开始接触这么多的消息传递机制的时候，我们可能有些无所适从，觉得所有的机制都可以被选用。不过一旦我们仔细分析每个机制的时候，它们各自都有特殊的要求和能力。\n\n文中的选择流程图是帮助你清楚认识这些机制的好的开始，当然它不是所有问题的答案。如果你觉得这和你自己选择机制的方式相似或是有任何缺漏，欢迎来信指正。\n\n\n-----\n\n*观点仅代表自己，期待你的留言。*\nhttp://objccn.io/issue-7-4/\n","source":"_posts/ios-msg-transfer.md","raw":"---\ntitle: iOS开发过程中几种消息传递机制的理解\ntags:\n  - iOS\n  - 转载\ndate: 2016-03-30 17:39:24\n---\n\n\n## 几种消息传递机制\n首先我们来看看每种机制的具体特点。在这个基础上，下一节我们会画一个流程图来帮我们在具体情况下正确选择应该使用的机制。最后，我们会介绍一些苹果框架里的例子并且解释为什么在那些用例中会选择这样的机制。\n\n### KVO\nKVO 是提供对象属性被改变时的通知的机制。KVO 的实现在 Foundation 中，很多基于 Foundation 的框架都依赖它。\n\n如果只对某个对象的值的改变感兴趣的话，就可以使用 KVO 消息传递。不过有一些前提：第一，接收者（接收对象改变的通知的对象）需要知道发送者 （值会改变的对象）；第二，接收者需要知道发送者的生命周期，因为它需要在发送者被销毁前注销观察者身份。如果这两个要去符合的话，这个消息传递机制可以一对多（多个观察者可以注册观察同一个对象的变化）\n\n如果要在 Core Data 上使用 KVO 的话，方法会有些许差别。这和 Core Data 的惰性加载 (faulting) 机制有关。一旦一个 managed object 被惰性加载处理的话，即使它的属性没有被改变，它还是会触发相应的观察者。\n\n__编者注__ 把属性值先取入缓存中，在对象需要的时候再进行一次访问，这在 Core Data 中是默认行为，这种技术称为 Faulting。这么做可以避免降低内存开销，但是如果你确定将访问结果对象的具体属性值时，可以禁用 Faults 以提高获取性能。关于这个技术更多的情况，请移步[官方文档](https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/CoreData/Articles/cdFaultingUniquing.html)\n### 通知\n要在代码中的两个不相关的模块中传递消息时，通知机制是非常好的工具。通知机制广播消息，当消息内容丰富而且无需指望接收者一定要关注的话这一招特别有用。\n\n通知可以用来发送任意消息，甚至可以包含一个 userInfo 字典。你也可以继承 NSNotification 写一个自己的通知类来自定义行为。通知的独特之处在于，发送者和接收者不需要相互知道对方，所以通知可以被用来在不同的相隔很远的模块之间传递消息。这就意味着这种消息传递是单向的，我们不能回复一个通知。\n### 委托 (Delegation)\nDelegation 在苹果的框架中广泛存在。它让我们能自定义对象的行为，并收到一些触发的事件。要使用 delegation 模式的话，发送者需要知道接收者，但是反过来没有要求。因为发送者只需要知道接收者符合一定的协议，所以它们两者结合的很松。\n\n因为 delegate 协议可以定义任何的方法，我们可以照着自己的需求来传递消息。可以用方法参数来传递消息内容，delegate 可以通过返回值的形式来给发送者作出回应。如果只要在相对接近的两个模块间传递消息，delgation 是很灵活很直接的消息传递机制。\n\n过度使用 delegation 也会带来风险。如果两个对象结合得很紧密，任何其中一个对象都不能单独运转，那么就不需要用 delegate 协议了。这些情况下，对象已经知道各自的类型，可以直接交流。两个比较新的例子是 UICollectionViewLayout 和 NSURLSessionConfiguration。\n### Block\nBlock 是最近才加入 Objective-C 的，首次出现在 OS X 10.6 和 iOS 4 平台上。Block 通常可以完全替代 delegation 消息传递机制的角色。不过这两种机制都有它们自己的独特需求和优势。\n\n一个不使用 block 的理由通常是 block 会存在导致 retain 环 (retain cycles) 的风险。如果发送者需要 retain block 但又不能确保引用在什么时候被赋值为 nil， 那么所有在 block 内对 self 的引用就会发生潜在的 retain 环。\n\n假设我们要实现一个用 block 回调而不是 delegate 机制的 table view 里的选择方法，如下所示：\n```\nself.myTableView.selectionHandler = ^void(NSIndexPath *selectedIndexPath) {\n    // 处理选择\n};\n```\n这儿的问题是，self 会 retain table view，table view 为了让 block 之后可以使用而又需要 retain 这个 block。然而 table view 不能把这个引用设为 nil，因为它不知道什么时候不需要这个 block 了。如果我们不能保证打破 retain 环并且我们需要 retain 发送者，那么 block 就不是一个的好选择。\n\nNSOperation 是使用 block 的一个好范例。因为它在一定的地方打破了 retain 环，解决了上述的问题。\n```\nself.queue = [[NSOperationQueue alloc] init];\nMyOperation *operation = [[MyOperation alloc] init];\noperation.completionBlock = ^{\n    [self finishedOperation];\n};\n[self.queue addOperation:operation];\n```\n一眼看来好像上面的代码有一个 retain 环：self retain 了 queue，queue retain 了 operation， operation retain 了 completionBlock， 而 completionBlock retain 了 self。然而，把 operation 加入 queue 中会使 operation 在某个时间被执行，然后被从 queue 中移除。（如果没被执行，问题就大了。）一旦 queue 把 operation 移除，retain 环就被打破了。\n\n另一个例子是：我们在写一个视频编码器的类，在类里面我们会调用一个 encodeWithCompletionHandler: 的方法。为了不出问题，我们需要保证编码器对象在某个时间点会释放对 block 的引用。其代码如下所示：\n```\n@interface Encoder ()\n@property (nonatomic, copy) void (^completionHandler)();\n@end\n\n@implementation Encoder\n\n- (void)encodeWithCompletionHandler:(void (^)())handler\n{\n    self.completionHandler = handler;\n    // 进行异步处理...\n}\n\n// 这个方法会在完成后被调用一次\n- (void)finishedEncoding\n{\n    self.completionHandler();\n    self.completionHandler = nil; // <- 不要忘了这个!\n}\n\n@end\n```\n一旦任务完成，completion block 调用过了以后，我们就应该把它设为 nil。\n\n如果一个被调用的方法需要发送一个一次性的消息作为回复，那么使用 block 是很好的选择， 因为这样做我们可以打破潜在的 retain 环。另外，如果将处理的消息和对消息的调用放在一起可以增强可读性的话，我们也很难拒绝使用 block 来进行处理。在用例之中，使用 block 来做完成的回调，错误的回调，或者类似的事情，是很常见的情况。\n### Target-Action\nTarget-Action 是回应 UI 事件时典型的消息传递方式。iOS 上的 UIControl 和 Mac 上的 NSControl/NSCell 都支持这个机制。Target-Action 在消息的发送者和接收者之间建立了一个松散的关系。消息的接收者不知道发送者，甚至消息的发送者也不知道消息的接收者会是什么。如果 target 是 nil，action 会在[响应链 (responder chain) ](https://developer.apple.com/library/ios/documentation/general/conceptual/Devpedia-CocoaApp/Responder.html)中被传递下去，直到找到一个响应它的对象。在 iOS 中，每个控件甚至可以和多个 target-action 关联。\n\n基于 target-action 传递机制的一个局限是，发送的消息不能携带自定义的信息。在 Mac 平台上 action 方法的第一个参数永远接收者。iOS 中，可以选择性的把发送者和触发 action 的事件作为参数。除此之外就没有别的控制 action 消息内容的方法了。\n### 做出正确的选择\n基于上述对不同消息传递机制的特点，我们画了一个流程图来帮助我们在不同情境下做出不同的选择。一句忠告：流程图的建议不代表最终答案。有些时候别的选择依然能达到应有的效果。只不过大多数情况下这张图能引导你做出正确的决定。\n![](/images/communication-patterns-flow-chart.png)\n图中有些细节值得深究：\n\n有个框中说到： 发送者支持 KVO。这不仅仅是说发送者会在值改变的时候发送 KVO 通知，而且说明观察者需要知道发送者的生命周期。如果发送者被存在一个 weak 属性中，那么发送者有可能会自己变成 nil，那时观察者会导致内存泄露。\n\n一个在最后一行的框里说，消息直接响应方法调用。也就是说方法调用的接收者需要给调用者一个消息作为方法调用的直接反馈。这也就是说处理消息的代码和调用方法的代码必须在同一个地方。\n\n最后在右下角的地方，一个选择分支这样说：发送者能确保释放对 block 的引用吗？这涉及到了我们之前讨论 block 的 API 存在潜在的 retain 环的问题。如果发送者不能保证在某个时间点会释放对 block 的引用，那么你会惹上 retain 环的麻烦。\n\n## Framework 示例\n本节我们通过一些苹果框架里的例子来验证流程图的选择是否有道理，同时解释为什么苹果会选择用这些机制。\n### KVO\nNSOperationQueue 用了 KVO 观察队列中的 operation 状态属性的改变情况 (isFinished，isExecuting，isCancelled)。当状态改变的时候，队列会收到 KVO 通知。为什么 operation 队列要用 KVO 呢？\n\n消息的接收者（operation 队列）知道消息的发送者（operation），并 retain 它并控制后者的生命周期。另外，在这种情况下只需要单向的消息传递机制。当然如果考虑到 oepration 队列只关心那些改变 operation 的值的改变情况的话，就还不足以说服大家使用 KVO 了。但我们可以这么理解：被传递的消息可以被当成值的改变来处理。因为 state 属性在 operation 队列以外也是有用的，所以这里适合用 KVO。\n![](/images/kvo-flow-chart.png)\n当然 KVO 不是唯一的选择。我们也可以将 operation 队列作为 operation 的 delegate 来使用，operation 会调用类似 operationDidFinish: 或者 operationDidBeginExecuting: 等方法把它的 state 传递给 queue。这样就不太方便了，因为 operation 要保存 state 属性，以便于调用这些 delegate 方法。另外，由于 queue 不能主动获取 state 信息，所以 queue 也必须保存所有 operation 的 state。\n### Notifications\nCore Data 使用 notification 传递事件（例如一个 managed object context 中的改变————NSManagedObjectContextObjectsDidChangeNotification）\n\n发生改变时触发的 notification 是由 managed object contexts 发出的，所以我们不能假定消息的接收者知道消息的发送者。因为消息的源头不是一个 UI 事件，很多接收者可能在关注着此消息，并且消息传递是单向的，所以 notification 是唯一可行的选择。\n![](/images/notification-flow-chart.png)\n### Delegation\nTable view 的 delegate 有多重功能，它可以从管理 accessory view，直到追踪在屏幕上显示的 cell。例如我们可以看看 tableView:didSelectRowAtIndexPath: 方法。为什么用 delegate 实现而不是 target-action 机制？\n\n正如我们在上述流程图中看到的，用 target-action 时，不能传递自定义的数据。而选中 table view 的某个 cell 时，collection view 不仅需要告诉我们一个 cell 被选中了，也要通过 index path 告诉我们哪个 cell 被选中了。如果我们照着这个思路，流程图会引导我们使用 delegation 机制。\n![](/images/delegation-flow-chart.png)\n如果不在消息传递中包含选中 cell 的 index path，而是让选中项改变时我们像 table view 主动询问并获取选中 cell 的相关信息，会怎样呢？这会非常不方便，因为我们必须记住当前选中项的数据，这样才能在多选择中知道哪些 cell 是被新选中的。\n\n同理，我们可以想象通过观察 table view 选中项的 index path 属性，当该值发生改变的时候，获得一个选中项改变的通知。不过我们会遇到上述相似问题：不做记录的话我们就不能分辨哪一个 cell 被选择或取消选择了。\n### Block\n我们用 -[NSURLSession dataTaskWithURL:completionHandler:] 来作为一个 block API 的介绍。那么从 URL 加载部分返回给调用者是怎么传递消息的呢？首先，作为 API 的调用者，我们知道消息的发送者，但是我们并没有 retain 它。另外，这是个单向的消息传递————它直接调用 dataTaskWithURL: 的方法。如果我们对照流程图，会发现这属于 block 消息传递机制。\n![](/images/block-flow-chart.png)\n有其他的选项吗？当然，苹果自己的 NSURLConnection 就是最好的例子。NSURLConnection在 block 问世之前就存在了，所以它并没有用 block 来实现消息传递，而是使用 delegation 来完成。当 block 出现以后，苹果就在 OS X 10.7 和 iOS 5 平台上的 NSURLConnection 中加了 sendAsynchronousRequest:queue:completionHandler:，所以我们不再在简单的任务中使用 delegate 了。\n\n因为 NSURLSession 是个最近在 OS X 10.9 和 iOS 7 才出现的 API，所以它们使用 block 来实现消息传递机制（NSURLSession 有一个 delegate，但是是用于其他目的）。\n### Target-Action\n一个明显的 target-action 用例是按钮。按钮在不被按下的时候不需要发送任何的信息。为了这个目的，target-action 是 UI 中消息传递的最佳选择。\n![](/images/target-action-flow-chart.png)\n如果 target 是明确指定的，那么 action 消息会发送给指定的对象。如果 target 是 nil， action 消息会一直在响应链中被传递下去，直到找到一个能处理它的对象。在这种情况下，我们有一个完全解耦的消息传递机制：发送者不需要知道接收者，反之亦然。\n\nTarget-action 机制非常适合响应 UI 的事件。没有其他的消息传递机制能够提供相同的功能。虽然 notification 在发送者和接收者的松散关系上最接近它，但是 target-action 可以用于响应链——只有一个对象获得 action 并响应，action 在响应链中传递，直到能遇到响应这个 action 的对象。\n## 总结\n一开始接触这么多的消息传递机制的时候，我们可能有些无所适从，觉得所有的机制都可以被选用。不过一旦我们仔细分析每个机制的时候，它们各自都有特殊的要求和能力。\n\n文中的选择流程图是帮助你清楚认识这些机制的好的开始，当然它不是所有问题的答案。如果你觉得这和你自己选择机制的方式相似或是有任何缺漏，欢迎来信指正。\n\n\n-----\n\n*观点仅代表自己，期待你的留言。*\nhttp://objccn.io/issue-7-4/\n","slug":"ios-msg-transfer","published":1,"updated":"2021-08-31T14:23:11.543Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cku52dyn60021bbin215i7cr9","content":"<h2 id=\"几种消息传递机制\"><a href=\"#几种消息传递机制\" class=\"headerlink\" title=\"几种消息传递机制\"></a>几种消息传递机制</h2><p>首先我们来看看每种机制的具体特点。在这个基础上，下一节我们会画一个流程图来帮我们在具体情况下正确选择应该使用的机制。最后，我们会介绍一些苹果框架里的例子并且解释为什么在那些用例中会选择这样的机制。</p>\n<h3 id=\"KVO\"><a href=\"#KVO\" class=\"headerlink\" title=\"KVO\"></a>KVO</h3><p>KVO 是提供对象属性被改变时的通知的机制。KVO 的实现在 Foundation 中，很多基于 Foundation 的框架都依赖它。</p>\n<p>如果只对某个对象的值的改变感兴趣的话，就可以使用 KVO 消息传递。不过有一些前提：第一，接收者（接收对象改变的通知的对象）需要知道发送者 （值会改变的对象）；第二，接收者需要知道发送者的生命周期，因为它需要在发送者被销毁前注销观察者身份。如果这两个要去符合的话，这个消息传递机制可以一对多（多个观察者可以注册观察同一个对象的变化）</p>\n<p>如果要在 Core Data 上使用 KVO 的话，方法会有些许差别。这和 Core Data 的惰性加载 (faulting) 机制有关。一旦一个 managed object 被惰性加载处理的话，即使它的属性没有被改变，它还是会触发相应的观察者。</p>\n<p><strong>编者注</strong> 把属性值先取入缓存中，在对象需要的时候再进行一次访问，这在 Core Data 中是默认行为，这种技术称为 Faulting。这么做可以避免降低内存开销，但是如果你确定将访问结果对象的具体属性值时，可以禁用 Faults 以提高获取性能。关于这个技术更多的情况，请移步<a href=\"https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/CoreData/Articles/cdFaultingUniquing.html\">官方文档</a></p>\n<h3 id=\"通知\"><a href=\"#通知\" class=\"headerlink\" title=\"通知\"></a>通知</h3><p>要在代码中的两个不相关的模块中传递消息时，通知机制是非常好的工具。通知机制广播消息，当消息内容丰富而且无需指望接收者一定要关注的话这一招特别有用。</p>\n<p>通知可以用来发送任意消息，甚至可以包含一个 userInfo 字典。你也可以继承 NSNotification 写一个自己的通知类来自定义行为。通知的独特之处在于，发送者和接收者不需要相互知道对方，所以通知可以被用来在不同的相隔很远的模块之间传递消息。这就意味着这种消息传递是单向的，我们不能回复一个通知。</p>\n<h3 id=\"委托-Delegation\"><a href=\"#委托-Delegation\" class=\"headerlink\" title=\"委托 (Delegation)\"></a>委托 (Delegation)</h3><p>Delegation 在苹果的框架中广泛存在。它让我们能自定义对象的行为，并收到一些触发的事件。要使用 delegation 模式的话，发送者需要知道接收者，但是反过来没有要求。因为发送者只需要知道接收者符合一定的协议，所以它们两者结合的很松。</p>\n<p>因为 delegate 协议可以定义任何的方法，我们可以照着自己的需求来传递消息。可以用方法参数来传递消息内容，delegate 可以通过返回值的形式来给发送者作出回应。如果只要在相对接近的两个模块间传递消息，delgation 是很灵活很直接的消息传递机制。</p>\n<p>过度使用 delegation 也会带来风险。如果两个对象结合得很紧密，任何其中一个对象都不能单独运转，那么就不需要用 delegate 协议了。这些情况下，对象已经知道各自的类型，可以直接交流。两个比较新的例子是 UICollectionViewLayout 和 NSURLSessionConfiguration。</p>\n<h3 id=\"Block\"><a href=\"#Block\" class=\"headerlink\" title=\"Block\"></a>Block</h3><p>Block 是最近才加入 Objective-C 的，首次出现在 OS X 10.6 和 iOS 4 平台上。Block 通常可以完全替代 delegation 消息传递机制的角色。不过这两种机制都有它们自己的独特需求和优势。</p>\n<p>一个不使用 block 的理由通常是 block 会存在导致 retain 环 (retain cycles) 的风险。如果发送者需要 retain block 但又不能确保引用在什么时候被赋值为 nil， 那么所有在 block 内对 self 的引用就会发生潜在的 retain 环。</p>\n<p>假设我们要实现一个用 block 回调而不是 delegate 机制的 table view 里的选择方法，如下所示：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">self.myTableView.selectionHandler = ^void(NSIndexPath *selectedIndexPath) &#123;</span><br><span class=\"line\">    // 处理选择</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>这儿的问题是，self 会 retain table view，table view 为了让 block 之后可以使用而又需要 retain 这个 block。然而 table view 不能把这个引用设为 nil，因为它不知道什么时候不需要这个 block 了。如果我们不能保证打破 retain 环并且我们需要 retain 发送者，那么 block 就不是一个的好选择。</p>\n<p>NSOperation 是使用 block 的一个好范例。因为它在一定的地方打破了 retain 环，解决了上述的问题。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">self.queue = [[NSOperationQueue alloc] init];</span><br><span class=\"line\">MyOperation *operation = [[MyOperation alloc] init];</span><br><span class=\"line\">operation.completionBlock = ^&#123;</span><br><span class=\"line\">    [self finishedOperation];</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">[self.queue addOperation:operation];</span><br></pre></td></tr></table></figure>\n<p>一眼看来好像上面的代码有一个 retain 环：self retain 了 queue，queue retain 了 operation， operation retain 了 completionBlock， 而 completionBlock retain 了 self。然而，把 operation 加入 queue 中会使 operation 在某个时间被执行，然后被从 queue 中移除。（如果没被执行，问题就大了。）一旦 queue 把 operation 移除，retain 环就被打破了。</p>\n<p>另一个例子是：我们在写一个视频编码器的类，在类里面我们会调用一个 encodeWithCompletionHandler: 的方法。为了不出问题，我们需要保证编码器对象在某个时间点会释放对 block 的引用。其代码如下所示：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@interface Encoder ()</span><br><span class=\"line\">@property (nonatomic, copy) void (^completionHandler)();</span><br><span class=\"line\">@end</span><br><span class=\"line\"></span><br><span class=\"line\">@implementation Encoder</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)encodeWithCompletionHandler:(void (^)())handler</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    self.completionHandler = handler;</span><br><span class=\"line\">    // 进行异步处理...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 这个方法会在完成后被调用一次</span><br><span class=\"line\">- (void)finishedEncoding</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    self.completionHandler();</span><br><span class=\"line\">    self.completionHandler = nil; // &lt;- 不要忘了这个!</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">@end</span><br></pre></td></tr></table></figure>\n<p>一旦任务完成，completion block 调用过了以后，我们就应该把它设为 nil。</p>\n<p>如果一个被调用的方法需要发送一个一次性的消息作为回复，那么使用 block 是很好的选择， 因为这样做我们可以打破潜在的 retain 环。另外，如果将处理的消息和对消息的调用放在一起可以增强可读性的话，我们也很难拒绝使用 block 来进行处理。在用例之中，使用 block 来做完成的回调，错误的回调，或者类似的事情，是很常见的情况。</p>\n<h3 id=\"Target-Action\"><a href=\"#Target-Action\" class=\"headerlink\" title=\"Target-Action\"></a>Target-Action</h3><p>Target-Action 是回应 UI 事件时典型的消息传递方式。iOS 上的 UIControl 和 Mac 上的 NSControl/NSCell 都支持这个机制。Target-Action 在消息的发送者和接收者之间建立了一个松散的关系。消息的接收者不知道发送者，甚至消息的发送者也不知道消息的接收者会是什么。如果 target 是 nil，action 会在<a href=\"https://developer.apple.com/library/ios/documentation/general/conceptual/Devpedia-CocoaApp/Responder.html\">响应链 (responder chain) </a>中被传递下去，直到找到一个响应它的对象。在 iOS 中，每个控件甚至可以和多个 target-action 关联。</p>\n<p>基于 target-action 传递机制的一个局限是，发送的消息不能携带自定义的信息。在 Mac 平台上 action 方法的第一个参数永远接收者。iOS 中，可以选择性的把发送者和触发 action 的事件作为参数。除此之外就没有别的控制 action 消息内容的方法了。</p>\n<h3 id=\"做出正确的选择\"><a href=\"#做出正确的选择\" class=\"headerlink\" title=\"做出正确的选择\"></a>做出正确的选择</h3><p>基于上述对不同消息传递机制的特点，我们画了一个流程图来帮助我们在不同情境下做出不同的选择。一句忠告：流程图的建议不代表最终答案。有些时候别的选择依然能达到应有的效果。只不过大多数情况下这张图能引导你做出正确的决定。<br><img src=\"/images/communication-patterns-flow-chart.png\"><br>图中有些细节值得深究：</p>\n<p>有个框中说到： 发送者支持 KVO。这不仅仅是说发送者会在值改变的时候发送 KVO 通知，而且说明观察者需要知道发送者的生命周期。如果发送者被存在一个 weak 属性中，那么发送者有可能会自己变成 nil，那时观察者会导致内存泄露。</p>\n<p>一个在最后一行的框里说，消息直接响应方法调用。也就是说方法调用的接收者需要给调用者一个消息作为方法调用的直接反馈。这也就是说处理消息的代码和调用方法的代码必须在同一个地方。</p>\n<p>最后在右下角的地方，一个选择分支这样说：发送者能确保释放对 block 的引用吗？这涉及到了我们之前讨论 block 的 API 存在潜在的 retain 环的问题。如果发送者不能保证在某个时间点会释放对 block 的引用，那么你会惹上 retain 环的麻烦。</p>\n<h2 id=\"Framework-示例\"><a href=\"#Framework-示例\" class=\"headerlink\" title=\"Framework 示例\"></a>Framework 示例</h2><p>本节我们通过一些苹果框架里的例子来验证流程图的选择是否有道理，同时解释为什么苹果会选择用这些机制。</p>\n<h3 id=\"KVO-1\"><a href=\"#KVO-1\" class=\"headerlink\" title=\"KVO\"></a>KVO</h3><p>NSOperationQueue 用了 KVO 观察队列中的 operation 状态属性的改变情况 (isFinished，isExecuting，isCancelled)。当状态改变的时候，队列会收到 KVO 通知。为什么 operation 队列要用 KVO 呢？</p>\n<p>消息的接收者（operation 队列）知道消息的发送者（operation），并 retain 它并控制后者的生命周期。另外，在这种情况下只需要单向的消息传递机制。当然如果考虑到 oepration 队列只关心那些改变 operation 的值的改变情况的话，就还不足以说服大家使用 KVO 了。但我们可以这么理解：被传递的消息可以被当成值的改变来处理。因为 state 属性在 operation 队列以外也是有用的，所以这里适合用 KVO。<br><img src=\"/images/kvo-flow-chart.png\"><br>当然 KVO 不是唯一的选择。我们也可以将 operation 队列作为 operation 的 delegate 来使用，operation 会调用类似 operationDidFinish: 或者 operationDidBeginExecuting: 等方法把它的 state 传递给 queue。这样就不太方便了，因为 operation 要保存 state 属性，以便于调用这些 delegate 方法。另外，由于 queue 不能主动获取 state 信息，所以 queue 也必须保存所有 operation 的 state。</p>\n<h3 id=\"Notifications\"><a href=\"#Notifications\" class=\"headerlink\" title=\"Notifications\"></a>Notifications</h3><p>Core Data 使用 notification 传递事件（例如一个 managed object context 中的改变————NSManagedObjectContextObjectsDidChangeNotification）</p>\n<p>发生改变时触发的 notification 是由 managed object contexts 发出的，所以我们不能假定消息的接收者知道消息的发送者。因为消息的源头不是一个 UI 事件，很多接收者可能在关注着此消息，并且消息传递是单向的，所以 notification 是唯一可行的选择。<br><img src=\"/images/notification-flow-chart.png\"></p>\n<h3 id=\"Delegation\"><a href=\"#Delegation\" class=\"headerlink\" title=\"Delegation\"></a>Delegation</h3><p>Table view 的 delegate 有多重功能，它可以从管理 accessory view，直到追踪在屏幕上显示的 cell。例如我们可以看看 tableView:didSelectRowAtIndexPath: 方法。为什么用 delegate 实现而不是 target-action 机制？</p>\n<p>正如我们在上述流程图中看到的，用 target-action 时，不能传递自定义的数据。而选中 table view 的某个 cell 时，collection view 不仅需要告诉我们一个 cell 被选中了，也要通过 index path 告诉我们哪个 cell 被选中了。如果我们照着这个思路，流程图会引导我们使用 delegation 机制。<br><img src=\"/images/delegation-flow-chart.png\"><br>如果不在消息传递中包含选中 cell 的 index path，而是让选中项改变时我们像 table view 主动询问并获取选中 cell 的相关信息，会怎样呢？这会非常不方便，因为我们必须记住当前选中项的数据，这样才能在多选择中知道哪些 cell 是被新选中的。</p>\n<p>同理，我们可以想象通过观察 table view 选中项的 index path 属性，当该值发生改变的时候，获得一个选中项改变的通知。不过我们会遇到上述相似问题：不做记录的话我们就不能分辨哪一个 cell 被选择或取消选择了。</p>\n<h3 id=\"Block-1\"><a href=\"#Block-1\" class=\"headerlink\" title=\"Block\"></a>Block</h3><p>我们用 -[NSURLSession dataTaskWithURL:completionHandler:] 来作为一个 block API 的介绍。那么从 URL 加载部分返回给调用者是怎么传递消息的呢？首先，作为 API 的调用者，我们知道消息的发送者，但是我们并没有 retain 它。另外，这是个单向的消息传递————它直接调用 dataTaskWithURL: 的方法。如果我们对照流程图，会发现这属于 block 消息传递机制。<br><img src=\"/images/block-flow-chart.png\"><br>有其他的选项吗？当然，苹果自己的 NSURLConnection 就是最好的例子。NSURLConnection在 block 问世之前就存在了，所以它并没有用 block 来实现消息传递，而是使用 delegation 来完成。当 block 出现以后，苹果就在 OS X 10.7 和 iOS 5 平台上的 NSURLConnection 中加了 sendAsynchronousRequest:queue:completionHandler:，所以我们不再在简单的任务中使用 delegate 了。</p>\n<p>因为 NSURLSession 是个最近在 OS X 10.9 和 iOS 7 才出现的 API，所以它们使用 block 来实现消息传递机制（NSURLSession 有一个 delegate，但是是用于其他目的）。</p>\n<h3 id=\"Target-Action-1\"><a href=\"#Target-Action-1\" class=\"headerlink\" title=\"Target-Action\"></a>Target-Action</h3><p>一个明显的 target-action 用例是按钮。按钮在不被按下的时候不需要发送任何的信息。为了这个目的，target-action 是 UI 中消息传递的最佳选择。<br><img src=\"/images/target-action-flow-chart.png\"><br>如果 target 是明确指定的，那么 action 消息会发送给指定的对象。如果 target 是 nil， action 消息会一直在响应链中被传递下去，直到找到一个能处理它的对象。在这种情况下，我们有一个完全解耦的消息传递机制：发送者不需要知道接收者，反之亦然。</p>\n<p>Target-action 机制非常适合响应 UI 的事件。没有其他的消息传递机制能够提供相同的功能。虽然 notification 在发送者和接收者的松散关系上最接近它，但是 target-action 可以用于响应链——只有一个对象获得 action 并响应，action 在响应链中传递，直到能遇到响应这个 action 的对象。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>一开始接触这么多的消息传递机制的时候，我们可能有些无所适从，觉得所有的机制都可以被选用。不过一旦我们仔细分析每个机制的时候，它们各自都有特殊的要求和能力。</p>\n<p>文中的选择流程图是帮助你清楚认识这些机制的好的开始，当然它不是所有问题的答案。如果你觉得这和你自己选择机制的方式相似或是有任何缺漏，欢迎来信指正。</p>\n<hr>\n<p><em>观点仅代表自己，期待你的留言。</em><br><a href=\"http://objccn.io/issue-7-4/\">http://objccn.io/issue-7-4/</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"几种消息传递机制\"><a href=\"#几种消息传递机制\" class=\"headerlink\" title=\"几种消息传递机制\"></a>几种消息传递机制</h2><p>首先我们来看看每种机制的具体特点。在这个基础上，下一节我们会画一个流程图来帮我们在具体情况下正确选择应该使用的机制。最后，我们会介绍一些苹果框架里的例子并且解释为什么在那些用例中会选择这样的机制。</p>\n<h3 id=\"KVO\"><a href=\"#KVO\" class=\"headerlink\" title=\"KVO\"></a>KVO</h3><p>KVO 是提供对象属性被改变时的通知的机制。KVO 的实现在 Foundation 中，很多基于 Foundation 的框架都依赖它。</p>\n<p>如果只对某个对象的值的改变感兴趣的话，就可以使用 KVO 消息传递。不过有一些前提：第一，接收者（接收对象改变的通知的对象）需要知道发送者 （值会改变的对象）；第二，接收者需要知道发送者的生命周期，因为它需要在发送者被销毁前注销观察者身份。如果这两个要去符合的话，这个消息传递机制可以一对多（多个观察者可以注册观察同一个对象的变化）</p>\n<p>如果要在 Core Data 上使用 KVO 的话，方法会有些许差别。这和 Core Data 的惰性加载 (faulting) 机制有关。一旦一个 managed object 被惰性加载处理的话，即使它的属性没有被改变，它还是会触发相应的观察者。</p>\n<p><strong>编者注</strong> 把属性值先取入缓存中，在对象需要的时候再进行一次访问，这在 Core Data 中是默认行为，这种技术称为 Faulting。这么做可以避免降低内存开销，但是如果你确定将访问结果对象的具体属性值时，可以禁用 Faults 以提高获取性能。关于这个技术更多的情况，请移步<a href=\"https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/CoreData/Articles/cdFaultingUniquing.html\">官方文档</a></p>\n<h3 id=\"通知\"><a href=\"#通知\" class=\"headerlink\" title=\"通知\"></a>通知</h3><p>要在代码中的两个不相关的模块中传递消息时，通知机制是非常好的工具。通知机制广播消息，当消息内容丰富而且无需指望接收者一定要关注的话这一招特别有用。</p>\n<p>通知可以用来发送任意消息，甚至可以包含一个 userInfo 字典。你也可以继承 NSNotification 写一个自己的通知类来自定义行为。通知的独特之处在于，发送者和接收者不需要相互知道对方，所以通知可以被用来在不同的相隔很远的模块之间传递消息。这就意味着这种消息传递是单向的，我们不能回复一个通知。</p>\n<h3 id=\"委托-Delegation\"><a href=\"#委托-Delegation\" class=\"headerlink\" title=\"委托 (Delegation)\"></a>委托 (Delegation)</h3><p>Delegation 在苹果的框架中广泛存在。它让我们能自定义对象的行为，并收到一些触发的事件。要使用 delegation 模式的话，发送者需要知道接收者，但是反过来没有要求。因为发送者只需要知道接收者符合一定的协议，所以它们两者结合的很松。</p>\n<p>因为 delegate 协议可以定义任何的方法，我们可以照着自己的需求来传递消息。可以用方法参数来传递消息内容，delegate 可以通过返回值的形式来给发送者作出回应。如果只要在相对接近的两个模块间传递消息，delgation 是很灵活很直接的消息传递机制。</p>\n<p>过度使用 delegation 也会带来风险。如果两个对象结合得很紧密，任何其中一个对象都不能单独运转，那么就不需要用 delegate 协议了。这些情况下，对象已经知道各自的类型，可以直接交流。两个比较新的例子是 UICollectionViewLayout 和 NSURLSessionConfiguration。</p>\n<h3 id=\"Block\"><a href=\"#Block\" class=\"headerlink\" title=\"Block\"></a>Block</h3><p>Block 是最近才加入 Objective-C 的，首次出现在 OS X 10.6 和 iOS 4 平台上。Block 通常可以完全替代 delegation 消息传递机制的角色。不过这两种机制都有它们自己的独特需求和优势。</p>\n<p>一个不使用 block 的理由通常是 block 会存在导致 retain 环 (retain cycles) 的风险。如果发送者需要 retain block 但又不能确保引用在什么时候被赋值为 nil， 那么所有在 block 内对 self 的引用就会发生潜在的 retain 环。</p>\n<p>假设我们要实现一个用 block 回调而不是 delegate 机制的 table view 里的选择方法，如下所示：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">self.myTableView.selectionHandler = ^void(NSIndexPath *selectedIndexPath) &#123;</span><br><span class=\"line\">    // 处理选择</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>这儿的问题是，self 会 retain table view，table view 为了让 block 之后可以使用而又需要 retain 这个 block。然而 table view 不能把这个引用设为 nil，因为它不知道什么时候不需要这个 block 了。如果我们不能保证打破 retain 环并且我们需要 retain 发送者，那么 block 就不是一个的好选择。</p>\n<p>NSOperation 是使用 block 的一个好范例。因为它在一定的地方打破了 retain 环，解决了上述的问题。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">self.queue = [[NSOperationQueue alloc] init];</span><br><span class=\"line\">MyOperation *operation = [[MyOperation alloc] init];</span><br><span class=\"line\">operation.completionBlock = ^&#123;</span><br><span class=\"line\">    [self finishedOperation];</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">[self.queue addOperation:operation];</span><br></pre></td></tr></table></figure>\n<p>一眼看来好像上面的代码有一个 retain 环：self retain 了 queue，queue retain 了 operation， operation retain 了 completionBlock， 而 completionBlock retain 了 self。然而，把 operation 加入 queue 中会使 operation 在某个时间被执行，然后被从 queue 中移除。（如果没被执行，问题就大了。）一旦 queue 把 operation 移除，retain 环就被打破了。</p>\n<p>另一个例子是：我们在写一个视频编码器的类，在类里面我们会调用一个 encodeWithCompletionHandler: 的方法。为了不出问题，我们需要保证编码器对象在某个时间点会释放对 block 的引用。其代码如下所示：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@interface Encoder ()</span><br><span class=\"line\">@property (nonatomic, copy) void (^completionHandler)();</span><br><span class=\"line\">@end</span><br><span class=\"line\"></span><br><span class=\"line\">@implementation Encoder</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)encodeWithCompletionHandler:(void (^)())handler</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    self.completionHandler = handler;</span><br><span class=\"line\">    // 进行异步处理...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 这个方法会在完成后被调用一次</span><br><span class=\"line\">- (void)finishedEncoding</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    self.completionHandler();</span><br><span class=\"line\">    self.completionHandler = nil; // &lt;- 不要忘了这个!</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">@end</span><br></pre></td></tr></table></figure>\n<p>一旦任务完成，completion block 调用过了以后，我们就应该把它设为 nil。</p>\n<p>如果一个被调用的方法需要发送一个一次性的消息作为回复，那么使用 block 是很好的选择， 因为这样做我们可以打破潜在的 retain 环。另外，如果将处理的消息和对消息的调用放在一起可以增强可读性的话，我们也很难拒绝使用 block 来进行处理。在用例之中，使用 block 来做完成的回调，错误的回调，或者类似的事情，是很常见的情况。</p>\n<h3 id=\"Target-Action\"><a href=\"#Target-Action\" class=\"headerlink\" title=\"Target-Action\"></a>Target-Action</h3><p>Target-Action 是回应 UI 事件时典型的消息传递方式。iOS 上的 UIControl 和 Mac 上的 NSControl/NSCell 都支持这个机制。Target-Action 在消息的发送者和接收者之间建立了一个松散的关系。消息的接收者不知道发送者，甚至消息的发送者也不知道消息的接收者会是什么。如果 target 是 nil，action 会在<a href=\"https://developer.apple.com/library/ios/documentation/general/conceptual/Devpedia-CocoaApp/Responder.html\">响应链 (responder chain) </a>中被传递下去，直到找到一个响应它的对象。在 iOS 中，每个控件甚至可以和多个 target-action 关联。</p>\n<p>基于 target-action 传递机制的一个局限是，发送的消息不能携带自定义的信息。在 Mac 平台上 action 方法的第一个参数永远接收者。iOS 中，可以选择性的把发送者和触发 action 的事件作为参数。除此之外就没有别的控制 action 消息内容的方法了。</p>\n<h3 id=\"做出正确的选择\"><a href=\"#做出正确的选择\" class=\"headerlink\" title=\"做出正确的选择\"></a>做出正确的选择</h3><p>基于上述对不同消息传递机制的特点，我们画了一个流程图来帮助我们在不同情境下做出不同的选择。一句忠告：流程图的建议不代表最终答案。有些时候别的选择依然能达到应有的效果。只不过大多数情况下这张图能引导你做出正确的决定。<br><img src=\"/images/communication-patterns-flow-chart.png\"><br>图中有些细节值得深究：</p>\n<p>有个框中说到： 发送者支持 KVO。这不仅仅是说发送者会在值改变的时候发送 KVO 通知，而且说明观察者需要知道发送者的生命周期。如果发送者被存在一个 weak 属性中，那么发送者有可能会自己变成 nil，那时观察者会导致内存泄露。</p>\n<p>一个在最后一行的框里说，消息直接响应方法调用。也就是说方法调用的接收者需要给调用者一个消息作为方法调用的直接反馈。这也就是说处理消息的代码和调用方法的代码必须在同一个地方。</p>\n<p>最后在右下角的地方，一个选择分支这样说：发送者能确保释放对 block 的引用吗？这涉及到了我们之前讨论 block 的 API 存在潜在的 retain 环的问题。如果发送者不能保证在某个时间点会释放对 block 的引用，那么你会惹上 retain 环的麻烦。</p>\n<h2 id=\"Framework-示例\"><a href=\"#Framework-示例\" class=\"headerlink\" title=\"Framework 示例\"></a>Framework 示例</h2><p>本节我们通过一些苹果框架里的例子来验证流程图的选择是否有道理，同时解释为什么苹果会选择用这些机制。</p>\n<h3 id=\"KVO-1\"><a href=\"#KVO-1\" class=\"headerlink\" title=\"KVO\"></a>KVO</h3><p>NSOperationQueue 用了 KVO 观察队列中的 operation 状态属性的改变情况 (isFinished，isExecuting，isCancelled)。当状态改变的时候，队列会收到 KVO 通知。为什么 operation 队列要用 KVO 呢？</p>\n<p>消息的接收者（operation 队列）知道消息的发送者（operation），并 retain 它并控制后者的生命周期。另外，在这种情况下只需要单向的消息传递机制。当然如果考虑到 oepration 队列只关心那些改变 operation 的值的改变情况的话，就还不足以说服大家使用 KVO 了。但我们可以这么理解：被传递的消息可以被当成值的改变来处理。因为 state 属性在 operation 队列以外也是有用的，所以这里适合用 KVO。<br><img src=\"/images/kvo-flow-chart.png\"><br>当然 KVO 不是唯一的选择。我们也可以将 operation 队列作为 operation 的 delegate 来使用，operation 会调用类似 operationDidFinish: 或者 operationDidBeginExecuting: 等方法把它的 state 传递给 queue。这样就不太方便了，因为 operation 要保存 state 属性，以便于调用这些 delegate 方法。另外，由于 queue 不能主动获取 state 信息，所以 queue 也必须保存所有 operation 的 state。</p>\n<h3 id=\"Notifications\"><a href=\"#Notifications\" class=\"headerlink\" title=\"Notifications\"></a>Notifications</h3><p>Core Data 使用 notification 传递事件（例如一个 managed object context 中的改变————NSManagedObjectContextObjectsDidChangeNotification）</p>\n<p>发生改变时触发的 notification 是由 managed object contexts 发出的，所以我们不能假定消息的接收者知道消息的发送者。因为消息的源头不是一个 UI 事件，很多接收者可能在关注着此消息，并且消息传递是单向的，所以 notification 是唯一可行的选择。<br><img src=\"/images/notification-flow-chart.png\"></p>\n<h3 id=\"Delegation\"><a href=\"#Delegation\" class=\"headerlink\" title=\"Delegation\"></a>Delegation</h3><p>Table view 的 delegate 有多重功能，它可以从管理 accessory view，直到追踪在屏幕上显示的 cell。例如我们可以看看 tableView:didSelectRowAtIndexPath: 方法。为什么用 delegate 实现而不是 target-action 机制？</p>\n<p>正如我们在上述流程图中看到的，用 target-action 时，不能传递自定义的数据。而选中 table view 的某个 cell 时，collection view 不仅需要告诉我们一个 cell 被选中了，也要通过 index path 告诉我们哪个 cell 被选中了。如果我们照着这个思路，流程图会引导我们使用 delegation 机制。<br><img src=\"/images/delegation-flow-chart.png\"><br>如果不在消息传递中包含选中 cell 的 index path，而是让选中项改变时我们像 table view 主动询问并获取选中 cell 的相关信息，会怎样呢？这会非常不方便，因为我们必须记住当前选中项的数据，这样才能在多选择中知道哪些 cell 是被新选中的。</p>\n<p>同理，我们可以想象通过观察 table view 选中项的 index path 属性，当该值发生改变的时候，获得一个选中项改变的通知。不过我们会遇到上述相似问题：不做记录的话我们就不能分辨哪一个 cell 被选择或取消选择了。</p>\n<h3 id=\"Block-1\"><a href=\"#Block-1\" class=\"headerlink\" title=\"Block\"></a>Block</h3><p>我们用 -[NSURLSession dataTaskWithURL:completionHandler:] 来作为一个 block API 的介绍。那么从 URL 加载部分返回给调用者是怎么传递消息的呢？首先，作为 API 的调用者，我们知道消息的发送者，但是我们并没有 retain 它。另外，这是个单向的消息传递————它直接调用 dataTaskWithURL: 的方法。如果我们对照流程图，会发现这属于 block 消息传递机制。<br><img src=\"/images/block-flow-chart.png\"><br>有其他的选项吗？当然，苹果自己的 NSURLConnection 就是最好的例子。NSURLConnection在 block 问世之前就存在了，所以它并没有用 block 来实现消息传递，而是使用 delegation 来完成。当 block 出现以后，苹果就在 OS X 10.7 和 iOS 5 平台上的 NSURLConnection 中加了 sendAsynchronousRequest:queue:completionHandler:，所以我们不再在简单的任务中使用 delegate 了。</p>\n<p>因为 NSURLSession 是个最近在 OS X 10.9 和 iOS 7 才出现的 API，所以它们使用 block 来实现消息传递机制（NSURLSession 有一个 delegate，但是是用于其他目的）。</p>\n<h3 id=\"Target-Action-1\"><a href=\"#Target-Action-1\" class=\"headerlink\" title=\"Target-Action\"></a>Target-Action</h3><p>一个明显的 target-action 用例是按钮。按钮在不被按下的时候不需要发送任何的信息。为了这个目的，target-action 是 UI 中消息传递的最佳选择。<br><img src=\"/images/target-action-flow-chart.png\"><br>如果 target 是明确指定的，那么 action 消息会发送给指定的对象。如果 target 是 nil， action 消息会一直在响应链中被传递下去，直到找到一个能处理它的对象。在这种情况下，我们有一个完全解耦的消息传递机制：发送者不需要知道接收者，反之亦然。</p>\n<p>Target-action 机制非常适合响应 UI 的事件。没有其他的消息传递机制能够提供相同的功能。虽然 notification 在发送者和接收者的松散关系上最接近它，但是 target-action 可以用于响应链——只有一个对象获得 action 并响应，action 在响应链中传递，直到能遇到响应这个 action 的对象。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>一开始接触这么多的消息传递机制的时候，我们可能有些无所适从，觉得所有的机制都可以被选用。不过一旦我们仔细分析每个机制的时候，它们各自都有特殊的要求和能力。</p>\n<p>文中的选择流程图是帮助你清楚认识这些机制的好的开始，当然它不是所有问题的答案。如果你觉得这和你自己选择机制的方式相似或是有任何缺漏，欢迎来信指正。</p>\n<hr>\n<p><em>观点仅代表自己，期待你的留言。</em><br><a href=\"http://objccn.io/issue-7-4/\">http://objccn.io/issue-7-4/</a></p>\n"},{"title":"iOS开发MVVM理解与总结","date":"2016-04-07T10:14:40.000Z","_content":"\n## MVC存在的问题\n![](/images/ios-mvc.png)\n### iOS概念对应\n`M（model）:` 普通Class，用于对基础数据类型的对象封装，不包含界面逻辑、业务逻辑与数据转换等功能。\n`V（view）:`  xib或storyboard，用于显示给用户的界面。\n`C（controller）:` ViewController，用户下行数据输入与上线数据显示，view跳转，数据校验等功能。\n### 问题\n1. 所有的逻辑代码，数据校验，UI控制，对象转换，数据缓存等服务都存在到Controller中，造成代码过于臃肿，可读性低。\n2. Controller中处理所有的任务，基本上很难多人协作完成，分工性差。\n3. Controller依赖到UIKit库，让单元测试无法覆盖，功能可靠性不可预测。\n4. 试想，iphone程序更换成macosx程序哪些能重用？功能的重用性低。\n\n分析MVC的问题，主要还是由于Controller完成的任务过多造成，为了解决以上问题，必须让Controller进行减肥。\n\n## MVVM\n![](/images/ios-mvvm.png)\n### iOS概念对应\n`M（model）:` 与MVC中概念一致之外，将View分为数据model与界面model。\n`V（view）:`  与MVC中概念一致之外，另外将与view连接紧密的viewcontroller划分到一起。viewcontroller只负责界面跳转、用户下行数据获取、用户上行数据绑定以及vm层的调用。\n`VM（view-model）:` 用于连接view与model层，完成界面逻辑，业务逻辑，接口调用，数据model与界面model数据转换，数据校验上行数据处理与下行数据转换，数据缓存等功能。\n\n## 另外的建议\n使用[CocoaPods]将各层分开成不同的project，由workspace融合，最终通过静态库的形式进行相互的引用。\n这样做的好处有以下几点：\n1. 代码清晰，分工明确。\n2. 对于代码修改后的编译为分段进行，提高了编译速度。\n3. 对各层的代码都可以进行版本化管理，调用者的各层代码固化调用版本，对于重构代码等过程有很大的好处。\n4. 由于静态库可由其它程序平台重用（iOS与MacOSX），一次编译，多次使用。\n\n[CocoaPods]: https://cocoapods.org/\n\n-----\n\n*观点仅代表自己，期待你的留言。*\n","source":"_posts/ios-mvvm.md","raw":"---\ntitle: iOS开发MVVM理解与总结\ntags:\n  - iOS\n  - 原创\ndate: 2016-04-07 18:14:40\n---\n\n## MVC存在的问题\n![](/images/ios-mvc.png)\n### iOS概念对应\n`M（model）:` 普通Class，用于对基础数据类型的对象封装，不包含界面逻辑、业务逻辑与数据转换等功能。\n`V（view）:`  xib或storyboard，用于显示给用户的界面。\n`C（controller）:` ViewController，用户下行数据输入与上线数据显示，view跳转，数据校验等功能。\n### 问题\n1. 所有的逻辑代码，数据校验，UI控制，对象转换，数据缓存等服务都存在到Controller中，造成代码过于臃肿，可读性低。\n2. Controller中处理所有的任务，基本上很难多人协作完成，分工性差。\n3. Controller依赖到UIKit库，让单元测试无法覆盖，功能可靠性不可预测。\n4. 试想，iphone程序更换成macosx程序哪些能重用？功能的重用性低。\n\n分析MVC的问题，主要还是由于Controller完成的任务过多造成，为了解决以上问题，必须让Controller进行减肥。\n\n## MVVM\n![](/images/ios-mvvm.png)\n### iOS概念对应\n`M（model）:` 与MVC中概念一致之外，将View分为数据model与界面model。\n`V（view）:`  与MVC中概念一致之外，另外将与view连接紧密的viewcontroller划分到一起。viewcontroller只负责界面跳转、用户下行数据获取、用户上行数据绑定以及vm层的调用。\n`VM（view-model）:` 用于连接view与model层，完成界面逻辑，业务逻辑，接口调用，数据model与界面model数据转换，数据校验上行数据处理与下行数据转换，数据缓存等功能。\n\n## 另外的建议\n使用[CocoaPods]将各层分开成不同的project，由workspace融合，最终通过静态库的形式进行相互的引用。\n这样做的好处有以下几点：\n1. 代码清晰，分工明确。\n2. 对于代码修改后的编译为分段进行，提高了编译速度。\n3. 对各层的代码都可以进行版本化管理，调用者的各层代码固化调用版本，对于重构代码等过程有很大的好处。\n4. 由于静态库可由其它程序平台重用（iOS与MacOSX），一次编译，多次使用。\n\n[CocoaPods]: https://cocoapods.org/\n\n-----\n\n*观点仅代表自己，期待你的留言。*\n","slug":"ios-mvvm","published":1,"updated":"2021-08-31T14:23:11.543Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cku52dyn80023bbing3wp3z7r","content":"<h2 id=\"MVC存在的问题\"><a href=\"#MVC存在的问题\" class=\"headerlink\" title=\"MVC存在的问题\"></a>MVC存在的问题</h2><p><img src=\"/images/ios-mvc.png\"></p>\n<h3 id=\"iOS概念对应\"><a href=\"#iOS概念对应\" class=\"headerlink\" title=\"iOS概念对应\"></a>iOS概念对应</h3><p><code>M（model）:</code> 普通Class，用于对基础数据类型的对象封装，不包含界面逻辑、业务逻辑与数据转换等功能。<br><code>V（view）:</code>  xib或storyboard，用于显示给用户的界面。<br><code>C（controller）:</code> ViewController，用户下行数据输入与上线数据显示，view跳转，数据校验等功能。</p>\n<h3 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h3><ol>\n<li>所有的逻辑代码，数据校验，UI控制，对象转换，数据缓存等服务都存在到Controller中，造成代码过于臃肿，可读性低。</li>\n<li>Controller中处理所有的任务，基本上很难多人协作完成，分工性差。</li>\n<li>Controller依赖到UIKit库，让单元测试无法覆盖，功能可靠性不可预测。</li>\n<li>试想，iphone程序更换成macosx程序哪些能重用？功能的重用性低。</li>\n</ol>\n<p>分析MVC的问题，主要还是由于Controller完成的任务过多造成，为了解决以上问题，必须让Controller进行减肥。</p>\n<h2 id=\"MVVM\"><a href=\"#MVVM\" class=\"headerlink\" title=\"MVVM\"></a>MVVM</h2><p><img src=\"/images/ios-mvvm.png\"></p>\n<h3 id=\"iOS概念对应-1\"><a href=\"#iOS概念对应-1\" class=\"headerlink\" title=\"iOS概念对应\"></a>iOS概念对应</h3><p><code>M（model）:</code> 与MVC中概念一致之外，将View分为数据model与界面model。<br><code>V（view）:</code>  与MVC中概念一致之外，另外将与view连接紧密的viewcontroller划分到一起。viewcontroller只负责界面跳转、用户下行数据获取、用户上行数据绑定以及vm层的调用。<br><code>VM（view-model）:</code> 用于连接view与model层，完成界面逻辑，业务逻辑，接口调用，数据model与界面model数据转换，数据校验上行数据处理与下行数据转换，数据缓存等功能。</p>\n<h2 id=\"另外的建议\"><a href=\"#另外的建议\" class=\"headerlink\" title=\"另外的建议\"></a>另外的建议</h2><p>使用<a href=\"https://cocoapods.org/\">CocoaPods</a>将各层分开成不同的project，由workspace融合，最终通过静态库的形式进行相互的引用。<br>这样做的好处有以下几点：</p>\n<ol>\n<li>代码清晰，分工明确。</li>\n<li>对于代码修改后的编译为分段进行，提高了编译速度。</li>\n<li>对各层的代码都可以进行版本化管理，调用者的各层代码固化调用版本，对于重构代码等过程有很大的好处。</li>\n<li>由于静态库可由其它程序平台重用（iOS与MacOSX），一次编译，多次使用。</li>\n</ol>\n<hr>\n<p><em>观点仅代表自己，期待你的留言。</em></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"MVC存在的问题\"><a href=\"#MVC存在的问题\" class=\"headerlink\" title=\"MVC存在的问题\"></a>MVC存在的问题</h2><p><img src=\"/images/ios-mvc.png\"></p>\n<h3 id=\"iOS概念对应\"><a href=\"#iOS概念对应\" class=\"headerlink\" title=\"iOS概念对应\"></a>iOS概念对应</h3><p><code>M（model）:</code> 普通Class，用于对基础数据类型的对象封装，不包含界面逻辑、业务逻辑与数据转换等功能。<br><code>V（view）:</code>  xib或storyboard，用于显示给用户的界面。<br><code>C（controller）:</code> ViewController，用户下行数据输入与上线数据显示，view跳转，数据校验等功能。</p>\n<h3 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h3><ol>\n<li>所有的逻辑代码，数据校验，UI控制，对象转换，数据缓存等服务都存在到Controller中，造成代码过于臃肿，可读性低。</li>\n<li>Controller中处理所有的任务，基本上很难多人协作完成，分工性差。</li>\n<li>Controller依赖到UIKit库，让单元测试无法覆盖，功能可靠性不可预测。</li>\n<li>试想，iphone程序更换成macosx程序哪些能重用？功能的重用性低。</li>\n</ol>\n<p>分析MVC的问题，主要还是由于Controller完成的任务过多造成，为了解决以上问题，必须让Controller进行减肥。</p>\n<h2 id=\"MVVM\"><a href=\"#MVVM\" class=\"headerlink\" title=\"MVVM\"></a>MVVM</h2><p><img src=\"/images/ios-mvvm.png\"></p>\n<h3 id=\"iOS概念对应-1\"><a href=\"#iOS概念对应-1\" class=\"headerlink\" title=\"iOS概念对应\"></a>iOS概念对应</h3><p><code>M（model）:</code> 与MVC中概念一致之外，将View分为数据model与界面model。<br><code>V（view）:</code>  与MVC中概念一致之外，另外将与view连接紧密的viewcontroller划分到一起。viewcontroller只负责界面跳转、用户下行数据获取、用户上行数据绑定以及vm层的调用。<br><code>VM（view-model）:</code> 用于连接view与model层，完成界面逻辑，业务逻辑，接口调用，数据model与界面model数据转换，数据校验上行数据处理与下行数据转换，数据缓存等功能。</p>\n<h2 id=\"另外的建议\"><a href=\"#另外的建议\" class=\"headerlink\" title=\"另外的建议\"></a>另外的建议</h2><p>使用<a href=\"https://cocoapods.org/\">CocoaPods</a>将各层分开成不同的project，由workspace融合，最终通过静态库的形式进行相互的引用。<br>这样做的好处有以下几点：</p>\n<ol>\n<li>代码清晰，分工明确。</li>\n<li>对于代码修改后的编译为分段进行，提高了编译速度。</li>\n<li>对各层的代码都可以进行版本化管理，调用者的各层代码固化调用版本，对于重构代码等过程有很大的好处。</li>\n<li>由于静态库可由其它程序平台重用（iOS与MacOSX），一次编译，多次使用。</li>\n</ol>\n<hr>\n<p><em>观点仅代表自己，期待你的留言。</em></p>\n"},{"title":"Effective Objective-C 理解消息传递机制","date":"2016-03-30T08:44:25.000Z","_content":"\n## 最简单的动态\nObjective-C 是一门极其动态的语言，许多东西都可以推迟到运行时决定、修改。那么到底何为动态、何为静态？我们通过一个简单的例子对比下\n```\n/***********  例1 静态绑定   ***********/\n#import <stdio.h>\nvoid printHello() {\n    printf(\"Hello, world!\\n\");\n}\nvoid printGoodbye() {\n    printf(\"Goodbye, world!\\n\");\n}\nvoid saySomething(int type) \n{\n    if (type == 0) {\n        printHello();\n    } else {\n        printGoodbye();\n    }\n    return 0;\n}\n```\n```\n/***********  例2 动态绑定   ***********/\n#import <stdio.h>\nvoid printHello() {\n    printf(\"Hello, world!\\n\");\n}\nvoid printGoodbye() {\n    printf(\"Goodbye, world!\\n\");\n}\nvoid saySomething(int type) \n{\n    void (*func)();\n    if (type == 0) {\n        func = printHello;\n    } else {\n        func = printGoodbye;\n    }\n    func();\n    return 0;\n}\n```\n例1的代码在编译期，编译器就已经知道了有 void printHello()、void printGoodbye() 俩函数，并且在 saySomething() 函数中，调用的函数明确，可以直接将函数名硬编码成地址，生成调用指令，这就是 __静态绑定__（static binding）。那么例2呢？例2的调用的是 func() 函数，而这函数实际调用的地址只能到程序运行时才能确定，这就是所谓的 __动态绑定__（dynamic binding）。动态绑定将函数调用从编译期推迟到了运行时。\n\n在 Objective-C 中，向对象传递消息，就会使用这种动态绑定机制来决定需要调用的方法，这种动态特性使得 Objective-C 成为一门真正动态的语言。\n\n## objec_msgSend 函数\nObjective-C 的方法调用通常都是下面这种形式\n```\nid returnValue = [someObject messageName:parameter];\n```\n这种方法调用其实就是消息传递，编译器看到这条消息会转换成一条标准的 C 语言函数调用\n```\nid returnValue = objc_msgSend(someObject,\n                              @selector(messageName:),\n                              parameter);\n```\n用消息传递的话来解释就是：向 someObject 对象发送了一个名叫 messageName 的消息，这个消息携带了一个叫 parameter 的参数。这里用到了一个 objc_msgSend 函数，其函数原型如下\n```\nvoid objc_msgSend(id self, SEL cmd, ...);\n```\n这是一个可变参数的函数，第一个参数代表消息接收者，第二个代表 SEL 类型，后面的参数就是消息传递中使用的参数。\n\n那么什么是 SEL 呢？SEL 就是代码在编译时，编译器根据方法签名来生成的一个唯一 ID。此 ID 可以用以区分不同的方法，只要 ID 一致，即看成同一个方法，ID 不同，即为不同的方法。\n\n当进行消息传递，对象在响应消息时，是通过 SEL 在 methodlist 中查找函数指针 IMP，找到后直接通过指针调用函数，这其实就是前文介绍的 __动态绑定__。若是找到对应函数就跳转到实现代码，若找不到，就沿着继承链往上查找，直到找到相应的实现代码为止。若最终还是没找到实现代码，说明当前对象无法响应此消息，接下来就会执行 __消息转发__ 操作，以试图找到一个能响应此消息的对象。\n```\n// 获取 SEL \nSEL sel = @selector(methodName);\n// 获取 IMP\nIMP imp = methodForSelector(sel);\n```\n## 消息转发\n消息转发并不神奇，我们其实早已接触过，只是不知道而已\n```\n-[__NSCFNumber lowercaseString]:unrecognized selector sent to instance 0x87\n*** Terminating app due to uncaught exception 'NSInvalidArgumentException', reason:'-[NSCFNumber lowercaseString]:unrecognized selector sent to instance 0x87'\n```\n这段异常代码就是由 NSObject 的 doesNotRecognizeSelector: 方法所抛出的，异常表明：消息的接收者类型为 __NSCFNumber，无法响应 lowercaseString 消息，从而转发给 NSObject 处理。\n\n消息转发分为三大阶段\n\n* 第一阶段先征询消息接收者所属的类，看其是否能动态添加方法，以处理当前这个无法响应的 selector，这叫做 动态方法解析（dynamic method resolution）。如果运行期系统（runtime system） 第一阶段执行结束，接收者就无法再以动态新增方法的手段来响应消息，进入第二阶段。\n* 第二阶段看看有没有其他对象（备援接收者，replacement receiver）能处理此消息。如果有，运行期系统会把消息转发给那个对象，转发过程结束；如果没有，则启动完整的消息转发机制。\n* 第三阶段 完整的消息转发机制。运行期系统会把与消息有关的全部细节都封装到 NSInvocation 对象中，再给接收者最后一次机会，令其设法解决当前还未处理的消息。\n\n### 动态方法解析\n对象在收到无法响应的消息后，会调用其所属类的下列方法\n```\n/**\n *  如果尚未实现的方法是实例方法，则调用此函数\n *\n *  @param selector 未处理的方法\n *\n *  @return 返回布尔值，表示是否能新增实例方法用以处理selector\n */\n+ (BOOL)resolveInstanceMethod:(SEL)selector;\n/**\n *  如果尚未实现的方法是类方法，则调用此函数\n *\n *  @param selector 未处理的方法\n *\n *  @return 返回布尔值，表示是否能新增类方法用以处理selector\n */\n+ (BOOL)resolveClassMethod:(SEL)selector;\n```\n方法返回布尔类型，表示是否能新增一个方法来处理 selector，此方案通常用来实现 @dynamic 属性。\n```\n/************** 使用 resolveInstanceMethod 实现 @dynamic 属性 **************/\nid autoDictionaryGetter(id self, SEL _cmd);\nvoid autoDictionarySetter(id self, SEL _cmd, id value);\n+ (BOOL)resolveInstanceMethod:(SEL)selector\n{\n    NSString *selectorString = NSStringFromSelector(selector);\n    if (/* selector is from a @dynamic property */)\n    {\n        if ([selectorString hasPrefix:@\"set\"])\n        {\n            // 添加 setter 方法\n            class_addMethod(self, selector, (IMP)autoDictionarySetter, \"v@:@\");\n        }\n        else\n        {\n            // 添加 getter 方法\n            class_addMethod(self, selector, (IMP)autoDictionaryGetter, \"@@:\");\n        }\n        return YES;\n    }\n    return [super resolveInstanceMethod:selector];\n}\n```\n### 备援接收者\n如果无法 __动态解析方法__，运行期系统就会询问是否能将消息转给其他接收者来处理，对应的方法为\n```\n/**\n *  此方法询问是否能将消息转给其他接收者来处理\n *\n *  @param aSelector 未处理的方法\n *\n *  @return 如果当前接收者能找到备援对象，就将其返回；否则返回nil；\n */\n- (id)forwardingTargetForSelector:(SEL)aSelector;\n```\n在对象内部，可能还有其他对象，该对象可通过此方法将能够处理 selector 的相关内部对象返回，在外界看来，就好像是该对象自己处理的似得。\n### 完整的消息转发机制\n如果前面两步都无法处理消息，就会启动完整的消息转发机制。首先创建 NSInvocation 对象，把尚未处理的那条消息有关的全部细节装在里面，在触发 NSInvocation 对象时，消息派发系统（message-dispatch system）将会把消息指派给目标对象。对应的方法为\n```\n/**\n *  消息派发系统通过此方法，将消息派发给目标对象\n *\n *  @param anInvocation 之前创建的NSInvocation实例对象，用于装载有关消息的所有内容\n */\n- (void)forwardInvocation:(NSInvocation *)anInvocation;\n```\n这个方法可以实现的很简单，通过改变调用的目标对象，使得消息在新目标对象上得以调用即可。然而这样实现的效果与 __备援接收者__ 差不多，所以很少人会这么做。更加有用的实现方式为：在触发消息前，先以某种方式改变消息内容，比如追加另一个参数、修改 selector 等等。\n\n## 总结\n![](/images/image_note64270_1.png)\n\n\n-----\n\n*观点仅代表自己，期待你的留言。*\nhttps://www.zybuluo.com/MicroCai/note/64270\n\n","source":"_posts/ios-sendmsg.md","raw":"---\ntitle: Effective Objective-C 理解消息传递机制\ntags:\n  - iOS\n  - 转载\ndate: 2016-03-30 16:44:25\n---\n\n## 最简单的动态\nObjective-C 是一门极其动态的语言，许多东西都可以推迟到运行时决定、修改。那么到底何为动态、何为静态？我们通过一个简单的例子对比下\n```\n/***********  例1 静态绑定   ***********/\n#import <stdio.h>\nvoid printHello() {\n    printf(\"Hello, world!\\n\");\n}\nvoid printGoodbye() {\n    printf(\"Goodbye, world!\\n\");\n}\nvoid saySomething(int type) \n{\n    if (type == 0) {\n        printHello();\n    } else {\n        printGoodbye();\n    }\n    return 0;\n}\n```\n```\n/***********  例2 动态绑定   ***********/\n#import <stdio.h>\nvoid printHello() {\n    printf(\"Hello, world!\\n\");\n}\nvoid printGoodbye() {\n    printf(\"Goodbye, world!\\n\");\n}\nvoid saySomething(int type) \n{\n    void (*func)();\n    if (type == 0) {\n        func = printHello;\n    } else {\n        func = printGoodbye;\n    }\n    func();\n    return 0;\n}\n```\n例1的代码在编译期，编译器就已经知道了有 void printHello()、void printGoodbye() 俩函数，并且在 saySomething() 函数中，调用的函数明确，可以直接将函数名硬编码成地址，生成调用指令，这就是 __静态绑定__（static binding）。那么例2呢？例2的调用的是 func() 函数，而这函数实际调用的地址只能到程序运行时才能确定，这就是所谓的 __动态绑定__（dynamic binding）。动态绑定将函数调用从编译期推迟到了运行时。\n\n在 Objective-C 中，向对象传递消息，就会使用这种动态绑定机制来决定需要调用的方法，这种动态特性使得 Objective-C 成为一门真正动态的语言。\n\n## objec_msgSend 函数\nObjective-C 的方法调用通常都是下面这种形式\n```\nid returnValue = [someObject messageName:parameter];\n```\n这种方法调用其实就是消息传递，编译器看到这条消息会转换成一条标准的 C 语言函数调用\n```\nid returnValue = objc_msgSend(someObject,\n                              @selector(messageName:),\n                              parameter);\n```\n用消息传递的话来解释就是：向 someObject 对象发送了一个名叫 messageName 的消息，这个消息携带了一个叫 parameter 的参数。这里用到了一个 objc_msgSend 函数，其函数原型如下\n```\nvoid objc_msgSend(id self, SEL cmd, ...);\n```\n这是一个可变参数的函数，第一个参数代表消息接收者，第二个代表 SEL 类型，后面的参数就是消息传递中使用的参数。\n\n那么什么是 SEL 呢？SEL 就是代码在编译时，编译器根据方法签名来生成的一个唯一 ID。此 ID 可以用以区分不同的方法，只要 ID 一致，即看成同一个方法，ID 不同，即为不同的方法。\n\n当进行消息传递，对象在响应消息时，是通过 SEL 在 methodlist 中查找函数指针 IMP，找到后直接通过指针调用函数，这其实就是前文介绍的 __动态绑定__。若是找到对应函数就跳转到实现代码，若找不到，就沿着继承链往上查找，直到找到相应的实现代码为止。若最终还是没找到实现代码，说明当前对象无法响应此消息，接下来就会执行 __消息转发__ 操作，以试图找到一个能响应此消息的对象。\n```\n// 获取 SEL \nSEL sel = @selector(methodName);\n// 获取 IMP\nIMP imp = methodForSelector(sel);\n```\n## 消息转发\n消息转发并不神奇，我们其实早已接触过，只是不知道而已\n```\n-[__NSCFNumber lowercaseString]:unrecognized selector sent to instance 0x87\n*** Terminating app due to uncaught exception 'NSInvalidArgumentException', reason:'-[NSCFNumber lowercaseString]:unrecognized selector sent to instance 0x87'\n```\n这段异常代码就是由 NSObject 的 doesNotRecognizeSelector: 方法所抛出的，异常表明：消息的接收者类型为 __NSCFNumber，无法响应 lowercaseString 消息，从而转发给 NSObject 处理。\n\n消息转发分为三大阶段\n\n* 第一阶段先征询消息接收者所属的类，看其是否能动态添加方法，以处理当前这个无法响应的 selector，这叫做 动态方法解析（dynamic method resolution）。如果运行期系统（runtime system） 第一阶段执行结束，接收者就无法再以动态新增方法的手段来响应消息，进入第二阶段。\n* 第二阶段看看有没有其他对象（备援接收者，replacement receiver）能处理此消息。如果有，运行期系统会把消息转发给那个对象，转发过程结束；如果没有，则启动完整的消息转发机制。\n* 第三阶段 完整的消息转发机制。运行期系统会把与消息有关的全部细节都封装到 NSInvocation 对象中，再给接收者最后一次机会，令其设法解决当前还未处理的消息。\n\n### 动态方法解析\n对象在收到无法响应的消息后，会调用其所属类的下列方法\n```\n/**\n *  如果尚未实现的方法是实例方法，则调用此函数\n *\n *  @param selector 未处理的方法\n *\n *  @return 返回布尔值，表示是否能新增实例方法用以处理selector\n */\n+ (BOOL)resolveInstanceMethod:(SEL)selector;\n/**\n *  如果尚未实现的方法是类方法，则调用此函数\n *\n *  @param selector 未处理的方法\n *\n *  @return 返回布尔值，表示是否能新增类方法用以处理selector\n */\n+ (BOOL)resolveClassMethod:(SEL)selector;\n```\n方法返回布尔类型，表示是否能新增一个方法来处理 selector，此方案通常用来实现 @dynamic 属性。\n```\n/************** 使用 resolveInstanceMethod 实现 @dynamic 属性 **************/\nid autoDictionaryGetter(id self, SEL _cmd);\nvoid autoDictionarySetter(id self, SEL _cmd, id value);\n+ (BOOL)resolveInstanceMethod:(SEL)selector\n{\n    NSString *selectorString = NSStringFromSelector(selector);\n    if (/* selector is from a @dynamic property */)\n    {\n        if ([selectorString hasPrefix:@\"set\"])\n        {\n            // 添加 setter 方法\n            class_addMethod(self, selector, (IMP)autoDictionarySetter, \"v@:@\");\n        }\n        else\n        {\n            // 添加 getter 方法\n            class_addMethod(self, selector, (IMP)autoDictionaryGetter, \"@@:\");\n        }\n        return YES;\n    }\n    return [super resolveInstanceMethod:selector];\n}\n```\n### 备援接收者\n如果无法 __动态解析方法__，运行期系统就会询问是否能将消息转给其他接收者来处理，对应的方法为\n```\n/**\n *  此方法询问是否能将消息转给其他接收者来处理\n *\n *  @param aSelector 未处理的方法\n *\n *  @return 如果当前接收者能找到备援对象，就将其返回；否则返回nil；\n */\n- (id)forwardingTargetForSelector:(SEL)aSelector;\n```\n在对象内部，可能还有其他对象，该对象可通过此方法将能够处理 selector 的相关内部对象返回，在外界看来，就好像是该对象自己处理的似得。\n### 完整的消息转发机制\n如果前面两步都无法处理消息，就会启动完整的消息转发机制。首先创建 NSInvocation 对象，把尚未处理的那条消息有关的全部细节装在里面，在触发 NSInvocation 对象时，消息派发系统（message-dispatch system）将会把消息指派给目标对象。对应的方法为\n```\n/**\n *  消息派发系统通过此方法，将消息派发给目标对象\n *\n *  @param anInvocation 之前创建的NSInvocation实例对象，用于装载有关消息的所有内容\n */\n- (void)forwardInvocation:(NSInvocation *)anInvocation;\n```\n这个方法可以实现的很简单，通过改变调用的目标对象，使得消息在新目标对象上得以调用即可。然而这样实现的效果与 __备援接收者__ 差不多，所以很少人会这么做。更加有用的实现方式为：在触发消息前，先以某种方式改变消息内容，比如追加另一个参数、修改 selector 等等。\n\n## 总结\n![](/images/image_note64270_1.png)\n\n\n-----\n\n*观点仅代表自己，期待你的留言。*\nhttps://www.zybuluo.com/MicroCai/note/64270\n\n","slug":"ios-sendmsg","published":1,"updated":"2021-08-31T14:23:11.544Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cku52dyna0025bbind91ka78h","content":"<h2 id=\"最简单的动态\"><a href=\"#最简单的动态\" class=\"headerlink\" title=\"最简单的动态\"></a>最简单的动态</h2><p>Objective-C 是一门极其动态的语言，许多东西都可以推迟到运行时决定、修改。那么到底何为动态、何为静态？我们通过一个简单的例子对比下</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/***********  例1 静态绑定   ***********/</span><br><span class=\"line\">#import &lt;stdio.h&gt;</span><br><span class=\"line\">void printHello() &#123;</span><br><span class=\"line\">    printf(&quot;Hello, world!\\n&quot;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">void printGoodbye() &#123;</span><br><span class=\"line\">    printf(&quot;Goodbye, world!\\n&quot;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">void saySomething(int type) </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    if (type == 0) &#123;</span><br><span class=\"line\">        printHello();</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">        printGoodbye();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/***********  例2 动态绑定   ***********/</span><br><span class=\"line\">#import &lt;stdio.h&gt;</span><br><span class=\"line\">void printHello() &#123;</span><br><span class=\"line\">    printf(&quot;Hello, world!\\n&quot;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">void printGoodbye() &#123;</span><br><span class=\"line\">    printf(&quot;Goodbye, world!\\n&quot;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">void saySomething(int type) </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    void (*func)();</span><br><span class=\"line\">    if (type == 0) &#123;</span><br><span class=\"line\">        func = printHello;</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">        func = printGoodbye;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    func();</span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>例1的代码在编译期，编译器就已经知道了有 void printHello()、void printGoodbye() 俩函数，并且在 saySomething() 函数中，调用的函数明确，可以直接将函数名硬编码成地址，生成调用指令，这就是 __静态绑定__（static binding）。那么例2呢？例2的调用的是 func() 函数，而这函数实际调用的地址只能到程序运行时才能确定，这就是所谓的 __动态绑定__（dynamic binding）。动态绑定将函数调用从编译期推迟到了运行时。</p>\n<p>在 Objective-C 中，向对象传递消息，就会使用这种动态绑定机制来决定需要调用的方法，这种动态特性使得 Objective-C 成为一门真正动态的语言。</p>\n<h2 id=\"objec-msgSend-函数\"><a href=\"#objec-msgSend-函数\" class=\"headerlink\" title=\"objec_msgSend 函数\"></a>objec_msgSend 函数</h2><p>Objective-C 的方法调用通常都是下面这种形式</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">id returnValue = [someObject messageName:parameter];</span><br></pre></td></tr></table></figure>\n<p>这种方法调用其实就是消息传递，编译器看到这条消息会转换成一条标准的 C 语言函数调用</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">id returnValue = objc_msgSend(someObject,</span><br><span class=\"line\">                              @selector(messageName:),</span><br><span class=\"line\">                              parameter);</span><br></pre></td></tr></table></figure>\n<p>用消息传递的话来解释就是：向 someObject 对象发送了一个名叫 messageName 的消息，这个消息携带了一个叫 parameter 的参数。这里用到了一个 objc_msgSend 函数，其函数原型如下</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void objc_msgSend(id self, SEL cmd, ...);</span><br></pre></td></tr></table></figure>\n<p>这是一个可变参数的函数，第一个参数代表消息接收者，第二个代表 SEL 类型，后面的参数就是消息传递中使用的参数。</p>\n<p>那么什么是 SEL 呢？SEL 就是代码在编译时，编译器根据方法签名来生成的一个唯一 ID。此 ID 可以用以区分不同的方法，只要 ID 一致，即看成同一个方法，ID 不同，即为不同的方法。</p>\n<p>当进行消息传递，对象在响应消息时，是通过 SEL 在 methodlist 中查找函数指针 IMP，找到后直接通过指针调用函数，这其实就是前文介绍的 __动态绑定__。若是找到对应函数就跳转到实现代码，若找不到，就沿着继承链往上查找，直到找到相应的实现代码为止。若最终还是没找到实现代码，说明当前对象无法响应此消息，接下来就会执行 <strong>消息转发</strong> 操作，以试图找到一个能响应此消息的对象。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 获取 SEL </span><br><span class=\"line\">SEL sel = @selector(methodName);</span><br><span class=\"line\">// 获取 IMP</span><br><span class=\"line\">IMP imp = methodForSelector(sel);</span><br></pre></td></tr></table></figure>\n<h2 id=\"消息转发\"><a href=\"#消息转发\" class=\"headerlink\" title=\"消息转发\"></a>消息转发</h2><p>消息转发并不神奇，我们其实早已接触过，只是不知道而已</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-[__NSCFNumber lowercaseString]:unrecognized selector sent to instance 0x87</span><br><span class=\"line\">*** Terminating app due to uncaught exception &#x27;NSInvalidArgumentException&#x27;, reason:&#x27;-[NSCFNumber lowercaseString]:unrecognized selector sent to instance 0x87&#x27;</span><br></pre></td></tr></table></figure>\n<p>这段异常代码就是由 NSObject 的 doesNotRecognizeSelector: 方法所抛出的，异常表明：消息的接收者类型为 __NSCFNumber，无法响应 lowercaseString 消息，从而转发给 NSObject 处理。</p>\n<p>消息转发分为三大阶段</p>\n<ul>\n<li>第一阶段先征询消息接收者所属的类，看其是否能动态添加方法，以处理当前这个无法响应的 selector，这叫做 动态方法解析（dynamic method resolution）。如果运行期系统（runtime system） 第一阶段执行结束，接收者就无法再以动态新增方法的手段来响应消息，进入第二阶段。</li>\n<li>第二阶段看看有没有其他对象（备援接收者，replacement receiver）能处理此消息。如果有，运行期系统会把消息转发给那个对象，转发过程结束；如果没有，则启动完整的消息转发机制。</li>\n<li>第三阶段 完整的消息转发机制。运行期系统会把与消息有关的全部细节都封装到 NSInvocation 对象中，再给接收者最后一次机会，令其设法解决当前还未处理的消息。</li>\n</ul>\n<h3 id=\"动态方法解析\"><a href=\"#动态方法解析\" class=\"headerlink\" title=\"动态方法解析\"></a>动态方法解析</h3><p>对象在收到无法响应的消息后，会调用其所属类的下列方法</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> *  如果尚未实现的方法是实例方法，则调用此函数</span><br><span class=\"line\"> *</span><br><span class=\"line\"> *  @param selector 未处理的方法</span><br><span class=\"line\"> *</span><br><span class=\"line\"> *  @return 返回布尔值，表示是否能新增实例方法用以处理selector</span><br><span class=\"line\"> */</span><br><span class=\"line\">+ (BOOL)resolveInstanceMethod:(SEL)selector;</span><br><span class=\"line\">/**</span><br><span class=\"line\"> *  如果尚未实现的方法是类方法，则调用此函数</span><br><span class=\"line\"> *</span><br><span class=\"line\"> *  @param selector 未处理的方法</span><br><span class=\"line\"> *</span><br><span class=\"line\"> *  @return 返回布尔值，表示是否能新增类方法用以处理selector</span><br><span class=\"line\"> */</span><br><span class=\"line\">+ (BOOL)resolveClassMethod:(SEL)selector;</span><br></pre></td></tr></table></figure>\n<p>方法返回布尔类型，表示是否能新增一个方法来处理 selector，此方案通常用来实现 @dynamic 属性。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/************** 使用 resolveInstanceMethod 实现 @dynamic 属性 **************/</span><br><span class=\"line\">id autoDictionaryGetter(id self, SEL _cmd);</span><br><span class=\"line\">void autoDictionarySetter(id self, SEL _cmd, id value);</span><br><span class=\"line\">+ (BOOL)resolveInstanceMethod:(SEL)selector</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    NSString *selectorString = NSStringFromSelector(selector);</span><br><span class=\"line\">    if (/* selector is from a @dynamic property */)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        if ([selectorString hasPrefix:@&quot;set&quot;])</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            // 添加 setter 方法</span><br><span class=\"line\">            class_addMethod(self, selector, (IMP)autoDictionarySetter, &quot;v@:@&quot;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        else</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            // 添加 getter 方法</span><br><span class=\"line\">            class_addMethod(self, selector, (IMP)autoDictionaryGetter, &quot;@@:&quot;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return YES;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return [super resolveInstanceMethod:selector];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"备援接收者\"><a href=\"#备援接收者\" class=\"headerlink\" title=\"备援接收者\"></a>备援接收者</h3><p>如果无法 __动态解析方法__，运行期系统就会询问是否能将消息转给其他接收者来处理，对应的方法为</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> *  此方法询问是否能将消息转给其他接收者来处理</span><br><span class=\"line\"> *</span><br><span class=\"line\"> *  @param aSelector 未处理的方法</span><br><span class=\"line\"> *</span><br><span class=\"line\"> *  @return 如果当前接收者能找到备援对象，就将其返回；否则返回nil；</span><br><span class=\"line\"> */</span><br><span class=\"line\">- (id)forwardingTargetForSelector:(SEL)aSelector;</span><br></pre></td></tr></table></figure>\n<p>在对象内部，可能还有其他对象，该对象可通过此方法将能够处理 selector 的相关内部对象返回，在外界看来，就好像是该对象自己处理的似得。</p>\n<h3 id=\"完整的消息转发机制\"><a href=\"#完整的消息转发机制\" class=\"headerlink\" title=\"完整的消息转发机制\"></a>完整的消息转发机制</h3><p>如果前面两步都无法处理消息，就会启动完整的消息转发机制。首先创建 NSInvocation 对象，把尚未处理的那条消息有关的全部细节装在里面，在触发 NSInvocation 对象时，消息派发系统（message-dispatch system）将会把消息指派给目标对象。对应的方法为</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> *  消息派发系统通过此方法，将消息派发给目标对象</span><br><span class=\"line\"> *</span><br><span class=\"line\"> *  @param anInvocation 之前创建的NSInvocation实例对象，用于装载有关消息的所有内容</span><br><span class=\"line\"> */</span><br><span class=\"line\">- (void)forwardInvocation:(NSInvocation *)anInvocation;</span><br></pre></td></tr></table></figure>\n<p>这个方法可以实现的很简单，通过改变调用的目标对象，使得消息在新目标对象上得以调用即可。然而这样实现的效果与 <strong>备援接收者</strong> 差不多，所以很少人会这么做。更加有用的实现方式为：在触发消息前，先以某种方式改变消息内容，比如追加另一个参数、修改 selector 等等。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p><img src=\"/images/image_note64270_1.png\"></p>\n<hr>\n<p><em>观点仅代表自己，期待你的留言。</em><br><a href=\"https://www.zybuluo.com/MicroCai/note/64270\">https://www.zybuluo.com/MicroCai/note/64270</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"最简单的动态\"><a href=\"#最简单的动态\" class=\"headerlink\" title=\"最简单的动态\"></a>最简单的动态</h2><p>Objective-C 是一门极其动态的语言，许多东西都可以推迟到运行时决定、修改。那么到底何为动态、何为静态？我们通过一个简单的例子对比下</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/***********  例1 静态绑定   ***********/</span><br><span class=\"line\">#import &lt;stdio.h&gt;</span><br><span class=\"line\">void printHello() &#123;</span><br><span class=\"line\">    printf(&quot;Hello, world!\\n&quot;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">void printGoodbye() &#123;</span><br><span class=\"line\">    printf(&quot;Goodbye, world!\\n&quot;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">void saySomething(int type) </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    if (type == 0) &#123;</span><br><span class=\"line\">        printHello();</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">        printGoodbye();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/***********  例2 动态绑定   ***********/</span><br><span class=\"line\">#import &lt;stdio.h&gt;</span><br><span class=\"line\">void printHello() &#123;</span><br><span class=\"line\">    printf(&quot;Hello, world!\\n&quot;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">void printGoodbye() &#123;</span><br><span class=\"line\">    printf(&quot;Goodbye, world!\\n&quot;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">void saySomething(int type) </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    void (*func)();</span><br><span class=\"line\">    if (type == 0) &#123;</span><br><span class=\"line\">        func = printHello;</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">        func = printGoodbye;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    func();</span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>例1的代码在编译期，编译器就已经知道了有 void printHello()、void printGoodbye() 俩函数，并且在 saySomething() 函数中，调用的函数明确，可以直接将函数名硬编码成地址，生成调用指令，这就是 __静态绑定__（static binding）。那么例2呢？例2的调用的是 func() 函数，而这函数实际调用的地址只能到程序运行时才能确定，这就是所谓的 __动态绑定__（dynamic binding）。动态绑定将函数调用从编译期推迟到了运行时。</p>\n<p>在 Objective-C 中，向对象传递消息，就会使用这种动态绑定机制来决定需要调用的方法，这种动态特性使得 Objective-C 成为一门真正动态的语言。</p>\n<h2 id=\"objec-msgSend-函数\"><a href=\"#objec-msgSend-函数\" class=\"headerlink\" title=\"objec_msgSend 函数\"></a>objec_msgSend 函数</h2><p>Objective-C 的方法调用通常都是下面这种形式</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">id returnValue = [someObject messageName:parameter];</span><br></pre></td></tr></table></figure>\n<p>这种方法调用其实就是消息传递，编译器看到这条消息会转换成一条标准的 C 语言函数调用</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">id returnValue = objc_msgSend(someObject,</span><br><span class=\"line\">                              @selector(messageName:),</span><br><span class=\"line\">                              parameter);</span><br></pre></td></tr></table></figure>\n<p>用消息传递的话来解释就是：向 someObject 对象发送了一个名叫 messageName 的消息，这个消息携带了一个叫 parameter 的参数。这里用到了一个 objc_msgSend 函数，其函数原型如下</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void objc_msgSend(id self, SEL cmd, ...);</span><br></pre></td></tr></table></figure>\n<p>这是一个可变参数的函数，第一个参数代表消息接收者，第二个代表 SEL 类型，后面的参数就是消息传递中使用的参数。</p>\n<p>那么什么是 SEL 呢？SEL 就是代码在编译时，编译器根据方法签名来生成的一个唯一 ID。此 ID 可以用以区分不同的方法，只要 ID 一致，即看成同一个方法，ID 不同，即为不同的方法。</p>\n<p>当进行消息传递，对象在响应消息时，是通过 SEL 在 methodlist 中查找函数指针 IMP，找到后直接通过指针调用函数，这其实就是前文介绍的 __动态绑定__。若是找到对应函数就跳转到实现代码，若找不到，就沿着继承链往上查找，直到找到相应的实现代码为止。若最终还是没找到实现代码，说明当前对象无法响应此消息，接下来就会执行 <strong>消息转发</strong> 操作，以试图找到一个能响应此消息的对象。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 获取 SEL </span><br><span class=\"line\">SEL sel = @selector(methodName);</span><br><span class=\"line\">// 获取 IMP</span><br><span class=\"line\">IMP imp = methodForSelector(sel);</span><br></pre></td></tr></table></figure>\n<h2 id=\"消息转发\"><a href=\"#消息转发\" class=\"headerlink\" title=\"消息转发\"></a>消息转发</h2><p>消息转发并不神奇，我们其实早已接触过，只是不知道而已</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-[__NSCFNumber lowercaseString]:unrecognized selector sent to instance 0x87</span><br><span class=\"line\">*** Terminating app due to uncaught exception &#x27;NSInvalidArgumentException&#x27;, reason:&#x27;-[NSCFNumber lowercaseString]:unrecognized selector sent to instance 0x87&#x27;</span><br></pre></td></tr></table></figure>\n<p>这段异常代码就是由 NSObject 的 doesNotRecognizeSelector: 方法所抛出的，异常表明：消息的接收者类型为 __NSCFNumber，无法响应 lowercaseString 消息，从而转发给 NSObject 处理。</p>\n<p>消息转发分为三大阶段</p>\n<ul>\n<li>第一阶段先征询消息接收者所属的类，看其是否能动态添加方法，以处理当前这个无法响应的 selector，这叫做 动态方法解析（dynamic method resolution）。如果运行期系统（runtime system） 第一阶段执行结束，接收者就无法再以动态新增方法的手段来响应消息，进入第二阶段。</li>\n<li>第二阶段看看有没有其他对象（备援接收者，replacement receiver）能处理此消息。如果有，运行期系统会把消息转发给那个对象，转发过程结束；如果没有，则启动完整的消息转发机制。</li>\n<li>第三阶段 完整的消息转发机制。运行期系统会把与消息有关的全部细节都封装到 NSInvocation 对象中，再给接收者最后一次机会，令其设法解决当前还未处理的消息。</li>\n</ul>\n<h3 id=\"动态方法解析\"><a href=\"#动态方法解析\" class=\"headerlink\" title=\"动态方法解析\"></a>动态方法解析</h3><p>对象在收到无法响应的消息后，会调用其所属类的下列方法</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> *  如果尚未实现的方法是实例方法，则调用此函数</span><br><span class=\"line\"> *</span><br><span class=\"line\"> *  @param selector 未处理的方法</span><br><span class=\"line\"> *</span><br><span class=\"line\"> *  @return 返回布尔值，表示是否能新增实例方法用以处理selector</span><br><span class=\"line\"> */</span><br><span class=\"line\">+ (BOOL)resolveInstanceMethod:(SEL)selector;</span><br><span class=\"line\">/**</span><br><span class=\"line\"> *  如果尚未实现的方法是类方法，则调用此函数</span><br><span class=\"line\"> *</span><br><span class=\"line\"> *  @param selector 未处理的方法</span><br><span class=\"line\"> *</span><br><span class=\"line\"> *  @return 返回布尔值，表示是否能新增类方法用以处理selector</span><br><span class=\"line\"> */</span><br><span class=\"line\">+ (BOOL)resolveClassMethod:(SEL)selector;</span><br></pre></td></tr></table></figure>\n<p>方法返回布尔类型，表示是否能新增一个方法来处理 selector，此方案通常用来实现 @dynamic 属性。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/************** 使用 resolveInstanceMethod 实现 @dynamic 属性 **************/</span><br><span class=\"line\">id autoDictionaryGetter(id self, SEL _cmd);</span><br><span class=\"line\">void autoDictionarySetter(id self, SEL _cmd, id value);</span><br><span class=\"line\">+ (BOOL)resolveInstanceMethod:(SEL)selector</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    NSString *selectorString = NSStringFromSelector(selector);</span><br><span class=\"line\">    if (/* selector is from a @dynamic property */)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        if ([selectorString hasPrefix:@&quot;set&quot;])</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            // 添加 setter 方法</span><br><span class=\"line\">            class_addMethod(self, selector, (IMP)autoDictionarySetter, &quot;v@:@&quot;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        else</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            // 添加 getter 方法</span><br><span class=\"line\">            class_addMethod(self, selector, (IMP)autoDictionaryGetter, &quot;@@:&quot;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return YES;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return [super resolveInstanceMethod:selector];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"备援接收者\"><a href=\"#备援接收者\" class=\"headerlink\" title=\"备援接收者\"></a>备援接收者</h3><p>如果无法 __动态解析方法__，运行期系统就会询问是否能将消息转给其他接收者来处理，对应的方法为</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> *  此方法询问是否能将消息转给其他接收者来处理</span><br><span class=\"line\"> *</span><br><span class=\"line\"> *  @param aSelector 未处理的方法</span><br><span class=\"line\"> *</span><br><span class=\"line\"> *  @return 如果当前接收者能找到备援对象，就将其返回；否则返回nil；</span><br><span class=\"line\"> */</span><br><span class=\"line\">- (id)forwardingTargetForSelector:(SEL)aSelector;</span><br></pre></td></tr></table></figure>\n<p>在对象内部，可能还有其他对象，该对象可通过此方法将能够处理 selector 的相关内部对象返回，在外界看来，就好像是该对象自己处理的似得。</p>\n<h3 id=\"完整的消息转发机制\"><a href=\"#完整的消息转发机制\" class=\"headerlink\" title=\"完整的消息转发机制\"></a>完整的消息转发机制</h3><p>如果前面两步都无法处理消息，就会启动完整的消息转发机制。首先创建 NSInvocation 对象，把尚未处理的那条消息有关的全部细节装在里面，在触发 NSInvocation 对象时，消息派发系统（message-dispatch system）将会把消息指派给目标对象。对应的方法为</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> *  消息派发系统通过此方法，将消息派发给目标对象</span><br><span class=\"line\"> *</span><br><span class=\"line\"> *  @param anInvocation 之前创建的NSInvocation实例对象，用于装载有关消息的所有内容</span><br><span class=\"line\"> */</span><br><span class=\"line\">- (void)forwardInvocation:(NSInvocation *)anInvocation;</span><br></pre></td></tr></table></figure>\n<p>这个方法可以实现的很简单，通过改变调用的目标对象，使得消息在新目标对象上得以调用即可。然而这样实现的效果与 <strong>备援接收者</strong> 差不多，所以很少人会这么做。更加有用的实现方式为：在触发消息前，先以某种方式改变消息内容，比如追加另一个参数、修改 selector 等等。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p><img src=\"/images/image_note64270_1.png\"></p>\n<hr>\n<p><em>观点仅代表自己，期待你的留言。</em><br><a href=\"https://www.zybuluo.com/MicroCai/note/64270\">https://www.zybuluo.com/MicroCai/note/64270</a></p>\n"},{"title":"Java Script Engine","keywords":["ScriptEngine","字符串运行结果"],"date":"2018-07-18T08:45:12.000Z","_content":"\n## Java Script Engine\n```java\npublic static void main(String[] agrs) throws ScriptException {\n    final ScriptEngine javascriptEngine = new ScriptEngineManager().getEngineByName(\"javascript\");\n    final Bindings globalBindings = javascriptEngine.getBindings(ScriptContext.GLOBAL_SCOPE);\n    globalBindings.put(\"a\", 5);\n    System.out.println(\"-------Engine bindings scope--------------\");\n    final Bindings javascriptEngineBindings = javascriptEngine.getBindings(ScriptContext.ENGINE_SCOPE);\n    javascriptEngineBindings.put(\"x\", 20);\n    javascriptEngineBindings.put(\"y\", 20.4);\n    javascriptEngineBindings.put(\"z\", 1);\n    final String[] scriptArray = {\"x*y+z\", \"x*(y+z)\", \"a+x*(y+z)\"};\n    eval(scriptArray, javascriptEngine);\n\n    System.out.println(\"-------Local bindings scope--------------\");\n    final Bindings localBinding = javascriptEngine.createBindings();\n    localBinding.put(\"x\", 2);\n    localBinding.put(\"y\", 3);\n    localBinding.put(\"z\", 1);\n    eval(scriptArray, javascriptEngine, localBinding);\n}\n\nprivate static void eval(String[] scriptArray, ScriptEngine javascriptEngine) throws ScriptException {\n    Bindings aBindings = javascriptEngine.getBindings(ScriptContext.GLOBAL_SCOPE);\n    for (String key : aBindings.keySet()) {\n        System.out.println(\"Args (Global bindings scope) > \" + key + \"=\" + aBindings.get(key));\n    }\n    aBindings = javascriptEngine.getBindings(ScriptContext.ENGINE_SCOPE);\n    for (String key : aBindings.keySet()) {\n        System.out.println(\"Args (Engine bindings scope) > \" + key + \"=\" + aBindings.get(key));\n    }\n    for (String script : scriptArray) {\n        System.out.println(\"script > \" + script + \" = \" + javascriptEngine.eval(script));\n    }\n}\n\nprivate static void eval(String[] scriptArray, ScriptEngine javascriptEngine, Bindings localBinding) throws ScriptException {\n    Bindings aBindings = javascriptEngine.getBindings(ScriptContext.GLOBAL_SCOPE);\n    for (String key : aBindings.keySet()) {\n        System.out.println(\"Args (Global bindings scope) > \" + key + \"=\" + aBindings.get(key));\n    }\n    aBindings = javascriptEngine.getBindings(ScriptContext.ENGINE_SCOPE);\n    for (String key : aBindings.keySet()) {\n        System.out.println(\"Args (Engine bindings scope) > \" + key + \"=\" + aBindings.get(key));\n    }\n    for (String s : localBinding.keySet()) {\n        System.out.println(\"Args (Local bindings scope) > \" + s + \"=\" + aBindings.get(s));\n    }\n    for (String script : scriptArray) {\n        System.out.println(\"script > \" + script + \" = \" + javascriptEngine.eval(script, localBinding));\n    }\n}\n```\n输出结果：\n```\n-------Engine bindings scope--------------\nArgs (Global bindings scope) > a=5\nArgs (Engine bindings scope) > z=1\nArgs (Engine bindings scope) > y=20.4\nArgs (Engine bindings scope) > x=20\nscript > x*y+z = 409.0\nscript > x*(y+z) = 428.0\nscript > a+x*(y+z) = 433.0\n-------Local bindings scope--------------\nArgs (Global bindings scope) > a=5\nArgs (Engine bindings scope) > println=sun.org.mozilla.javascript.internal.InterpretedFunction@45a23f67\nArgs (Engine bindings scope) > context=javax.script.SimpleScriptContext@1ef0a6e8\nArgs (Engine bindings scope) > z=1\nArgs (Engine bindings scope) > print=sun.org.mozilla.javascript.internal.InterpretedFunction@495dd936\nArgs (Engine bindings scope) > y=20.4\nArgs (Engine bindings scope) > x=20\nArgs (Local bindings scope) > z=1\nArgs (Local bindings scope) > y=20.4\nArgs (Local bindings scope) > x=20\nscript > x*y+z = 7.0\nscript > x*(y+z) = 8.0\nscript > a+x*(y+z) = 13.0\n\nProcess finished with exit code 0\n```\n__Bindings变量的有效范围__\n1. Global对应到ScriptEngineFactory，通过`scriptEngine.getBindings(ScriptContext.GLOBAL_SCOPE)`获得。\n2. Engine对应到ScriptEngine，通过`scriptEngine.getBindings(ScriptContext.ENGINE_SCOPE)`获得。\n3. Local Binding每一次执行script，通过`scriptEngine.createBindings()`获得。\n\n__使用场景适用于__\n1. 规则引擎\n2. 流程流转条件判定\n\n-----\n\n*观点仅代表自己，期待你的留言。*\n","source":"_posts/java-script-engine.md","raw":"---\ntitle: Java Script Engine\nkeywords:\n  - ScriptEngine\n  - 字符串运行结果\ntags:\n  - 原创\ndate: 2018-07-18 16:45:12\n---\n\n## Java Script Engine\n```java\npublic static void main(String[] agrs) throws ScriptException {\n    final ScriptEngine javascriptEngine = new ScriptEngineManager().getEngineByName(\"javascript\");\n    final Bindings globalBindings = javascriptEngine.getBindings(ScriptContext.GLOBAL_SCOPE);\n    globalBindings.put(\"a\", 5);\n    System.out.println(\"-------Engine bindings scope--------------\");\n    final Bindings javascriptEngineBindings = javascriptEngine.getBindings(ScriptContext.ENGINE_SCOPE);\n    javascriptEngineBindings.put(\"x\", 20);\n    javascriptEngineBindings.put(\"y\", 20.4);\n    javascriptEngineBindings.put(\"z\", 1);\n    final String[] scriptArray = {\"x*y+z\", \"x*(y+z)\", \"a+x*(y+z)\"};\n    eval(scriptArray, javascriptEngine);\n\n    System.out.println(\"-------Local bindings scope--------------\");\n    final Bindings localBinding = javascriptEngine.createBindings();\n    localBinding.put(\"x\", 2);\n    localBinding.put(\"y\", 3);\n    localBinding.put(\"z\", 1);\n    eval(scriptArray, javascriptEngine, localBinding);\n}\n\nprivate static void eval(String[] scriptArray, ScriptEngine javascriptEngine) throws ScriptException {\n    Bindings aBindings = javascriptEngine.getBindings(ScriptContext.GLOBAL_SCOPE);\n    for (String key : aBindings.keySet()) {\n        System.out.println(\"Args (Global bindings scope) > \" + key + \"=\" + aBindings.get(key));\n    }\n    aBindings = javascriptEngine.getBindings(ScriptContext.ENGINE_SCOPE);\n    for (String key : aBindings.keySet()) {\n        System.out.println(\"Args (Engine bindings scope) > \" + key + \"=\" + aBindings.get(key));\n    }\n    for (String script : scriptArray) {\n        System.out.println(\"script > \" + script + \" = \" + javascriptEngine.eval(script));\n    }\n}\n\nprivate static void eval(String[] scriptArray, ScriptEngine javascriptEngine, Bindings localBinding) throws ScriptException {\n    Bindings aBindings = javascriptEngine.getBindings(ScriptContext.GLOBAL_SCOPE);\n    for (String key : aBindings.keySet()) {\n        System.out.println(\"Args (Global bindings scope) > \" + key + \"=\" + aBindings.get(key));\n    }\n    aBindings = javascriptEngine.getBindings(ScriptContext.ENGINE_SCOPE);\n    for (String key : aBindings.keySet()) {\n        System.out.println(\"Args (Engine bindings scope) > \" + key + \"=\" + aBindings.get(key));\n    }\n    for (String s : localBinding.keySet()) {\n        System.out.println(\"Args (Local bindings scope) > \" + s + \"=\" + aBindings.get(s));\n    }\n    for (String script : scriptArray) {\n        System.out.println(\"script > \" + script + \" = \" + javascriptEngine.eval(script, localBinding));\n    }\n}\n```\n输出结果：\n```\n-------Engine bindings scope--------------\nArgs (Global bindings scope) > a=5\nArgs (Engine bindings scope) > z=1\nArgs (Engine bindings scope) > y=20.4\nArgs (Engine bindings scope) > x=20\nscript > x*y+z = 409.0\nscript > x*(y+z) = 428.0\nscript > a+x*(y+z) = 433.0\n-------Local bindings scope--------------\nArgs (Global bindings scope) > a=5\nArgs (Engine bindings scope) > println=sun.org.mozilla.javascript.internal.InterpretedFunction@45a23f67\nArgs (Engine bindings scope) > context=javax.script.SimpleScriptContext@1ef0a6e8\nArgs (Engine bindings scope) > z=1\nArgs (Engine bindings scope) > print=sun.org.mozilla.javascript.internal.InterpretedFunction@495dd936\nArgs (Engine bindings scope) > y=20.4\nArgs (Engine bindings scope) > x=20\nArgs (Local bindings scope) > z=1\nArgs (Local bindings scope) > y=20.4\nArgs (Local bindings scope) > x=20\nscript > x*y+z = 7.0\nscript > x*(y+z) = 8.0\nscript > a+x*(y+z) = 13.0\n\nProcess finished with exit code 0\n```\n__Bindings变量的有效范围__\n1. Global对应到ScriptEngineFactory，通过`scriptEngine.getBindings(ScriptContext.GLOBAL_SCOPE)`获得。\n2. Engine对应到ScriptEngine，通过`scriptEngine.getBindings(ScriptContext.ENGINE_SCOPE)`获得。\n3. Local Binding每一次执行script，通过`scriptEngine.createBindings()`获得。\n\n__使用场景适用于__\n1. 规则引擎\n2. 流程流转条件判定\n\n-----\n\n*观点仅代表自己，期待你的留言。*\n","slug":"java-script-engine","published":1,"updated":"2021-08-31T14:23:11.544Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cku52dynb0028bbin3ue92lfm","content":"<h2 id=\"Java-Script-Engine\"><a href=\"#Java-Script-Engine\" class=\"headerlink\" title=\"Java Script Engine\"></a>Java Script Engine</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] agrs)</span> <span class=\"keyword\">throws</span> ScriptException </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> ScriptEngine javascriptEngine = <span class=\"keyword\">new</span> ScriptEngineManager().getEngineByName(<span class=\"string\">&quot;javascript&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">final</span> Bindings globalBindings = javascriptEngine.getBindings(ScriptContext.GLOBAL_SCOPE);</span><br><span class=\"line\">    globalBindings.put(<span class=\"string\">&quot;a&quot;</span>, <span class=\"number\">5</span>);</span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;-------Engine bindings scope--------------&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">final</span> Bindings javascriptEngineBindings = javascriptEngine.getBindings(ScriptContext.ENGINE_SCOPE);</span><br><span class=\"line\">    javascriptEngineBindings.put(<span class=\"string\">&quot;x&quot;</span>, <span class=\"number\">20</span>);</span><br><span class=\"line\">    javascriptEngineBindings.put(<span class=\"string\">&quot;y&quot;</span>, <span class=\"number\">20.4</span>);</span><br><span class=\"line\">    javascriptEngineBindings.put(<span class=\"string\">&quot;z&quot;</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"keyword\">final</span> String[] scriptArray = &#123;<span class=\"string\">&quot;x*y+z&quot;</span>, <span class=\"string\">&quot;x*(y+z)&quot;</span>, <span class=\"string\">&quot;a+x*(y+z)&quot;</span>&#125;;</span><br><span class=\"line\">    eval(scriptArray, javascriptEngine);</span><br><span class=\"line\"></span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;-------Local bindings scope--------------&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">final</span> Bindings localBinding = javascriptEngine.createBindings();</span><br><span class=\"line\">    localBinding.put(<span class=\"string\">&quot;x&quot;</span>, <span class=\"number\">2</span>);</span><br><span class=\"line\">    localBinding.put(<span class=\"string\">&quot;y&quot;</span>, <span class=\"number\">3</span>);</span><br><span class=\"line\">    localBinding.put(<span class=\"string\">&quot;z&quot;</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\">    eval(scriptArray, javascriptEngine, localBinding);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">eval</span><span class=\"params\">(String[] scriptArray, ScriptEngine javascriptEngine)</span> <span class=\"keyword\">throws</span> ScriptException </span>&#123;</span><br><span class=\"line\">    Bindings aBindings = javascriptEngine.getBindings(ScriptContext.GLOBAL_SCOPE);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (String key : aBindings.keySet()) &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;Args (Global bindings scope) &gt; &quot;</span> + key + <span class=\"string\">&quot;=&quot;</span> + aBindings.get(key));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    aBindings = javascriptEngine.getBindings(ScriptContext.ENGINE_SCOPE);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (String key : aBindings.keySet()) &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;Args (Engine bindings scope) &gt; &quot;</span> + key + <span class=\"string\">&quot;=&quot;</span> + aBindings.get(key));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (String script : scriptArray) &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;script &gt; &quot;</span> + script + <span class=\"string\">&quot; = &quot;</span> + javascriptEngine.eval(script));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">eval</span><span class=\"params\">(String[] scriptArray, ScriptEngine javascriptEngine, Bindings localBinding)</span> <span class=\"keyword\">throws</span> ScriptException </span>&#123;</span><br><span class=\"line\">    Bindings aBindings = javascriptEngine.getBindings(ScriptContext.GLOBAL_SCOPE);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (String key : aBindings.keySet()) &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;Args (Global bindings scope) &gt; &quot;</span> + key + <span class=\"string\">&quot;=&quot;</span> + aBindings.get(key));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    aBindings = javascriptEngine.getBindings(ScriptContext.ENGINE_SCOPE);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (String key : aBindings.keySet()) &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;Args (Engine bindings scope) &gt; &quot;</span> + key + <span class=\"string\">&quot;=&quot;</span> + aBindings.get(key));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (String s : localBinding.keySet()) &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;Args (Local bindings scope) &gt; &quot;</span> + s + <span class=\"string\">&quot;=&quot;</span> + aBindings.get(s));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (String script : scriptArray) &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;script &gt; &quot;</span> + script + <span class=\"string\">&quot; = &quot;</span> + javascriptEngine.eval(script, localBinding));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>输出结果：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-------Engine bindings scope--------------</span><br><span class=\"line\">Args (Global bindings scope) &gt; a=5</span><br><span class=\"line\">Args (Engine bindings scope) &gt; z=1</span><br><span class=\"line\">Args (Engine bindings scope) &gt; y=20.4</span><br><span class=\"line\">Args (Engine bindings scope) &gt; x=20</span><br><span class=\"line\">script &gt; x*y+z = 409.0</span><br><span class=\"line\">script &gt; x*(y+z) = 428.0</span><br><span class=\"line\">script &gt; a+x*(y+z) = 433.0</span><br><span class=\"line\">-------Local bindings scope--------------</span><br><span class=\"line\">Args (Global bindings scope) &gt; a=5</span><br><span class=\"line\">Args (Engine bindings scope) &gt; println=sun.org.mozilla.javascript.internal.InterpretedFunction@45a23f67</span><br><span class=\"line\">Args (Engine bindings scope) &gt; context=javax.script.SimpleScriptContext@1ef0a6e8</span><br><span class=\"line\">Args (Engine bindings scope) &gt; z=1</span><br><span class=\"line\">Args (Engine bindings scope) &gt; print=sun.org.mozilla.javascript.internal.InterpretedFunction@495dd936</span><br><span class=\"line\">Args (Engine bindings scope) &gt; y=20.4</span><br><span class=\"line\">Args (Engine bindings scope) &gt; x=20</span><br><span class=\"line\">Args (Local bindings scope) &gt; z=1</span><br><span class=\"line\">Args (Local bindings scope) &gt; y=20.4</span><br><span class=\"line\">Args (Local bindings scope) &gt; x=20</span><br><span class=\"line\">script &gt; x*y+z = 7.0</span><br><span class=\"line\">script &gt; x*(y+z) = 8.0</span><br><span class=\"line\">script &gt; a+x*(y+z) = 13.0</span><br><span class=\"line\"></span><br><span class=\"line\">Process finished with exit code 0</span><br></pre></td></tr></table></figure>\n<p><strong>Bindings变量的有效范围</strong></p>\n<ol>\n<li>Global对应到ScriptEngineFactory，通过<code>scriptEngine.getBindings(ScriptContext.GLOBAL_SCOPE)</code>获得。</li>\n<li>Engine对应到ScriptEngine，通过<code>scriptEngine.getBindings(ScriptContext.ENGINE_SCOPE)</code>获得。</li>\n<li>Local Binding每一次执行script，通过<code>scriptEngine.createBindings()</code>获得。</li>\n</ol>\n<p><strong>使用场景适用于</strong></p>\n<ol>\n<li>规则引擎</li>\n<li>流程流转条件判定</li>\n</ol>\n<hr>\n<p><em>观点仅代表自己，期待你的留言。</em></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"Java-Script-Engine\"><a href=\"#Java-Script-Engine\" class=\"headerlink\" title=\"Java Script Engine\"></a>Java Script Engine</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] agrs)</span> <span class=\"keyword\">throws</span> ScriptException </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> ScriptEngine javascriptEngine = <span class=\"keyword\">new</span> ScriptEngineManager().getEngineByName(<span class=\"string\">&quot;javascript&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">final</span> Bindings globalBindings = javascriptEngine.getBindings(ScriptContext.GLOBAL_SCOPE);</span><br><span class=\"line\">    globalBindings.put(<span class=\"string\">&quot;a&quot;</span>, <span class=\"number\">5</span>);</span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;-------Engine bindings scope--------------&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">final</span> Bindings javascriptEngineBindings = javascriptEngine.getBindings(ScriptContext.ENGINE_SCOPE);</span><br><span class=\"line\">    javascriptEngineBindings.put(<span class=\"string\">&quot;x&quot;</span>, <span class=\"number\">20</span>);</span><br><span class=\"line\">    javascriptEngineBindings.put(<span class=\"string\">&quot;y&quot;</span>, <span class=\"number\">20.4</span>);</span><br><span class=\"line\">    javascriptEngineBindings.put(<span class=\"string\">&quot;z&quot;</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"keyword\">final</span> String[] scriptArray = &#123;<span class=\"string\">&quot;x*y+z&quot;</span>, <span class=\"string\">&quot;x*(y+z)&quot;</span>, <span class=\"string\">&quot;a+x*(y+z)&quot;</span>&#125;;</span><br><span class=\"line\">    eval(scriptArray, javascriptEngine);</span><br><span class=\"line\"></span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;-------Local bindings scope--------------&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">final</span> Bindings localBinding = javascriptEngine.createBindings();</span><br><span class=\"line\">    localBinding.put(<span class=\"string\">&quot;x&quot;</span>, <span class=\"number\">2</span>);</span><br><span class=\"line\">    localBinding.put(<span class=\"string\">&quot;y&quot;</span>, <span class=\"number\">3</span>);</span><br><span class=\"line\">    localBinding.put(<span class=\"string\">&quot;z&quot;</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\">    eval(scriptArray, javascriptEngine, localBinding);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">eval</span><span class=\"params\">(String[] scriptArray, ScriptEngine javascriptEngine)</span> <span class=\"keyword\">throws</span> ScriptException </span>&#123;</span><br><span class=\"line\">    Bindings aBindings = javascriptEngine.getBindings(ScriptContext.GLOBAL_SCOPE);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (String key : aBindings.keySet()) &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;Args (Global bindings scope) &gt; &quot;</span> + key + <span class=\"string\">&quot;=&quot;</span> + aBindings.get(key));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    aBindings = javascriptEngine.getBindings(ScriptContext.ENGINE_SCOPE);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (String key : aBindings.keySet()) &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;Args (Engine bindings scope) &gt; &quot;</span> + key + <span class=\"string\">&quot;=&quot;</span> + aBindings.get(key));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (String script : scriptArray) &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;script &gt; &quot;</span> + script + <span class=\"string\">&quot; = &quot;</span> + javascriptEngine.eval(script));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">eval</span><span class=\"params\">(String[] scriptArray, ScriptEngine javascriptEngine, Bindings localBinding)</span> <span class=\"keyword\">throws</span> ScriptException </span>&#123;</span><br><span class=\"line\">    Bindings aBindings = javascriptEngine.getBindings(ScriptContext.GLOBAL_SCOPE);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (String key : aBindings.keySet()) &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;Args (Global bindings scope) &gt; &quot;</span> + key + <span class=\"string\">&quot;=&quot;</span> + aBindings.get(key));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    aBindings = javascriptEngine.getBindings(ScriptContext.ENGINE_SCOPE);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (String key : aBindings.keySet()) &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;Args (Engine bindings scope) &gt; &quot;</span> + key + <span class=\"string\">&quot;=&quot;</span> + aBindings.get(key));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (String s : localBinding.keySet()) &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;Args (Local bindings scope) &gt; &quot;</span> + s + <span class=\"string\">&quot;=&quot;</span> + aBindings.get(s));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (String script : scriptArray) &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;script &gt; &quot;</span> + script + <span class=\"string\">&quot; = &quot;</span> + javascriptEngine.eval(script, localBinding));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>输出结果：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-------Engine bindings scope--------------</span><br><span class=\"line\">Args (Global bindings scope) &gt; a=5</span><br><span class=\"line\">Args (Engine bindings scope) &gt; z=1</span><br><span class=\"line\">Args (Engine bindings scope) &gt; y=20.4</span><br><span class=\"line\">Args (Engine bindings scope) &gt; x=20</span><br><span class=\"line\">script &gt; x*y+z = 409.0</span><br><span class=\"line\">script &gt; x*(y+z) = 428.0</span><br><span class=\"line\">script &gt; a+x*(y+z) = 433.0</span><br><span class=\"line\">-------Local bindings scope--------------</span><br><span class=\"line\">Args (Global bindings scope) &gt; a=5</span><br><span class=\"line\">Args (Engine bindings scope) &gt; println=sun.org.mozilla.javascript.internal.InterpretedFunction@45a23f67</span><br><span class=\"line\">Args (Engine bindings scope) &gt; context=javax.script.SimpleScriptContext@1ef0a6e8</span><br><span class=\"line\">Args (Engine bindings scope) &gt; z=1</span><br><span class=\"line\">Args (Engine bindings scope) &gt; print=sun.org.mozilla.javascript.internal.InterpretedFunction@495dd936</span><br><span class=\"line\">Args (Engine bindings scope) &gt; y=20.4</span><br><span class=\"line\">Args (Engine bindings scope) &gt; x=20</span><br><span class=\"line\">Args (Local bindings scope) &gt; z=1</span><br><span class=\"line\">Args (Local bindings scope) &gt; y=20.4</span><br><span class=\"line\">Args (Local bindings scope) &gt; x=20</span><br><span class=\"line\">script &gt; x*y+z = 7.0</span><br><span class=\"line\">script &gt; x*(y+z) = 8.0</span><br><span class=\"line\">script &gt; a+x*(y+z) = 13.0</span><br><span class=\"line\"></span><br><span class=\"line\">Process finished with exit code 0</span><br></pre></td></tr></table></figure>\n<p><strong>Bindings变量的有效范围</strong></p>\n<ol>\n<li>Global对应到ScriptEngineFactory，通过<code>scriptEngine.getBindings(ScriptContext.GLOBAL_SCOPE)</code>获得。</li>\n<li>Engine对应到ScriptEngine，通过<code>scriptEngine.getBindings(ScriptContext.ENGINE_SCOPE)</code>获得。</li>\n<li>Local Binding每一次执行script，通过<code>scriptEngine.createBindings()</code>获得。</li>\n</ol>\n<p><strong>使用场景适用于</strong></p>\n<ol>\n<li>规则引擎</li>\n<li>流程流转条件判定</li>\n</ol>\n<hr>\n<p><em>观点仅代表自己，期待你的留言。</em></p>\n"},{"title":"jvm查内存泄漏利器 - jmap","keywords":["jmap","内存泄漏","对象实例数","对象所占字节数"],"date":"2016-09-21T06:21:51.000Z","_content":"## 简介\nOracle将jmap描述为一种“输出进程、核心文件、远程调试服务器的共享对象内存映射和堆内存细节”的程序。\n通过它可以查看内存中对象实例，从而解决程序出现不正常的高内存负载、频繁无响应或内存溢出等问题。\n## 命令安装\n1. Oracle JDK在安装完成后bin目录下就会发现有jmap命令。\n2. Open JDK在安装完成后需要安装openjdk-devel开发包才能得到jmap命令。\n安装方法如下（以CentOS为例）：\n使用 `yum whatprovides '*/jmap'`查包含jmap命令开发包的名称。\n```\n[root@wujianjun-linux bin]# yum whatprovides '*/jmap'\nLoaded plugins: fastestmirror, security\nLoading mirror speeds from cached hostfile\nbase/filelists_db                                                                                  | 6.4 MB     00:00     \nextras/filelists_db                                                                                |  38 kB     00:00     \nupdates/filelists_db                                                                               | 1.5 MB     00:00     \n1:java-1.7.0-openjdk-devel-1.7.0.99-2.6.5.1.el6.x86_64 : OpenJDK Development Environment\nRepo        : base\nMatched from:\nFilename    : /usr/lib/jvm/java-1.7.0-openjdk-1.7.0.99.x86_64/bin/jmap\n......\n.....\n...\n```\n找到与jdk版本相对应的开发包进行安装\n```\n[root@wujianjun-linux bin]# yum install java-1.7.0-openjdk-devel\n```\n安装完成后查找命令所在目录\n```\n[root@wujianjun-linux bin]# whereis jmap\njmap: /usr/bin/jmap /usr/share/man/man1/jmap.1.gz\n```\n只要能显示相应目录，则表示安装成功。\n## jmap使用\n```\nroot@wujianjun-linux ~]# jmap --help\nUsage:\n    jmap [option] <pid>\n        (to connect to running process)\n    jmap [option] <executable <core>\n        (to connect to a core file)\n    jmap [option] [server_id@]<remote server IP or hostname>\n        (to connect to remote debug server)\n\nwhere <option> is one of:\n    <none>               to print same info as Solaris pmap\n    -heap                to print java heap summary\n    -histo[:live]        to print histogram of java object heap; if the \"live\"\n                         suboption is specified, only count live objects\n    -permstat            to print permanent generation statistics\n    -finalizerinfo       to print information on objects awaiting finalization\n    -dump:<dump-options> to dump java heap in hprof binary format\n                         dump-options:\n                           live         dump only live objects; if not specified,\n                                        all objects in the heap are dumped.\n                           format=b     binary format\n                           file=<file>  dump heap to <file>\n                         Example: jmap -dump:live,format=b,file=heap.bin <pid>\n    -F                   force. Use with -dump:<dump-options> <pid> or -histo\n                         to force a heap dump or histogram when <pid> does not\n                         respond. The \"live\" suboption is not supported\n                         in this mode.\n    -h | -help           to print this help message\n    -J<flag>             to pass <flag> directly to the runtime system\n```\n* jmap pid #打印内存使用的摘要信息\n* jmap –heap pid #java heap信息\n* jmap -histo:live pid #统计对象count ，live表示在使用\n* jmap -histo pid >mem.txt #打印比较简单的各个有多少个对象占了多少内存的信息，一般重定向的文件\n* jmap -dump:format=b,file=mem.dat pid #将内存使用的详细情况输出到mem.dat 文件\n  通过`jhat -port 7000 mem.dat`可以将mem.dat的内容以web的方式暴露到网络，访问`http://ip-server:7000`查看。\n\n针对内存泄漏这一问题，可以通过查看堆内存中存活对象实例及所占内存数查到对象是否一直被占用导致不能被GC回收。\n如：\n```\n[root@wujianjun-linux ~]# jps |grep -v Jps\n9495 Bootstrap\n\n[root@wujianjun-linux ~]# jmap -histo:live 9495\n num     #instances         #bytes  class name\n----------------------------------------------\n   1:        294149       29662584  [C\n   2:        187061       27752880  <constMethodKlass>\n   3:        187061       23955120  <methodKlass>\n   4:         15897       19221104  <constantPoolKlass>\n   5:         61107       13783928  [B\n   6:         15897       11445056  <instanceKlassKlass>\n   7:         13934       11267712  <constantPoolCacheKlass>\n   8:        280651        6735624  java.lang.String\n   9:        102892        5761952  org.springframework.asm.Item\n  10:        234489        5627736  org.springframework.asm.Edge\n  11:         84750        5424000  org.springframework.asm.Label\n  12:         66211        5296880  java.lang.reflect.Method\n  13:         63388        4503312  [I\n  14:         75275        4215400  org.springframework.asm.Item\n  15:         62580        4005120  org.springframework.asm.Label\n  16:        132458        3178992  org.springframework.asm.Edge\n\n[root@wujianjun-linux ~]# jmap -histo:live 9495|grep com.yqyw\n num     #instances         #bytes  class name\n----------------------------------------------\n2788:             1             48  com.yqyw.user.rpc.client.UserClient\n3570:             1             32  com.yqyw.pnr.sdk.client.ShopClient\n3731:             1             32  com.yqyw.pnr.sdk.client.ShopClient\n3842:             1             24  com.yqyw.user.rpc.client.impl.FavoriteServiceImpl\n```\n从以上输出可以看出目前堆内存中自己程序中的对象实例以及占用bytes，从而确定程序中哪些位置对这些对象进行创建使用且未被释放（典型的情况是将对象存入List等集合类而未被remove）。\n也通过多次执行`jmap -histo:live pid >mem.txt`将每次结果定向到不同的txt中，然后对象对比。发现对象实例的增长与占用字节的变化。\n\n\n__附 - jmap输出中class name非自定义类的说明：__\n\n|BaseType Character     |Type           |Interpretation\n|:- |:- |:- \n|B \t\t\t\t\t\t|byte \t\t\t|signed byte\n|C \t\t\t\t\t\t|char        \t|Unicode character\n|D \t\t\t\t\t\t|double\t\t\t|double-precision floating-point value\n|F \t\t\t\t\t\t|float \t\t\t|single-precision floating-point value\n|I \t\t\t\t\t\t|int \t\t\t|integer\n|J \t\t\t\t\t\t|long \t\t\t|long integer\n|L; \t\t\t\t\t|reference \t\t|an instance of class\n|S \t\t\t\t\t\t|short\t\t\t|signed short\n|Z\t\t\t\t\t\t|boolean \t\t|true or false\n|[ \t\t\t\t\t\t|reference \t\t|one array dimension\n\n-----\n\n*观点仅代表自己，期待你的留言。*\n","source":"_posts/jvm-tools-jmap.md","raw":"---\ntitle: jvm查内存泄漏利器 - jmap\nkeywords:\n  - jmap\n  - 内存泄漏\n  - 对象实例数\n  - 对象所占字节数\ntags:\n  - 原创\ndate: 2016-09-21 14:21:51\n---\n## 简介\nOracle将jmap描述为一种“输出进程、核心文件、远程调试服务器的共享对象内存映射和堆内存细节”的程序。\n通过它可以查看内存中对象实例，从而解决程序出现不正常的高内存负载、频繁无响应或内存溢出等问题。\n## 命令安装\n1. Oracle JDK在安装完成后bin目录下就会发现有jmap命令。\n2. Open JDK在安装完成后需要安装openjdk-devel开发包才能得到jmap命令。\n安装方法如下（以CentOS为例）：\n使用 `yum whatprovides '*/jmap'`查包含jmap命令开发包的名称。\n```\n[root@wujianjun-linux bin]# yum whatprovides '*/jmap'\nLoaded plugins: fastestmirror, security\nLoading mirror speeds from cached hostfile\nbase/filelists_db                                                                                  | 6.4 MB     00:00     \nextras/filelists_db                                                                                |  38 kB     00:00     \nupdates/filelists_db                                                                               | 1.5 MB     00:00     \n1:java-1.7.0-openjdk-devel-1.7.0.99-2.6.5.1.el6.x86_64 : OpenJDK Development Environment\nRepo        : base\nMatched from:\nFilename    : /usr/lib/jvm/java-1.7.0-openjdk-1.7.0.99.x86_64/bin/jmap\n......\n.....\n...\n```\n找到与jdk版本相对应的开发包进行安装\n```\n[root@wujianjun-linux bin]# yum install java-1.7.0-openjdk-devel\n```\n安装完成后查找命令所在目录\n```\n[root@wujianjun-linux bin]# whereis jmap\njmap: /usr/bin/jmap /usr/share/man/man1/jmap.1.gz\n```\n只要能显示相应目录，则表示安装成功。\n## jmap使用\n```\nroot@wujianjun-linux ~]# jmap --help\nUsage:\n    jmap [option] <pid>\n        (to connect to running process)\n    jmap [option] <executable <core>\n        (to connect to a core file)\n    jmap [option] [server_id@]<remote server IP or hostname>\n        (to connect to remote debug server)\n\nwhere <option> is one of:\n    <none>               to print same info as Solaris pmap\n    -heap                to print java heap summary\n    -histo[:live]        to print histogram of java object heap; if the \"live\"\n                         suboption is specified, only count live objects\n    -permstat            to print permanent generation statistics\n    -finalizerinfo       to print information on objects awaiting finalization\n    -dump:<dump-options> to dump java heap in hprof binary format\n                         dump-options:\n                           live         dump only live objects; if not specified,\n                                        all objects in the heap are dumped.\n                           format=b     binary format\n                           file=<file>  dump heap to <file>\n                         Example: jmap -dump:live,format=b,file=heap.bin <pid>\n    -F                   force. Use with -dump:<dump-options> <pid> or -histo\n                         to force a heap dump or histogram when <pid> does not\n                         respond. The \"live\" suboption is not supported\n                         in this mode.\n    -h | -help           to print this help message\n    -J<flag>             to pass <flag> directly to the runtime system\n```\n* jmap pid #打印内存使用的摘要信息\n* jmap –heap pid #java heap信息\n* jmap -histo:live pid #统计对象count ，live表示在使用\n* jmap -histo pid >mem.txt #打印比较简单的各个有多少个对象占了多少内存的信息，一般重定向的文件\n* jmap -dump:format=b,file=mem.dat pid #将内存使用的详细情况输出到mem.dat 文件\n  通过`jhat -port 7000 mem.dat`可以将mem.dat的内容以web的方式暴露到网络，访问`http://ip-server:7000`查看。\n\n针对内存泄漏这一问题，可以通过查看堆内存中存活对象实例及所占内存数查到对象是否一直被占用导致不能被GC回收。\n如：\n```\n[root@wujianjun-linux ~]# jps |grep -v Jps\n9495 Bootstrap\n\n[root@wujianjun-linux ~]# jmap -histo:live 9495\n num     #instances         #bytes  class name\n----------------------------------------------\n   1:        294149       29662584  [C\n   2:        187061       27752880  <constMethodKlass>\n   3:        187061       23955120  <methodKlass>\n   4:         15897       19221104  <constantPoolKlass>\n   5:         61107       13783928  [B\n   6:         15897       11445056  <instanceKlassKlass>\n   7:         13934       11267712  <constantPoolCacheKlass>\n   8:        280651        6735624  java.lang.String\n   9:        102892        5761952  org.springframework.asm.Item\n  10:        234489        5627736  org.springframework.asm.Edge\n  11:         84750        5424000  org.springframework.asm.Label\n  12:         66211        5296880  java.lang.reflect.Method\n  13:         63388        4503312  [I\n  14:         75275        4215400  org.springframework.asm.Item\n  15:         62580        4005120  org.springframework.asm.Label\n  16:        132458        3178992  org.springframework.asm.Edge\n\n[root@wujianjun-linux ~]# jmap -histo:live 9495|grep com.yqyw\n num     #instances         #bytes  class name\n----------------------------------------------\n2788:             1             48  com.yqyw.user.rpc.client.UserClient\n3570:             1             32  com.yqyw.pnr.sdk.client.ShopClient\n3731:             1             32  com.yqyw.pnr.sdk.client.ShopClient\n3842:             1             24  com.yqyw.user.rpc.client.impl.FavoriteServiceImpl\n```\n从以上输出可以看出目前堆内存中自己程序中的对象实例以及占用bytes，从而确定程序中哪些位置对这些对象进行创建使用且未被释放（典型的情况是将对象存入List等集合类而未被remove）。\n也通过多次执行`jmap -histo:live pid >mem.txt`将每次结果定向到不同的txt中，然后对象对比。发现对象实例的增长与占用字节的变化。\n\n\n__附 - jmap输出中class name非自定义类的说明：__\n\n|BaseType Character     |Type           |Interpretation\n|:- |:- |:- \n|B \t\t\t\t\t\t|byte \t\t\t|signed byte\n|C \t\t\t\t\t\t|char        \t|Unicode character\n|D \t\t\t\t\t\t|double\t\t\t|double-precision floating-point value\n|F \t\t\t\t\t\t|float \t\t\t|single-precision floating-point value\n|I \t\t\t\t\t\t|int \t\t\t|integer\n|J \t\t\t\t\t\t|long \t\t\t|long integer\n|L; \t\t\t\t\t|reference \t\t|an instance of class\n|S \t\t\t\t\t\t|short\t\t\t|signed short\n|Z\t\t\t\t\t\t|boolean \t\t|true or false\n|[ \t\t\t\t\t\t|reference \t\t|one array dimension\n\n-----\n\n*观点仅代表自己，期待你的留言。*\n","slug":"jvm-tools-jmap","published":1,"updated":"2021-09-18T03:03:59.590Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cku52dync002abbin1dd1gu6e","content":"<h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><p>Oracle将jmap描述为一种“输出进程、核心文件、远程调试服务器的共享对象内存映射和堆内存细节”的程序。<br>通过它可以查看内存中对象实例，从而解决程序出现不正常的高内存负载、频繁无响应或内存溢出等问题。</p>\n<h2 id=\"命令安装\"><a href=\"#命令安装\" class=\"headerlink\" title=\"命令安装\"></a>命令安装</h2><ol>\n<li>Oracle JDK在安装完成后bin目录下就会发现有jmap命令。</li>\n<li>Open JDK在安装完成后需要安装openjdk-devel开发包才能得到jmap命令。<br>安装方法如下（以CentOS为例）：<br>使用 <code>yum whatprovides &#39;*/jmap&#39;</code>查包含jmap命令开发包的名称。<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@wujianjun-linux bin]# yum whatprovides &#x27;*/jmap&#x27;</span><br><span class=\"line\">Loaded plugins: fastestmirror, security</span><br><span class=\"line\">Loading mirror speeds from cached hostfile</span><br><span class=\"line\">base/filelists_db                                                                                  | 6.4 MB     00:00     </span><br><span class=\"line\">extras/filelists_db                                                                                |  38 kB     00:00     </span><br><span class=\"line\">updates/filelists_db                                                                               | 1.5 MB     00:00     </span><br><span class=\"line\">1:java-1.7.0-openjdk-devel-1.7.0.99-2.6.5.1.el6.x86_64 : OpenJDK Development Environment</span><br><span class=\"line\">Repo        : base</span><br><span class=\"line\">Matched from:</span><br><span class=\"line\">Filename    : /usr/lib/jvm/java-1.7.0-openjdk-1.7.0.99.x86_64/bin/jmap</span><br><span class=\"line\">......</span><br><span class=\"line\">.....</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n找到与jdk版本相对应的开发包进行安装<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@wujianjun-linux bin]# yum install java-1.7.0-openjdk-devel</span><br></pre></td></tr></table></figure>\n安装完成后查找命令所在目录<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@wujianjun-linux bin]# whereis jmap</span><br><span class=\"line\">jmap: /usr/bin/jmap /usr/share/man/man1/jmap.1.gz</span><br></pre></td></tr></table></figure>\n只要能显示相应目录，则表示安装成功。<h2 id=\"jmap使用\"><a href=\"#jmap使用\" class=\"headerlink\" title=\"jmap使用\"></a>jmap使用</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">root@wujianjun-linux ~]# jmap --help</span><br><span class=\"line\">Usage:</span><br><span class=\"line\">    jmap [option] &lt;pid&gt;</span><br><span class=\"line\">        (to connect to running process)</span><br><span class=\"line\">    jmap [option] &lt;executable &lt;core&gt;</span><br><span class=\"line\">        (to connect to a core file)</span><br><span class=\"line\">    jmap [option] [server_id@]&lt;remote server IP or hostname&gt;</span><br><span class=\"line\">        (to connect to remote debug server)</span><br><span class=\"line\"></span><br><span class=\"line\">where &lt;option&gt; is one of:</span><br><span class=\"line\">    &lt;none&gt;               to print same info as Solaris pmap</span><br><span class=\"line\">    -heap                to print java heap summary</span><br><span class=\"line\">    -histo[:live]        to print histogram of java object heap; if the &quot;live&quot;</span><br><span class=\"line\">                         suboption is specified, only count live objects</span><br><span class=\"line\">    -permstat            to print permanent generation statistics</span><br><span class=\"line\">    -finalizerinfo       to print information on objects awaiting finalization</span><br><span class=\"line\">    -dump:&lt;dump-options&gt; to dump java heap in hprof binary format</span><br><span class=\"line\">                         dump-options:</span><br><span class=\"line\">                           live         dump only live objects; if not specified,</span><br><span class=\"line\">                                        all objects in the heap are dumped.</span><br><span class=\"line\">                           format=b     binary format</span><br><span class=\"line\">                           file=&lt;file&gt;  dump heap to &lt;file&gt;</span><br><span class=\"line\">                         Example: jmap -dump:live,format=b,file=heap.bin &lt;pid&gt;</span><br><span class=\"line\">    -F                   force. Use with -dump:&lt;dump-options&gt; &lt;pid&gt; or -histo</span><br><span class=\"line\">                         to force a heap dump or histogram when &lt;pid&gt; does not</span><br><span class=\"line\">                         respond. The &quot;live&quot; suboption is not supported</span><br><span class=\"line\">                         in this mode.</span><br><span class=\"line\">    -h | -help           to print this help message</span><br><span class=\"line\">    -J&lt;flag&gt;             to pass &lt;flag&gt; directly to the runtime system</span><br></pre></td></tr></table></figure></li>\n</ol>\n<ul>\n<li>jmap pid #打印内存使用的摘要信息</li>\n<li>jmap –heap pid #java heap信息</li>\n<li>jmap -histo:live pid #统计对象count ，live表示在使用</li>\n<li>jmap -histo pid &gt;mem.txt #打印比较简单的各个有多少个对象占了多少内存的信息，一般重定向的文件</li>\n<li>jmap -dump:format=b,file=mem.dat pid #将内存使用的详细情况输出到mem.dat 文件<br>通过<code>jhat -port 7000 mem.dat</code>可以将mem.dat的内容以web的方式暴露到网络，访问<code>http://ip-server:7000</code>查看。</li>\n</ul>\n<p>针对内存泄漏这一问题，可以通过查看堆内存中存活对象实例及所占内存数查到对象是否一直被占用导致不能被GC回收。<br>如：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@wujianjun-linux ~]# jps |grep -v Jps</span><br><span class=\"line\">9495 Bootstrap</span><br><span class=\"line\"></span><br><span class=\"line\">[root@wujianjun-linux ~]# jmap -histo:live 9495</span><br><span class=\"line\"> num     #instances         #bytes  class name</span><br><span class=\"line\">----------------------------------------------</span><br><span class=\"line\">   1:        294149       29662584  [C</span><br><span class=\"line\">   2:        187061       27752880  &lt;constMethodKlass&gt;</span><br><span class=\"line\">   3:        187061       23955120  &lt;methodKlass&gt;</span><br><span class=\"line\">   4:         15897       19221104  &lt;constantPoolKlass&gt;</span><br><span class=\"line\">   5:         61107       13783928  [B</span><br><span class=\"line\">   6:         15897       11445056  &lt;instanceKlassKlass&gt;</span><br><span class=\"line\">   7:         13934       11267712  &lt;constantPoolCacheKlass&gt;</span><br><span class=\"line\">   8:        280651        6735624  java.lang.String</span><br><span class=\"line\">   9:        102892        5761952  org.springframework.asm.Item</span><br><span class=\"line\">  10:        234489        5627736  org.springframework.asm.Edge</span><br><span class=\"line\">  11:         84750        5424000  org.springframework.asm.Label</span><br><span class=\"line\">  12:         66211        5296880  java.lang.reflect.Method</span><br><span class=\"line\">  13:         63388        4503312  [I</span><br><span class=\"line\">  14:         75275        4215400  org.springframework.asm.Item</span><br><span class=\"line\">  15:         62580        4005120  org.springframework.asm.Label</span><br><span class=\"line\">  16:        132458        3178992  org.springframework.asm.Edge</span><br><span class=\"line\"></span><br><span class=\"line\">[root@wujianjun-linux ~]# jmap -histo:live 9495|grep com.yqyw</span><br><span class=\"line\"> num     #instances         #bytes  class name</span><br><span class=\"line\">----------------------------------------------</span><br><span class=\"line\">2788:             1             48  com.yqyw.user.rpc.client.UserClient</span><br><span class=\"line\">3570:             1             32  com.yqyw.pnr.sdk.client.ShopClient</span><br><span class=\"line\">3731:             1             32  com.yqyw.pnr.sdk.client.ShopClient</span><br><span class=\"line\">3842:             1             24  com.yqyw.user.rpc.client.impl.FavoriteServiceImpl</span><br></pre></td></tr></table></figure>\n<p>从以上输出可以看出目前堆内存中自己程序中的对象实例以及占用bytes，从而确定程序中哪些位置对这些对象进行创建使用且未被释放（典型的情况是将对象存入List等集合类而未被remove）。<br>也通过多次执行<code>jmap -histo:live pid &gt;mem.txt</code>将每次结果定向到不同的txt中，然后对象对比。发现对象实例的增长与占用字节的变化。</p>\n<p><strong>附 - jmap输出中class name非自定义类的说明：</strong></p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">BaseType Character</th>\n<th align=\"left\">Type</th>\n<th align=\"left\">Interpretation</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">B</td>\n<td align=\"left\">byte</td>\n<td align=\"left\">signed byte</td>\n</tr>\n<tr>\n<td align=\"left\">C</td>\n<td align=\"left\">char</td>\n<td align=\"left\">Unicode character</td>\n</tr>\n<tr>\n<td align=\"left\">D</td>\n<td align=\"left\">double</td>\n<td align=\"left\">double-precision floating-point value</td>\n</tr>\n<tr>\n<td align=\"left\">F</td>\n<td align=\"left\">float</td>\n<td align=\"left\">single-precision floating-point value</td>\n</tr>\n<tr>\n<td align=\"left\">I</td>\n<td align=\"left\">int</td>\n<td align=\"left\">integer</td>\n</tr>\n<tr>\n<td align=\"left\">J</td>\n<td align=\"left\">long</td>\n<td align=\"left\">long integer</td>\n</tr>\n<tr>\n<td align=\"left\">L;</td>\n<td align=\"left\">reference</td>\n<td align=\"left\">an instance of class</td>\n</tr>\n<tr>\n<td align=\"left\">S</td>\n<td align=\"left\">short</td>\n<td align=\"left\">signed short</td>\n</tr>\n<tr>\n<td align=\"left\">Z</td>\n<td align=\"left\">boolean</td>\n<td align=\"left\">true or false</td>\n</tr>\n<tr>\n<td align=\"left\">[</td>\n<td align=\"left\">reference</td>\n<td align=\"left\">one array dimension</td>\n</tr>\n</tbody></table>\n<hr>\n<p><em>观点仅代表自己，期待你的留言。</em></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><p>Oracle将jmap描述为一种“输出进程、核心文件、远程调试服务器的共享对象内存映射和堆内存细节”的程序。<br>通过它可以查看内存中对象实例，从而解决程序出现不正常的高内存负载、频繁无响应或内存溢出等问题。</p>\n<h2 id=\"命令安装\"><a href=\"#命令安装\" class=\"headerlink\" title=\"命令安装\"></a>命令安装</h2><ol>\n<li>Oracle JDK在安装完成后bin目录下就会发现有jmap命令。</li>\n<li>Open JDK在安装完成后需要安装openjdk-devel开发包才能得到jmap命令。<br>安装方法如下（以CentOS为例）：<br>使用 <code>yum whatprovides &#39;*/jmap&#39;</code>查包含jmap命令开发包的名称。<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@wujianjun-linux bin]# yum whatprovides &#x27;*/jmap&#x27;</span><br><span class=\"line\">Loaded plugins: fastestmirror, security</span><br><span class=\"line\">Loading mirror speeds from cached hostfile</span><br><span class=\"line\">base/filelists_db                                                                                  | 6.4 MB     00:00     </span><br><span class=\"line\">extras/filelists_db                                                                                |  38 kB     00:00     </span><br><span class=\"line\">updates/filelists_db                                                                               | 1.5 MB     00:00     </span><br><span class=\"line\">1:java-1.7.0-openjdk-devel-1.7.0.99-2.6.5.1.el6.x86_64 : OpenJDK Development Environment</span><br><span class=\"line\">Repo        : base</span><br><span class=\"line\">Matched from:</span><br><span class=\"line\">Filename    : /usr/lib/jvm/java-1.7.0-openjdk-1.7.0.99.x86_64/bin/jmap</span><br><span class=\"line\">......</span><br><span class=\"line\">.....</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n找到与jdk版本相对应的开发包进行安装<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@wujianjun-linux bin]# yum install java-1.7.0-openjdk-devel</span><br></pre></td></tr></table></figure>\n安装完成后查找命令所在目录<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@wujianjun-linux bin]# whereis jmap</span><br><span class=\"line\">jmap: /usr/bin/jmap /usr/share/man/man1/jmap.1.gz</span><br></pre></td></tr></table></figure>\n只要能显示相应目录，则表示安装成功。<h2 id=\"jmap使用\"><a href=\"#jmap使用\" class=\"headerlink\" title=\"jmap使用\"></a>jmap使用</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">root@wujianjun-linux ~]# jmap --help</span><br><span class=\"line\">Usage:</span><br><span class=\"line\">    jmap [option] &lt;pid&gt;</span><br><span class=\"line\">        (to connect to running process)</span><br><span class=\"line\">    jmap [option] &lt;executable &lt;core&gt;</span><br><span class=\"line\">        (to connect to a core file)</span><br><span class=\"line\">    jmap [option] [server_id@]&lt;remote server IP or hostname&gt;</span><br><span class=\"line\">        (to connect to remote debug server)</span><br><span class=\"line\"></span><br><span class=\"line\">where &lt;option&gt; is one of:</span><br><span class=\"line\">    &lt;none&gt;               to print same info as Solaris pmap</span><br><span class=\"line\">    -heap                to print java heap summary</span><br><span class=\"line\">    -histo[:live]        to print histogram of java object heap; if the &quot;live&quot;</span><br><span class=\"line\">                         suboption is specified, only count live objects</span><br><span class=\"line\">    -permstat            to print permanent generation statistics</span><br><span class=\"line\">    -finalizerinfo       to print information on objects awaiting finalization</span><br><span class=\"line\">    -dump:&lt;dump-options&gt; to dump java heap in hprof binary format</span><br><span class=\"line\">                         dump-options:</span><br><span class=\"line\">                           live         dump only live objects; if not specified,</span><br><span class=\"line\">                                        all objects in the heap are dumped.</span><br><span class=\"line\">                           format=b     binary format</span><br><span class=\"line\">                           file=&lt;file&gt;  dump heap to &lt;file&gt;</span><br><span class=\"line\">                         Example: jmap -dump:live,format=b,file=heap.bin &lt;pid&gt;</span><br><span class=\"line\">    -F                   force. Use with -dump:&lt;dump-options&gt; &lt;pid&gt; or -histo</span><br><span class=\"line\">                         to force a heap dump or histogram when &lt;pid&gt; does not</span><br><span class=\"line\">                         respond. The &quot;live&quot; suboption is not supported</span><br><span class=\"line\">                         in this mode.</span><br><span class=\"line\">    -h | -help           to print this help message</span><br><span class=\"line\">    -J&lt;flag&gt;             to pass &lt;flag&gt; directly to the runtime system</span><br></pre></td></tr></table></figure></li>\n</ol>\n<ul>\n<li>jmap pid #打印内存使用的摘要信息</li>\n<li>jmap –heap pid #java heap信息</li>\n<li>jmap -histo:live pid #统计对象count ，live表示在使用</li>\n<li>jmap -histo pid &gt;mem.txt #打印比较简单的各个有多少个对象占了多少内存的信息，一般重定向的文件</li>\n<li>jmap -dump:format=b,file=mem.dat pid #将内存使用的详细情况输出到mem.dat 文件<br>通过<code>jhat -port 7000 mem.dat</code>可以将mem.dat的内容以web的方式暴露到网络，访问<code>http://ip-server:7000</code>查看。</li>\n</ul>\n<p>针对内存泄漏这一问题，可以通过查看堆内存中存活对象实例及所占内存数查到对象是否一直被占用导致不能被GC回收。<br>如：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@wujianjun-linux ~]# jps |grep -v Jps</span><br><span class=\"line\">9495 Bootstrap</span><br><span class=\"line\"></span><br><span class=\"line\">[root@wujianjun-linux ~]# jmap -histo:live 9495</span><br><span class=\"line\"> num     #instances         #bytes  class name</span><br><span class=\"line\">----------------------------------------------</span><br><span class=\"line\">   1:        294149       29662584  [C</span><br><span class=\"line\">   2:        187061       27752880  &lt;constMethodKlass&gt;</span><br><span class=\"line\">   3:        187061       23955120  &lt;methodKlass&gt;</span><br><span class=\"line\">   4:         15897       19221104  &lt;constantPoolKlass&gt;</span><br><span class=\"line\">   5:         61107       13783928  [B</span><br><span class=\"line\">   6:         15897       11445056  &lt;instanceKlassKlass&gt;</span><br><span class=\"line\">   7:         13934       11267712  &lt;constantPoolCacheKlass&gt;</span><br><span class=\"line\">   8:        280651        6735624  java.lang.String</span><br><span class=\"line\">   9:        102892        5761952  org.springframework.asm.Item</span><br><span class=\"line\">  10:        234489        5627736  org.springframework.asm.Edge</span><br><span class=\"line\">  11:         84750        5424000  org.springframework.asm.Label</span><br><span class=\"line\">  12:         66211        5296880  java.lang.reflect.Method</span><br><span class=\"line\">  13:         63388        4503312  [I</span><br><span class=\"line\">  14:         75275        4215400  org.springframework.asm.Item</span><br><span class=\"line\">  15:         62580        4005120  org.springframework.asm.Label</span><br><span class=\"line\">  16:        132458        3178992  org.springframework.asm.Edge</span><br><span class=\"line\"></span><br><span class=\"line\">[root@wujianjun-linux ~]# jmap -histo:live 9495|grep com.yqyw</span><br><span class=\"line\"> num     #instances         #bytes  class name</span><br><span class=\"line\">----------------------------------------------</span><br><span class=\"line\">2788:             1             48  com.yqyw.user.rpc.client.UserClient</span><br><span class=\"line\">3570:             1             32  com.yqyw.pnr.sdk.client.ShopClient</span><br><span class=\"line\">3731:             1             32  com.yqyw.pnr.sdk.client.ShopClient</span><br><span class=\"line\">3842:             1             24  com.yqyw.user.rpc.client.impl.FavoriteServiceImpl</span><br></pre></td></tr></table></figure>\n<p>从以上输出可以看出目前堆内存中自己程序中的对象实例以及占用bytes，从而确定程序中哪些位置对这些对象进行创建使用且未被释放（典型的情况是将对象存入List等集合类而未被remove）。<br>也通过多次执行<code>jmap -histo:live pid &gt;mem.txt</code>将每次结果定向到不同的txt中，然后对象对比。发现对象实例的增长与占用字节的变化。</p>\n<p><strong>附 - jmap输出中class name非自定义类的说明：</strong></p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">BaseType Character</th>\n<th align=\"left\">Type</th>\n<th align=\"left\">Interpretation</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">B</td>\n<td align=\"left\">byte</td>\n<td align=\"left\">signed byte</td>\n</tr>\n<tr>\n<td align=\"left\">C</td>\n<td align=\"left\">char</td>\n<td align=\"left\">Unicode character</td>\n</tr>\n<tr>\n<td align=\"left\">D</td>\n<td align=\"left\">double</td>\n<td align=\"left\">double-precision floating-point value</td>\n</tr>\n<tr>\n<td align=\"left\">F</td>\n<td align=\"left\">float</td>\n<td align=\"left\">single-precision floating-point value</td>\n</tr>\n<tr>\n<td align=\"left\">I</td>\n<td align=\"left\">int</td>\n<td align=\"left\">integer</td>\n</tr>\n<tr>\n<td align=\"left\">J</td>\n<td align=\"left\">long</td>\n<td align=\"left\">long integer</td>\n</tr>\n<tr>\n<td align=\"left\">L;</td>\n<td align=\"left\">reference</td>\n<td align=\"left\">an instance of class</td>\n</tr>\n<tr>\n<td align=\"left\">S</td>\n<td align=\"left\">short</td>\n<td align=\"left\">signed short</td>\n</tr>\n<tr>\n<td align=\"left\">Z</td>\n<td align=\"left\">boolean</td>\n<td align=\"left\">true or false</td>\n</tr>\n<tr>\n<td align=\"left\">[</td>\n<td align=\"left\">reference</td>\n<td align=\"left\">one array dimension</td>\n</tr>\n</tbody></table>\n<hr>\n<p><em>观点仅代表自己，期待你的留言。</em></p>\n"},{"title":"查看jvm堆内GC情况利器 - jstat","keywords":["jstat"],"date":"2016-09-22T09:30:09.000Z","_content":"\n## 简介\njstat是JDK自带的一个轻量级小工具。全称“Java Virtual Machine statistics monitoring tool”，主要利用JVM内建的指令对Java应用程序的资源和性能进行实时的命令行的监控，包括了对Heap size和垃圾回收状况的监控。\n以命令行方式运行对系统资源占用很小，在大压力下很少影响性能。并且运行要求低，只要通过Telnet或SSH等方式远程登录到服务器所在机器，就可以进行监控。在与jstat、jstack等工具结合使用时非常方便。\n## 命令安装\n1. Oracle JDK在安装完成后bin目录下就会发现有jstat命令。\n2. Open JDK在安装完成后需要安装openjdk-devel开发包才能得到jstat命令。\n安装方法如下（以CentOS为例）：\n使用 `yum whatprovides '*/jstat'`查包含jstat命令开发包的名称。\n```\n[root@wujianjun-linux bin]# yum whatprovides '*/jstat'\nLoaded plugins: fastestmirror, security\nLoading mirror speeds from cached hostfile\nbase/filelists_db                                                                                  | 6.4 MB     00:00     \nextras/filelists_db                                                                                |  38 kB     00:00     \nupdates/filelists_db                                                                               | 1.5 MB     00:00     \n1:java-1.7.0-openjdk-devel-1.7.0.99-2.6.5.1.el6.x86_64 : OpenJDK Development Environment\nRepo        : base\nMatched from:\nFilename    : /usr/lib/jvm/java-1.7.0-openjdk-1.7.0.99.x86_64/bin/jstat\n......\n.....\n...\n```\n找到与jdk版本相对应的开发包进行安装\n```\n[root@wujianjun-linux bin]# yum install java-1.7.0-openjdk-devel\n```\n安装完成后查找命令所在目录\n```\n[root@wujianjun-linux bin]# whereis jstat\njstat: /usr/bin/jstat /usr/share/man/man1/jstat.1.gz\n```\n只要能显示相应目录，则表示安装成功。\n## jstat使用\n```\n[root@order-zhiMaoQu-com ~]# jstat --help\ninvalid argument count\nUsage: jstat -help|-options\n       jstat -<option> [-t] [-h<lines>] <vmid> [<interval> [<count>]]\n\nDefinitions:\n  <option>      An option reported by the -options option\n  <vmid>        Virtual Machine Identifier. A vmid takes the following form:\n                     <lvmid>[@<hostname>[:<port>]]\n                Where <lvmid> is the local vm identifier for the target\n                Java virtual machine, typically a process id; <hostname> is\n                the name of the host running the target Java virtual machine;\n                and <port> is the port number for the rmiregistry on the\n                target host. See the jvmstat documentation for a more complete\n                description of the Virtual Machine Identifier.\n  <lines>       Number of samples between header lines.\n  <interval>    Sampling interval. The following forms are allowed:\n                    <n>[\"ms\"|\"s\"]\n                Where <n> is an integer and the suffix specifies the units as \n                milliseconds(\"ms\") or seconds(\"s\"). The default units are \"ms\".\n  <count>       Number of samples to take before terminating.\n  -J<flag>      Pass <flag> directly to the runtime system.\n```\n__<option> 可选值如下：__\n* -gcutil: 查看gc情况\n* -class: 显示加载class的数量，及所占空间等信息\n* -compiler: 显示VM实时编译的数量等信息。\n* –gccapacity: 可以显示，VM内存中三代（young,old,perm）对象的使用和占用大小，\n    如：PGCMN显示的是最小perm的内存使用量，PGCMX显示的是perm的内存最大使用量，PGC是当前新生成的perm内存占用量，PC是但前perm内存占用量。\n    其他的可以根据这个类推，OC是old内纯的占用量。\n* -gcnew: new对象的信息\n* -gcnewcapacity: new对象的信息及其占用量\n* -gcold: old对象的信息。\n* -gcoldcapacity: old对象的信息及其占用量\n* -gcpermcapacity: perm对象的信息及其占用量\n* -printcompilation: 当前VM执行的信息\n\n__附GC显示术语解释：__\n* S0C - 年轻代中第一个survivor（幸存区）的容量 (字节)\n* S1C - 年轻代中第二个survivor（幸存区）的容量 (字节)\n* S0U - 年轻代中第一个survivor（幸存区）目前已使用空间 (字节)\n* S1U - 年轻代中第二个survivor（幸存区）目前已使用空间 (字节)\n* EC - 年轻代中Eden的容量 (字节)\n* EU - 年轻代中Eden目前已使用空间 (字节)\n* OC - Old代的容量 (字节)\n* OU - Old代目前已使用空间 (字节)\n* PC - Perm(持久代)的容量 (字节)\n* PU - Perm(持久代)目前已使用空间 (字节)\n* YGC - 从应用程序启动到采样时年轻代中gc次数\n* YGCT - 从应用程序启动到采样时年轻代中gc所用时间(s)\n* FGC - 从应用程序启动到采样时old代(全gc)gc次数\n* FGCT - 从应用程序启动到采样时old代(全gc)gc所用时间(s)\n* GCT - 从应用程序启动到采样时gc用的总时间(s)\n* NGCMN - 年轻代(young)中初始化(最小)的大小 (字节)\n* NGCMX - 年轻代(young)的最大容量 (字节)\n* NGC - 年轻代(young)中当前的容量 (字节)\n* OGCMN - old代中初始化(最小)的大小 (字节)\n* OGCMX - old代的最大容量 (字节)\n* OGC - old代当前新生成的容量 (字节)\n* PGCMN - perm代中初始化(最小)的大小 (字节)\n* PGCMX - perm代的最大容量 (字节)\n* PGC - perm代当前新生成的容量 (字节)\n* S0 - 年轻代中第一个survivor（幸存区）已使用的占当前容量百分比\n* S1 - 年轻代中第二个survivor（幸存区）已使用的占当前容量百分比\n* E - 年轻代中Eden已使用的占当前容量百分比\n* O - old代已使用的占当前容量百分比\n* P - perm代已使用的占当前容量百分比\n* S0CMX - 年轻代中第一个survivor（幸存区）的最大容量 (字节)\n* S1CMX  - 年轻代中第二个survivor（幸存区）的最大容量 (字节)\n* ECMX - 年轻代中Eden的最大容量 (字节)\n* DSS - 当前需要survivor（幸存区）的容量 (字节)（Eden区已满）\n* TT -  持有次数限制\n* MTT  -  最大持有次数限制\n\n-----\n\n*观点仅代表自己，期待你的留言。*","source":"_posts/jvm-tools-jstat.md","raw":"---\ntitle: 查看jvm堆内GC情况利器 - jstat\nkeywords: \n  - jstat\ntags:\n  - 原创\ndate: 2016-09-22 17:30:09\n---\n\n## 简介\njstat是JDK自带的一个轻量级小工具。全称“Java Virtual Machine statistics monitoring tool”，主要利用JVM内建的指令对Java应用程序的资源和性能进行实时的命令行的监控，包括了对Heap size和垃圾回收状况的监控。\n以命令行方式运行对系统资源占用很小，在大压力下很少影响性能。并且运行要求低，只要通过Telnet或SSH等方式远程登录到服务器所在机器，就可以进行监控。在与jstat、jstack等工具结合使用时非常方便。\n## 命令安装\n1. Oracle JDK在安装完成后bin目录下就会发现有jstat命令。\n2. Open JDK在安装完成后需要安装openjdk-devel开发包才能得到jstat命令。\n安装方法如下（以CentOS为例）：\n使用 `yum whatprovides '*/jstat'`查包含jstat命令开发包的名称。\n```\n[root@wujianjun-linux bin]# yum whatprovides '*/jstat'\nLoaded plugins: fastestmirror, security\nLoading mirror speeds from cached hostfile\nbase/filelists_db                                                                                  | 6.4 MB     00:00     \nextras/filelists_db                                                                                |  38 kB     00:00     \nupdates/filelists_db                                                                               | 1.5 MB     00:00     \n1:java-1.7.0-openjdk-devel-1.7.0.99-2.6.5.1.el6.x86_64 : OpenJDK Development Environment\nRepo        : base\nMatched from:\nFilename    : /usr/lib/jvm/java-1.7.0-openjdk-1.7.0.99.x86_64/bin/jstat\n......\n.....\n...\n```\n找到与jdk版本相对应的开发包进行安装\n```\n[root@wujianjun-linux bin]# yum install java-1.7.0-openjdk-devel\n```\n安装完成后查找命令所在目录\n```\n[root@wujianjun-linux bin]# whereis jstat\njstat: /usr/bin/jstat /usr/share/man/man1/jstat.1.gz\n```\n只要能显示相应目录，则表示安装成功。\n## jstat使用\n```\n[root@order-zhiMaoQu-com ~]# jstat --help\ninvalid argument count\nUsage: jstat -help|-options\n       jstat -<option> [-t] [-h<lines>] <vmid> [<interval> [<count>]]\n\nDefinitions:\n  <option>      An option reported by the -options option\n  <vmid>        Virtual Machine Identifier. A vmid takes the following form:\n                     <lvmid>[@<hostname>[:<port>]]\n                Where <lvmid> is the local vm identifier for the target\n                Java virtual machine, typically a process id; <hostname> is\n                the name of the host running the target Java virtual machine;\n                and <port> is the port number for the rmiregistry on the\n                target host. See the jvmstat documentation for a more complete\n                description of the Virtual Machine Identifier.\n  <lines>       Number of samples between header lines.\n  <interval>    Sampling interval. The following forms are allowed:\n                    <n>[\"ms\"|\"s\"]\n                Where <n> is an integer and the suffix specifies the units as \n                milliseconds(\"ms\") or seconds(\"s\"). The default units are \"ms\".\n  <count>       Number of samples to take before terminating.\n  -J<flag>      Pass <flag> directly to the runtime system.\n```\n__<option> 可选值如下：__\n* -gcutil: 查看gc情况\n* -class: 显示加载class的数量，及所占空间等信息\n* -compiler: 显示VM实时编译的数量等信息。\n* –gccapacity: 可以显示，VM内存中三代（young,old,perm）对象的使用和占用大小，\n    如：PGCMN显示的是最小perm的内存使用量，PGCMX显示的是perm的内存最大使用量，PGC是当前新生成的perm内存占用量，PC是但前perm内存占用量。\n    其他的可以根据这个类推，OC是old内纯的占用量。\n* -gcnew: new对象的信息\n* -gcnewcapacity: new对象的信息及其占用量\n* -gcold: old对象的信息。\n* -gcoldcapacity: old对象的信息及其占用量\n* -gcpermcapacity: perm对象的信息及其占用量\n* -printcompilation: 当前VM执行的信息\n\n__附GC显示术语解释：__\n* S0C - 年轻代中第一个survivor（幸存区）的容量 (字节)\n* S1C - 年轻代中第二个survivor（幸存区）的容量 (字节)\n* S0U - 年轻代中第一个survivor（幸存区）目前已使用空间 (字节)\n* S1U - 年轻代中第二个survivor（幸存区）目前已使用空间 (字节)\n* EC - 年轻代中Eden的容量 (字节)\n* EU - 年轻代中Eden目前已使用空间 (字节)\n* OC - Old代的容量 (字节)\n* OU - Old代目前已使用空间 (字节)\n* PC - Perm(持久代)的容量 (字节)\n* PU - Perm(持久代)目前已使用空间 (字节)\n* YGC - 从应用程序启动到采样时年轻代中gc次数\n* YGCT - 从应用程序启动到采样时年轻代中gc所用时间(s)\n* FGC - 从应用程序启动到采样时old代(全gc)gc次数\n* FGCT - 从应用程序启动到采样时old代(全gc)gc所用时间(s)\n* GCT - 从应用程序启动到采样时gc用的总时间(s)\n* NGCMN - 年轻代(young)中初始化(最小)的大小 (字节)\n* NGCMX - 年轻代(young)的最大容量 (字节)\n* NGC - 年轻代(young)中当前的容量 (字节)\n* OGCMN - old代中初始化(最小)的大小 (字节)\n* OGCMX - old代的最大容量 (字节)\n* OGC - old代当前新生成的容量 (字节)\n* PGCMN - perm代中初始化(最小)的大小 (字节)\n* PGCMX - perm代的最大容量 (字节)\n* PGC - perm代当前新生成的容量 (字节)\n* S0 - 年轻代中第一个survivor（幸存区）已使用的占当前容量百分比\n* S1 - 年轻代中第二个survivor（幸存区）已使用的占当前容量百分比\n* E - 年轻代中Eden已使用的占当前容量百分比\n* O - old代已使用的占当前容量百分比\n* P - perm代已使用的占当前容量百分比\n* S0CMX - 年轻代中第一个survivor（幸存区）的最大容量 (字节)\n* S1CMX  - 年轻代中第二个survivor（幸存区）的最大容量 (字节)\n* ECMX - 年轻代中Eden的最大容量 (字节)\n* DSS - 当前需要survivor（幸存区）的容量 (字节)（Eden区已满）\n* TT -  持有次数限制\n* MTT  -  最大持有次数限制\n\n-----\n\n*观点仅代表自己，期待你的留言。*","slug":"jvm-tools-jstat","published":1,"updated":"2021-08-31T14:23:11.545Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cku52dynd002dbbinhxvwa8t3","content":"<h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><p>jstat是JDK自带的一个轻量级小工具。全称“Java Virtual Machine statistics monitoring tool”，主要利用JVM内建的指令对Java应用程序的资源和性能进行实时的命令行的监控，包括了对Heap size和垃圾回收状况的监控。<br>以命令行方式运行对系统资源占用很小，在大压力下很少影响性能。并且运行要求低，只要通过Telnet或SSH等方式远程登录到服务器所在机器，就可以进行监控。在与jstat、jstack等工具结合使用时非常方便。</p>\n<h2 id=\"命令安装\"><a href=\"#命令安装\" class=\"headerlink\" title=\"命令安装\"></a>命令安装</h2><ol>\n<li>Oracle JDK在安装完成后bin目录下就会发现有jstat命令。</li>\n<li>Open JDK在安装完成后需要安装openjdk-devel开发包才能得到jstat命令。<br>安装方法如下（以CentOS为例）：<br>使用 <code>yum whatprovides &#39;*/jstat&#39;</code>查包含jstat命令开发包的名称。<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@wujianjun-linux bin]# yum whatprovides &#x27;*/jstat&#x27;</span><br><span class=\"line\">Loaded plugins: fastestmirror, security</span><br><span class=\"line\">Loading mirror speeds from cached hostfile</span><br><span class=\"line\">base/filelists_db                                                                                  | 6.4 MB     00:00     </span><br><span class=\"line\">extras/filelists_db                                                                                |  38 kB     00:00     </span><br><span class=\"line\">updates/filelists_db                                                                               | 1.5 MB     00:00     </span><br><span class=\"line\">1:java-1.7.0-openjdk-devel-1.7.0.99-2.6.5.1.el6.x86_64 : OpenJDK Development Environment</span><br><span class=\"line\">Repo        : base</span><br><span class=\"line\">Matched from:</span><br><span class=\"line\">Filename    : /usr/lib/jvm/java-1.7.0-openjdk-1.7.0.99.x86_64/bin/jstat</span><br><span class=\"line\">......</span><br><span class=\"line\">.....</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n找到与jdk版本相对应的开发包进行安装<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@wujianjun-linux bin]# yum install java-1.7.0-openjdk-devel</span><br></pre></td></tr></table></figure>\n安装完成后查找命令所在目录<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@wujianjun-linux bin]# whereis jstat</span><br><span class=\"line\">jstat: /usr/bin/jstat /usr/share/man/man1/jstat.1.gz</span><br></pre></td></tr></table></figure>\n只要能显示相应目录，则表示安装成功。<h2 id=\"jstat使用\"><a href=\"#jstat使用\" class=\"headerlink\" title=\"jstat使用\"></a>jstat使用</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@order-zhiMaoQu-com ~]# jstat --help</span><br><span class=\"line\">invalid argument count</span><br><span class=\"line\">Usage: jstat -help|-options</span><br><span class=\"line\">       jstat -&lt;option&gt; [-t] [-h&lt;lines&gt;] &lt;vmid&gt; [&lt;interval&gt; [&lt;count&gt;]]</span><br><span class=\"line\"></span><br><span class=\"line\">Definitions:</span><br><span class=\"line\">  &lt;option&gt;      An option reported by the -options option</span><br><span class=\"line\">  &lt;vmid&gt;        Virtual Machine Identifier. A vmid takes the following form:</span><br><span class=\"line\">                     &lt;lvmid&gt;[@&lt;hostname&gt;[:&lt;port&gt;]]</span><br><span class=\"line\">                Where &lt;lvmid&gt; is the local vm identifier for the target</span><br><span class=\"line\">                Java virtual machine, typically a process id; &lt;hostname&gt; is</span><br><span class=\"line\">                the name of the host running the target Java virtual machine;</span><br><span class=\"line\">                and &lt;port&gt; is the port number for the rmiregistry on the</span><br><span class=\"line\">                target host. See the jvmstat documentation for a more complete</span><br><span class=\"line\">                description of the Virtual Machine Identifier.</span><br><span class=\"line\">  &lt;lines&gt;       Number of samples between header lines.</span><br><span class=\"line\">  &lt;interval&gt;    Sampling interval. The following forms are allowed:</span><br><span class=\"line\">                    &lt;n&gt;[&quot;ms&quot;|&quot;s&quot;]</span><br><span class=\"line\">                Where &lt;n&gt; is an integer and the suffix specifies the units as </span><br><span class=\"line\">                milliseconds(&quot;ms&quot;) or seconds(&quot;s&quot;). The default units are &quot;ms&quot;.</span><br><span class=\"line\">  &lt;count&gt;       Number of samples to take before terminating.</span><br><span class=\"line\">  -J&lt;flag&gt;      Pass &lt;flag&gt; directly to the runtime system.</span><br></pre></td></tr></table></figure>\n<strong><option> 可选值如下：</strong></li>\n</ol>\n<ul>\n<li>-gcutil: 查看gc情况</li>\n<li>-class: 显示加载class的数量，及所占空间等信息</li>\n<li>-compiler: 显示VM实时编译的数量等信息。</li>\n<li>–gccapacity: 可以显示，VM内存中三代（young,old,perm）对象的使用和占用大小，<br>  如：PGCMN显示的是最小perm的内存使用量，PGCMX显示的是perm的内存最大使用量，PGC是当前新生成的perm内存占用量，PC是但前perm内存占用量。<br>  其他的可以根据这个类推，OC是old内纯的占用量。</li>\n<li>-gcnew: new对象的信息</li>\n<li>-gcnewcapacity: new对象的信息及其占用量</li>\n<li>-gcold: old对象的信息。</li>\n<li>-gcoldcapacity: old对象的信息及其占用量</li>\n<li>-gcpermcapacity: perm对象的信息及其占用量</li>\n<li>-printcompilation: 当前VM执行的信息</li>\n</ul>\n<p><strong>附GC显示术语解释：</strong></p>\n<ul>\n<li>S0C - 年轻代中第一个survivor（幸存区）的容量 (字节)</li>\n<li>S1C - 年轻代中第二个survivor（幸存区）的容量 (字节)</li>\n<li>S0U - 年轻代中第一个survivor（幸存区）目前已使用空间 (字节)</li>\n<li>S1U - 年轻代中第二个survivor（幸存区）目前已使用空间 (字节)</li>\n<li>EC - 年轻代中Eden的容量 (字节)</li>\n<li>EU - 年轻代中Eden目前已使用空间 (字节)</li>\n<li>OC - Old代的容量 (字节)</li>\n<li>OU - Old代目前已使用空间 (字节)</li>\n<li>PC - Perm(持久代)的容量 (字节)</li>\n<li>PU - Perm(持久代)目前已使用空间 (字节)</li>\n<li>YGC - 从应用程序启动到采样时年轻代中gc次数</li>\n<li>YGCT - 从应用程序启动到采样时年轻代中gc所用时间(s)</li>\n<li>FGC - 从应用程序启动到采样时old代(全gc)gc次数</li>\n<li>FGCT - 从应用程序启动到采样时old代(全gc)gc所用时间(s)</li>\n<li>GCT - 从应用程序启动到采样时gc用的总时间(s)</li>\n<li>NGCMN - 年轻代(young)中初始化(最小)的大小 (字节)</li>\n<li>NGCMX - 年轻代(young)的最大容量 (字节)</li>\n<li>NGC - 年轻代(young)中当前的容量 (字节)</li>\n<li>OGCMN - old代中初始化(最小)的大小 (字节)</li>\n<li>OGCMX - old代的最大容量 (字节)</li>\n<li>OGC - old代当前新生成的容量 (字节)</li>\n<li>PGCMN - perm代中初始化(最小)的大小 (字节)</li>\n<li>PGCMX - perm代的最大容量 (字节)</li>\n<li>PGC - perm代当前新生成的容量 (字节)</li>\n<li>S0 - 年轻代中第一个survivor（幸存区）已使用的占当前容量百分比</li>\n<li>S1 - 年轻代中第二个survivor（幸存区）已使用的占当前容量百分比</li>\n<li>E - 年轻代中Eden已使用的占当前容量百分比</li>\n<li>O - old代已使用的占当前容量百分比</li>\n<li>P - perm代已使用的占当前容量百分比</li>\n<li>S0CMX - 年轻代中第一个survivor（幸存区）的最大容量 (字节)</li>\n<li>S1CMX  - 年轻代中第二个survivor（幸存区）的最大容量 (字节)</li>\n<li>ECMX - 年轻代中Eden的最大容量 (字节)</li>\n<li>DSS - 当前需要survivor（幸存区）的容量 (字节)（Eden区已满）</li>\n<li>TT -  持有次数限制</li>\n<li>MTT  -  最大持有次数限制</li>\n</ul>\n<hr>\n<p><em>观点仅代表自己，期待你的留言。</em></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><p>jstat是JDK自带的一个轻量级小工具。全称“Java Virtual Machine statistics monitoring tool”，主要利用JVM内建的指令对Java应用程序的资源和性能进行实时的命令行的监控，包括了对Heap size和垃圾回收状况的监控。<br>以命令行方式运行对系统资源占用很小，在大压力下很少影响性能。并且运行要求低，只要通过Telnet或SSH等方式远程登录到服务器所在机器，就可以进行监控。在与jstat、jstack等工具结合使用时非常方便。</p>\n<h2 id=\"命令安装\"><a href=\"#命令安装\" class=\"headerlink\" title=\"命令安装\"></a>命令安装</h2><ol>\n<li>Oracle JDK在安装完成后bin目录下就会发现有jstat命令。</li>\n<li>Open JDK在安装完成后需要安装openjdk-devel开发包才能得到jstat命令。<br>安装方法如下（以CentOS为例）：<br>使用 <code>yum whatprovides &#39;*/jstat&#39;</code>查包含jstat命令开发包的名称。<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@wujianjun-linux bin]# yum whatprovides &#x27;*/jstat&#x27;</span><br><span class=\"line\">Loaded plugins: fastestmirror, security</span><br><span class=\"line\">Loading mirror speeds from cached hostfile</span><br><span class=\"line\">base/filelists_db                                                                                  | 6.4 MB     00:00     </span><br><span class=\"line\">extras/filelists_db                                                                                |  38 kB     00:00     </span><br><span class=\"line\">updates/filelists_db                                                                               | 1.5 MB     00:00     </span><br><span class=\"line\">1:java-1.7.0-openjdk-devel-1.7.0.99-2.6.5.1.el6.x86_64 : OpenJDK Development Environment</span><br><span class=\"line\">Repo        : base</span><br><span class=\"line\">Matched from:</span><br><span class=\"line\">Filename    : /usr/lib/jvm/java-1.7.0-openjdk-1.7.0.99.x86_64/bin/jstat</span><br><span class=\"line\">......</span><br><span class=\"line\">.....</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n找到与jdk版本相对应的开发包进行安装<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@wujianjun-linux bin]# yum install java-1.7.0-openjdk-devel</span><br></pre></td></tr></table></figure>\n安装完成后查找命令所在目录<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@wujianjun-linux bin]# whereis jstat</span><br><span class=\"line\">jstat: /usr/bin/jstat /usr/share/man/man1/jstat.1.gz</span><br></pre></td></tr></table></figure>\n只要能显示相应目录，则表示安装成功。<h2 id=\"jstat使用\"><a href=\"#jstat使用\" class=\"headerlink\" title=\"jstat使用\"></a>jstat使用</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@order-zhiMaoQu-com ~]# jstat --help</span><br><span class=\"line\">invalid argument count</span><br><span class=\"line\">Usage: jstat -help|-options</span><br><span class=\"line\">       jstat -&lt;option&gt; [-t] [-h&lt;lines&gt;] &lt;vmid&gt; [&lt;interval&gt; [&lt;count&gt;]]</span><br><span class=\"line\"></span><br><span class=\"line\">Definitions:</span><br><span class=\"line\">  &lt;option&gt;      An option reported by the -options option</span><br><span class=\"line\">  &lt;vmid&gt;        Virtual Machine Identifier. A vmid takes the following form:</span><br><span class=\"line\">                     &lt;lvmid&gt;[@&lt;hostname&gt;[:&lt;port&gt;]]</span><br><span class=\"line\">                Where &lt;lvmid&gt; is the local vm identifier for the target</span><br><span class=\"line\">                Java virtual machine, typically a process id; &lt;hostname&gt; is</span><br><span class=\"line\">                the name of the host running the target Java virtual machine;</span><br><span class=\"line\">                and &lt;port&gt; is the port number for the rmiregistry on the</span><br><span class=\"line\">                target host. See the jvmstat documentation for a more complete</span><br><span class=\"line\">                description of the Virtual Machine Identifier.</span><br><span class=\"line\">  &lt;lines&gt;       Number of samples between header lines.</span><br><span class=\"line\">  &lt;interval&gt;    Sampling interval. The following forms are allowed:</span><br><span class=\"line\">                    &lt;n&gt;[&quot;ms&quot;|&quot;s&quot;]</span><br><span class=\"line\">                Where &lt;n&gt; is an integer and the suffix specifies the units as </span><br><span class=\"line\">                milliseconds(&quot;ms&quot;) or seconds(&quot;s&quot;). The default units are &quot;ms&quot;.</span><br><span class=\"line\">  &lt;count&gt;       Number of samples to take before terminating.</span><br><span class=\"line\">  -J&lt;flag&gt;      Pass &lt;flag&gt; directly to the runtime system.</span><br></pre></td></tr></table></figure>\n<strong><option> 可选值如下：</strong></li>\n</ol>\n<ul>\n<li>-gcutil: 查看gc情况</li>\n<li>-class: 显示加载class的数量，及所占空间等信息</li>\n<li>-compiler: 显示VM实时编译的数量等信息。</li>\n<li>–gccapacity: 可以显示，VM内存中三代（young,old,perm）对象的使用和占用大小，<br>  如：PGCMN显示的是最小perm的内存使用量，PGCMX显示的是perm的内存最大使用量，PGC是当前新生成的perm内存占用量，PC是但前perm内存占用量。<br>  其他的可以根据这个类推，OC是old内纯的占用量。</li>\n<li>-gcnew: new对象的信息</li>\n<li>-gcnewcapacity: new对象的信息及其占用量</li>\n<li>-gcold: old对象的信息。</li>\n<li>-gcoldcapacity: old对象的信息及其占用量</li>\n<li>-gcpermcapacity: perm对象的信息及其占用量</li>\n<li>-printcompilation: 当前VM执行的信息</li>\n</ul>\n<p><strong>附GC显示术语解释：</strong></p>\n<ul>\n<li>S0C - 年轻代中第一个survivor（幸存区）的容量 (字节)</li>\n<li>S1C - 年轻代中第二个survivor（幸存区）的容量 (字节)</li>\n<li>S0U - 年轻代中第一个survivor（幸存区）目前已使用空间 (字节)</li>\n<li>S1U - 年轻代中第二个survivor（幸存区）目前已使用空间 (字节)</li>\n<li>EC - 年轻代中Eden的容量 (字节)</li>\n<li>EU - 年轻代中Eden目前已使用空间 (字节)</li>\n<li>OC - Old代的容量 (字节)</li>\n<li>OU - Old代目前已使用空间 (字节)</li>\n<li>PC - Perm(持久代)的容量 (字节)</li>\n<li>PU - Perm(持久代)目前已使用空间 (字节)</li>\n<li>YGC - 从应用程序启动到采样时年轻代中gc次数</li>\n<li>YGCT - 从应用程序启动到采样时年轻代中gc所用时间(s)</li>\n<li>FGC - 从应用程序启动到采样时old代(全gc)gc次数</li>\n<li>FGCT - 从应用程序启动到采样时old代(全gc)gc所用时间(s)</li>\n<li>GCT - 从应用程序启动到采样时gc用的总时间(s)</li>\n<li>NGCMN - 年轻代(young)中初始化(最小)的大小 (字节)</li>\n<li>NGCMX - 年轻代(young)的最大容量 (字节)</li>\n<li>NGC - 年轻代(young)中当前的容量 (字节)</li>\n<li>OGCMN - old代中初始化(最小)的大小 (字节)</li>\n<li>OGCMX - old代的最大容量 (字节)</li>\n<li>OGC - old代当前新生成的容量 (字节)</li>\n<li>PGCMN - perm代中初始化(最小)的大小 (字节)</li>\n<li>PGCMX - perm代的最大容量 (字节)</li>\n<li>PGC - perm代当前新生成的容量 (字节)</li>\n<li>S0 - 年轻代中第一个survivor（幸存区）已使用的占当前容量百分比</li>\n<li>S1 - 年轻代中第二个survivor（幸存区）已使用的占当前容量百分比</li>\n<li>E - 年轻代中Eden已使用的占当前容量百分比</li>\n<li>O - old代已使用的占当前容量百分比</li>\n<li>P - perm代已使用的占当前容量百分比</li>\n<li>S0CMX - 年轻代中第一个survivor（幸存区）的最大容量 (字节)</li>\n<li>S1CMX  - 年轻代中第二个survivor（幸存区）的最大容量 (字节)</li>\n<li>ECMX - 年轻代中Eden的最大容量 (字节)</li>\n<li>DSS - 当前需要survivor（幸存区）的容量 (字节)（Eden区已满）</li>\n<li>TT -  持有次数限制</li>\n<li>MTT  -  最大持有次数限制</li>\n</ul>\n<hr>\n<p><em>观点仅代表自己，期待你的留言。</em></p>\n"},{"title":"Linux开机自动启动Tomcat应用","date":"2016-10-09T10:43:51.000Z","_content":"\n## 前言\n刚过国庆长假，工作机房断电，重回工作岗位发现N多的应用需要手动启动。感觉烦燥？\nso.. 配置linux开机自启动\n\n## 配置\n在_/etc/rc.local_文件末尾增加以下内容\n```\n#!/bin/sh\n#\n# This script will be executed *after* all the other init scripts.\n# You can put your own initialization stuff in here if you don't\n# want to do the full Sys V style init stuff.\n\nO_Path=`pwd`\ncd /myapps/servers/apache-tomcat-6.0.43/bin/\nsh startup.sh\ncd $O_Path\n\n```\n\n__需要注意以下几点：__\n* 检查startup.sh是否已授执行权限，如果没有，执行`chmod +x /myapps/servers/apache-tomcat-6.0.43/bin/startup.sh`\n* 所需要执行的shell文件不能带参数。\n\n\n经过以上配置则可以通过`sudo reboot`进行验证。当Linux重启成功后，可通过__/var/log/boot.log__来查看开机时的日志输出。\n\n## 其它\n`who -r` 查看开机级别\n\n```\nwho --help\n用法：who [选项]... [ 文件 | 参数1 参数2 ]\n显示当前已登录的用户信息。\n\n  -a, --all\t\t等于-b -d --login -p -r -t -T -u 选项的组合\n  -b, --boot\t\t上次系统启动时间\n  -d, --dead\t\t显示已死的进程\n  -H, --heading\t输出头部的标题列\n  -l，--login\t\t显示系统登录进程\n      --lookup\t\t尝试通过 DNS 查验主机名\n  -m\t\t\t只面对和标准输入有直接交互的主机和用户\n  -p, --process\t显示由 init 进程衍生的活动进程\n  -q, --count\t\t列出所有已登录用户的登录名与用户数量\n  -r, --runlevel\t显示当前的运行级别\n  -s, --short\t\t只显示名称、线路和时间(默认)\n  -T, -w, --mesg\t用+，- 或 ? 标注用户消息状态\n  -u, --users\t\t列出已登录的用户\n      --message\t等于-T\n      --writable\t等于-T\n      --help\t\t显示此帮助信息并退出\n      --version\t\t显示版本信息并退出\n```\n\n-----\n\n*观点仅代表自己，期待你的留言。*\n","source":"_posts/linux-autostart.md","raw":"---\ntitle: Linux开机自动启动Tomcat应用\ntags:\n  - 原创\ndate: 2016-10-09 18:43:51\n---\n\n## 前言\n刚过国庆长假，工作机房断电，重回工作岗位发现N多的应用需要手动启动。感觉烦燥？\nso.. 配置linux开机自启动\n\n## 配置\n在_/etc/rc.local_文件末尾增加以下内容\n```\n#!/bin/sh\n#\n# This script will be executed *after* all the other init scripts.\n# You can put your own initialization stuff in here if you don't\n# want to do the full Sys V style init stuff.\n\nO_Path=`pwd`\ncd /myapps/servers/apache-tomcat-6.0.43/bin/\nsh startup.sh\ncd $O_Path\n\n```\n\n__需要注意以下几点：__\n* 检查startup.sh是否已授执行权限，如果没有，执行`chmod +x /myapps/servers/apache-tomcat-6.0.43/bin/startup.sh`\n* 所需要执行的shell文件不能带参数。\n\n\n经过以上配置则可以通过`sudo reboot`进行验证。当Linux重启成功后，可通过__/var/log/boot.log__来查看开机时的日志输出。\n\n## 其它\n`who -r` 查看开机级别\n\n```\nwho --help\n用法：who [选项]... [ 文件 | 参数1 参数2 ]\n显示当前已登录的用户信息。\n\n  -a, --all\t\t等于-b -d --login -p -r -t -T -u 选项的组合\n  -b, --boot\t\t上次系统启动时间\n  -d, --dead\t\t显示已死的进程\n  -H, --heading\t输出头部的标题列\n  -l，--login\t\t显示系统登录进程\n      --lookup\t\t尝试通过 DNS 查验主机名\n  -m\t\t\t只面对和标准输入有直接交互的主机和用户\n  -p, --process\t显示由 init 进程衍生的活动进程\n  -q, --count\t\t列出所有已登录用户的登录名与用户数量\n  -r, --runlevel\t显示当前的运行级别\n  -s, --short\t\t只显示名称、线路和时间(默认)\n  -T, -w, --mesg\t用+，- 或 ? 标注用户消息状态\n  -u, --users\t\t列出已登录的用户\n      --message\t等于-T\n      --writable\t等于-T\n      --help\t\t显示此帮助信息并退出\n      --version\t\t显示版本信息并退出\n```\n\n-----\n\n*观点仅代表自己，期待你的留言。*\n","slug":"linux-autostart","published":1,"updated":"2021-08-31T14:23:11.545Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cku52dyne002fbbin0dtsa54v","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>刚过国庆长假，工作机房断电，重回工作岗位发现N多的应用需要手动启动。感觉烦燥？<br>so.. 配置linux开机自启动</p>\n<h2 id=\"配置\"><a href=\"#配置\" class=\"headerlink\" title=\"配置\"></a>配置</h2><p>在_/etc/rc.local_文件末尾增加以下内容</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#!/bin/sh</span><br><span class=\"line\">#</span><br><span class=\"line\"># This script will be executed *after* all the other init scripts.</span><br><span class=\"line\"># You can put your own initialization stuff in here if you don&#x27;t</span><br><span class=\"line\"># want to do the full Sys V style init stuff.</span><br><span class=\"line\"></span><br><span class=\"line\">O_Path=`pwd`</span><br><span class=\"line\">cd /myapps/servers/apache-tomcat-6.0.43/bin/</span><br><span class=\"line\">sh startup.sh</span><br><span class=\"line\">cd $O_Path</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p><strong>需要注意以下几点：</strong></p>\n<ul>\n<li>检查startup.sh是否已授执行权限，如果没有，执行<code>chmod +x /myapps/servers/apache-tomcat-6.0.43/bin/startup.sh</code></li>\n<li>所需要执行的shell文件不能带参数。</li>\n</ul>\n<p>经过以上配置则可以通过<code>sudo reboot</code>进行验证。当Linux重启成功后，可通过__/var/log/boot.log__来查看开机时的日志输出。</p>\n<h2 id=\"其它\"><a href=\"#其它\" class=\"headerlink\" title=\"其它\"></a>其它</h2><p><code>who -r</code> 查看开机级别</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">who --help</span><br><span class=\"line\">用法：who [选项]... [ 文件 | 参数1 参数2 ]</span><br><span class=\"line\">显示当前已登录的用户信息。</span><br><span class=\"line\"></span><br><span class=\"line\">  -a, --all\t\t等于-b -d --login -p -r -t -T -u 选项的组合</span><br><span class=\"line\">  -b, --boot\t\t上次系统启动时间</span><br><span class=\"line\">  -d, --dead\t\t显示已死的进程</span><br><span class=\"line\">  -H, --heading\t输出头部的标题列</span><br><span class=\"line\">  -l，--login\t\t显示系统登录进程</span><br><span class=\"line\">      --lookup\t\t尝试通过 DNS 查验主机名</span><br><span class=\"line\">  -m\t\t\t只面对和标准输入有直接交互的主机和用户</span><br><span class=\"line\">  -p, --process\t显示由 init 进程衍生的活动进程</span><br><span class=\"line\">  -q, --count\t\t列出所有已登录用户的登录名与用户数量</span><br><span class=\"line\">  -r, --runlevel\t显示当前的运行级别</span><br><span class=\"line\">  -s, --short\t\t只显示名称、线路和时间(默认)</span><br><span class=\"line\">  -T, -w, --mesg\t用+，- 或 ? 标注用户消息状态</span><br><span class=\"line\">  -u, --users\t\t列出已登录的用户</span><br><span class=\"line\">      --message\t等于-T</span><br><span class=\"line\">      --writable\t等于-T</span><br><span class=\"line\">      --help\t\t显示此帮助信息并退出</span><br><span class=\"line\">      --version\t\t显示版本信息并退出</span><br></pre></td></tr></table></figure>\n\n<hr>\n<p><em>观点仅代表自己，期待你的留言。</em></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>刚过国庆长假，工作机房断电，重回工作岗位发现N多的应用需要手动启动。感觉烦燥？<br>so.. 配置linux开机自启动</p>\n<h2 id=\"配置\"><a href=\"#配置\" class=\"headerlink\" title=\"配置\"></a>配置</h2><p>在_/etc/rc.local_文件末尾增加以下内容</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#!/bin/sh</span><br><span class=\"line\">#</span><br><span class=\"line\"># This script will be executed *after* all the other init scripts.</span><br><span class=\"line\"># You can put your own initialization stuff in here if you don&#x27;t</span><br><span class=\"line\"># want to do the full Sys V style init stuff.</span><br><span class=\"line\"></span><br><span class=\"line\">O_Path=`pwd`</span><br><span class=\"line\">cd /myapps/servers/apache-tomcat-6.0.43/bin/</span><br><span class=\"line\">sh startup.sh</span><br><span class=\"line\">cd $O_Path</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p><strong>需要注意以下几点：</strong></p>\n<ul>\n<li>检查startup.sh是否已授执行权限，如果没有，执行<code>chmod +x /myapps/servers/apache-tomcat-6.0.43/bin/startup.sh</code></li>\n<li>所需要执行的shell文件不能带参数。</li>\n</ul>\n<p>经过以上配置则可以通过<code>sudo reboot</code>进行验证。当Linux重启成功后，可通过__/var/log/boot.log__来查看开机时的日志输出。</p>\n<h2 id=\"其它\"><a href=\"#其它\" class=\"headerlink\" title=\"其它\"></a>其它</h2><p><code>who -r</code> 查看开机级别</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">who --help</span><br><span class=\"line\">用法：who [选项]... [ 文件 | 参数1 参数2 ]</span><br><span class=\"line\">显示当前已登录的用户信息。</span><br><span class=\"line\"></span><br><span class=\"line\">  -a, --all\t\t等于-b -d --login -p -r -t -T -u 选项的组合</span><br><span class=\"line\">  -b, --boot\t\t上次系统启动时间</span><br><span class=\"line\">  -d, --dead\t\t显示已死的进程</span><br><span class=\"line\">  -H, --heading\t输出头部的标题列</span><br><span class=\"line\">  -l，--login\t\t显示系统登录进程</span><br><span class=\"line\">      --lookup\t\t尝试通过 DNS 查验主机名</span><br><span class=\"line\">  -m\t\t\t只面对和标准输入有直接交互的主机和用户</span><br><span class=\"line\">  -p, --process\t显示由 init 进程衍生的活动进程</span><br><span class=\"line\">  -q, --count\t\t列出所有已登录用户的登录名与用户数量</span><br><span class=\"line\">  -r, --runlevel\t显示当前的运行级别</span><br><span class=\"line\">  -s, --short\t\t只显示名称、线路和时间(默认)</span><br><span class=\"line\">  -T, -w, --mesg\t用+，- 或 ? 标注用户消息状态</span><br><span class=\"line\">  -u, --users\t\t列出已登录的用户</span><br><span class=\"line\">      --message\t等于-T</span><br><span class=\"line\">      --writable\t等于-T</span><br><span class=\"line\">      --help\t\t显示此帮助信息并退出</span><br><span class=\"line\">      --version\t\t显示版本信息并退出</span><br></pre></td></tr></table></figure>\n\n<hr>\n<p><em>观点仅代表自己，期待你的留言。</em></p>\n"},{"title":"Linux常用命令备注（nslookup,find,grep,sed,awk）","keywords":["nslookup","find","grep","sed","awk"],"date":"2018-09-10T07:09:20.000Z","_content":"\n## nslookup 指定DNS服务器解析\n```bash\nwujianjun@smzc ~ $ nslookup m.vvip-u.com 10.28.17.101\nServer:\t\t10.28.17.101\nAddress:\t10.28.17.101#53\n\nName:\tm.vvip-u.com\nAddress: 10.28.17.80\n\nwujianjun@smzc ~ $ nslookup m.vvip-u.com\nServer:\t\t127.0.1.1\nAddress:\t127.0.1.1#53\n\nNon-authoritative answer:\nName:\tm.vvip-u.com\nAddress: 120.77.124.39\n```\n## BIND 局域网DNS程序\n\nhttps://www.isc.org/downloads/bind/\n\n## find包含某关键字的文件内容\n```bash\nwujianjun@smzc ~ $ find /smapp/logs -name “*” | xargs grep “keywords”\n```\n\n```bash\nwujianjun@smzc ~ $ grep -nR \"keywords\" /smapp/logs\n```\n\ngrep + RegExp (提取行首不是abc的行)\n```bash\nwujianjun@smzc ~ $ grep “^[^abc]” /smapp/logs\n```\n\n## 文本替换\n```bash\nwujianjun@smzc ~ $ sed -n ‘s/oldk/newk/g’ file\n```\n\n先删除1到3行，然后用bb替换aa；\n```bash\nwujianjun@smzc ~ $ sed -e ’1,3d’ -e ‘s/aa/bb/g’ file\n```\n\n## 文本处理\n打印所有内容行(相当于cat)\n```bash\nwujianjun@smzc ~ $ awk '{print $0}' result.txt\n18100000011 - \"status\":\"SUCCESS\"\n18100000012 - \"status\":\"SUCCESS\"\n18100000013 - \"status\":\"SUCCESS\"\n18100000014 - \"status\":\"SUCCESS\"\n```\n\n按`空格`分隔逐行内容并打印第一个内容\n```bash\nwujianjun@smzc ~ $ awk '{print $1}' result.txt\n18100000011\n18100000012\n18100000013\n18100000014\n```\n\n-----\n\n*观点仅代表自己，期待你的留言。*\n","source":"_posts/linux-cmd-notes.md","raw":"---\ntitle: Linux常用命令备注（nslookup,find,grep,sed,awk）\ntags:\n  - 原创\nkeywords:\n  - nslookup\n  - find\n  - grep\n  - sed\n  - awk\n\ndate: 2018-09-10 15:09:20\n---\n\n## nslookup 指定DNS服务器解析\n```bash\nwujianjun@smzc ~ $ nslookup m.vvip-u.com 10.28.17.101\nServer:\t\t10.28.17.101\nAddress:\t10.28.17.101#53\n\nName:\tm.vvip-u.com\nAddress: 10.28.17.80\n\nwujianjun@smzc ~ $ nslookup m.vvip-u.com\nServer:\t\t127.0.1.1\nAddress:\t127.0.1.1#53\n\nNon-authoritative answer:\nName:\tm.vvip-u.com\nAddress: 120.77.124.39\n```\n## BIND 局域网DNS程序\n\nhttps://www.isc.org/downloads/bind/\n\n## find包含某关键字的文件内容\n```bash\nwujianjun@smzc ~ $ find /smapp/logs -name “*” | xargs grep “keywords”\n```\n\n```bash\nwujianjun@smzc ~ $ grep -nR \"keywords\" /smapp/logs\n```\n\ngrep + RegExp (提取行首不是abc的行)\n```bash\nwujianjun@smzc ~ $ grep “^[^abc]” /smapp/logs\n```\n\n## 文本替换\n```bash\nwujianjun@smzc ~ $ sed -n ‘s/oldk/newk/g’ file\n```\n\n先删除1到3行，然后用bb替换aa；\n```bash\nwujianjun@smzc ~ $ sed -e ’1,3d’ -e ‘s/aa/bb/g’ file\n```\n\n## 文本处理\n打印所有内容行(相当于cat)\n```bash\nwujianjun@smzc ~ $ awk '{print $0}' result.txt\n18100000011 - \"status\":\"SUCCESS\"\n18100000012 - \"status\":\"SUCCESS\"\n18100000013 - \"status\":\"SUCCESS\"\n18100000014 - \"status\":\"SUCCESS\"\n```\n\n按`空格`分隔逐行内容并打印第一个内容\n```bash\nwujianjun@smzc ~ $ awk '{print $1}' result.txt\n18100000011\n18100000012\n18100000013\n18100000014\n```\n\n-----\n\n*观点仅代表自己，期待你的留言。*\n","slug":"linux-cmd-notes","published":1,"updated":"2021-08-31T14:23:11.545Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cku52dynf002ibbin13le2gxg","content":"<h2 id=\"nslookup-指定DNS服务器解析\"><a href=\"#nslookup-指定DNS服务器解析\" class=\"headerlink\" title=\"nslookup 指定DNS服务器解析\"></a>nslookup 指定DNS服务器解析</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wujianjun@smzc ~ $ nslookup m.vvip-u.com 10.28.17.101</span><br><span class=\"line\">Server:\t\t10.28.17.101</span><br><span class=\"line\">Address:\t10.28.17.101<span class=\"comment\">#53</span></span><br><span class=\"line\"></span><br><span class=\"line\">Name:\tm.vvip-u.com</span><br><span class=\"line\">Address: 10.28.17.80</span><br><span class=\"line\"></span><br><span class=\"line\">wujianjun@smzc ~ $ nslookup m.vvip-u.com</span><br><span class=\"line\">Server:\t\t127.0.1.1</span><br><span class=\"line\">Address:\t127.0.1.1<span class=\"comment\">#53</span></span><br><span class=\"line\"></span><br><span class=\"line\">Non-authoritative answer:</span><br><span class=\"line\">Name:\tm.vvip-u.com</span><br><span class=\"line\">Address: 120.77.124.39</span><br></pre></td></tr></table></figure>\n<h2 id=\"BIND-局域网DNS程序\"><a href=\"#BIND-局域网DNS程序\" class=\"headerlink\" title=\"BIND 局域网DNS程序\"></a>BIND 局域网DNS程序</h2><p><a href=\"https://www.isc.org/downloads/bind/\">https://www.isc.org/downloads/bind/</a></p>\n<h2 id=\"find包含某关键字的文件内容\"><a href=\"#find包含某关键字的文件内容\" class=\"headerlink\" title=\"find包含某关键字的文件内容\"></a>find包含某关键字的文件内容</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wujianjun@smzc ~ $ find /smapp/logs -name “*” | xargs grep “keywords”</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wujianjun@smzc ~ $ grep -nR <span class=\"string\">&quot;keywords&quot;</span> /smapp/logs</span><br></pre></td></tr></table></figure>\n\n<p>grep + RegExp (提取行首不是abc的行)</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wujianjun@smzc ~ $ grep “^[^abc]” /smapp/logs</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"文本替换\"><a href=\"#文本替换\" class=\"headerlink\" title=\"文本替换\"></a>文本替换</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wujianjun@smzc ~ $ sed -n ‘s/oldk/newk/g’ file</span><br></pre></td></tr></table></figure>\n\n<p>先删除1到3行，然后用bb替换aa；</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wujianjun@smzc ~ $ sed -e ’1,3d’ -e ‘s/aa/bb/g’ file</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"文本处理\"><a href=\"#文本处理\" class=\"headerlink\" title=\"文本处理\"></a>文本处理</h2><p>打印所有内容行(相当于cat)</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wujianjun@smzc ~ $ awk <span class=\"string\">&#x27;&#123;print $0&#125;&#x27;</span> result.txt</span><br><span class=\"line\">18100000011 - <span class=\"string\">&quot;status&quot;</span>:<span class=\"string\">&quot;SUCCESS&quot;</span></span><br><span class=\"line\">18100000012 - <span class=\"string\">&quot;status&quot;</span>:<span class=\"string\">&quot;SUCCESS&quot;</span></span><br><span class=\"line\">18100000013 - <span class=\"string\">&quot;status&quot;</span>:<span class=\"string\">&quot;SUCCESS&quot;</span></span><br><span class=\"line\">18100000014 - <span class=\"string\">&quot;status&quot;</span>:<span class=\"string\">&quot;SUCCESS&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>按<code>空格</code>分隔逐行内容并打印第一个内容</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wujianjun@smzc ~ $ awk <span class=\"string\">&#x27;&#123;print $1&#125;&#x27;</span> result.txt</span><br><span class=\"line\">18100000011</span><br><span class=\"line\">18100000012</span><br><span class=\"line\">18100000013</span><br><span class=\"line\">18100000014</span><br></pre></td></tr></table></figure>\n\n<hr>\n<p><em>观点仅代表自己，期待你的留言。</em></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"nslookup-指定DNS服务器解析\"><a href=\"#nslookup-指定DNS服务器解析\" class=\"headerlink\" title=\"nslookup 指定DNS服务器解析\"></a>nslookup 指定DNS服务器解析</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wujianjun@smzc ~ $ nslookup m.vvip-u.com 10.28.17.101</span><br><span class=\"line\">Server:\t\t10.28.17.101</span><br><span class=\"line\">Address:\t10.28.17.101<span class=\"comment\">#53</span></span><br><span class=\"line\"></span><br><span class=\"line\">Name:\tm.vvip-u.com</span><br><span class=\"line\">Address: 10.28.17.80</span><br><span class=\"line\"></span><br><span class=\"line\">wujianjun@smzc ~ $ nslookup m.vvip-u.com</span><br><span class=\"line\">Server:\t\t127.0.1.1</span><br><span class=\"line\">Address:\t127.0.1.1<span class=\"comment\">#53</span></span><br><span class=\"line\"></span><br><span class=\"line\">Non-authoritative answer:</span><br><span class=\"line\">Name:\tm.vvip-u.com</span><br><span class=\"line\">Address: 120.77.124.39</span><br></pre></td></tr></table></figure>\n<h2 id=\"BIND-局域网DNS程序\"><a href=\"#BIND-局域网DNS程序\" class=\"headerlink\" title=\"BIND 局域网DNS程序\"></a>BIND 局域网DNS程序</h2><p><a href=\"https://www.isc.org/downloads/bind/\">https://www.isc.org/downloads/bind/</a></p>\n<h2 id=\"find包含某关键字的文件内容\"><a href=\"#find包含某关键字的文件内容\" class=\"headerlink\" title=\"find包含某关键字的文件内容\"></a>find包含某关键字的文件内容</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wujianjun@smzc ~ $ find /smapp/logs -name “*” | xargs grep “keywords”</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wujianjun@smzc ~ $ grep -nR <span class=\"string\">&quot;keywords&quot;</span> /smapp/logs</span><br></pre></td></tr></table></figure>\n\n<p>grep + RegExp (提取行首不是abc的行)</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wujianjun@smzc ~ $ grep “^[^abc]” /smapp/logs</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"文本替换\"><a href=\"#文本替换\" class=\"headerlink\" title=\"文本替换\"></a>文本替换</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wujianjun@smzc ~ $ sed -n ‘s/oldk/newk/g’ file</span><br></pre></td></tr></table></figure>\n\n<p>先删除1到3行，然后用bb替换aa；</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wujianjun@smzc ~ $ sed -e ’1,3d’ -e ‘s/aa/bb/g’ file</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"文本处理\"><a href=\"#文本处理\" class=\"headerlink\" title=\"文本处理\"></a>文本处理</h2><p>打印所有内容行(相当于cat)</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wujianjun@smzc ~ $ awk <span class=\"string\">&#x27;&#123;print $0&#125;&#x27;</span> result.txt</span><br><span class=\"line\">18100000011 - <span class=\"string\">&quot;status&quot;</span>:<span class=\"string\">&quot;SUCCESS&quot;</span></span><br><span class=\"line\">18100000012 - <span class=\"string\">&quot;status&quot;</span>:<span class=\"string\">&quot;SUCCESS&quot;</span></span><br><span class=\"line\">18100000013 - <span class=\"string\">&quot;status&quot;</span>:<span class=\"string\">&quot;SUCCESS&quot;</span></span><br><span class=\"line\">18100000014 - <span class=\"string\">&quot;status&quot;</span>:<span class=\"string\">&quot;SUCCESS&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>按<code>空格</code>分隔逐行内容并打印第一个内容</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wujianjun@smzc ~ $ awk <span class=\"string\">&#x27;&#123;print $1&#125;&#x27;</span> result.txt</span><br><span class=\"line\">18100000011</span><br><span class=\"line\">18100000012</span><br><span class=\"line\">18100000013</span><br><span class=\"line\">18100000014</span><br></pre></td></tr></table></figure>\n\n<hr>\n<p><em>观点仅代表自己，期待你的留言。</em></p>\n"},{"title":"Linux定时任务之crontab","keywords":["linux","crontab"],"date":"2021-07-30T04:01:55.000Z","_content":"\n## Linux定时任务\n\n-  列出当前用户签定的任务： # crontab -l\n-  删除当前用户签定的任务： # crontab -r\n-  编辑用户个人的计划任务： # crontab -e\n```\n# m h  dom mon dow   command m:分钟，0-59，每分钟可以用 * 或 */1 表示，每5分钟用 */5 表示 h:小时，0-23 dom:日期，1-31\nmon:月份，1-12 dow:星期，0-7，其中0、7都是代表星期天 command:需要执行的命令\n```\n示例： */30 * * * * echo ‘hello’ 每 30 分钟输出hello\n30 * * * *  echo ‘hello’ 每小时的 30 分钟（间隔1小时）输出hello\n30 1-3 * * *  echo ‘hello’ 每日 1:00-3:00 之间的 30 分钟（即1:30、2:30、3:30）输出hello\n*/30 1-3 * * *  echo ‘hello’ 每日 1:00-3:00 之间每隔 30 分钟输出hello\n30 3 * * *  echo ‘hello’ 每日 3:30 输出hello\n30 3 1,5,9 * *  echo ‘hello’ 每月1、5、9日 3:30 输出hello\n30 3 1,5,9 1 *  echo ‘hello’ 每年1月1、5、9日 3:30 输出hello\n30 3 * * 0,6  echo ‘hello’ 每星期六、日 3:30 输出hello\n\n- 编辑系统计划任务： # vi /etc/crontab\n```\n# m h dom mon dow user  command\nm:分钟，0-59，每分钟可以用 * 或 */1 表示，每5分钟用 */5 表示 h:小时，0-23 dom:日期，1-31\nmon:月份，1-12 dow:星期，0-7，其中0、7都是代表星期天\nuser: 指定用户名 command:需要执行的命令\n```\n示例：\n*/10 * * * * root /usr/local/demo.sh\n每 10 分钟以 root 身份执行 /usr/local/demo.sh 这个脚本。\n\n- 开启运行日志：#vi /etc/rsyslog.d/50-default.conf && sudo systemctl restart rsyslog.service\n```\ntail -f /var/log/cron.log\n```\n\n\n-----\n\n*观点仅代表自己，期待你的留言。*\n","source":"_posts/linux-crontab.md","raw":"---\ntitle: Linux定时任务之crontab\ntags:\n  - 原创\nkeywords:\n  - linux\n  - crontab\ndate: 2021-07-30 12:01:55\n---\n\n## Linux定时任务\n\n-  列出当前用户签定的任务： # crontab -l\n-  删除当前用户签定的任务： # crontab -r\n-  编辑用户个人的计划任务： # crontab -e\n```\n# m h  dom mon dow   command m:分钟，0-59，每分钟可以用 * 或 */1 表示，每5分钟用 */5 表示 h:小时，0-23 dom:日期，1-31\nmon:月份，1-12 dow:星期，0-7，其中0、7都是代表星期天 command:需要执行的命令\n```\n示例： */30 * * * * echo ‘hello’ 每 30 分钟输出hello\n30 * * * *  echo ‘hello’ 每小时的 30 分钟（间隔1小时）输出hello\n30 1-3 * * *  echo ‘hello’ 每日 1:00-3:00 之间的 30 分钟（即1:30、2:30、3:30）输出hello\n*/30 1-3 * * *  echo ‘hello’ 每日 1:00-3:00 之间每隔 30 分钟输出hello\n30 3 * * *  echo ‘hello’ 每日 3:30 输出hello\n30 3 1,5,9 * *  echo ‘hello’ 每月1、5、9日 3:30 输出hello\n30 3 1,5,9 1 *  echo ‘hello’ 每年1月1、5、9日 3:30 输出hello\n30 3 * * 0,6  echo ‘hello’ 每星期六、日 3:30 输出hello\n\n- 编辑系统计划任务： # vi /etc/crontab\n```\n# m h dom mon dow user  command\nm:分钟，0-59，每分钟可以用 * 或 */1 表示，每5分钟用 */5 表示 h:小时，0-23 dom:日期，1-31\nmon:月份，1-12 dow:星期，0-7，其中0、7都是代表星期天\nuser: 指定用户名 command:需要执行的命令\n```\n示例：\n*/10 * * * * root /usr/local/demo.sh\n每 10 分钟以 root 身份执行 /usr/local/demo.sh 这个脚本。\n\n- 开启运行日志：#vi /etc/rsyslog.d/50-default.conf && sudo systemctl restart rsyslog.service\n```\ntail -f /var/log/cron.log\n```\n\n\n-----\n\n*观点仅代表自己，期待你的留言。*\n","slug":"linux-crontab","published":1,"updated":"2021-09-01T02:03:15.528Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cku52dyng002kbbin5ot7cm8m","content":"<h2 id=\"Linux定时任务\"><a href=\"#Linux定时任务\" class=\"headerlink\" title=\"Linux定时任务\"></a>Linux定时任务</h2><ul>\n<li> 列出当前用户签定的任务： # crontab -l</li>\n<li> 删除当前用户签定的任务： # crontab -r</li>\n<li> 编辑用户个人的计划任务： # crontab -e<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># m h  dom mon dow   command m:分钟，0-59，每分钟可以用 * 或 */1 表示，每5分钟用 */5 表示 h:小时，0-23 dom:日期，1-31</span><br><span class=\"line\">mon:月份，1-12 dow:星期，0-7，其中0、7都是代表星期天 command:需要执行的命令</span><br></pre></td></tr></table></figure>\n示例： */30 * * * * echo ‘hello’ 每 30 分钟输出hello<br>30 * * * *  echo ‘hello’ 每小时的 30 分钟（间隔1小时）输出hello<br>30 1-3 * * *  echo ‘hello’ 每日 1:00-3:00 之间的 30 分钟（即1:30、2:30、3:30）输出hello</li>\n</ul>\n<p>*/30 1-3 * * *  echo ‘hello’ 每日 1:00-3:00 之间每隔 30 分钟输出hello<br>30 3 * * *  echo ‘hello’ 每日 3:30 输出hello<br>30 3 1,5,9 * *  echo ‘hello’ 每月1、5、9日 3:30 输出hello<br>30 3 1,5,9 1 *  echo ‘hello’ 每年1月1、5、9日 3:30 输出hello<br>30 3 * * 0,6  echo ‘hello’ 每星期六、日 3:30 输出hello</p>\n<ul>\n<li>编辑系统计划任务： # vi /etc/crontab<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># m h dom mon dow user  command</span><br><span class=\"line\">m:分钟，0-59，每分钟可以用 * 或 */1 表示，每5分钟用 */5 表示 h:小时，0-23 dom:日期，1-31</span><br><span class=\"line\">mon:月份，1-12 dow:星期，0-7，其中0、7都是代表星期天</span><br><span class=\"line\">user: 指定用户名 command:需要执行的命令</span><br></pre></td></tr></table></figure>\n示例：</li>\n</ul>\n<p>*/10 * * * * root /usr/local/demo.sh<br>每 10 分钟以 root 身份执行 /usr/local/demo.sh 这个脚本。</p>\n<ul>\n<li>开启运行日志：#vi /etc/rsyslog.d/50-default.conf &amp;&amp; sudo systemctl restart rsyslog.service<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tail -f /var/log/cron.log</span><br></pre></td></tr></table></figure></li>\n</ul>\n<hr>\n<p><em>观点仅代表自己，期待你的留言。</em></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"Linux定时任务\"><a href=\"#Linux定时任务\" class=\"headerlink\" title=\"Linux定时任务\"></a>Linux定时任务</h2><ul>\n<li> 列出当前用户签定的任务： # crontab -l</li>\n<li> 删除当前用户签定的任务： # crontab -r</li>\n<li> 编辑用户个人的计划任务： # crontab -e<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># m h  dom mon dow   command m:分钟，0-59，每分钟可以用 * 或 */1 表示，每5分钟用 */5 表示 h:小时，0-23 dom:日期，1-31</span><br><span class=\"line\">mon:月份，1-12 dow:星期，0-7，其中0、7都是代表星期天 command:需要执行的命令</span><br></pre></td></tr></table></figure>\n示例： */30 * * * * echo ‘hello’ 每 30 分钟输出hello<br>30 * * * *  echo ‘hello’ 每小时的 30 分钟（间隔1小时）输出hello<br>30 1-3 * * *  echo ‘hello’ 每日 1:00-3:00 之间的 30 分钟（即1:30、2:30、3:30）输出hello</li>\n</ul>\n<p>*/30 1-3 * * *  echo ‘hello’ 每日 1:00-3:00 之间每隔 30 分钟输出hello<br>30 3 * * *  echo ‘hello’ 每日 3:30 输出hello<br>30 3 1,5,9 * *  echo ‘hello’ 每月1、5、9日 3:30 输出hello<br>30 3 1,5,9 1 *  echo ‘hello’ 每年1月1、5、9日 3:30 输出hello<br>30 3 * * 0,6  echo ‘hello’ 每星期六、日 3:30 输出hello</p>\n<ul>\n<li>编辑系统计划任务： # vi /etc/crontab<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># m h dom mon dow user  command</span><br><span class=\"line\">m:分钟，0-59，每分钟可以用 * 或 */1 表示，每5分钟用 */5 表示 h:小时，0-23 dom:日期，1-31</span><br><span class=\"line\">mon:月份，1-12 dow:星期，0-7，其中0、7都是代表星期天</span><br><span class=\"line\">user: 指定用户名 command:需要执行的命令</span><br></pre></td></tr></table></figure>\n示例：</li>\n</ul>\n<p>*/10 * * * * root /usr/local/demo.sh<br>每 10 分钟以 root 身份执行 /usr/local/demo.sh 这个脚本。</p>\n<ul>\n<li>开启运行日志：#vi /etc/rsyslog.d/50-default.conf &amp;&amp; sudo systemctl restart rsyslog.service<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tail -f /var/log/cron.log</span><br></pre></td></tr></table></figure></li>\n</ul>\n<hr>\n<p><em>观点仅代表自己，期待你的留言。</em></p>\n"},{"title":"内网linux远程访问","keywords":["linux远程","cockpit"],"date":"2021-09-02T11:09:51.000Z","_content":"\n## 开通ssh远程端口\n通过外网做端口映射出ssh端口(22)之后，通过外网IP进行访问\n\n## 安装vpn\n利用vpn软件远程登录进内网进行内网linux的访问\n\n## 内网找一台电脑安装软件（如：向日葵、TeamViewer等）\n\n## 安装cockpit\nCockpit是一个Web端的系统管理工具。Cockpit使用系统上已经存在的API。可以在Web界面管理服务、容器、存储等等，还可以配置网络、检查日志都非常方便。\n\n由于22端口映射过于敏感，可以在内网linux上安装cockpit后，然后再做外网映射（默认9090）映射完成后，则可通过浏览器使用linux登录用户进行登录访问。\n\n### 安装\n`CentOS`：\n```\nwujianjun@wujianjun-work:~$ sudo yum install cockpit\n```\n\n`Ubuntu`：\n```\nwujianjun@wujianjun-work:~$ sudo apt install cockpit\n```\n### 端口更改\n默认端口为9090，如果遇上端口冲突可按以下方式进行修改\n```\nwujianjun@wujianjun-work:~$ sudo vi /etc/systemd/system/sockets.target.wants/cockpit.socket #更改ListenStream后的端口号\nwujianjun@wujianjun-work:~$ sudo systemctl restart cockpit.socket\nwujianjun@wujianjun-work:~$ sudo systemctl daemon-reload\n```\n\n-----\n\n*观点仅代表自己，期待你的留言。*\n","source":"_posts/linux-remote.md","raw":"---\ntitle: 内网linux远程访问\ntags:\n  - 原创\nkeywords:\n  - linux远程\n  - cockpit\ndate: 2021-09-02 19:09:51\n---\n\n## 开通ssh远程端口\n通过外网做端口映射出ssh端口(22)之后，通过外网IP进行访问\n\n## 安装vpn\n利用vpn软件远程登录进内网进行内网linux的访问\n\n## 内网找一台电脑安装软件（如：向日葵、TeamViewer等）\n\n## 安装cockpit\nCockpit是一个Web端的系统管理工具。Cockpit使用系统上已经存在的API。可以在Web界面管理服务、容器、存储等等，还可以配置网络、检查日志都非常方便。\n\n由于22端口映射过于敏感，可以在内网linux上安装cockpit后，然后再做外网映射（默认9090）映射完成后，则可通过浏览器使用linux登录用户进行登录访问。\n\n### 安装\n`CentOS`：\n```\nwujianjun@wujianjun-work:~$ sudo yum install cockpit\n```\n\n`Ubuntu`：\n```\nwujianjun@wujianjun-work:~$ sudo apt install cockpit\n```\n### 端口更改\n默认端口为9090，如果遇上端口冲突可按以下方式进行修改\n```\nwujianjun@wujianjun-work:~$ sudo vi /etc/systemd/system/sockets.target.wants/cockpit.socket #更改ListenStream后的端口号\nwujianjun@wujianjun-work:~$ sudo systemctl restart cockpit.socket\nwujianjun@wujianjun-work:~$ sudo systemctl daemon-reload\n```\n\n-----\n\n*观点仅代表自己，期待你的留言。*\n","slug":"linux-remote","published":1,"updated":"2021-09-02T11:33:21.283Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cku52dynh002nbbinevo17tyc","content":"<h2 id=\"开通ssh远程端口\"><a href=\"#开通ssh远程端口\" class=\"headerlink\" title=\"开通ssh远程端口\"></a>开通ssh远程端口</h2><p>通过外网做端口映射出ssh端口(22)之后，通过外网IP进行访问</p>\n<h2 id=\"安装vpn\"><a href=\"#安装vpn\" class=\"headerlink\" title=\"安装vpn\"></a>安装vpn</h2><p>利用vpn软件远程登录进内网进行内网linux的访问</p>\n<h2 id=\"内网找一台电脑安装软件（如：向日葵、TeamViewer等）\"><a href=\"#内网找一台电脑安装软件（如：向日葵、TeamViewer等）\" class=\"headerlink\" title=\"内网找一台电脑安装软件（如：向日葵、TeamViewer等）\"></a>内网找一台电脑安装软件（如：向日葵、TeamViewer等）</h2><h2 id=\"安装cockpit\"><a href=\"#安装cockpit\" class=\"headerlink\" title=\"安装cockpit\"></a>安装cockpit</h2><p>Cockpit是一个Web端的系统管理工具。Cockpit使用系统上已经存在的API。可以在Web界面管理服务、容器、存储等等，还可以配置网络、检查日志都非常方便。</p>\n<p>由于22端口映射过于敏感，可以在内网linux上安装cockpit后，然后再做外网映射（默认9090）映射完成后，则可通过浏览器使用linux登录用户进行登录访问。</p>\n<h3 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h3><p><code>CentOS</code>：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wujianjun@wujianjun-work:~$ sudo yum install cockpit</span><br></pre></td></tr></table></figure>\n\n<p><code>Ubuntu</code>：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wujianjun@wujianjun-work:~$ sudo apt install cockpit</span><br></pre></td></tr></table></figure>\n<h3 id=\"端口更改\"><a href=\"#端口更改\" class=\"headerlink\" title=\"端口更改\"></a>端口更改</h3><p>默认端口为9090，如果遇上端口冲突可按以下方式进行修改</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wujianjun@wujianjun-work:~$ sudo vi /etc/systemd/system/sockets.target.wants/cockpit.socket #更改ListenStream后的端口号</span><br><span class=\"line\">wujianjun@wujianjun-work:~$ sudo systemctl restart cockpit.socket</span><br><span class=\"line\">wujianjun@wujianjun-work:~$ sudo systemctl daemon-reload</span><br></pre></td></tr></table></figure>\n\n<hr>\n<p><em>观点仅代表自己，期待你的留言。</em></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"开通ssh远程端口\"><a href=\"#开通ssh远程端口\" class=\"headerlink\" title=\"开通ssh远程端口\"></a>开通ssh远程端口</h2><p>通过外网做端口映射出ssh端口(22)之后，通过外网IP进行访问</p>\n<h2 id=\"安装vpn\"><a href=\"#安装vpn\" class=\"headerlink\" title=\"安装vpn\"></a>安装vpn</h2><p>利用vpn软件远程登录进内网进行内网linux的访问</p>\n<h2 id=\"内网找一台电脑安装软件（如：向日葵、TeamViewer等）\"><a href=\"#内网找一台电脑安装软件（如：向日葵、TeamViewer等）\" class=\"headerlink\" title=\"内网找一台电脑安装软件（如：向日葵、TeamViewer等）\"></a>内网找一台电脑安装软件（如：向日葵、TeamViewer等）</h2><h2 id=\"安装cockpit\"><a href=\"#安装cockpit\" class=\"headerlink\" title=\"安装cockpit\"></a>安装cockpit</h2><p>Cockpit是一个Web端的系统管理工具。Cockpit使用系统上已经存在的API。可以在Web界面管理服务、容器、存储等等，还可以配置网络、检查日志都非常方便。</p>\n<p>由于22端口映射过于敏感，可以在内网linux上安装cockpit后，然后再做外网映射（默认9090）映射完成后，则可通过浏览器使用linux登录用户进行登录访问。</p>\n<h3 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h3><p><code>CentOS</code>：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wujianjun@wujianjun-work:~$ sudo yum install cockpit</span><br></pre></td></tr></table></figure>\n\n<p><code>Ubuntu</code>：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wujianjun@wujianjun-work:~$ sudo apt install cockpit</span><br></pre></td></tr></table></figure>\n<h3 id=\"端口更改\"><a href=\"#端口更改\" class=\"headerlink\" title=\"端口更改\"></a>端口更改</h3><p>默认端口为9090，如果遇上端口冲突可按以下方式进行修改</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wujianjun@wujianjun-work:~$ sudo vi /etc/systemd/system/sockets.target.wants/cockpit.socket #更改ListenStream后的端口号</span><br><span class=\"line\">wujianjun@wujianjun-work:~$ sudo systemctl restart cockpit.socket</span><br><span class=\"line\">wujianjun@wujianjun-work:~$ sudo systemctl daemon-reload</span><br></pre></td></tr></table></figure>\n\n<hr>\n<p><em>观点仅代表自己，期待你的留言。</em></p>\n"},{"title":"linux-strace跟踪运行中进程对系统资源的访问","date":"2016-03-18T07:40:02.000Z","_content":"\n## 简介\nstrace常用来跟踪进程执行时的系统调用和所接收的信号。 在Linux世界，进程不能直接访问硬件设备，当进程需要访问硬件设备(比如读取磁盘文件，接收网络数据等等)时，必须由用户态模式切换至内核态模式，通 过系统调用访问硬件设备。strace可以跟踪到一个进程产生的系统调用,包括参数，返回值，执行消耗的时间。\n## 输出参数含义\n```\nroot@ubuntu:/usr# strace cat /dev/null\nexecve(\"/bin/cat\", [\"cat\", \"/dev/null\"], [/* 22 vars */]) = 0\nbrk(0)                                  = 0xab1000\naccess(\"/etc/ld.so.nohwcap\", F_OK)      = -1 ENOENT (No such file or directory)\nmmap(NULL, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7f29379a7000\naccess(\"/etc/ld.so.preload\", R_OK)      = -1 ENOENT (No such file or directory)\n...\nbrk(0) = 0xab1000\nbrk(0xad2000) = 0xad2000\nfstat(1, {st_mode=S_IFCHR|0620, st_rdev=makedev(136, 0), ...}) = 0\nopen(\"/dev/null\", O_RDONLY) = 3\nfstat(3, {st_mode=S_IFCHR|0666, st_rdev=makedev(1, 3), ...}) = 0\nread(3, \"\", 32768) = 0\nclose(3) = 0\nclose(1) = 0\nclose(2) = 0\nexit_group(0) = ?\n```\n每一行都是一条系统调用，等号左边是系统调用的函数名及其参数，右边是该调用的返回值。\nstrace 显示这些调用的参数并返回符号形式的值。strace 从内核接收信息，而且不需要以任何特殊的方式来构建内核。\n## strace参数\n```\n-c 统计每一系统调用的所执行的时间,次数和出错的次数等.\n-d 输出strace关于标准错误的调试信息.\n-f 跟踪由fork调用所产生的子进程.\n-ff 如果提供-o filename,则所有进程的跟踪结果输出到相应的filename.pid中,pid是各进程的进程号.\n-F 尝试跟踪vfork调用.在-f时,vfork不被跟踪.\n-h 输出简要的帮助信息.\n-i 输出系统调用的入口指针.\n-q 禁止输出关于脱离的消息.\n-r 打印出相对时间关于,,每一个系统调用.\n-t 在输出中的每一行前加上时间信息.\n-tt 在输出中的每一行前加上时间信息,微秒级.\n-ttt 微秒级输出,以秒了表示时间.\n-T 显示每一调用所耗的时间.\n-v 输出所有的系统调用.一些调用关于环境变量,状态,输入输出等调用由于使用频繁,默认不输出.\n-V 输出strace的版本信息.\n-x 以十六进制形式输出非标准字符串\n-xx 所有字符串以十六进制形式输出.\n-a column\n设置返回值的输出位置.默认 为40.\n-e expr\n指定一个表达式,用来控制如何跟踪.格式如下:\n[qualifier=][!]value1[,value2]...\nqualifier只能是 trace,abbrev,verbose,raw,signal,read,write其中之一.value是用来限定的符号或数字.默认的 qualifier是 trace.感叹号是否定符号.例如:\n-eopen等价于 -e trace=open,表示只跟踪open调用.而-etrace!=open表示跟踪除了open以外的其他调用.有两个特殊的符号 all 和 none.\n注意有些shell使用!来执行历史记录里的命令,所以要使用\\\\.\n-e trace=set\n只跟踪指定的系统 调用.例如:-e trace=open,close,rean,write表示只跟踪这四个系统调用.默认的为set=all.\n-e trace=file\n只跟踪有关文件操作的系统调用.\n-e trace=process\n只跟踪有关进程控制的系统调用.\n-e trace=network\n跟踪与网络有关的所有系统调用.\n-e strace=signal\n跟踪所有与系统信号有关的 系统调用\n-e trace=ipc\n跟踪所有与进程通讯有关的系统调用\n-e abbrev=set\n设定 strace输出的系统调用的结果集.-v 等与 abbrev=none.默认为abbrev=all.\n-e raw=set\n将指 定的系统调用的参数以十六进制显示.\n-e signal=set\n指定跟踪的系统信号.默认为all.如 signal=!SIGIO(或者signal=!io),表示不跟踪SIGIO信号.\n-e read=set\n输出从指定文件中读出 的数据.例如:\n-e read=3,5\n-e write=set\n输出写入到指定文件中的数据.\n-o filename\n将strace的输出写入文件filename\n-p pid\n跟踪指定的进程pid.\n-s strsize\n指定输出的字符串的最大长度.默认为32.文件名一直全部输出.\n-u username\n以username 的UID和GID执行被跟踪的命令\n```\n\n## 命令实例\n通用的完整用法：\n```\nstrace -o output.txt -T -tt -e trace=all -p 28979\n```\n上面的含义是 跟踪28979进程的所有系统调用（-e trace=all），并统计系统调用的花费时间，以及开始时间（并以可视化的时分秒格式显示），最后将记录结果存在output.txt文件里面。\n\n## 限制strace只跟踪特定的系统调用\n如果你已经知道你要找什么，你可以让strace只跟踪一些类型的系统调用。例如，你需要看看在configure脚本里面执行的程序，你需要监视的系统调 用就是execve。让strace只记录execve的调用用这个命令：\n```\nstrace -f -o configure-strace.txt -e execve ./configure\n```\n\n-----\n\n精品博文转自： http://www.cnblogs.com/ggjucheng/archive/2012/01/08/2316692.html\n","source":"_posts/linux-strace.md","raw":"---\ntitle: linux-strace跟踪运行中进程对系统资源的访问\ntags:\n  - 转载\n  - linux\ndate: 2016-03-18 15:40:02\n---\n\n## 简介\nstrace常用来跟踪进程执行时的系统调用和所接收的信号。 在Linux世界，进程不能直接访问硬件设备，当进程需要访问硬件设备(比如读取磁盘文件，接收网络数据等等)时，必须由用户态模式切换至内核态模式，通 过系统调用访问硬件设备。strace可以跟踪到一个进程产生的系统调用,包括参数，返回值，执行消耗的时间。\n## 输出参数含义\n```\nroot@ubuntu:/usr# strace cat /dev/null\nexecve(\"/bin/cat\", [\"cat\", \"/dev/null\"], [/* 22 vars */]) = 0\nbrk(0)                                  = 0xab1000\naccess(\"/etc/ld.so.nohwcap\", F_OK)      = -1 ENOENT (No such file or directory)\nmmap(NULL, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7f29379a7000\naccess(\"/etc/ld.so.preload\", R_OK)      = -1 ENOENT (No such file or directory)\n...\nbrk(0) = 0xab1000\nbrk(0xad2000) = 0xad2000\nfstat(1, {st_mode=S_IFCHR|0620, st_rdev=makedev(136, 0), ...}) = 0\nopen(\"/dev/null\", O_RDONLY) = 3\nfstat(3, {st_mode=S_IFCHR|0666, st_rdev=makedev(1, 3), ...}) = 0\nread(3, \"\", 32768) = 0\nclose(3) = 0\nclose(1) = 0\nclose(2) = 0\nexit_group(0) = ?\n```\n每一行都是一条系统调用，等号左边是系统调用的函数名及其参数，右边是该调用的返回值。\nstrace 显示这些调用的参数并返回符号形式的值。strace 从内核接收信息，而且不需要以任何特殊的方式来构建内核。\n## strace参数\n```\n-c 统计每一系统调用的所执行的时间,次数和出错的次数等.\n-d 输出strace关于标准错误的调试信息.\n-f 跟踪由fork调用所产生的子进程.\n-ff 如果提供-o filename,则所有进程的跟踪结果输出到相应的filename.pid中,pid是各进程的进程号.\n-F 尝试跟踪vfork调用.在-f时,vfork不被跟踪.\n-h 输出简要的帮助信息.\n-i 输出系统调用的入口指针.\n-q 禁止输出关于脱离的消息.\n-r 打印出相对时间关于,,每一个系统调用.\n-t 在输出中的每一行前加上时间信息.\n-tt 在输出中的每一行前加上时间信息,微秒级.\n-ttt 微秒级输出,以秒了表示时间.\n-T 显示每一调用所耗的时间.\n-v 输出所有的系统调用.一些调用关于环境变量,状态,输入输出等调用由于使用频繁,默认不输出.\n-V 输出strace的版本信息.\n-x 以十六进制形式输出非标准字符串\n-xx 所有字符串以十六进制形式输出.\n-a column\n设置返回值的输出位置.默认 为40.\n-e expr\n指定一个表达式,用来控制如何跟踪.格式如下:\n[qualifier=][!]value1[,value2]...\nqualifier只能是 trace,abbrev,verbose,raw,signal,read,write其中之一.value是用来限定的符号或数字.默认的 qualifier是 trace.感叹号是否定符号.例如:\n-eopen等价于 -e trace=open,表示只跟踪open调用.而-etrace!=open表示跟踪除了open以外的其他调用.有两个特殊的符号 all 和 none.\n注意有些shell使用!来执行历史记录里的命令,所以要使用\\\\.\n-e trace=set\n只跟踪指定的系统 调用.例如:-e trace=open,close,rean,write表示只跟踪这四个系统调用.默认的为set=all.\n-e trace=file\n只跟踪有关文件操作的系统调用.\n-e trace=process\n只跟踪有关进程控制的系统调用.\n-e trace=network\n跟踪与网络有关的所有系统调用.\n-e strace=signal\n跟踪所有与系统信号有关的 系统调用\n-e trace=ipc\n跟踪所有与进程通讯有关的系统调用\n-e abbrev=set\n设定 strace输出的系统调用的结果集.-v 等与 abbrev=none.默认为abbrev=all.\n-e raw=set\n将指 定的系统调用的参数以十六进制显示.\n-e signal=set\n指定跟踪的系统信号.默认为all.如 signal=!SIGIO(或者signal=!io),表示不跟踪SIGIO信号.\n-e read=set\n输出从指定文件中读出 的数据.例如:\n-e read=3,5\n-e write=set\n输出写入到指定文件中的数据.\n-o filename\n将strace的输出写入文件filename\n-p pid\n跟踪指定的进程pid.\n-s strsize\n指定输出的字符串的最大长度.默认为32.文件名一直全部输出.\n-u username\n以username 的UID和GID执行被跟踪的命令\n```\n\n## 命令实例\n通用的完整用法：\n```\nstrace -o output.txt -T -tt -e trace=all -p 28979\n```\n上面的含义是 跟踪28979进程的所有系统调用（-e trace=all），并统计系统调用的花费时间，以及开始时间（并以可视化的时分秒格式显示），最后将记录结果存在output.txt文件里面。\n\n## 限制strace只跟踪特定的系统调用\n如果你已经知道你要找什么，你可以让strace只跟踪一些类型的系统调用。例如，你需要看看在configure脚本里面执行的程序，你需要监视的系统调 用就是execve。让strace只记录execve的调用用这个命令：\n```\nstrace -f -o configure-strace.txt -e execve ./configure\n```\n\n-----\n\n精品博文转自： http://www.cnblogs.com/ggjucheng/archive/2012/01/08/2316692.html\n","slug":"linux-strace","published":1,"updated":"2021-09-18T05:13:56.724Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cku52dyni002pbbin778pe3ev","content":"<h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><p>strace常用来跟踪进程执行时的系统调用和所接收的信号。 在Linux世界，进程不能直接访问硬件设备，当进程需要访问硬件设备(比如读取磁盘文件，接收网络数据等等)时，必须由用户态模式切换至内核态模式，通 过系统调用访问硬件设备。strace可以跟踪到一个进程产生的系统调用,包括参数，返回值，执行消耗的时间。</p>\n<h2 id=\"输出参数含义\"><a href=\"#输出参数含义\" class=\"headerlink\" title=\"输出参数含义\"></a>输出参数含义</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">root@ubuntu:/usr# strace cat /dev/null</span><br><span class=\"line\">execve(&quot;/bin/cat&quot;, [&quot;cat&quot;, &quot;/dev/null&quot;], [/* 22 vars */]) = 0</span><br><span class=\"line\">brk(0)                                  = 0xab1000</span><br><span class=\"line\">access(&quot;/etc/ld.so.nohwcap&quot;, F_OK)      = -1 ENOENT (No such file or directory)</span><br><span class=\"line\">mmap(NULL, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7f29379a7000</span><br><span class=\"line\">access(&quot;/etc/ld.so.preload&quot;, R_OK)      = -1 ENOENT (No such file or directory)</span><br><span class=\"line\">...</span><br><span class=\"line\">brk(0) = 0xab1000</span><br><span class=\"line\">brk(0xad2000) = 0xad2000</span><br><span class=\"line\">fstat(1, &#123;st_mode=S_IFCHR|0620, st_rdev=makedev(136, 0), ...&#125;) = 0</span><br><span class=\"line\">open(&quot;/dev/null&quot;, O_RDONLY) = 3</span><br><span class=\"line\">fstat(3, &#123;st_mode=S_IFCHR|0666, st_rdev=makedev(1, 3), ...&#125;) = 0</span><br><span class=\"line\">read(3, &quot;&quot;, 32768) = 0</span><br><span class=\"line\">close(3) = 0</span><br><span class=\"line\">close(1) = 0</span><br><span class=\"line\">close(2) = 0</span><br><span class=\"line\">exit_group(0) = ?</span><br></pre></td></tr></table></figure>\n<p>每一行都是一条系统调用，等号左边是系统调用的函数名及其参数，右边是该调用的返回值。<br>strace 显示这些调用的参数并返回符号形式的值。strace 从内核接收信息，而且不需要以任何特殊的方式来构建内核。</p>\n<h2 id=\"strace参数\"><a href=\"#strace参数\" class=\"headerlink\" title=\"strace参数\"></a>strace参数</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-c 统计每一系统调用的所执行的时间,次数和出错的次数等.</span><br><span class=\"line\">-d 输出strace关于标准错误的调试信息.</span><br><span class=\"line\">-f 跟踪由fork调用所产生的子进程.</span><br><span class=\"line\">-ff 如果提供-o filename,则所有进程的跟踪结果输出到相应的filename.pid中,pid是各进程的进程号.</span><br><span class=\"line\">-F 尝试跟踪vfork调用.在-f时,vfork不被跟踪.</span><br><span class=\"line\">-h 输出简要的帮助信息.</span><br><span class=\"line\">-i 输出系统调用的入口指针.</span><br><span class=\"line\">-q 禁止输出关于脱离的消息.</span><br><span class=\"line\">-r 打印出相对时间关于,,每一个系统调用.</span><br><span class=\"line\">-t 在输出中的每一行前加上时间信息.</span><br><span class=\"line\">-tt 在输出中的每一行前加上时间信息,微秒级.</span><br><span class=\"line\">-ttt 微秒级输出,以秒了表示时间.</span><br><span class=\"line\">-T 显示每一调用所耗的时间.</span><br><span class=\"line\">-v 输出所有的系统调用.一些调用关于环境变量,状态,输入输出等调用由于使用频繁,默认不输出.</span><br><span class=\"line\">-V 输出strace的版本信息.</span><br><span class=\"line\">-x 以十六进制形式输出非标准字符串</span><br><span class=\"line\">-xx 所有字符串以十六进制形式输出.</span><br><span class=\"line\">-a column</span><br><span class=\"line\">设置返回值的输出位置.默认 为40.</span><br><span class=\"line\">-e expr</span><br><span class=\"line\">指定一个表达式,用来控制如何跟踪.格式如下:</span><br><span class=\"line\">[qualifier=][!]value1[,value2]...</span><br><span class=\"line\">qualifier只能是 trace,abbrev,verbose,raw,signal,read,write其中之一.value是用来限定的符号或数字.默认的 qualifier是 trace.感叹号是否定符号.例如:</span><br><span class=\"line\">-eopen等价于 -e trace=open,表示只跟踪open调用.而-etrace!=open表示跟踪除了open以外的其他调用.有两个特殊的符号 all 和 none.</span><br><span class=\"line\">注意有些shell使用!来执行历史记录里的命令,所以要使用\\\\.</span><br><span class=\"line\">-e trace=set</span><br><span class=\"line\">只跟踪指定的系统 调用.例如:-e trace=open,close,rean,write表示只跟踪这四个系统调用.默认的为set=all.</span><br><span class=\"line\">-e trace=file</span><br><span class=\"line\">只跟踪有关文件操作的系统调用.</span><br><span class=\"line\">-e trace=process</span><br><span class=\"line\">只跟踪有关进程控制的系统调用.</span><br><span class=\"line\">-e trace=network</span><br><span class=\"line\">跟踪与网络有关的所有系统调用.</span><br><span class=\"line\">-e strace=signal</span><br><span class=\"line\">跟踪所有与系统信号有关的 系统调用</span><br><span class=\"line\">-e trace=ipc</span><br><span class=\"line\">跟踪所有与进程通讯有关的系统调用</span><br><span class=\"line\">-e abbrev=set</span><br><span class=\"line\">设定 strace输出的系统调用的结果集.-v 等与 abbrev=none.默认为abbrev=all.</span><br><span class=\"line\">-e raw=set</span><br><span class=\"line\">将指 定的系统调用的参数以十六进制显示.</span><br><span class=\"line\">-e signal=set</span><br><span class=\"line\">指定跟踪的系统信号.默认为all.如 signal=!SIGIO(或者signal=!io),表示不跟踪SIGIO信号.</span><br><span class=\"line\">-e read=set</span><br><span class=\"line\">输出从指定文件中读出 的数据.例如:</span><br><span class=\"line\">-e read=3,5</span><br><span class=\"line\">-e write=set</span><br><span class=\"line\">输出写入到指定文件中的数据.</span><br><span class=\"line\">-o filename</span><br><span class=\"line\">将strace的输出写入文件filename</span><br><span class=\"line\">-p pid</span><br><span class=\"line\">跟踪指定的进程pid.</span><br><span class=\"line\">-s strsize</span><br><span class=\"line\">指定输出的字符串的最大长度.默认为32.文件名一直全部输出.</span><br><span class=\"line\">-u username</span><br><span class=\"line\">以username 的UID和GID执行被跟踪的命令</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"命令实例\"><a href=\"#命令实例\" class=\"headerlink\" title=\"命令实例\"></a>命令实例</h2><p>通用的完整用法：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">strace -o output.txt -T -tt -e trace=all -p 28979</span><br></pre></td></tr></table></figure>\n<p>上面的含义是 跟踪28979进程的所有系统调用（-e trace=all），并统计系统调用的花费时间，以及开始时间（并以可视化的时分秒格式显示），最后将记录结果存在output.txt文件里面。</p>\n<h2 id=\"限制strace只跟踪特定的系统调用\"><a href=\"#限制strace只跟踪特定的系统调用\" class=\"headerlink\" title=\"限制strace只跟踪特定的系统调用\"></a>限制strace只跟踪特定的系统调用</h2><p>如果你已经知道你要找什么，你可以让strace只跟踪一些类型的系统调用。例如，你需要看看在configure脚本里面执行的程序，你需要监视的系统调 用就是execve。让strace只记录execve的调用用这个命令：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">strace -f -o configure-strace.txt -e execve ./configure</span><br></pre></td></tr></table></figure>\n\n<hr>\n<p>精品博文转自： <a href=\"http://www.cnblogs.com/ggjucheng/archive/2012/01/08/2316692.html\">http://www.cnblogs.com/ggjucheng/archive/2012/01/08/2316692.html</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><p>strace常用来跟踪进程执行时的系统调用和所接收的信号。 在Linux世界，进程不能直接访问硬件设备，当进程需要访问硬件设备(比如读取磁盘文件，接收网络数据等等)时，必须由用户态模式切换至内核态模式，通 过系统调用访问硬件设备。strace可以跟踪到一个进程产生的系统调用,包括参数，返回值，执行消耗的时间。</p>\n<h2 id=\"输出参数含义\"><a href=\"#输出参数含义\" class=\"headerlink\" title=\"输出参数含义\"></a>输出参数含义</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">root@ubuntu:/usr# strace cat /dev/null</span><br><span class=\"line\">execve(&quot;/bin/cat&quot;, [&quot;cat&quot;, &quot;/dev/null&quot;], [/* 22 vars */]) = 0</span><br><span class=\"line\">brk(0)                                  = 0xab1000</span><br><span class=\"line\">access(&quot;/etc/ld.so.nohwcap&quot;, F_OK)      = -1 ENOENT (No such file or directory)</span><br><span class=\"line\">mmap(NULL, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7f29379a7000</span><br><span class=\"line\">access(&quot;/etc/ld.so.preload&quot;, R_OK)      = -1 ENOENT (No such file or directory)</span><br><span class=\"line\">...</span><br><span class=\"line\">brk(0) = 0xab1000</span><br><span class=\"line\">brk(0xad2000) = 0xad2000</span><br><span class=\"line\">fstat(1, &#123;st_mode=S_IFCHR|0620, st_rdev=makedev(136, 0), ...&#125;) = 0</span><br><span class=\"line\">open(&quot;/dev/null&quot;, O_RDONLY) = 3</span><br><span class=\"line\">fstat(3, &#123;st_mode=S_IFCHR|0666, st_rdev=makedev(1, 3), ...&#125;) = 0</span><br><span class=\"line\">read(3, &quot;&quot;, 32768) = 0</span><br><span class=\"line\">close(3) = 0</span><br><span class=\"line\">close(1) = 0</span><br><span class=\"line\">close(2) = 0</span><br><span class=\"line\">exit_group(0) = ?</span><br></pre></td></tr></table></figure>\n<p>每一行都是一条系统调用，等号左边是系统调用的函数名及其参数，右边是该调用的返回值。<br>strace 显示这些调用的参数并返回符号形式的值。strace 从内核接收信息，而且不需要以任何特殊的方式来构建内核。</p>\n<h2 id=\"strace参数\"><a href=\"#strace参数\" class=\"headerlink\" title=\"strace参数\"></a>strace参数</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-c 统计每一系统调用的所执行的时间,次数和出错的次数等.</span><br><span class=\"line\">-d 输出strace关于标准错误的调试信息.</span><br><span class=\"line\">-f 跟踪由fork调用所产生的子进程.</span><br><span class=\"line\">-ff 如果提供-o filename,则所有进程的跟踪结果输出到相应的filename.pid中,pid是各进程的进程号.</span><br><span class=\"line\">-F 尝试跟踪vfork调用.在-f时,vfork不被跟踪.</span><br><span class=\"line\">-h 输出简要的帮助信息.</span><br><span class=\"line\">-i 输出系统调用的入口指针.</span><br><span class=\"line\">-q 禁止输出关于脱离的消息.</span><br><span class=\"line\">-r 打印出相对时间关于,,每一个系统调用.</span><br><span class=\"line\">-t 在输出中的每一行前加上时间信息.</span><br><span class=\"line\">-tt 在输出中的每一行前加上时间信息,微秒级.</span><br><span class=\"line\">-ttt 微秒级输出,以秒了表示时间.</span><br><span class=\"line\">-T 显示每一调用所耗的时间.</span><br><span class=\"line\">-v 输出所有的系统调用.一些调用关于环境变量,状态,输入输出等调用由于使用频繁,默认不输出.</span><br><span class=\"line\">-V 输出strace的版本信息.</span><br><span class=\"line\">-x 以十六进制形式输出非标准字符串</span><br><span class=\"line\">-xx 所有字符串以十六进制形式输出.</span><br><span class=\"line\">-a column</span><br><span class=\"line\">设置返回值的输出位置.默认 为40.</span><br><span class=\"line\">-e expr</span><br><span class=\"line\">指定一个表达式,用来控制如何跟踪.格式如下:</span><br><span class=\"line\">[qualifier=][!]value1[,value2]...</span><br><span class=\"line\">qualifier只能是 trace,abbrev,verbose,raw,signal,read,write其中之一.value是用来限定的符号或数字.默认的 qualifier是 trace.感叹号是否定符号.例如:</span><br><span class=\"line\">-eopen等价于 -e trace=open,表示只跟踪open调用.而-etrace!=open表示跟踪除了open以外的其他调用.有两个特殊的符号 all 和 none.</span><br><span class=\"line\">注意有些shell使用!来执行历史记录里的命令,所以要使用\\\\.</span><br><span class=\"line\">-e trace=set</span><br><span class=\"line\">只跟踪指定的系统 调用.例如:-e trace=open,close,rean,write表示只跟踪这四个系统调用.默认的为set=all.</span><br><span class=\"line\">-e trace=file</span><br><span class=\"line\">只跟踪有关文件操作的系统调用.</span><br><span class=\"line\">-e trace=process</span><br><span class=\"line\">只跟踪有关进程控制的系统调用.</span><br><span class=\"line\">-e trace=network</span><br><span class=\"line\">跟踪与网络有关的所有系统调用.</span><br><span class=\"line\">-e strace=signal</span><br><span class=\"line\">跟踪所有与系统信号有关的 系统调用</span><br><span class=\"line\">-e trace=ipc</span><br><span class=\"line\">跟踪所有与进程通讯有关的系统调用</span><br><span class=\"line\">-e abbrev=set</span><br><span class=\"line\">设定 strace输出的系统调用的结果集.-v 等与 abbrev=none.默认为abbrev=all.</span><br><span class=\"line\">-e raw=set</span><br><span class=\"line\">将指 定的系统调用的参数以十六进制显示.</span><br><span class=\"line\">-e signal=set</span><br><span class=\"line\">指定跟踪的系统信号.默认为all.如 signal=!SIGIO(或者signal=!io),表示不跟踪SIGIO信号.</span><br><span class=\"line\">-e read=set</span><br><span class=\"line\">输出从指定文件中读出 的数据.例如:</span><br><span class=\"line\">-e read=3,5</span><br><span class=\"line\">-e write=set</span><br><span class=\"line\">输出写入到指定文件中的数据.</span><br><span class=\"line\">-o filename</span><br><span class=\"line\">将strace的输出写入文件filename</span><br><span class=\"line\">-p pid</span><br><span class=\"line\">跟踪指定的进程pid.</span><br><span class=\"line\">-s strsize</span><br><span class=\"line\">指定输出的字符串的最大长度.默认为32.文件名一直全部输出.</span><br><span class=\"line\">-u username</span><br><span class=\"line\">以username 的UID和GID执行被跟踪的命令</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"命令实例\"><a href=\"#命令实例\" class=\"headerlink\" title=\"命令实例\"></a>命令实例</h2><p>通用的完整用法：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">strace -o output.txt -T -tt -e trace=all -p 28979</span><br></pre></td></tr></table></figure>\n<p>上面的含义是 跟踪28979进程的所有系统调用（-e trace=all），并统计系统调用的花费时间，以及开始时间（并以可视化的时分秒格式显示），最后将记录结果存在output.txt文件里面。</p>\n<h2 id=\"限制strace只跟踪特定的系统调用\"><a href=\"#限制strace只跟踪特定的系统调用\" class=\"headerlink\" title=\"限制strace只跟踪特定的系统调用\"></a>限制strace只跟踪特定的系统调用</h2><p>如果你已经知道你要找什么，你可以让strace只跟踪一些类型的系统调用。例如，你需要看看在configure脚本里面执行的程序，你需要监视的系统调 用就是execve。让strace只记录execve的调用用这个命令：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">strace -f -o configure-strace.txt -e execve ./configure</span><br></pre></td></tr></table></figure>\n\n<hr>\n<p>精品博文转自： <a href=\"http://www.cnblogs.com/ggjucheng/archive/2012/01/08/2316692.html\">http://www.cnblogs.com/ggjucheng/archive/2012/01/08/2316692.html</a></p>\n"},{"title":"Maven应用远程部署","keywords":["Maven应用发布","Maven deploy","远程发布","远程部署"],"date":"2016-05-26T08:51:51.000Z","_content":"\n## 简介\n在程序开发的过程中对研发环境服务器应用部署将会非常的频繁，而通过tomcat-maven-plugin的deploy很容易实现web应用的远程发布。\n而针对jar的发布一般会搭建maven私服，同样在研发阶段也会发布的非常频繁通过maven的deploy也非常容易实现maven私服的jar提交。\n\n## 远程发布Web应用\n以tomcat-maven-plugin为例，具体配置如下：\n_pom.xml_\n```\n<?xml version='1.0' encoding='utf-8'?>\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n    <build>\t\n    \t<plugins>\t\n    \t\t<plugin>\n                <groupId>org.apache.tomcat.maven</groupId>\n                <artifactId>tomcat7-maven-plugin</artifactId>\n                <version>2.2</version>\n                <configuration>\n                    <path>/</path>\n                    <port>8080</port>\n                    <uriEncoding>UTF-8</uriEncoding>\n                    <server>DevServer</server>\n                    <url>http://deploy.dev.com/manager</url>\n                </configuration>\n            </plugin>\n        </plugins>\n    </build>\n</project>\n```\n__说明:__\nserver: 为settings.xml中配置的server节点ID，用于上传鉴权。\nurl：发布到的服务器的tomcat/manager工程访问地址。\n\n_settings.xml_\n```\n<?xml version='1.0' encoding='utf-8'?>\n<settings xsi:schemaLocation=\"http://maven.apache.org/SETTINGS/1.1.0 http://maven.apache.org/xsd/settings-1.1.0.xsd\" xmlns=\"http://maven.apache.org/SETTINGS/1.1.0\"\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\">\n    <servers>\n\t    <server>\n\t    \t<id>DevServer</id>\n\t      \t<username>abc</username>\n\t        <password>xxx</password>\n\t    </server>\n    </servers>\n</settings>\n```\n_tomcat-users.xml_\n```\n<?xml version='1.0' encoding='utf-8'?>\n<tomcat-users>\n<role rolename=\"manager-gui\" />\n<role rolename=\"manager-script\" />\n<user username=\"abc\" password=\"xxx\" roles=\"manager-gui,manager-script\"/>\n</tomcat-users>\n```\n\n--[更新] 发现更简便配置,详细如下：---\n将maven的pom.xml中将server节点直接替换成username与password节点，这样就不需要在setting.xml中进行配置了。\n_pom.xml_\n```\n<?xml version='1.0' encoding='utf-8'?>\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n    <build> \n      <plugins> \n        <plugin>\n                <groupId>org.apache.tomcat.maven</groupId>\n                <artifactId>tomcat7-maven-plugin</artifactId>\n                <version>2.2</version>\n                <configuration>\n                    <path>/</path>\n                    <port>8080</port>\n                    <uriEncoding>UTF-8</uriEncoding>\n                    <username>abc</username>\n                    <password>xxx</password>\n                    <url>http://deploy.dev.com/manager</url>\n                </configuration>\n            </plugin>\n        </plugins>\n    </build>\n</project>\n```\n\n## 远程发布依赖库jar\n_pom.xml_\n```\n<?xml version='1.0' encoding='utf-8'?>\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n    <distributionManagement>\n        <snapshotRepository>\n            <id>snapshots</id>\n            <name>libs-snapshot</name>\n            <url>http://mvn.code.com/artifactory/libs-snapshot-local</url>\n        </snapshotRepository>\n    </distributionManagement>\n</project>\n```\n__说明:__\nid: 表示配置的用户名和密码，这个ID在settings.xml里配置\nurl: 为私服上传地址。\n\n_settings.xml_\n```\n<?xml version='1.0' encoding='utf-8'?>\n<settings xsi:schemaLocation=\"http://maven.apache.org/SETTINGS/1.1.0 http://maven.apache.org/xsd/settings-1.1.0.xsd\" xmlns=\"http://maven.apache.org/SETTINGS/1.1.0\"\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\">\n    <servers>\n\t    <server>\n\t    \t<id>snapshots</id>\n\t      \t<username>abc</username>\n\t        <password>xxx</password>\n\t    </server>\n    </servers>\n</settings>\n```\n\n配置完成之后执行`maven deploy`就OK啦。\n\n-----\n\n*观点仅代表自己，期待你的留言。*","source":"_posts/maven-deploy.md","raw":"---\ntitle: Maven应用远程部署\nkeywords:\n  - \"Maven应用发布\"\n  - \"Maven deploy\"\n  - \"远程发布\"\n  - \"远程部署\"\ntags:\n  - 原创\n  - Maven\ndate: 2016-05-26 16:51:51\n---\n\n## 简介\n在程序开发的过程中对研发环境服务器应用部署将会非常的频繁，而通过tomcat-maven-plugin的deploy很容易实现web应用的远程发布。\n而针对jar的发布一般会搭建maven私服，同样在研发阶段也会发布的非常频繁通过maven的deploy也非常容易实现maven私服的jar提交。\n\n## 远程发布Web应用\n以tomcat-maven-plugin为例，具体配置如下：\n_pom.xml_\n```\n<?xml version='1.0' encoding='utf-8'?>\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n    <build>\t\n    \t<plugins>\t\n    \t\t<plugin>\n                <groupId>org.apache.tomcat.maven</groupId>\n                <artifactId>tomcat7-maven-plugin</artifactId>\n                <version>2.2</version>\n                <configuration>\n                    <path>/</path>\n                    <port>8080</port>\n                    <uriEncoding>UTF-8</uriEncoding>\n                    <server>DevServer</server>\n                    <url>http://deploy.dev.com/manager</url>\n                </configuration>\n            </plugin>\n        </plugins>\n    </build>\n</project>\n```\n__说明:__\nserver: 为settings.xml中配置的server节点ID，用于上传鉴权。\nurl：发布到的服务器的tomcat/manager工程访问地址。\n\n_settings.xml_\n```\n<?xml version='1.0' encoding='utf-8'?>\n<settings xsi:schemaLocation=\"http://maven.apache.org/SETTINGS/1.1.0 http://maven.apache.org/xsd/settings-1.1.0.xsd\" xmlns=\"http://maven.apache.org/SETTINGS/1.1.0\"\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\">\n    <servers>\n\t    <server>\n\t    \t<id>DevServer</id>\n\t      \t<username>abc</username>\n\t        <password>xxx</password>\n\t    </server>\n    </servers>\n</settings>\n```\n_tomcat-users.xml_\n```\n<?xml version='1.0' encoding='utf-8'?>\n<tomcat-users>\n<role rolename=\"manager-gui\" />\n<role rolename=\"manager-script\" />\n<user username=\"abc\" password=\"xxx\" roles=\"manager-gui,manager-script\"/>\n</tomcat-users>\n```\n\n--[更新] 发现更简便配置,详细如下：---\n将maven的pom.xml中将server节点直接替换成username与password节点，这样就不需要在setting.xml中进行配置了。\n_pom.xml_\n```\n<?xml version='1.0' encoding='utf-8'?>\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n    <build> \n      <plugins> \n        <plugin>\n                <groupId>org.apache.tomcat.maven</groupId>\n                <artifactId>tomcat7-maven-plugin</artifactId>\n                <version>2.2</version>\n                <configuration>\n                    <path>/</path>\n                    <port>8080</port>\n                    <uriEncoding>UTF-8</uriEncoding>\n                    <username>abc</username>\n                    <password>xxx</password>\n                    <url>http://deploy.dev.com/manager</url>\n                </configuration>\n            </plugin>\n        </plugins>\n    </build>\n</project>\n```\n\n## 远程发布依赖库jar\n_pom.xml_\n```\n<?xml version='1.0' encoding='utf-8'?>\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n    <distributionManagement>\n        <snapshotRepository>\n            <id>snapshots</id>\n            <name>libs-snapshot</name>\n            <url>http://mvn.code.com/artifactory/libs-snapshot-local</url>\n        </snapshotRepository>\n    </distributionManagement>\n</project>\n```\n__说明:__\nid: 表示配置的用户名和密码，这个ID在settings.xml里配置\nurl: 为私服上传地址。\n\n_settings.xml_\n```\n<?xml version='1.0' encoding='utf-8'?>\n<settings xsi:schemaLocation=\"http://maven.apache.org/SETTINGS/1.1.0 http://maven.apache.org/xsd/settings-1.1.0.xsd\" xmlns=\"http://maven.apache.org/SETTINGS/1.1.0\"\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\">\n    <servers>\n\t    <server>\n\t    \t<id>snapshots</id>\n\t      \t<username>abc</username>\n\t        <password>xxx</password>\n\t    </server>\n    </servers>\n</settings>\n```\n\n配置完成之后执行`maven deploy`就OK啦。\n\n-----\n\n*观点仅代表自己，期待你的留言。*","slug":"maven-deploy","published":1,"updated":"2021-08-31T14:23:11.546Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cku52dynj002sbbin9xho56ph","content":"<h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><p>在程序开发的过程中对研发环境服务器应用部署将会非常的频繁，而通过tomcat-maven-plugin的deploy很容易实现web应用的远程发布。<br>而针对jar的发布一般会搭建maven私服，同样在研发阶段也会发布的非常频繁通过maven的deploy也非常容易实现maven私服的jar提交。</p>\n<h2 id=\"远程发布Web应用\"><a href=\"#远程发布Web应用\" class=\"headerlink\" title=\"远程发布Web应用\"></a>远程发布Web应用</h2><p>以tomcat-maven-plugin为例，具体配置如下：<br><em>pom.xml</em></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?xml version=&#x27;1.0&#x27; encoding=&#x27;utf-8&#x27;?&gt;</span><br><span class=\"line\">&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class=\"line\">         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;</span><br><span class=\"line\">    &lt;build&gt;\t</span><br><span class=\"line\">    \t&lt;plugins&gt;\t</span><br><span class=\"line\">    \t\t&lt;plugin&gt;</span><br><span class=\"line\">                &lt;groupId&gt;org.apache.tomcat.maven&lt;/groupId&gt;</span><br><span class=\"line\">                &lt;artifactId&gt;tomcat7-maven-plugin&lt;/artifactId&gt;</span><br><span class=\"line\">                &lt;version&gt;2.2&lt;/version&gt;</span><br><span class=\"line\">                &lt;configuration&gt;</span><br><span class=\"line\">                    &lt;path&gt;/&lt;/path&gt;</span><br><span class=\"line\">                    &lt;port&gt;8080&lt;/port&gt;</span><br><span class=\"line\">                    &lt;uriEncoding&gt;UTF-8&lt;/uriEncoding&gt;</span><br><span class=\"line\">                    &lt;server&gt;DevServer&lt;/server&gt;</span><br><span class=\"line\">                    &lt;url&gt;http://deploy.dev.com/manager&lt;/url&gt;</span><br><span class=\"line\">                &lt;/configuration&gt;</span><br><span class=\"line\">            &lt;/plugin&gt;</span><br><span class=\"line\">        &lt;/plugins&gt;</span><br><span class=\"line\">    &lt;/build&gt;</span><br><span class=\"line\">&lt;/project&gt;</span><br></pre></td></tr></table></figure>\n<p><strong>说明:</strong><br>server: 为settings.xml中配置的server节点ID，用于上传鉴权。<br>url：发布到的服务器的tomcat/manager工程访问地址。</p>\n<p><em>settings.xml</em></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?xml version=&#x27;1.0&#x27; encoding=&#x27;utf-8&#x27;?&gt;</span><br><span class=\"line\">&lt;settings xsi:schemaLocation=&quot;http://maven.apache.org/SETTINGS/1.1.0 http://maven.apache.org/xsd/settings-1.1.0.xsd&quot; xmlns=&quot;http://maven.apache.org/SETTINGS/1.1.0&quot;</span><br><span class=\"line\">    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&gt;</span><br><span class=\"line\">    &lt;servers&gt;</span><br><span class=\"line\">\t    &lt;server&gt;</span><br><span class=\"line\">\t    \t&lt;id&gt;DevServer&lt;/id&gt;</span><br><span class=\"line\">\t      \t&lt;username&gt;abc&lt;/username&gt;</span><br><span class=\"line\">\t        &lt;password&gt;xxx&lt;/password&gt;</span><br><span class=\"line\">\t    &lt;/server&gt;</span><br><span class=\"line\">    &lt;/servers&gt;</span><br><span class=\"line\">&lt;/settings&gt;</span><br></pre></td></tr></table></figure>\n<p><em>tomcat-users.xml</em></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?xml version=&#x27;1.0&#x27; encoding=&#x27;utf-8&#x27;?&gt;</span><br><span class=\"line\">&lt;tomcat-users&gt;</span><br><span class=\"line\">&lt;role rolename=&quot;manager-gui&quot; /&gt;</span><br><span class=\"line\">&lt;role rolename=&quot;manager-script&quot; /&gt;</span><br><span class=\"line\">&lt;user username=&quot;abc&quot; password=&quot;xxx&quot; roles=&quot;manager-gui,manager-script&quot;/&gt;</span><br><span class=\"line\">&lt;/tomcat-users&gt;</span><br></pre></td></tr></table></figure>\n\n<p>–[更新] 发现更简便配置,详细如下：—<br>将maven的pom.xml中将server节点直接替换成username与password节点，这样就不需要在setting.xml中进行配置了。<br><em>pom.xml</em></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?xml version=&#x27;1.0&#x27; encoding=&#x27;utf-8&#x27;?&gt;</span><br><span class=\"line\">&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class=\"line\">         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;</span><br><span class=\"line\">    &lt;build&gt; </span><br><span class=\"line\">      &lt;plugins&gt; </span><br><span class=\"line\">        &lt;plugin&gt;</span><br><span class=\"line\">                &lt;groupId&gt;org.apache.tomcat.maven&lt;/groupId&gt;</span><br><span class=\"line\">                &lt;artifactId&gt;tomcat7-maven-plugin&lt;/artifactId&gt;</span><br><span class=\"line\">                &lt;version&gt;2.2&lt;/version&gt;</span><br><span class=\"line\">                &lt;configuration&gt;</span><br><span class=\"line\">                    &lt;path&gt;/&lt;/path&gt;</span><br><span class=\"line\">                    &lt;port&gt;8080&lt;/port&gt;</span><br><span class=\"line\">                    &lt;uriEncoding&gt;UTF-8&lt;/uriEncoding&gt;</span><br><span class=\"line\">                    &lt;username&gt;abc&lt;/username&gt;</span><br><span class=\"line\">                    &lt;password&gt;xxx&lt;/password&gt;</span><br><span class=\"line\">                    &lt;url&gt;http://deploy.dev.com/manager&lt;/url&gt;</span><br><span class=\"line\">                &lt;/configuration&gt;</span><br><span class=\"line\">            &lt;/plugin&gt;</span><br><span class=\"line\">        &lt;/plugins&gt;</span><br><span class=\"line\">    &lt;/build&gt;</span><br><span class=\"line\">&lt;/project&gt;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"远程发布依赖库jar\"><a href=\"#远程发布依赖库jar\" class=\"headerlink\" title=\"远程发布依赖库jar\"></a>远程发布依赖库jar</h2><p><em>pom.xml</em></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?xml version=&#x27;1.0&#x27; encoding=&#x27;utf-8&#x27;?&gt;</span><br><span class=\"line\">&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class=\"line\">         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;</span><br><span class=\"line\">    &lt;distributionManagement&gt;</span><br><span class=\"line\">        &lt;snapshotRepository&gt;</span><br><span class=\"line\">            &lt;id&gt;snapshots&lt;/id&gt;</span><br><span class=\"line\">            &lt;name&gt;libs-snapshot&lt;/name&gt;</span><br><span class=\"line\">            &lt;url&gt;http://mvn.code.com/artifactory/libs-snapshot-local&lt;/url&gt;</span><br><span class=\"line\">        &lt;/snapshotRepository&gt;</span><br><span class=\"line\">    &lt;/distributionManagement&gt;</span><br><span class=\"line\">&lt;/project&gt;</span><br></pre></td></tr></table></figure>\n<p><strong>说明:</strong><br>id: 表示配置的用户名和密码，这个ID在settings.xml里配置<br>url: 为私服上传地址。</p>\n<p><em>settings.xml</em></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?xml version=&#x27;1.0&#x27; encoding=&#x27;utf-8&#x27;?&gt;</span><br><span class=\"line\">&lt;settings xsi:schemaLocation=&quot;http://maven.apache.org/SETTINGS/1.1.0 http://maven.apache.org/xsd/settings-1.1.0.xsd&quot; xmlns=&quot;http://maven.apache.org/SETTINGS/1.1.0&quot;</span><br><span class=\"line\">    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&gt;</span><br><span class=\"line\">    &lt;servers&gt;</span><br><span class=\"line\">\t    &lt;server&gt;</span><br><span class=\"line\">\t    \t&lt;id&gt;snapshots&lt;/id&gt;</span><br><span class=\"line\">\t      \t&lt;username&gt;abc&lt;/username&gt;</span><br><span class=\"line\">\t        &lt;password&gt;xxx&lt;/password&gt;</span><br><span class=\"line\">\t    &lt;/server&gt;</span><br><span class=\"line\">    &lt;/servers&gt;</span><br><span class=\"line\">&lt;/settings&gt;</span><br></pre></td></tr></table></figure>\n\n<p>配置完成之后执行<code>maven deploy</code>就OK啦。</p>\n<hr>\n<p><em>观点仅代表自己，期待你的留言。</em></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><p>在程序开发的过程中对研发环境服务器应用部署将会非常的频繁，而通过tomcat-maven-plugin的deploy很容易实现web应用的远程发布。<br>而针对jar的发布一般会搭建maven私服，同样在研发阶段也会发布的非常频繁通过maven的deploy也非常容易实现maven私服的jar提交。</p>\n<h2 id=\"远程发布Web应用\"><a href=\"#远程发布Web应用\" class=\"headerlink\" title=\"远程发布Web应用\"></a>远程发布Web应用</h2><p>以tomcat-maven-plugin为例，具体配置如下：<br><em>pom.xml</em></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?xml version=&#x27;1.0&#x27; encoding=&#x27;utf-8&#x27;?&gt;</span><br><span class=\"line\">&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class=\"line\">         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;</span><br><span class=\"line\">    &lt;build&gt;\t</span><br><span class=\"line\">    \t&lt;plugins&gt;\t</span><br><span class=\"line\">    \t\t&lt;plugin&gt;</span><br><span class=\"line\">                &lt;groupId&gt;org.apache.tomcat.maven&lt;/groupId&gt;</span><br><span class=\"line\">                &lt;artifactId&gt;tomcat7-maven-plugin&lt;/artifactId&gt;</span><br><span class=\"line\">                &lt;version&gt;2.2&lt;/version&gt;</span><br><span class=\"line\">                &lt;configuration&gt;</span><br><span class=\"line\">                    &lt;path&gt;/&lt;/path&gt;</span><br><span class=\"line\">                    &lt;port&gt;8080&lt;/port&gt;</span><br><span class=\"line\">                    &lt;uriEncoding&gt;UTF-8&lt;/uriEncoding&gt;</span><br><span class=\"line\">                    &lt;server&gt;DevServer&lt;/server&gt;</span><br><span class=\"line\">                    &lt;url&gt;http://deploy.dev.com/manager&lt;/url&gt;</span><br><span class=\"line\">                &lt;/configuration&gt;</span><br><span class=\"line\">            &lt;/plugin&gt;</span><br><span class=\"line\">        &lt;/plugins&gt;</span><br><span class=\"line\">    &lt;/build&gt;</span><br><span class=\"line\">&lt;/project&gt;</span><br></pre></td></tr></table></figure>\n<p><strong>说明:</strong><br>server: 为settings.xml中配置的server节点ID，用于上传鉴权。<br>url：发布到的服务器的tomcat/manager工程访问地址。</p>\n<p><em>settings.xml</em></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?xml version=&#x27;1.0&#x27; encoding=&#x27;utf-8&#x27;?&gt;</span><br><span class=\"line\">&lt;settings xsi:schemaLocation=&quot;http://maven.apache.org/SETTINGS/1.1.0 http://maven.apache.org/xsd/settings-1.1.0.xsd&quot; xmlns=&quot;http://maven.apache.org/SETTINGS/1.1.0&quot;</span><br><span class=\"line\">    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&gt;</span><br><span class=\"line\">    &lt;servers&gt;</span><br><span class=\"line\">\t    &lt;server&gt;</span><br><span class=\"line\">\t    \t&lt;id&gt;DevServer&lt;/id&gt;</span><br><span class=\"line\">\t      \t&lt;username&gt;abc&lt;/username&gt;</span><br><span class=\"line\">\t        &lt;password&gt;xxx&lt;/password&gt;</span><br><span class=\"line\">\t    &lt;/server&gt;</span><br><span class=\"line\">    &lt;/servers&gt;</span><br><span class=\"line\">&lt;/settings&gt;</span><br></pre></td></tr></table></figure>\n<p><em>tomcat-users.xml</em></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?xml version=&#x27;1.0&#x27; encoding=&#x27;utf-8&#x27;?&gt;</span><br><span class=\"line\">&lt;tomcat-users&gt;</span><br><span class=\"line\">&lt;role rolename=&quot;manager-gui&quot; /&gt;</span><br><span class=\"line\">&lt;role rolename=&quot;manager-script&quot; /&gt;</span><br><span class=\"line\">&lt;user username=&quot;abc&quot; password=&quot;xxx&quot; roles=&quot;manager-gui,manager-script&quot;/&gt;</span><br><span class=\"line\">&lt;/tomcat-users&gt;</span><br></pre></td></tr></table></figure>\n\n<p>–[更新] 发现更简便配置,详细如下：—<br>将maven的pom.xml中将server节点直接替换成username与password节点，这样就不需要在setting.xml中进行配置了。<br><em>pom.xml</em></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?xml version=&#x27;1.0&#x27; encoding=&#x27;utf-8&#x27;?&gt;</span><br><span class=\"line\">&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class=\"line\">         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;</span><br><span class=\"line\">    &lt;build&gt; </span><br><span class=\"line\">      &lt;plugins&gt; </span><br><span class=\"line\">        &lt;plugin&gt;</span><br><span class=\"line\">                &lt;groupId&gt;org.apache.tomcat.maven&lt;/groupId&gt;</span><br><span class=\"line\">                &lt;artifactId&gt;tomcat7-maven-plugin&lt;/artifactId&gt;</span><br><span class=\"line\">                &lt;version&gt;2.2&lt;/version&gt;</span><br><span class=\"line\">                &lt;configuration&gt;</span><br><span class=\"line\">                    &lt;path&gt;/&lt;/path&gt;</span><br><span class=\"line\">                    &lt;port&gt;8080&lt;/port&gt;</span><br><span class=\"line\">                    &lt;uriEncoding&gt;UTF-8&lt;/uriEncoding&gt;</span><br><span class=\"line\">                    &lt;username&gt;abc&lt;/username&gt;</span><br><span class=\"line\">                    &lt;password&gt;xxx&lt;/password&gt;</span><br><span class=\"line\">                    &lt;url&gt;http://deploy.dev.com/manager&lt;/url&gt;</span><br><span class=\"line\">                &lt;/configuration&gt;</span><br><span class=\"line\">            &lt;/plugin&gt;</span><br><span class=\"line\">        &lt;/plugins&gt;</span><br><span class=\"line\">    &lt;/build&gt;</span><br><span class=\"line\">&lt;/project&gt;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"远程发布依赖库jar\"><a href=\"#远程发布依赖库jar\" class=\"headerlink\" title=\"远程发布依赖库jar\"></a>远程发布依赖库jar</h2><p><em>pom.xml</em></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?xml version=&#x27;1.0&#x27; encoding=&#x27;utf-8&#x27;?&gt;</span><br><span class=\"line\">&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class=\"line\">         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;</span><br><span class=\"line\">    &lt;distributionManagement&gt;</span><br><span class=\"line\">        &lt;snapshotRepository&gt;</span><br><span class=\"line\">            &lt;id&gt;snapshots&lt;/id&gt;</span><br><span class=\"line\">            &lt;name&gt;libs-snapshot&lt;/name&gt;</span><br><span class=\"line\">            &lt;url&gt;http://mvn.code.com/artifactory/libs-snapshot-local&lt;/url&gt;</span><br><span class=\"line\">        &lt;/snapshotRepository&gt;</span><br><span class=\"line\">    &lt;/distributionManagement&gt;</span><br><span class=\"line\">&lt;/project&gt;</span><br></pre></td></tr></table></figure>\n<p><strong>说明:</strong><br>id: 表示配置的用户名和密码，这个ID在settings.xml里配置<br>url: 为私服上传地址。</p>\n<p><em>settings.xml</em></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?xml version=&#x27;1.0&#x27; encoding=&#x27;utf-8&#x27;?&gt;</span><br><span class=\"line\">&lt;settings xsi:schemaLocation=&quot;http://maven.apache.org/SETTINGS/1.1.0 http://maven.apache.org/xsd/settings-1.1.0.xsd&quot; xmlns=&quot;http://maven.apache.org/SETTINGS/1.1.0&quot;</span><br><span class=\"line\">    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&gt;</span><br><span class=\"line\">    &lt;servers&gt;</span><br><span class=\"line\">\t    &lt;server&gt;</span><br><span class=\"line\">\t    \t&lt;id&gt;snapshots&lt;/id&gt;</span><br><span class=\"line\">\t      \t&lt;username&gt;abc&lt;/username&gt;</span><br><span class=\"line\">\t        &lt;password&gt;xxx&lt;/password&gt;</span><br><span class=\"line\">\t    &lt;/server&gt;</span><br><span class=\"line\">    &lt;/servers&gt;</span><br><span class=\"line\">&lt;/settings&gt;</span><br></pre></td></tr></table></figure>\n\n<p>配置完成之后执行<code>maven deploy</code>就OK啦。</p>\n<hr>\n<p><em>观点仅代表自己，期待你的留言。</em></p>\n"},{"title":"Maven应用发布之不同环境不同配置的实现","keywords":["Maven管理依赖","Maven多套环境打包","Maven Profile"],"date":"2016-05-26T08:15:01.000Z","_content":"\n## 简介\n一个应用程序从研发到发布一般需要经过三套环境（研发环境、测试环境、生产环境）甚至更多。针对这同的运行环境应用程序也需要一些不同的参数配置值（如果日志输出级别、数据库连接池配置等）。\nMaven的Profile配置很好的解决这一问题。在pom.xml中配置多套参数值，在程序打包__编译时期__通过部署环境对配置参数进行替换来完成。\n__注意:__当配置项找不到对应的配置值时会保持原样。\n## pom.xml多套参数配置\n以不同部署环境配置日志输出级别为例。\n```\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd\">\n    <properties>\n    \t<catalina.base>/app/servers/logs</catalina.base>\n    </properties>\n    <profiles>\n    \t<profile>\n            <id>dev</id>\n            <activation>\n                <activeByDefault>true</activeByDefault>\n            </activation>\n            <properties>\n                <catalina.log.priority>debug</catalina.log.priority>\n            </properties>\n        </profile>\n        <profile>\n            <id>test</id>\n            <properties>\n                <catalina.log.priority>warn</catalina.log.priority>\n            </properties>\n        </profile>\n    \t<profile>\n            <id>pro</id>\n            <properties>\n                <catalina.log.priority>error</catalina.log.priority>\n            </properties>\n        </profile>\n    </profiles>\n    <build>\n    \t<resources>\n            <resource>\n                <directory>src/main/resources</directory>\n                <filtering>true</filtering>\n            </resource>\n        </resources>\n    </build>\n</project>\n```\n__说明：__\n以上配置表示在编译时期对`src/main/resources`目录下配置文件中的`${catalina.log.priority}`和`${catalina.base}`进行替换。而catalina.base参数值不区分部署环境。\n编译开发环境的部署程序包命令如下：\n```\nJianjun:~ Jianjun$ mvn package –P dev\n```\n编译测试环境的部署程序包命令如下：\n```\nJianjun:~ Jianjun$ mvn package –P test\n```\n编译生产环境的部署程序包命令如下：\n```\nJianjun:~ Jianjun$ mvn package –P pro\n```\n如果不指-P参数，默认会使用dev的配置，由于dev节点配置了__activeByDefault__\n\n## 参数配置项太多\n当配置项太多之后我们可以通过外置properties文件来进行配置，而properties文件需要与pom.xml在同一路径下。\nproperties配置如下：\n_product-deploy-config-dev.properties_\n```\ncatalina.log.priority=debug\n```\n_product-deploy-config-test.properties_\n```\ncatalina.log.priority=warn\n```\n_product-deploy-config-pro.properties_\n```\ncatalina.log.priority=error\n```\npom.xml配置如下：\n```\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd\">\n    <properties>\n    \t<catalina.base>/app/servers/logs</catalina.base>\n    </properties>\n    <profiles>\n    \t<profile>\n            <id>dev</id>\n            <activation>\n                <activeByDefault>true</activeByDefault>\n            </activation>\n            <build>\n            \t<filters>\n            \t\t<filter>product-deploy-config-dev.properties</filter>\n\t\t\t\t</filters>\n            </build>\n        </profile>\n        <profile>\n            <id>test</id>\n            <build>\n            \t<filters>\n\t\t\t\t\t<filter>product-deploy-config-test.properties</filter>\n\t\t\t\t</filters>\n            </build>\n        </profile>\n    \t<profile>\n            <id>pro</id>\n            <build>\n            \t<filters>\n\t\t\t\t\t<filter>product-deploy-config-pro.properties</filter>\n\t\t\t\t</filters>\n            </build>\n        </profile>\n    </profiles>\n    <build>\n    \t<resources>\n            <resource>\n                <directory>src/main/resources</directory>\n                <filtering>true</filtering>\n            </resource>\n        </resources>\n    </build>\n</project>\n```\n\n-----\n\n*观点仅代表自己，期待你的留言。*","source":"_posts/maven-profile.md","raw":"---\ntitle: Maven应用发布之不同环境不同配置的实现\nkeywords:\n  - \"Maven管理依赖\"\n  - \"Maven多套环境打包\"\n  - \"Maven Profile\"\ntags:\n  - 原创\n  - Maven\ndate: 2016-05-26 16:15:01\n---\n\n## 简介\n一个应用程序从研发到发布一般需要经过三套环境（研发环境、测试环境、生产环境）甚至更多。针对这同的运行环境应用程序也需要一些不同的参数配置值（如果日志输出级别、数据库连接池配置等）。\nMaven的Profile配置很好的解决这一问题。在pom.xml中配置多套参数值，在程序打包__编译时期__通过部署环境对配置参数进行替换来完成。\n__注意:__当配置项找不到对应的配置值时会保持原样。\n## pom.xml多套参数配置\n以不同部署环境配置日志输出级别为例。\n```\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd\">\n    <properties>\n    \t<catalina.base>/app/servers/logs</catalina.base>\n    </properties>\n    <profiles>\n    \t<profile>\n            <id>dev</id>\n            <activation>\n                <activeByDefault>true</activeByDefault>\n            </activation>\n            <properties>\n                <catalina.log.priority>debug</catalina.log.priority>\n            </properties>\n        </profile>\n        <profile>\n            <id>test</id>\n            <properties>\n                <catalina.log.priority>warn</catalina.log.priority>\n            </properties>\n        </profile>\n    \t<profile>\n            <id>pro</id>\n            <properties>\n                <catalina.log.priority>error</catalina.log.priority>\n            </properties>\n        </profile>\n    </profiles>\n    <build>\n    \t<resources>\n            <resource>\n                <directory>src/main/resources</directory>\n                <filtering>true</filtering>\n            </resource>\n        </resources>\n    </build>\n</project>\n```\n__说明：__\n以上配置表示在编译时期对`src/main/resources`目录下配置文件中的`${catalina.log.priority}`和`${catalina.base}`进行替换。而catalina.base参数值不区分部署环境。\n编译开发环境的部署程序包命令如下：\n```\nJianjun:~ Jianjun$ mvn package –P dev\n```\n编译测试环境的部署程序包命令如下：\n```\nJianjun:~ Jianjun$ mvn package –P test\n```\n编译生产环境的部署程序包命令如下：\n```\nJianjun:~ Jianjun$ mvn package –P pro\n```\n如果不指-P参数，默认会使用dev的配置，由于dev节点配置了__activeByDefault__\n\n## 参数配置项太多\n当配置项太多之后我们可以通过外置properties文件来进行配置，而properties文件需要与pom.xml在同一路径下。\nproperties配置如下：\n_product-deploy-config-dev.properties_\n```\ncatalina.log.priority=debug\n```\n_product-deploy-config-test.properties_\n```\ncatalina.log.priority=warn\n```\n_product-deploy-config-pro.properties_\n```\ncatalina.log.priority=error\n```\npom.xml配置如下：\n```\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd\">\n    <properties>\n    \t<catalina.base>/app/servers/logs</catalina.base>\n    </properties>\n    <profiles>\n    \t<profile>\n            <id>dev</id>\n            <activation>\n                <activeByDefault>true</activeByDefault>\n            </activation>\n            <build>\n            \t<filters>\n            \t\t<filter>product-deploy-config-dev.properties</filter>\n\t\t\t\t</filters>\n            </build>\n        </profile>\n        <profile>\n            <id>test</id>\n            <build>\n            \t<filters>\n\t\t\t\t\t<filter>product-deploy-config-test.properties</filter>\n\t\t\t\t</filters>\n            </build>\n        </profile>\n    \t<profile>\n            <id>pro</id>\n            <build>\n            \t<filters>\n\t\t\t\t\t<filter>product-deploy-config-pro.properties</filter>\n\t\t\t\t</filters>\n            </build>\n        </profile>\n    </profiles>\n    <build>\n    \t<resources>\n            <resource>\n                <directory>src/main/resources</directory>\n                <filtering>true</filtering>\n            </resource>\n        </resources>\n    </build>\n</project>\n```\n\n-----\n\n*观点仅代表自己，期待你的留言。*","slug":"maven-profile","published":1,"updated":"2021-08-31T14:23:11.546Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cku52dyno002ubbinhupu3bqp","content":"<h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><p>一个应用程序从研发到发布一般需要经过三套环境（研发环境、测试环境、生产环境）甚至更多。针对这同的运行环境应用程序也需要一些不同的参数配置值（如果日志输出级别、数据库连接池配置等）。<br>Maven的Profile配置很好的解决这一问题。在pom.xml中配置多套参数值，在程序打包__编译时期__通过部署环境对配置参数进行替换来完成。<br>__注意:__当配置项找不到对应的配置值时会保持原样。</p>\n<h2 id=\"pom-xml多套参数配置\"><a href=\"#pom-xml多套参数配置\" class=\"headerlink\" title=\"pom.xml多套参数配置\"></a>pom.xml多套参数配置</h2><p>以不同部署环境配置日志输出级别为例。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class=\"line\">         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd&quot;&gt;</span><br><span class=\"line\">    &lt;properties&gt;</span><br><span class=\"line\">    \t&lt;catalina.base&gt;/app/servers/logs&lt;/catalina.base&gt;</span><br><span class=\"line\">    &lt;/properties&gt;</span><br><span class=\"line\">    &lt;profiles&gt;</span><br><span class=\"line\">    \t&lt;profile&gt;</span><br><span class=\"line\">            &lt;id&gt;dev&lt;/id&gt;</span><br><span class=\"line\">            &lt;activation&gt;</span><br><span class=\"line\">                &lt;activeByDefault&gt;true&lt;/activeByDefault&gt;</span><br><span class=\"line\">            &lt;/activation&gt;</span><br><span class=\"line\">            &lt;properties&gt;</span><br><span class=\"line\">                &lt;catalina.log.priority&gt;debug&lt;/catalina.log.priority&gt;</span><br><span class=\"line\">            &lt;/properties&gt;</span><br><span class=\"line\">        &lt;/profile&gt;</span><br><span class=\"line\">        &lt;profile&gt;</span><br><span class=\"line\">            &lt;id&gt;test&lt;/id&gt;</span><br><span class=\"line\">            &lt;properties&gt;</span><br><span class=\"line\">                &lt;catalina.log.priority&gt;warn&lt;/catalina.log.priority&gt;</span><br><span class=\"line\">            &lt;/properties&gt;</span><br><span class=\"line\">        &lt;/profile&gt;</span><br><span class=\"line\">    \t&lt;profile&gt;</span><br><span class=\"line\">            &lt;id&gt;pro&lt;/id&gt;</span><br><span class=\"line\">            &lt;properties&gt;</span><br><span class=\"line\">                &lt;catalina.log.priority&gt;error&lt;/catalina.log.priority&gt;</span><br><span class=\"line\">            &lt;/properties&gt;</span><br><span class=\"line\">        &lt;/profile&gt;</span><br><span class=\"line\">    &lt;/profiles&gt;</span><br><span class=\"line\">    &lt;build&gt;</span><br><span class=\"line\">    \t&lt;resources&gt;</span><br><span class=\"line\">            &lt;resource&gt;</span><br><span class=\"line\">                &lt;directory&gt;src/main/resources&lt;/directory&gt;</span><br><span class=\"line\">                &lt;filtering&gt;true&lt;/filtering&gt;</span><br><span class=\"line\">            &lt;/resource&gt;</span><br><span class=\"line\">        &lt;/resources&gt;</span><br><span class=\"line\">    &lt;/build&gt;</span><br><span class=\"line\">&lt;/project&gt;</span><br></pre></td></tr></table></figure>\n<p><strong>说明：</strong><br>以上配置表示在编译时期对<code>src/main/resources</code>目录下配置文件中的<code>$&#123;catalina.log.priority&#125;</code>和<code>$&#123;catalina.base&#125;</code>进行替换。而catalina.base参数值不区分部署环境。<br>编译开发环境的部署程序包命令如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Jianjun:~ Jianjun$ mvn package –P dev</span><br></pre></td></tr></table></figure>\n<p>编译测试环境的部署程序包命令如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Jianjun:~ Jianjun$ mvn package –P test</span><br></pre></td></tr></table></figure>\n<p>编译生产环境的部署程序包命令如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Jianjun:~ Jianjun$ mvn package –P pro</span><br></pre></td></tr></table></figure>\n<p>如果不指-P参数，默认会使用dev的配置，由于dev节点配置了__activeByDefault__</p>\n<h2 id=\"参数配置项太多\"><a href=\"#参数配置项太多\" class=\"headerlink\" title=\"参数配置项太多\"></a>参数配置项太多</h2><p>当配置项太多之后我们可以通过外置properties文件来进行配置，而properties文件需要与pom.xml在同一路径下。<br>properties配置如下：<br><em>product-deploy-config-dev.properties</em></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">catalina.log.priority=debug</span><br></pre></td></tr></table></figure>\n<p><em>product-deploy-config-test.properties</em></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">catalina.log.priority=warn</span><br></pre></td></tr></table></figure>\n<p><em>product-deploy-config-pro.properties</em></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">catalina.log.priority=error</span><br></pre></td></tr></table></figure>\n<p>pom.xml配置如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class=\"line\">         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd&quot;&gt;</span><br><span class=\"line\">    &lt;properties&gt;</span><br><span class=\"line\">    \t&lt;catalina.base&gt;/app/servers/logs&lt;/catalina.base&gt;</span><br><span class=\"line\">    &lt;/properties&gt;</span><br><span class=\"line\">    &lt;profiles&gt;</span><br><span class=\"line\">    \t&lt;profile&gt;</span><br><span class=\"line\">            &lt;id&gt;dev&lt;/id&gt;</span><br><span class=\"line\">            &lt;activation&gt;</span><br><span class=\"line\">                &lt;activeByDefault&gt;true&lt;/activeByDefault&gt;</span><br><span class=\"line\">            &lt;/activation&gt;</span><br><span class=\"line\">            &lt;build&gt;</span><br><span class=\"line\">            \t&lt;filters&gt;</span><br><span class=\"line\">            \t\t&lt;filter&gt;product-deploy-config-dev.properties&lt;/filter&gt;</span><br><span class=\"line\">\t\t\t\t&lt;/filters&gt;</span><br><span class=\"line\">            &lt;/build&gt;</span><br><span class=\"line\">        &lt;/profile&gt;</span><br><span class=\"line\">        &lt;profile&gt;</span><br><span class=\"line\">            &lt;id&gt;test&lt;/id&gt;</span><br><span class=\"line\">            &lt;build&gt;</span><br><span class=\"line\">            \t&lt;filters&gt;</span><br><span class=\"line\">\t\t\t\t\t&lt;filter&gt;product-deploy-config-test.properties&lt;/filter&gt;</span><br><span class=\"line\">\t\t\t\t&lt;/filters&gt;</span><br><span class=\"line\">            &lt;/build&gt;</span><br><span class=\"line\">        &lt;/profile&gt;</span><br><span class=\"line\">    \t&lt;profile&gt;</span><br><span class=\"line\">            &lt;id&gt;pro&lt;/id&gt;</span><br><span class=\"line\">            &lt;build&gt;</span><br><span class=\"line\">            \t&lt;filters&gt;</span><br><span class=\"line\">\t\t\t\t\t&lt;filter&gt;product-deploy-config-pro.properties&lt;/filter&gt;</span><br><span class=\"line\">\t\t\t\t&lt;/filters&gt;</span><br><span class=\"line\">            &lt;/build&gt;</span><br><span class=\"line\">        &lt;/profile&gt;</span><br><span class=\"line\">    &lt;/profiles&gt;</span><br><span class=\"line\">    &lt;build&gt;</span><br><span class=\"line\">    \t&lt;resources&gt;</span><br><span class=\"line\">            &lt;resource&gt;</span><br><span class=\"line\">                &lt;directory&gt;src/main/resources&lt;/directory&gt;</span><br><span class=\"line\">                &lt;filtering&gt;true&lt;/filtering&gt;</span><br><span class=\"line\">            &lt;/resource&gt;</span><br><span class=\"line\">        &lt;/resources&gt;</span><br><span class=\"line\">    &lt;/build&gt;</span><br><span class=\"line\">&lt;/project&gt;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<p><em>观点仅代表自己，期待你的留言。</em></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><p>一个应用程序从研发到发布一般需要经过三套环境（研发环境、测试环境、生产环境）甚至更多。针对这同的运行环境应用程序也需要一些不同的参数配置值（如果日志输出级别、数据库连接池配置等）。<br>Maven的Profile配置很好的解决这一问题。在pom.xml中配置多套参数值，在程序打包__编译时期__通过部署环境对配置参数进行替换来完成。<br>__注意:__当配置项找不到对应的配置值时会保持原样。</p>\n<h2 id=\"pom-xml多套参数配置\"><a href=\"#pom-xml多套参数配置\" class=\"headerlink\" title=\"pom.xml多套参数配置\"></a>pom.xml多套参数配置</h2><p>以不同部署环境配置日志输出级别为例。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class=\"line\">         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd&quot;&gt;</span><br><span class=\"line\">    &lt;properties&gt;</span><br><span class=\"line\">    \t&lt;catalina.base&gt;/app/servers/logs&lt;/catalina.base&gt;</span><br><span class=\"line\">    &lt;/properties&gt;</span><br><span class=\"line\">    &lt;profiles&gt;</span><br><span class=\"line\">    \t&lt;profile&gt;</span><br><span class=\"line\">            &lt;id&gt;dev&lt;/id&gt;</span><br><span class=\"line\">            &lt;activation&gt;</span><br><span class=\"line\">                &lt;activeByDefault&gt;true&lt;/activeByDefault&gt;</span><br><span class=\"line\">            &lt;/activation&gt;</span><br><span class=\"line\">            &lt;properties&gt;</span><br><span class=\"line\">                &lt;catalina.log.priority&gt;debug&lt;/catalina.log.priority&gt;</span><br><span class=\"line\">            &lt;/properties&gt;</span><br><span class=\"line\">        &lt;/profile&gt;</span><br><span class=\"line\">        &lt;profile&gt;</span><br><span class=\"line\">            &lt;id&gt;test&lt;/id&gt;</span><br><span class=\"line\">            &lt;properties&gt;</span><br><span class=\"line\">                &lt;catalina.log.priority&gt;warn&lt;/catalina.log.priority&gt;</span><br><span class=\"line\">            &lt;/properties&gt;</span><br><span class=\"line\">        &lt;/profile&gt;</span><br><span class=\"line\">    \t&lt;profile&gt;</span><br><span class=\"line\">            &lt;id&gt;pro&lt;/id&gt;</span><br><span class=\"line\">            &lt;properties&gt;</span><br><span class=\"line\">                &lt;catalina.log.priority&gt;error&lt;/catalina.log.priority&gt;</span><br><span class=\"line\">            &lt;/properties&gt;</span><br><span class=\"line\">        &lt;/profile&gt;</span><br><span class=\"line\">    &lt;/profiles&gt;</span><br><span class=\"line\">    &lt;build&gt;</span><br><span class=\"line\">    \t&lt;resources&gt;</span><br><span class=\"line\">            &lt;resource&gt;</span><br><span class=\"line\">                &lt;directory&gt;src/main/resources&lt;/directory&gt;</span><br><span class=\"line\">                &lt;filtering&gt;true&lt;/filtering&gt;</span><br><span class=\"line\">            &lt;/resource&gt;</span><br><span class=\"line\">        &lt;/resources&gt;</span><br><span class=\"line\">    &lt;/build&gt;</span><br><span class=\"line\">&lt;/project&gt;</span><br></pre></td></tr></table></figure>\n<p><strong>说明：</strong><br>以上配置表示在编译时期对<code>src/main/resources</code>目录下配置文件中的<code>$&#123;catalina.log.priority&#125;</code>和<code>$&#123;catalina.base&#125;</code>进行替换。而catalina.base参数值不区分部署环境。<br>编译开发环境的部署程序包命令如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Jianjun:~ Jianjun$ mvn package –P dev</span><br></pre></td></tr></table></figure>\n<p>编译测试环境的部署程序包命令如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Jianjun:~ Jianjun$ mvn package –P test</span><br></pre></td></tr></table></figure>\n<p>编译生产环境的部署程序包命令如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Jianjun:~ Jianjun$ mvn package –P pro</span><br></pre></td></tr></table></figure>\n<p>如果不指-P参数，默认会使用dev的配置，由于dev节点配置了__activeByDefault__</p>\n<h2 id=\"参数配置项太多\"><a href=\"#参数配置项太多\" class=\"headerlink\" title=\"参数配置项太多\"></a>参数配置项太多</h2><p>当配置项太多之后我们可以通过外置properties文件来进行配置，而properties文件需要与pom.xml在同一路径下。<br>properties配置如下：<br><em>product-deploy-config-dev.properties</em></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">catalina.log.priority=debug</span><br></pre></td></tr></table></figure>\n<p><em>product-deploy-config-test.properties</em></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">catalina.log.priority=warn</span><br></pre></td></tr></table></figure>\n<p><em>product-deploy-config-pro.properties</em></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">catalina.log.priority=error</span><br></pre></td></tr></table></figure>\n<p>pom.xml配置如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class=\"line\">         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd&quot;&gt;</span><br><span class=\"line\">    &lt;properties&gt;</span><br><span class=\"line\">    \t&lt;catalina.base&gt;/app/servers/logs&lt;/catalina.base&gt;</span><br><span class=\"line\">    &lt;/properties&gt;</span><br><span class=\"line\">    &lt;profiles&gt;</span><br><span class=\"line\">    \t&lt;profile&gt;</span><br><span class=\"line\">            &lt;id&gt;dev&lt;/id&gt;</span><br><span class=\"line\">            &lt;activation&gt;</span><br><span class=\"line\">                &lt;activeByDefault&gt;true&lt;/activeByDefault&gt;</span><br><span class=\"line\">            &lt;/activation&gt;</span><br><span class=\"line\">            &lt;build&gt;</span><br><span class=\"line\">            \t&lt;filters&gt;</span><br><span class=\"line\">            \t\t&lt;filter&gt;product-deploy-config-dev.properties&lt;/filter&gt;</span><br><span class=\"line\">\t\t\t\t&lt;/filters&gt;</span><br><span class=\"line\">            &lt;/build&gt;</span><br><span class=\"line\">        &lt;/profile&gt;</span><br><span class=\"line\">        &lt;profile&gt;</span><br><span class=\"line\">            &lt;id&gt;test&lt;/id&gt;</span><br><span class=\"line\">            &lt;build&gt;</span><br><span class=\"line\">            \t&lt;filters&gt;</span><br><span class=\"line\">\t\t\t\t\t&lt;filter&gt;product-deploy-config-test.properties&lt;/filter&gt;</span><br><span class=\"line\">\t\t\t\t&lt;/filters&gt;</span><br><span class=\"line\">            &lt;/build&gt;</span><br><span class=\"line\">        &lt;/profile&gt;</span><br><span class=\"line\">    \t&lt;profile&gt;</span><br><span class=\"line\">            &lt;id&gt;pro&lt;/id&gt;</span><br><span class=\"line\">            &lt;build&gt;</span><br><span class=\"line\">            \t&lt;filters&gt;</span><br><span class=\"line\">\t\t\t\t\t&lt;filter&gt;product-deploy-config-pro.properties&lt;/filter&gt;</span><br><span class=\"line\">\t\t\t\t&lt;/filters&gt;</span><br><span class=\"line\">            &lt;/build&gt;</span><br><span class=\"line\">        &lt;/profile&gt;</span><br><span class=\"line\">    &lt;/profiles&gt;</span><br><span class=\"line\">    &lt;build&gt;</span><br><span class=\"line\">    \t&lt;resources&gt;</span><br><span class=\"line\">            &lt;resource&gt;</span><br><span class=\"line\">                &lt;directory&gt;src/main/resources&lt;/directory&gt;</span><br><span class=\"line\">                &lt;filtering&gt;true&lt;/filtering&gt;</span><br><span class=\"line\">            &lt;/resource&gt;</span><br><span class=\"line\">        &lt;/resources&gt;</span><br><span class=\"line\">    &lt;/build&gt;</span><br><span class=\"line\">&lt;/project&gt;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<p><em>观点仅代表自己，期待你的留言。</em></p>\n"},{"title":"Maven打包source与javadoc","keywords":["Maven打包源码","Maven生成JavaDoc"],"date":"2016-06-12T10:30:13.000Z","_content":"\n_pom.xml_\n```xml\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n\t<build>\n        <plugins>\n            <plugin>\n                <groupId>org.apache.maven.plugins</groupId>\n                <artifactId>maven-source-plugin</artifactId>\n                <version>2.2.1</version>\n                <executions>\n                    <execution>\n                        <id>create-source</id><!--指定一个名字-->\n                        <phase>compile</phase><!--在编译阶段生成source包-->\n                        <goals>\n                            <goal>jar</goal><!--指定生成的文件为jar包-->\n                        </goals>\n                    </execution>\n                </executions>\n            </plugin>\n            <plugin>\n                <groupId>org.apache.maven.plugins</groupId>\n                <artifactId>maven-javadoc-plugin</artifactId>\n                <version>2.9.1</version>\n                <executions>\n                    <execution>\n                        <id>create-doc</id><!--指定一个名字-->\n                        <phase>compile</phase><!--在编译阶段生成javadoc包-->\n                        <goals>\n                            <goal>jar</goal><!--指定生成的文件为jar包-->\n                        </goals>\n                    </execution>\n                </executions>\n            </plugin>\n        </plugins>\n    </build>\n</project>\n```\n\n`结论：`由于指定插件在phase=compile时期生成源码与Javadoc，当执行完成编译后，会在target目录下生成三个文件,xxx.jar,xxx-javadoc.jar,xxx-sources.jar\n\n\n-----\n\n*观点仅代表自己，期待你的留言。*","source":"_posts/maven-source-doc.md","raw":"---\ntitle: Maven打包source与javadoc\nkeywords: \n  - Maven打包源码\n  - Maven生成JavaDoc\ntags:\n  - 原创\ndate: 2016-06-12 18:30:13\n---\n\n_pom.xml_\n```xml\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n\t<build>\n        <plugins>\n            <plugin>\n                <groupId>org.apache.maven.plugins</groupId>\n                <artifactId>maven-source-plugin</artifactId>\n                <version>2.2.1</version>\n                <executions>\n                    <execution>\n                        <id>create-source</id><!--指定一个名字-->\n                        <phase>compile</phase><!--在编译阶段生成source包-->\n                        <goals>\n                            <goal>jar</goal><!--指定生成的文件为jar包-->\n                        </goals>\n                    </execution>\n                </executions>\n            </plugin>\n            <plugin>\n                <groupId>org.apache.maven.plugins</groupId>\n                <artifactId>maven-javadoc-plugin</artifactId>\n                <version>2.9.1</version>\n                <executions>\n                    <execution>\n                        <id>create-doc</id><!--指定一个名字-->\n                        <phase>compile</phase><!--在编译阶段生成javadoc包-->\n                        <goals>\n                            <goal>jar</goal><!--指定生成的文件为jar包-->\n                        </goals>\n                    </execution>\n                </executions>\n            </plugin>\n        </plugins>\n    </build>\n</project>\n```\n\n`结论：`由于指定插件在phase=compile时期生成源码与Javadoc，当执行完成编译后，会在target目录下生成三个文件,xxx.jar,xxx-javadoc.jar,xxx-sources.jar\n\n\n-----\n\n*观点仅代表自己，期待你的留言。*","slug":"maven-source-doc","published":1,"updated":"2021-08-31T14:23:11.546Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cku52dynq002xbbin1b2ob86i","content":"<p><em>pom.xml</em></p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">project</span> <span class=\"attr\">xmlns</span>=<span class=\"string\">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class=\"attr\">xmlns:xsi</span>=<span class=\"string\">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span> <span class=\"attr\">xsi:schemaLocation</span>=<span class=\"string\">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">build</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">plugins</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">plugin</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.apache.maven.plugins<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>maven-source-plugin<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>2.2.1<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">executions</span>&gt;</span></span><br><span class=\"line\">                    <span class=\"tag\">&lt;<span class=\"name\">execution</span>&gt;</span></span><br><span class=\"line\">                        <span class=\"tag\">&lt;<span class=\"name\">id</span>&gt;</span>create-source<span class=\"tag\">&lt;/<span class=\"name\">id</span>&gt;</span><span class=\"comment\">&lt;!--指定一个名字--&gt;</span></span><br><span class=\"line\">                        <span class=\"tag\">&lt;<span class=\"name\">phase</span>&gt;</span>compile<span class=\"tag\">&lt;/<span class=\"name\">phase</span>&gt;</span><span class=\"comment\">&lt;!--在编译阶段生成source包--&gt;</span></span><br><span class=\"line\">                        <span class=\"tag\">&lt;<span class=\"name\">goals</span>&gt;</span></span><br><span class=\"line\">                            <span class=\"tag\">&lt;<span class=\"name\">goal</span>&gt;</span>jar<span class=\"tag\">&lt;/<span class=\"name\">goal</span>&gt;</span><span class=\"comment\">&lt;!--指定生成的文件为jar包--&gt;</span></span><br><span class=\"line\">                        <span class=\"tag\">&lt;/<span class=\"name\">goals</span>&gt;</span></span><br><span class=\"line\">                    <span class=\"tag\">&lt;/<span class=\"name\">execution</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;/<span class=\"name\">executions</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;/<span class=\"name\">plugin</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">plugin</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.apache.maven.plugins<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>maven-javadoc-plugin<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>2.9.1<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">executions</span>&gt;</span></span><br><span class=\"line\">                    <span class=\"tag\">&lt;<span class=\"name\">execution</span>&gt;</span></span><br><span class=\"line\">                        <span class=\"tag\">&lt;<span class=\"name\">id</span>&gt;</span>create-doc<span class=\"tag\">&lt;/<span class=\"name\">id</span>&gt;</span><span class=\"comment\">&lt;!--指定一个名字--&gt;</span></span><br><span class=\"line\">                        <span class=\"tag\">&lt;<span class=\"name\">phase</span>&gt;</span>compile<span class=\"tag\">&lt;/<span class=\"name\">phase</span>&gt;</span><span class=\"comment\">&lt;!--在编译阶段生成javadoc包--&gt;</span></span><br><span class=\"line\">                        <span class=\"tag\">&lt;<span class=\"name\">goals</span>&gt;</span></span><br><span class=\"line\">                            <span class=\"tag\">&lt;<span class=\"name\">goal</span>&gt;</span>jar<span class=\"tag\">&lt;/<span class=\"name\">goal</span>&gt;</span><span class=\"comment\">&lt;!--指定生成的文件为jar包--&gt;</span></span><br><span class=\"line\">                        <span class=\"tag\">&lt;/<span class=\"name\">goals</span>&gt;</span></span><br><span class=\"line\">                    <span class=\"tag\">&lt;/<span class=\"name\">execution</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;/<span class=\"name\">executions</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;/<span class=\"name\">plugin</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">plugins</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">build</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">project</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p><code>结论：</code>由于指定插件在phase=compile时期生成源码与Javadoc，当执行完成编译后，会在target目录下生成三个文件,xxx.jar,xxx-javadoc.jar,xxx-sources.jar</p>\n<hr>\n<p><em>观点仅代表自己，期待你的留言。</em></p>\n","site":{"data":{}},"excerpt":"","more":"<p><em>pom.xml</em></p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">project</span> <span class=\"attr\">xmlns</span>=<span class=\"string\">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class=\"attr\">xmlns:xsi</span>=<span class=\"string\">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span> <span class=\"attr\">xsi:schemaLocation</span>=<span class=\"string\">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">build</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">plugins</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">plugin</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.apache.maven.plugins<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>maven-source-plugin<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>2.2.1<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">executions</span>&gt;</span></span><br><span class=\"line\">                    <span class=\"tag\">&lt;<span class=\"name\">execution</span>&gt;</span></span><br><span class=\"line\">                        <span class=\"tag\">&lt;<span class=\"name\">id</span>&gt;</span>create-source<span class=\"tag\">&lt;/<span class=\"name\">id</span>&gt;</span><span class=\"comment\">&lt;!--指定一个名字--&gt;</span></span><br><span class=\"line\">                        <span class=\"tag\">&lt;<span class=\"name\">phase</span>&gt;</span>compile<span class=\"tag\">&lt;/<span class=\"name\">phase</span>&gt;</span><span class=\"comment\">&lt;!--在编译阶段生成source包--&gt;</span></span><br><span class=\"line\">                        <span class=\"tag\">&lt;<span class=\"name\">goals</span>&gt;</span></span><br><span class=\"line\">                            <span class=\"tag\">&lt;<span class=\"name\">goal</span>&gt;</span>jar<span class=\"tag\">&lt;/<span class=\"name\">goal</span>&gt;</span><span class=\"comment\">&lt;!--指定生成的文件为jar包--&gt;</span></span><br><span class=\"line\">                        <span class=\"tag\">&lt;/<span class=\"name\">goals</span>&gt;</span></span><br><span class=\"line\">                    <span class=\"tag\">&lt;/<span class=\"name\">execution</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;/<span class=\"name\">executions</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;/<span class=\"name\">plugin</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">plugin</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.apache.maven.plugins<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>maven-javadoc-plugin<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>2.9.1<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">executions</span>&gt;</span></span><br><span class=\"line\">                    <span class=\"tag\">&lt;<span class=\"name\">execution</span>&gt;</span></span><br><span class=\"line\">                        <span class=\"tag\">&lt;<span class=\"name\">id</span>&gt;</span>create-doc<span class=\"tag\">&lt;/<span class=\"name\">id</span>&gt;</span><span class=\"comment\">&lt;!--指定一个名字--&gt;</span></span><br><span class=\"line\">                        <span class=\"tag\">&lt;<span class=\"name\">phase</span>&gt;</span>compile<span class=\"tag\">&lt;/<span class=\"name\">phase</span>&gt;</span><span class=\"comment\">&lt;!--在编译阶段生成javadoc包--&gt;</span></span><br><span class=\"line\">                        <span class=\"tag\">&lt;<span class=\"name\">goals</span>&gt;</span></span><br><span class=\"line\">                            <span class=\"tag\">&lt;<span class=\"name\">goal</span>&gt;</span>jar<span class=\"tag\">&lt;/<span class=\"name\">goal</span>&gt;</span><span class=\"comment\">&lt;!--指定生成的文件为jar包--&gt;</span></span><br><span class=\"line\">                        <span class=\"tag\">&lt;/<span class=\"name\">goals</span>&gt;</span></span><br><span class=\"line\">                    <span class=\"tag\">&lt;/<span class=\"name\">execution</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;/<span class=\"name\">executions</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;/<span class=\"name\">plugin</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">plugins</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">build</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">project</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p><code>结论：</code>由于指定插件在phase=compile时期生成源码与Javadoc，当执行完成编译后，会在target目录下生成三个文件,xxx.jar,xxx-javadoc.jar,xxx-sources.jar</p>\n<hr>\n<p><em>观点仅代表自己，期待你的留言。</em></p>\n"},{"title":"同一微服务连接多套RocketMQ集群","date":"2018-08-22T03:11:03.000Z","_content":"\n## 需要实现的通讯消息架构\n![通讯消息连接架构](/images/multi-rocketmq-1.png)\n## 分析\n`注`:　以下分析均在rocketmq4.0.0-incubating源码上进行\n\norg.apache.rocketmq.client.impl.producer.DefaultMQProducerImpl#start(boolean)\n```java\npublic void start(final boolean startFactory) throws MQClientException {\n    switch (this.serviceState) {\n        case CREATE_JUST:\n            this.serviceState = ServiceState.START_FAILED;\n\n            this.checkConfig();\n\n            if (!this.defaultMQProducer.getProducerGroup().equals(MixAll.CLIENT_INNER_PRODUCER_GROUP)) {\n                this.defaultMQProducer.changeInstanceNameToPID();\n            }\n\n            this.mQClientFactory = MQClientManager.getInstance().getAndCreateMQClientInstance(this.defaultMQProducer, rpcHook);\n            // 从上一句可以看出：MQClientManager为Producer连接管理器，用户管理连接ＭQ的TCP客户端的连接\n\n            boolean registerOK = mQClientFactory.registerProducer(this.defaultMQProducer.getProducerGroup(), this);\n            if (!registerOK) {\n                this.serviceState = ServiceState.CREATE_JUST;\n                throw new MQClientException(\"The producer group[\" + this.defaultMQProducer.getProducerGroup()\n                    + \"] has been created before, specify another name please.\" + FAQUrl.suggestTodo(FAQUrl.GROUP_NAME_DUPLICATE_URL),\n                    null);\n            }\n\n            this.topicPublishInfoTable.put(this.defaultMQProducer.getCreateTopicKey(), new TopicPublishInfo());\n\n            if (startFactory) {\n                mQClientFactory.start();\n            }\n\n            log.info(\"the producer [{}] start OK. sendMessageWithVIPChannel={}\", this.defaultMQProducer.getProducerGroup(),\n                this.defaultMQProducer.isSendMessageWithVIPChannel());\n            this.serviceState = ServiceState.RUNNING;\n            break;\n        case RUNNING:\n        case START_FAILED:\n        case SHUTDOWN_ALREADY:\n            throw new MQClientException(\"The producer service state not OK, maybe started once, \"//\n                + this.serviceState//\n                + FAQUrl.suggestTodo(FAQUrl.CLIENT_SERVICE_NOT_OK),\n                null);\n        default:\n            break;\n    }\n\n    this.mQClientFactory.sendHeartbeatToAllBrokerWithLock();\n}\n```\n\norg.apache.rocketmq.client.impl.MQClientManager#getAndCreateMQClientInstance(org.apache.rocketmq.client.ClientConfig, org.apache.rocketmq.remoting.RPCHook)\n```java\npublic MQClientInstance getAndCreateMQClientInstance(final ClientConfig clientConfig, RPCHook rpcHook) {\n    String clientId = clientConfig.buildMQClientId();\n    MQClientInstance instance = this.factoryTable.get(clientId);\n    //　从上一句可以看出：找到对应的客户端通讯实例是通过一个clientId在factoryTable内存缓存中进行查询的\n\n    if (null == instance) {\n        instance =\n            new MQClientInstance(clientConfig.cloneClientConfig(),\n                this.factoryIndexGenerator.getAndIncrement(), clientId, rpcHook);\n        MQClientInstance prev = this.factoryTable.putIfAbsent(clientId, instance);\n        if (prev != null) {\n            instance = prev;\n            log.warn(\"Returned Previous MQClientInstance for clientId:[{}]\", clientId);\n        } else {\n            log.info(\"Created new MQClientInstance for clientId:[{}]\", clientId);\n        }\n    }\n\n    return instance;\n}\n```\n\norg.apache.rocketmq.client.ClientConfig#buildMQClientId\n```java\npublic String buildMQClientId() {\n    StringBuilder sb = new StringBuilder();\n    sb.append(this.getClientIP());\n\n    sb.append(\"@\");\n    sb.append(this.getInstanceName());\n    if (!UtilAll.isBlank(this.unitName)) {\n        sb.append(\"@\");\n        sb.append(this.unitName);\n    }\n\n    return sb.toString();\n}\n//　从以上方法可以看出：这个clientId信息中包含当前微服务的IP，当前模块实例名(默认通过changeInstanceNameToPID更改为进程ID值）和一个unitName\n```\n\n`结论`: 经以上源码可以得到一个模块需要连接多个RocketMQ集群，则需要生产多个MQClientInstance，换言之，则需要在获取MQClientInstance时传递不同的ClientID即可。\n      由于__ClientID=localIP + instanceName + unitName__，所以只需要创建Producer对象时传入不同的instanceName或unitName值即可。\n\n\n-----\n\n*观点仅代表自己，期待你的留言。*\n","source":"_posts/module-multi-rocketmq.md","raw":"---\ntitle: 同一微服务连接多套RocketMQ集群\ntags:\n  - 原创\n  - rocketmq\ndate: 2018-08-22 11:11:03\n---\n\n## 需要实现的通讯消息架构\n![通讯消息连接架构](/images/multi-rocketmq-1.png)\n## 分析\n`注`:　以下分析均在rocketmq4.0.0-incubating源码上进行\n\norg.apache.rocketmq.client.impl.producer.DefaultMQProducerImpl#start(boolean)\n```java\npublic void start(final boolean startFactory) throws MQClientException {\n    switch (this.serviceState) {\n        case CREATE_JUST:\n            this.serviceState = ServiceState.START_FAILED;\n\n            this.checkConfig();\n\n            if (!this.defaultMQProducer.getProducerGroup().equals(MixAll.CLIENT_INNER_PRODUCER_GROUP)) {\n                this.defaultMQProducer.changeInstanceNameToPID();\n            }\n\n            this.mQClientFactory = MQClientManager.getInstance().getAndCreateMQClientInstance(this.defaultMQProducer, rpcHook);\n            // 从上一句可以看出：MQClientManager为Producer连接管理器，用户管理连接ＭQ的TCP客户端的连接\n\n            boolean registerOK = mQClientFactory.registerProducer(this.defaultMQProducer.getProducerGroup(), this);\n            if (!registerOK) {\n                this.serviceState = ServiceState.CREATE_JUST;\n                throw new MQClientException(\"The producer group[\" + this.defaultMQProducer.getProducerGroup()\n                    + \"] has been created before, specify another name please.\" + FAQUrl.suggestTodo(FAQUrl.GROUP_NAME_DUPLICATE_URL),\n                    null);\n            }\n\n            this.topicPublishInfoTable.put(this.defaultMQProducer.getCreateTopicKey(), new TopicPublishInfo());\n\n            if (startFactory) {\n                mQClientFactory.start();\n            }\n\n            log.info(\"the producer [{}] start OK. sendMessageWithVIPChannel={}\", this.defaultMQProducer.getProducerGroup(),\n                this.defaultMQProducer.isSendMessageWithVIPChannel());\n            this.serviceState = ServiceState.RUNNING;\n            break;\n        case RUNNING:\n        case START_FAILED:\n        case SHUTDOWN_ALREADY:\n            throw new MQClientException(\"The producer service state not OK, maybe started once, \"//\n                + this.serviceState//\n                + FAQUrl.suggestTodo(FAQUrl.CLIENT_SERVICE_NOT_OK),\n                null);\n        default:\n            break;\n    }\n\n    this.mQClientFactory.sendHeartbeatToAllBrokerWithLock();\n}\n```\n\norg.apache.rocketmq.client.impl.MQClientManager#getAndCreateMQClientInstance(org.apache.rocketmq.client.ClientConfig, org.apache.rocketmq.remoting.RPCHook)\n```java\npublic MQClientInstance getAndCreateMQClientInstance(final ClientConfig clientConfig, RPCHook rpcHook) {\n    String clientId = clientConfig.buildMQClientId();\n    MQClientInstance instance = this.factoryTable.get(clientId);\n    //　从上一句可以看出：找到对应的客户端通讯实例是通过一个clientId在factoryTable内存缓存中进行查询的\n\n    if (null == instance) {\n        instance =\n            new MQClientInstance(clientConfig.cloneClientConfig(),\n                this.factoryIndexGenerator.getAndIncrement(), clientId, rpcHook);\n        MQClientInstance prev = this.factoryTable.putIfAbsent(clientId, instance);\n        if (prev != null) {\n            instance = prev;\n            log.warn(\"Returned Previous MQClientInstance for clientId:[{}]\", clientId);\n        } else {\n            log.info(\"Created new MQClientInstance for clientId:[{}]\", clientId);\n        }\n    }\n\n    return instance;\n}\n```\n\norg.apache.rocketmq.client.ClientConfig#buildMQClientId\n```java\npublic String buildMQClientId() {\n    StringBuilder sb = new StringBuilder();\n    sb.append(this.getClientIP());\n\n    sb.append(\"@\");\n    sb.append(this.getInstanceName());\n    if (!UtilAll.isBlank(this.unitName)) {\n        sb.append(\"@\");\n        sb.append(this.unitName);\n    }\n\n    return sb.toString();\n}\n//　从以上方法可以看出：这个clientId信息中包含当前微服务的IP，当前模块实例名(默认通过changeInstanceNameToPID更改为进程ID值）和一个unitName\n```\n\n`结论`: 经以上源码可以得到一个模块需要连接多个RocketMQ集群，则需要生产多个MQClientInstance，换言之，则需要在获取MQClientInstance时传递不同的ClientID即可。\n      由于__ClientID=localIP + instanceName + unitName__，所以只需要创建Producer对象时传入不同的instanceName或unitName值即可。\n\n\n-----\n\n*观点仅代表自己，期待你的留言。*\n","slug":"module-multi-rocketmq","published":1,"updated":"2021-08-31T14:23:11.546Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cku52dynr002zbbindeylda27","content":"<h2 id=\"需要实现的通讯消息架构\"><a href=\"#需要实现的通讯消息架构\" class=\"headerlink\" title=\"需要实现的通讯消息架构\"></a>需要实现的通讯消息架构</h2><p><img src=\"/images/multi-rocketmq-1.png\" alt=\"通讯消息连接架构\"></p>\n<h2 id=\"分析\"><a href=\"#分析\" class=\"headerlink\" title=\"分析\"></a>分析</h2><p><code>注</code>:　以下分析均在rocketmq4.0.0-incubating源码上进行</p>\n<p>org.apache.rocketmq.client.impl.producer.DefaultMQProducerImpl#start(boolean)</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">start</span><span class=\"params\">(<span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> startFactory)</span> <span class=\"keyword\">throws</span> MQClientException </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">switch</span> (<span class=\"keyword\">this</span>.serviceState) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> CREATE_JUST:</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.serviceState = ServiceState.START_FAILED;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">this</span>.checkConfig();</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!<span class=\"keyword\">this</span>.defaultMQProducer.getProducerGroup().equals(MixAll.CLIENT_INNER_PRODUCER_GROUP)) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">this</span>.defaultMQProducer.changeInstanceNameToPID();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">this</span>.mQClientFactory = MQClientManager.getInstance().getAndCreateMQClientInstance(<span class=\"keyword\">this</span>.defaultMQProducer, rpcHook);</span><br><span class=\"line\">            <span class=\"comment\">// 从上一句可以看出：MQClientManager为Producer连接管理器，用户管理连接ＭQ的TCP客户端的连接</span></span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">boolean</span> registerOK = mQClientFactory.registerProducer(<span class=\"keyword\">this</span>.defaultMQProducer.getProducerGroup(), <span class=\"keyword\">this</span>);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!registerOK) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">this</span>.serviceState = ServiceState.CREATE_JUST;</span><br><span class=\"line\">                <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> MQClientException(<span class=\"string\">&quot;The producer group[&quot;</span> + <span class=\"keyword\">this</span>.defaultMQProducer.getProducerGroup()</span><br><span class=\"line\">                    + <span class=\"string\">&quot;] has been created before, specify another name please.&quot;</span> + FAQUrl.suggestTodo(FAQUrl.GROUP_NAME_DUPLICATE_URL),</span><br><span class=\"line\">                    <span class=\"keyword\">null</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">this</span>.topicPublishInfoTable.put(<span class=\"keyword\">this</span>.defaultMQProducer.getCreateTopicKey(), <span class=\"keyword\">new</span> TopicPublishInfo());</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (startFactory) &#123;</span><br><span class=\"line\">                mQClientFactory.start();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            log.info(<span class=\"string\">&quot;the producer [&#123;&#125;] start OK. sendMessageWithVIPChannel=&#123;&#125;&quot;</span>, <span class=\"keyword\">this</span>.defaultMQProducer.getProducerGroup(),</span><br><span class=\"line\">                <span class=\"keyword\">this</span>.defaultMQProducer.isSendMessageWithVIPChannel());</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.serviceState = ServiceState.RUNNING;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> RUNNING:</span><br><span class=\"line\">        <span class=\"keyword\">case</span> START_FAILED:</span><br><span class=\"line\">        <span class=\"keyword\">case</span> SHUTDOWN_ALREADY:</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> MQClientException(<span class=\"string\">&quot;The producer service state not OK, maybe started once, &quot;</span><span class=\"comment\">//</span></span><br><span class=\"line\">                + <span class=\"keyword\">this</span>.serviceState<span class=\"comment\">//</span></span><br><span class=\"line\">                + FAQUrl.suggestTodo(FAQUrl.CLIENT_SERVICE_NOT_OK),</span><br><span class=\"line\">                <span class=\"keyword\">null</span>);</span><br><span class=\"line\">        <span class=\"keyword\">default</span>:</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.mQClientFactory.sendHeartbeatToAllBrokerWithLock();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>org.apache.rocketmq.client.impl.MQClientManager#getAndCreateMQClientInstance(org.apache.rocketmq.client.ClientConfig, org.apache.rocketmq.remoting.RPCHook)</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> MQClientInstance <span class=\"title\">getAndCreateMQClientInstance</span><span class=\"params\">(<span class=\"keyword\">final</span> ClientConfig clientConfig, RPCHook rpcHook)</span> </span>&#123;</span><br><span class=\"line\">    String clientId = clientConfig.buildMQClientId();</span><br><span class=\"line\">    MQClientInstance instance = <span class=\"keyword\">this</span>.factoryTable.get(clientId);</span><br><span class=\"line\">    <span class=\"comment\">//　从上一句可以看出：找到对应的客户端通讯实例是通过一个clientId在factoryTable内存缓存中进行查询的</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">null</span> == instance) &#123;</span><br><span class=\"line\">        instance =</span><br><span class=\"line\">            <span class=\"keyword\">new</span> MQClientInstance(clientConfig.cloneClientConfig(),</span><br><span class=\"line\">                <span class=\"keyword\">this</span>.factoryIndexGenerator.getAndIncrement(), clientId, rpcHook);</span><br><span class=\"line\">        MQClientInstance prev = <span class=\"keyword\">this</span>.factoryTable.putIfAbsent(clientId, instance);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (prev != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            instance = prev;</span><br><span class=\"line\">            log.warn(<span class=\"string\">&quot;Returned Previous MQClientInstance for clientId:[&#123;&#125;]&quot;</span>, clientId);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            log.info(<span class=\"string\">&quot;Created new MQClientInstance for clientId:[&#123;&#125;]&quot;</span>, clientId);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>org.apache.rocketmq.client.ClientConfig#buildMQClientId</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">buildMQClientId</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    StringBuilder sb = <span class=\"keyword\">new</span> StringBuilder();</span><br><span class=\"line\">    sb.append(<span class=\"keyword\">this</span>.getClientIP());</span><br><span class=\"line\"></span><br><span class=\"line\">    sb.append(<span class=\"string\">&quot;@&quot;</span>);</span><br><span class=\"line\">    sb.append(<span class=\"keyword\">this</span>.getInstanceName());</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!UtilAll.isBlank(<span class=\"keyword\">this</span>.unitName)) &#123;</span><br><span class=\"line\">        sb.append(<span class=\"string\">&quot;@&quot;</span>);</span><br><span class=\"line\">        sb.append(<span class=\"keyword\">this</span>.unitName);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> sb.toString();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//　从以上方法可以看出：这个clientId信息中包含当前微服务的IP，当前模块实例名(默认通过changeInstanceNameToPID更改为进程ID值）和一个unitName</span></span><br></pre></td></tr></table></figure>\n\n<p><code>结论</code>: 经以上源码可以得到一个模块需要连接多个RocketMQ集群，则需要生产多个MQClientInstance，换言之，则需要在获取MQClientInstance时传递不同的ClientID即可。<br>      由于__ClientID=localIP + instanceName + unitName__，所以只需要创建Producer对象时传入不同的instanceName或unitName值即可。</p>\n<hr>\n<p><em>观点仅代表自己，期待你的留言。</em></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"需要实现的通讯消息架构\"><a href=\"#需要实现的通讯消息架构\" class=\"headerlink\" title=\"需要实现的通讯消息架构\"></a>需要实现的通讯消息架构</h2><p><img src=\"/images/multi-rocketmq-1.png\" alt=\"通讯消息连接架构\"></p>\n<h2 id=\"分析\"><a href=\"#分析\" class=\"headerlink\" title=\"分析\"></a>分析</h2><p><code>注</code>:　以下分析均在rocketmq4.0.0-incubating源码上进行</p>\n<p>org.apache.rocketmq.client.impl.producer.DefaultMQProducerImpl#start(boolean)</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">start</span><span class=\"params\">(<span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> startFactory)</span> <span class=\"keyword\">throws</span> MQClientException </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">switch</span> (<span class=\"keyword\">this</span>.serviceState) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> CREATE_JUST:</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.serviceState = ServiceState.START_FAILED;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">this</span>.checkConfig();</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!<span class=\"keyword\">this</span>.defaultMQProducer.getProducerGroup().equals(MixAll.CLIENT_INNER_PRODUCER_GROUP)) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">this</span>.defaultMQProducer.changeInstanceNameToPID();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">this</span>.mQClientFactory = MQClientManager.getInstance().getAndCreateMQClientInstance(<span class=\"keyword\">this</span>.defaultMQProducer, rpcHook);</span><br><span class=\"line\">            <span class=\"comment\">// 从上一句可以看出：MQClientManager为Producer连接管理器，用户管理连接ＭQ的TCP客户端的连接</span></span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">boolean</span> registerOK = mQClientFactory.registerProducer(<span class=\"keyword\">this</span>.defaultMQProducer.getProducerGroup(), <span class=\"keyword\">this</span>);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!registerOK) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">this</span>.serviceState = ServiceState.CREATE_JUST;</span><br><span class=\"line\">                <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> MQClientException(<span class=\"string\">&quot;The producer group[&quot;</span> + <span class=\"keyword\">this</span>.defaultMQProducer.getProducerGroup()</span><br><span class=\"line\">                    + <span class=\"string\">&quot;] has been created before, specify another name please.&quot;</span> + FAQUrl.suggestTodo(FAQUrl.GROUP_NAME_DUPLICATE_URL),</span><br><span class=\"line\">                    <span class=\"keyword\">null</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">this</span>.topicPublishInfoTable.put(<span class=\"keyword\">this</span>.defaultMQProducer.getCreateTopicKey(), <span class=\"keyword\">new</span> TopicPublishInfo());</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (startFactory) &#123;</span><br><span class=\"line\">                mQClientFactory.start();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            log.info(<span class=\"string\">&quot;the producer [&#123;&#125;] start OK. sendMessageWithVIPChannel=&#123;&#125;&quot;</span>, <span class=\"keyword\">this</span>.defaultMQProducer.getProducerGroup(),</span><br><span class=\"line\">                <span class=\"keyword\">this</span>.defaultMQProducer.isSendMessageWithVIPChannel());</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.serviceState = ServiceState.RUNNING;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> RUNNING:</span><br><span class=\"line\">        <span class=\"keyword\">case</span> START_FAILED:</span><br><span class=\"line\">        <span class=\"keyword\">case</span> SHUTDOWN_ALREADY:</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> MQClientException(<span class=\"string\">&quot;The producer service state not OK, maybe started once, &quot;</span><span class=\"comment\">//</span></span><br><span class=\"line\">                + <span class=\"keyword\">this</span>.serviceState<span class=\"comment\">//</span></span><br><span class=\"line\">                + FAQUrl.suggestTodo(FAQUrl.CLIENT_SERVICE_NOT_OK),</span><br><span class=\"line\">                <span class=\"keyword\">null</span>);</span><br><span class=\"line\">        <span class=\"keyword\">default</span>:</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.mQClientFactory.sendHeartbeatToAllBrokerWithLock();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>org.apache.rocketmq.client.impl.MQClientManager#getAndCreateMQClientInstance(org.apache.rocketmq.client.ClientConfig, org.apache.rocketmq.remoting.RPCHook)</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> MQClientInstance <span class=\"title\">getAndCreateMQClientInstance</span><span class=\"params\">(<span class=\"keyword\">final</span> ClientConfig clientConfig, RPCHook rpcHook)</span> </span>&#123;</span><br><span class=\"line\">    String clientId = clientConfig.buildMQClientId();</span><br><span class=\"line\">    MQClientInstance instance = <span class=\"keyword\">this</span>.factoryTable.get(clientId);</span><br><span class=\"line\">    <span class=\"comment\">//　从上一句可以看出：找到对应的客户端通讯实例是通过一个clientId在factoryTable内存缓存中进行查询的</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">null</span> == instance) &#123;</span><br><span class=\"line\">        instance =</span><br><span class=\"line\">            <span class=\"keyword\">new</span> MQClientInstance(clientConfig.cloneClientConfig(),</span><br><span class=\"line\">                <span class=\"keyword\">this</span>.factoryIndexGenerator.getAndIncrement(), clientId, rpcHook);</span><br><span class=\"line\">        MQClientInstance prev = <span class=\"keyword\">this</span>.factoryTable.putIfAbsent(clientId, instance);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (prev != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            instance = prev;</span><br><span class=\"line\">            log.warn(<span class=\"string\">&quot;Returned Previous MQClientInstance for clientId:[&#123;&#125;]&quot;</span>, clientId);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            log.info(<span class=\"string\">&quot;Created new MQClientInstance for clientId:[&#123;&#125;]&quot;</span>, clientId);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>org.apache.rocketmq.client.ClientConfig#buildMQClientId</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">buildMQClientId</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    StringBuilder sb = <span class=\"keyword\">new</span> StringBuilder();</span><br><span class=\"line\">    sb.append(<span class=\"keyword\">this</span>.getClientIP());</span><br><span class=\"line\"></span><br><span class=\"line\">    sb.append(<span class=\"string\">&quot;@&quot;</span>);</span><br><span class=\"line\">    sb.append(<span class=\"keyword\">this</span>.getInstanceName());</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!UtilAll.isBlank(<span class=\"keyword\">this</span>.unitName)) &#123;</span><br><span class=\"line\">        sb.append(<span class=\"string\">&quot;@&quot;</span>);</span><br><span class=\"line\">        sb.append(<span class=\"keyword\">this</span>.unitName);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> sb.toString();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//　从以上方法可以看出：这个clientId信息中包含当前微服务的IP，当前模块实例名(默认通过changeInstanceNameToPID更改为进程ID值）和一个unitName</span></span><br></pre></td></tr></table></figure>\n\n<p><code>结论</code>: 经以上源码可以得到一个模块需要连接多个RocketMQ集群，则需要生产多个MQClientInstance，换言之，则需要在获取MQClientInstance时传递不同的ClientID即可。<br>      由于__ClientID=localIP + instanceName + unitName__，所以只需要创建Producer对象时传入不同的instanceName或unitName值即可。</p>\n<hr>\n<p><em>观点仅代表自己，期待你的留言。</em></p>\n"},{"title":"RocketMQ使用指南及参数详解","keywords":["Apache RocketMQ 使用"],"date":"2018-04-04T09:58:58.000Z","toc":true,"list_number":false,"_content":"\n## 一、使用指南\n\n+  客户端寻址方式\n\n在代码中指定NameServer地址\n```\nProducer.setNamesrvAddr(“192.168.8.106:9876”);\n```\n或\n```\nConsumer.setNamesrvAddr(“192.168.8.106:9876”);\n```\nJava启动参数中指定NameServer地址\n```\n-Drocketmq.namesrv.addr=192.168.8.106:9876\n```\n环境变量指定NameServer地址·\n```\nexport NAMESRV_ADDR=192.168.8.106:9876\n```\n\n+  http静态服务器寻址\n\n客户端启动后，会定时访问一个静态的HTTP服务器，地址如下：\n\nhttp://jmenv.tbsite.net:8080/rocketmq/msaddr\n\n这个URL的返回内容如下：\n\n192.168.8.106:9876\n\n客户端默认每隔2分钟访问一次这个HTTP服务器，并更新本地的NameServer地址。URL已经在代码中写死，可通过修改/etc/hosts文件来改变要访问的服务器，例如在/etc/hosts增加如下配置：\n\n10.232.22.67   jmenv.taobao.net\n\n## 二、参数详解\n\n + 客户端的公共配置类：ClientConfig\n\n|参数名                         |默认值                 |说明\n|:- |:- |:-\n|NamesrvAddr                   |无                     |NameServer地址列表，多个nameServer地址用分号隔开\n|clientIP                      |本机IP                 |客户端本机IP地址，某些机器会发生无法识别客户端IP地址情况，需要应用在代码中强制指定\n|instanceName                  |DEFAULT               |客户端实例名称，客户端创建的多个Producer，Consumer实际是共用一个内部实例（这个实例包含网络连接，线程资源等）\n|clientCallbackExecutorThreads |4                     |通信层异步回调线程数\n|pollNameServerInteval         |30000                 |轮训Name Server 间隔时间，单位毫秒\n|heartbeatBrokerInterval       | 30000                |向Broker发送心跳间隔时间，单位毫秒\n|persistConsumerOffsetInterval |5000                  |持久化Consumer消费进度间隔时间，单位毫秒\n\n + Producer配置\n\n|参数名                              |默认值                 |说明\n|:- |:- |:-\n|producerGroup                      |DEFAULT_PRODUCER      |Producer组名，多个Producer如果属于一个应用，发送同样的消息，则应该将它们归为同一组。\n|createTopicKey                     |TBW102                |在发送消息时，自动创建服务器不存在的topic，需要指定key\n|defaultTopicQueueNums              |4                     |在发送消息时，自动创建服务器不存在的topic，默认创建的队列数\n|sendMsgTimeout                     |10000                 |发送消息超时时间，单位毫秒\n|compressMsgBodyOverHowmuch         |4096                  |消息Body超过多大开始压缩（Consumer收到消息会自动解压缩），单位字节\n|retryAnotherBrokerWhenNotStoreOK   |FALSE                 |如果发送消息返回sendResult,但是sendStatus!=SEND_OK,是否重试发送\n|maxMessageSize                     |131072                |客户端限制的消息大小，超过报错，同时服务端也会限制（默认128K）\n|transactionCheckListener           |无                    |事物消息回查监听器，如果发送事务消息，必须设置\n|checkThreadPoolMinSize             |1                     |Broker回查Producer事务状态时，线程池大小\n|checkThreadPoolMaxSize             |1                     |Broker回查Producer事务状态时，线程池大小\n|checkRequestHoldMax                |2000                   |Broker回查Producer事务状态时，Producer本地缓冲请求队列大小\n\n + PushConsumer配置\n\n|参数名                                  |默认值                                |说明\n|:- |:- |:-\n|consumerGroup                          |DEFAULT_CONSUMER                     |Consumer组名，多个Consumer如果属于一个应用，订阅同样的消息，且消费逻辑一致，则应将它们归为同一组\n|messageModel                           |CLUSTERING                           |消息模型，支持以下两种1.集群消费2.广播消费\n|consumeFromWhere                       |CONSUME_FROM_LAST_OFFSET             |Consumer启动后，默认从什么位置开始消费\n|allocateMessageQueueStrategy           |AllocateMessageQueueAveragely        |Rebalance算法实现策略\n|Subscription                           |{}                                   |订阅关系\n|messageListener                        |无                                   |消息监听器\n|offsetStore                            |无                                   |消费进度存储\n|consumeThreadMin                       |10                                   |消费线程池数量\n|consumeThreadMax                       |20                                   |消费线程池数量\n|consumeConcurrentlyMaxSpan             |2000                                 |单队列并行消费允许的最大跨度\n|pullThresholdForQueue                  |1000                                 |拉消息本地队列缓存消息最大数\n|Pullinterval                           |0                                    |拉消息间隔，由于是长轮询，所以为0，但是如果应用了流控，也可以设置大于0的值，单位毫秒\n|consumeMessageBatchMaxSize             |1                                    |批量消费，一次消费多少条消息\n|pullBatchSize                          |32                                   |批量拉消息，一次最多拉多少条\n\n + PullConsumer配置\n\n|参数名                                  |默认值                                |说明\n|:- |:- |:-\n|consumerGroup                          |无                     |Conusmer组名，多个Consumer如果属于一个应用，订阅同样的消息，且消费逻辑一致，则应该将它们归为同一组\n|brokerSuspendMaxTimeMillis             |20000                     |长轮询，Consumer拉消息请求在Broker挂起最长时间，单位毫秒\n|consumerPullTimeoutMillis              |10000                     |非长轮询，拉消息超时时间，单位毫秒\n|consumerTimeoutMillisWhenSuspend       |30000                     |长轮询，Consumer拉消息请求咋broker挂起超过指定时间，客户端认为超时，单位毫秒\n|messageModel                           |BROADCASTING                     |消息模型，支持以下两种：1集群消费 2广播模式\n|messageQueueListener                   |无                     |监听队列变化\n|offsetStore                            |无                     |消费进度存储\n|registerTopics                         |无                     |注册的topic集合\n|allocateMessageQueueStrategy           |无                     |Rebalance算法实现策略\n\n + Broker配置参数\n查看Broker默认配置\n\n```\nsh mqbroker -m\n```\n\n|参数名                                  |默认值                                |说明\n|:- |:- |:- \n|consumerGroup                          |无                     |Conusmer组名，多个Consumer如果属于一个应用，订阅同样的消息，且消费逻辑一致，则应该将它们归为同一组\n|listenPort                          |10911                     |Broker对外服务的监听端口\n|namesrvAddr                          |Null                     |Name Server地址\n|brokerIP1                          |本机IP                     |本机IP地址，默认系统自动识别，但是某些多网卡机器会存在识别错误的情况，这种情况下可以人工配置。\n|brokerName                          |本机主机名                     |无\n|brokerClusterName                          |DefaultCluster                     |Broker所属哪个集群\n|brokerId                          |0                     |BrokerId,必须是大等于0的整数，0表示Master，>0表示Slave，一个Master可以挂多个Slave，Master和Slave通过BrokerName来配对\n|storePathCommitLog                          |$HOME/store/commitlog                     |commitLog存储路径\n|storePathConsumeQueue                          |$HOME/store/consumequeue                     |消费队列存储路径\n|storePathIndex                          |$HOME/store/index                    |消息索引存储队列\n|deleteWhen                          |4                     |删除时间时间点，默认凌晨4点\n|fileReservedTime                          |48                     |文件保留时间，默认48小时\n|maxTransferBytesOnMessageInMemory                          |262144                     |单次pull消息（内存）传输的最大字节数\n|maxTransferCountOnMessageInMemory                          |32                     |单次pull消息（内存）传输的最大条数\n|maxTransferBytesOnMessageInDisk                          |65535                     |单次pull消息（磁盘）传输的最大字节数\n|maxTransferCountOnMessageInDisk                          |8                     |单次pull消息（磁盘）传输的最大条数\n|messageIndexEnable                          |TRUE                     |是否开启消息索引功能\n|messageIndexSafe                          |FALSE                     |是否提供安全的消息索引机制，索引保证不丢\n|brokerRole                          |ASYNC_MASTER                    |Broker的角色 -ASYNC_MASTER异步复制Master -SYNC_MASTER同步双写Master -SLAVE\n|flushDiskType                          |ASYNC_FLUSH                     |刷盘方式 -ASYNC_FLUSH异步刷盘 -SYNC_FLUSH同步刷盘\n|cleanFileForciblyEnable                          |TRUE                     |磁盘满，且无过期文件情况下TRUE表示强制删除文件，优先保证服务可用 FALSE标记服务不可用，文件不删除\n\n\n-----\n_转自:https://www.cnblogs.com/xiaodf/p/5075167.html_\n\n*观点仅代表自己，期待你的留言。*\n","source":"_posts/mq-rocketmq-manuals.md","raw":"---\ntitle: RocketMQ使用指南及参数详解\ntags:\n  - 转载\nkeywords:\n  - Apache RocketMQ 使用\ndate: 2018-04-04 17:58:58\ntoc: true\nlist_number: false\n---\n\n## 一、使用指南\n\n+  客户端寻址方式\n\n在代码中指定NameServer地址\n```\nProducer.setNamesrvAddr(“192.168.8.106:9876”);\n```\n或\n```\nConsumer.setNamesrvAddr(“192.168.8.106:9876”);\n```\nJava启动参数中指定NameServer地址\n```\n-Drocketmq.namesrv.addr=192.168.8.106:9876\n```\n环境变量指定NameServer地址·\n```\nexport NAMESRV_ADDR=192.168.8.106:9876\n```\n\n+  http静态服务器寻址\n\n客户端启动后，会定时访问一个静态的HTTP服务器，地址如下：\n\nhttp://jmenv.tbsite.net:8080/rocketmq/msaddr\n\n这个URL的返回内容如下：\n\n192.168.8.106:9876\n\n客户端默认每隔2分钟访问一次这个HTTP服务器，并更新本地的NameServer地址。URL已经在代码中写死，可通过修改/etc/hosts文件来改变要访问的服务器，例如在/etc/hosts增加如下配置：\n\n10.232.22.67   jmenv.taobao.net\n\n## 二、参数详解\n\n + 客户端的公共配置类：ClientConfig\n\n|参数名                         |默认值                 |说明\n|:- |:- |:-\n|NamesrvAddr                   |无                     |NameServer地址列表，多个nameServer地址用分号隔开\n|clientIP                      |本机IP                 |客户端本机IP地址，某些机器会发生无法识别客户端IP地址情况，需要应用在代码中强制指定\n|instanceName                  |DEFAULT               |客户端实例名称，客户端创建的多个Producer，Consumer实际是共用一个内部实例（这个实例包含网络连接，线程资源等）\n|clientCallbackExecutorThreads |4                     |通信层异步回调线程数\n|pollNameServerInteval         |30000                 |轮训Name Server 间隔时间，单位毫秒\n|heartbeatBrokerInterval       | 30000                |向Broker发送心跳间隔时间，单位毫秒\n|persistConsumerOffsetInterval |5000                  |持久化Consumer消费进度间隔时间，单位毫秒\n\n + Producer配置\n\n|参数名                              |默认值                 |说明\n|:- |:- |:-\n|producerGroup                      |DEFAULT_PRODUCER      |Producer组名，多个Producer如果属于一个应用，发送同样的消息，则应该将它们归为同一组。\n|createTopicKey                     |TBW102                |在发送消息时，自动创建服务器不存在的topic，需要指定key\n|defaultTopicQueueNums              |4                     |在发送消息时，自动创建服务器不存在的topic，默认创建的队列数\n|sendMsgTimeout                     |10000                 |发送消息超时时间，单位毫秒\n|compressMsgBodyOverHowmuch         |4096                  |消息Body超过多大开始压缩（Consumer收到消息会自动解压缩），单位字节\n|retryAnotherBrokerWhenNotStoreOK   |FALSE                 |如果发送消息返回sendResult,但是sendStatus!=SEND_OK,是否重试发送\n|maxMessageSize                     |131072                |客户端限制的消息大小，超过报错，同时服务端也会限制（默认128K）\n|transactionCheckListener           |无                    |事物消息回查监听器，如果发送事务消息，必须设置\n|checkThreadPoolMinSize             |1                     |Broker回查Producer事务状态时，线程池大小\n|checkThreadPoolMaxSize             |1                     |Broker回查Producer事务状态时，线程池大小\n|checkRequestHoldMax                |2000                   |Broker回查Producer事务状态时，Producer本地缓冲请求队列大小\n\n + PushConsumer配置\n\n|参数名                                  |默认值                                |说明\n|:- |:- |:-\n|consumerGroup                          |DEFAULT_CONSUMER                     |Consumer组名，多个Consumer如果属于一个应用，订阅同样的消息，且消费逻辑一致，则应将它们归为同一组\n|messageModel                           |CLUSTERING                           |消息模型，支持以下两种1.集群消费2.广播消费\n|consumeFromWhere                       |CONSUME_FROM_LAST_OFFSET             |Consumer启动后，默认从什么位置开始消费\n|allocateMessageQueueStrategy           |AllocateMessageQueueAveragely        |Rebalance算法实现策略\n|Subscription                           |{}                                   |订阅关系\n|messageListener                        |无                                   |消息监听器\n|offsetStore                            |无                                   |消费进度存储\n|consumeThreadMin                       |10                                   |消费线程池数量\n|consumeThreadMax                       |20                                   |消费线程池数量\n|consumeConcurrentlyMaxSpan             |2000                                 |单队列并行消费允许的最大跨度\n|pullThresholdForQueue                  |1000                                 |拉消息本地队列缓存消息最大数\n|Pullinterval                           |0                                    |拉消息间隔，由于是长轮询，所以为0，但是如果应用了流控，也可以设置大于0的值，单位毫秒\n|consumeMessageBatchMaxSize             |1                                    |批量消费，一次消费多少条消息\n|pullBatchSize                          |32                                   |批量拉消息，一次最多拉多少条\n\n + PullConsumer配置\n\n|参数名                                  |默认值                                |说明\n|:- |:- |:-\n|consumerGroup                          |无                     |Conusmer组名，多个Consumer如果属于一个应用，订阅同样的消息，且消费逻辑一致，则应该将它们归为同一组\n|brokerSuspendMaxTimeMillis             |20000                     |长轮询，Consumer拉消息请求在Broker挂起最长时间，单位毫秒\n|consumerPullTimeoutMillis              |10000                     |非长轮询，拉消息超时时间，单位毫秒\n|consumerTimeoutMillisWhenSuspend       |30000                     |长轮询，Consumer拉消息请求咋broker挂起超过指定时间，客户端认为超时，单位毫秒\n|messageModel                           |BROADCASTING                     |消息模型，支持以下两种：1集群消费 2广播模式\n|messageQueueListener                   |无                     |监听队列变化\n|offsetStore                            |无                     |消费进度存储\n|registerTopics                         |无                     |注册的topic集合\n|allocateMessageQueueStrategy           |无                     |Rebalance算法实现策略\n\n + Broker配置参数\n查看Broker默认配置\n\n```\nsh mqbroker -m\n```\n\n|参数名                                  |默认值                                |说明\n|:- |:- |:- \n|consumerGroup                          |无                     |Conusmer组名，多个Consumer如果属于一个应用，订阅同样的消息，且消费逻辑一致，则应该将它们归为同一组\n|listenPort                          |10911                     |Broker对外服务的监听端口\n|namesrvAddr                          |Null                     |Name Server地址\n|brokerIP1                          |本机IP                     |本机IP地址，默认系统自动识别，但是某些多网卡机器会存在识别错误的情况，这种情况下可以人工配置。\n|brokerName                          |本机主机名                     |无\n|brokerClusterName                          |DefaultCluster                     |Broker所属哪个集群\n|brokerId                          |0                     |BrokerId,必须是大等于0的整数，0表示Master，>0表示Slave，一个Master可以挂多个Slave，Master和Slave通过BrokerName来配对\n|storePathCommitLog                          |$HOME/store/commitlog                     |commitLog存储路径\n|storePathConsumeQueue                          |$HOME/store/consumequeue                     |消费队列存储路径\n|storePathIndex                          |$HOME/store/index                    |消息索引存储队列\n|deleteWhen                          |4                     |删除时间时间点，默认凌晨4点\n|fileReservedTime                          |48                     |文件保留时间，默认48小时\n|maxTransferBytesOnMessageInMemory                          |262144                     |单次pull消息（内存）传输的最大字节数\n|maxTransferCountOnMessageInMemory                          |32                     |单次pull消息（内存）传输的最大条数\n|maxTransferBytesOnMessageInDisk                          |65535                     |单次pull消息（磁盘）传输的最大字节数\n|maxTransferCountOnMessageInDisk                          |8                     |单次pull消息（磁盘）传输的最大条数\n|messageIndexEnable                          |TRUE                     |是否开启消息索引功能\n|messageIndexSafe                          |FALSE                     |是否提供安全的消息索引机制，索引保证不丢\n|brokerRole                          |ASYNC_MASTER                    |Broker的角色 -ASYNC_MASTER异步复制Master -SYNC_MASTER同步双写Master -SLAVE\n|flushDiskType                          |ASYNC_FLUSH                     |刷盘方式 -ASYNC_FLUSH异步刷盘 -SYNC_FLUSH同步刷盘\n|cleanFileForciblyEnable                          |TRUE                     |磁盘满，且无过期文件情况下TRUE表示强制删除文件，优先保证服务可用 FALSE标记服务不可用，文件不删除\n\n\n-----\n_转自:https://www.cnblogs.com/xiaodf/p/5075167.html_\n\n*观点仅代表自己，期待你的留言。*\n","slug":"mq-rocketmq-manuals","published":1,"updated":"2021-09-18T03:04:39.241Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cku52dyns0032bbinci9ba9fs","content":"<h2 id=\"一、使用指南\"><a href=\"#一、使用指南\" class=\"headerlink\" title=\"一、使用指南\"></a>一、使用指南</h2><ul>\n<li> 客户端寻址方式</li>\n</ul>\n<p>在代码中指定NameServer地址</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Producer.setNamesrvAddr(“192.168.8.106:9876”);</span><br></pre></td></tr></table></figure>\n<p>或</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Consumer.setNamesrvAddr(“192.168.8.106:9876”);</span><br></pre></td></tr></table></figure>\n<p>Java启动参数中指定NameServer地址</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-Drocketmq.namesrv.addr=192.168.8.106:9876</span><br></pre></td></tr></table></figure>\n<p>环境变量指定NameServer地址·</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">export NAMESRV_ADDR=192.168.8.106:9876</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li> http静态服务器寻址</li>\n</ul>\n<p>客户端启动后，会定时访问一个静态的HTTP服务器，地址如下：</p>\n<p><a href=\"http://jmenv.tbsite.net:8080/rocketmq/msaddr\">http://jmenv.tbsite.net:8080/rocketmq/msaddr</a></p>\n<p>这个URL的返回内容如下：</p>\n<p>192.168.8.106:9876</p>\n<p>客户端默认每隔2分钟访问一次这个HTTP服务器，并更新本地的NameServer地址。URL已经在代码中写死，可通过修改/etc/hosts文件来改变要访问的服务器，例如在/etc/hosts增加如下配置：</p>\n<p>10.232.22.67   jmenv.taobao.net</p>\n<h2 id=\"二、参数详解\"><a href=\"#二、参数详解\" class=\"headerlink\" title=\"二、参数详解\"></a>二、参数详解</h2><ul>\n<li>客户端的公共配置类：ClientConfig</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th align=\"left\">参数名</th>\n<th align=\"left\">默认值</th>\n<th align=\"left\">说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">NamesrvAddr</td>\n<td align=\"left\">无</td>\n<td align=\"left\">NameServer地址列表，多个nameServer地址用分号隔开</td>\n</tr>\n<tr>\n<td align=\"left\">clientIP</td>\n<td align=\"left\">本机IP</td>\n<td align=\"left\">客户端本机IP地址，某些机器会发生无法识别客户端IP地址情况，需要应用在代码中强制指定</td>\n</tr>\n<tr>\n<td align=\"left\">instanceName</td>\n<td align=\"left\">DEFAULT</td>\n<td align=\"left\">客户端实例名称，客户端创建的多个Producer，Consumer实际是共用一个内部实例（这个实例包含网络连接，线程资源等）</td>\n</tr>\n<tr>\n<td align=\"left\">clientCallbackExecutorThreads</td>\n<td align=\"left\">4</td>\n<td align=\"left\">通信层异步回调线程数</td>\n</tr>\n<tr>\n<td align=\"left\">pollNameServerInteval</td>\n<td align=\"left\">30000</td>\n<td align=\"left\">轮训Name Server 间隔时间，单位毫秒</td>\n</tr>\n<tr>\n<td align=\"left\">heartbeatBrokerInterval</td>\n<td align=\"left\">30000</td>\n<td align=\"left\">向Broker发送心跳间隔时间，单位毫秒</td>\n</tr>\n<tr>\n<td align=\"left\">persistConsumerOffsetInterval</td>\n<td align=\"left\">5000</td>\n<td align=\"left\">持久化Consumer消费进度间隔时间，单位毫秒</td>\n</tr>\n</tbody></table>\n<ul>\n<li>Producer配置</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th align=\"left\">参数名</th>\n<th align=\"left\">默认值</th>\n<th align=\"left\">说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">producerGroup</td>\n<td align=\"left\">DEFAULT_PRODUCER</td>\n<td align=\"left\">Producer组名，多个Producer如果属于一个应用，发送同样的消息，则应该将它们归为同一组。</td>\n</tr>\n<tr>\n<td align=\"left\">createTopicKey</td>\n<td align=\"left\">TBW102</td>\n<td align=\"left\">在发送消息时，自动创建服务器不存在的topic，需要指定key</td>\n</tr>\n<tr>\n<td align=\"left\">defaultTopicQueueNums</td>\n<td align=\"left\">4</td>\n<td align=\"left\">在发送消息时，自动创建服务器不存在的topic，默认创建的队列数</td>\n</tr>\n<tr>\n<td align=\"left\">sendMsgTimeout</td>\n<td align=\"left\">10000</td>\n<td align=\"left\">发送消息超时时间，单位毫秒</td>\n</tr>\n<tr>\n<td align=\"left\">compressMsgBodyOverHowmuch</td>\n<td align=\"left\">4096</td>\n<td align=\"left\">消息Body超过多大开始压缩（Consumer收到消息会自动解压缩），单位字节</td>\n</tr>\n<tr>\n<td align=\"left\">retryAnotherBrokerWhenNotStoreOK</td>\n<td align=\"left\">FALSE</td>\n<td align=\"left\">如果发送消息返回sendResult,但是sendStatus!=SEND_OK,是否重试发送</td>\n</tr>\n<tr>\n<td align=\"left\">maxMessageSize</td>\n<td align=\"left\">131072</td>\n<td align=\"left\">客户端限制的消息大小，超过报错，同时服务端也会限制（默认128K）</td>\n</tr>\n<tr>\n<td align=\"left\">transactionCheckListener</td>\n<td align=\"left\">无</td>\n<td align=\"left\">事物消息回查监听器，如果发送事务消息，必须设置</td>\n</tr>\n<tr>\n<td align=\"left\">checkThreadPoolMinSize</td>\n<td align=\"left\">1</td>\n<td align=\"left\">Broker回查Producer事务状态时，线程池大小</td>\n</tr>\n<tr>\n<td align=\"left\">checkThreadPoolMaxSize</td>\n<td align=\"left\">1</td>\n<td align=\"left\">Broker回查Producer事务状态时，线程池大小</td>\n</tr>\n<tr>\n<td align=\"left\">checkRequestHoldMax</td>\n<td align=\"left\">2000</td>\n<td align=\"left\">Broker回查Producer事务状态时，Producer本地缓冲请求队列大小</td>\n</tr>\n</tbody></table>\n<ul>\n<li>PushConsumer配置</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th align=\"left\">参数名</th>\n<th align=\"left\">默认值</th>\n<th align=\"left\">说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">consumerGroup</td>\n<td align=\"left\">DEFAULT_CONSUMER</td>\n<td align=\"left\">Consumer组名，多个Consumer如果属于一个应用，订阅同样的消息，且消费逻辑一致，则应将它们归为同一组</td>\n</tr>\n<tr>\n<td align=\"left\">messageModel</td>\n<td align=\"left\">CLUSTERING</td>\n<td align=\"left\">消息模型，支持以下两种1.集群消费2.广播消费</td>\n</tr>\n<tr>\n<td align=\"left\">consumeFromWhere</td>\n<td align=\"left\">CONSUME_FROM_LAST_OFFSET</td>\n<td align=\"left\">Consumer启动后，默认从什么位置开始消费</td>\n</tr>\n<tr>\n<td align=\"left\">allocateMessageQueueStrategy</td>\n<td align=\"left\">AllocateMessageQueueAveragely</td>\n<td align=\"left\">Rebalance算法实现策略</td>\n</tr>\n<tr>\n<td align=\"left\">Subscription</td>\n<td align=\"left\">{}</td>\n<td align=\"left\">订阅关系</td>\n</tr>\n<tr>\n<td align=\"left\">messageListener</td>\n<td align=\"left\">无</td>\n<td align=\"left\">消息监听器</td>\n</tr>\n<tr>\n<td align=\"left\">offsetStore</td>\n<td align=\"left\">无</td>\n<td align=\"left\">消费进度存储</td>\n</tr>\n<tr>\n<td align=\"left\">consumeThreadMin</td>\n<td align=\"left\">10</td>\n<td align=\"left\">消费线程池数量</td>\n</tr>\n<tr>\n<td align=\"left\">consumeThreadMax</td>\n<td align=\"left\">20</td>\n<td align=\"left\">消费线程池数量</td>\n</tr>\n<tr>\n<td align=\"left\">consumeConcurrentlyMaxSpan</td>\n<td align=\"left\">2000</td>\n<td align=\"left\">单队列并行消费允许的最大跨度</td>\n</tr>\n<tr>\n<td align=\"left\">pullThresholdForQueue</td>\n<td align=\"left\">1000</td>\n<td align=\"left\">拉消息本地队列缓存消息最大数</td>\n</tr>\n<tr>\n<td align=\"left\">Pullinterval</td>\n<td align=\"left\">0</td>\n<td align=\"left\">拉消息间隔，由于是长轮询，所以为0，但是如果应用了流控，也可以设置大于0的值，单位毫秒</td>\n</tr>\n<tr>\n<td align=\"left\">consumeMessageBatchMaxSize</td>\n<td align=\"left\">1</td>\n<td align=\"left\">批量消费，一次消费多少条消息</td>\n</tr>\n<tr>\n<td align=\"left\">pullBatchSize</td>\n<td align=\"left\">32</td>\n<td align=\"left\">批量拉消息，一次最多拉多少条</td>\n</tr>\n</tbody></table>\n<ul>\n<li>PullConsumer配置</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th align=\"left\">参数名</th>\n<th align=\"left\">默认值</th>\n<th align=\"left\">说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">consumerGroup</td>\n<td align=\"left\">无</td>\n<td align=\"left\">Conusmer组名，多个Consumer如果属于一个应用，订阅同样的消息，且消费逻辑一致，则应该将它们归为同一组</td>\n</tr>\n<tr>\n<td align=\"left\">brokerSuspendMaxTimeMillis</td>\n<td align=\"left\">20000</td>\n<td align=\"left\">长轮询，Consumer拉消息请求在Broker挂起最长时间，单位毫秒</td>\n</tr>\n<tr>\n<td align=\"left\">consumerPullTimeoutMillis</td>\n<td align=\"left\">10000</td>\n<td align=\"left\">非长轮询，拉消息超时时间，单位毫秒</td>\n</tr>\n<tr>\n<td align=\"left\">consumerTimeoutMillisWhenSuspend</td>\n<td align=\"left\">30000</td>\n<td align=\"left\">长轮询，Consumer拉消息请求咋broker挂起超过指定时间，客户端认为超时，单位毫秒</td>\n</tr>\n<tr>\n<td align=\"left\">messageModel</td>\n<td align=\"left\">BROADCASTING</td>\n<td align=\"left\">消息模型，支持以下两种：1集群消费 2广播模式</td>\n</tr>\n<tr>\n<td align=\"left\">messageQueueListener</td>\n<td align=\"left\">无</td>\n<td align=\"left\">监听队列变化</td>\n</tr>\n<tr>\n<td align=\"left\">offsetStore</td>\n<td align=\"left\">无</td>\n<td align=\"left\">消费进度存储</td>\n</tr>\n<tr>\n<td align=\"left\">registerTopics</td>\n<td align=\"left\">无</td>\n<td align=\"left\">注册的topic集合</td>\n</tr>\n<tr>\n<td align=\"left\">allocateMessageQueueStrategy</td>\n<td align=\"left\">无</td>\n<td align=\"left\">Rebalance算法实现策略</td>\n</tr>\n</tbody></table>\n<ul>\n<li>Broker配置参数<br>查看Broker默认配置</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sh mqbroker -m</span><br></pre></td></tr></table></figure>\n\n<table>\n<thead>\n<tr>\n<th align=\"left\">参数名</th>\n<th align=\"left\">默认值</th>\n<th align=\"left\">说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">consumerGroup</td>\n<td align=\"left\">无</td>\n<td align=\"left\">Conusmer组名，多个Consumer如果属于一个应用，订阅同样的消息，且消费逻辑一致，则应该将它们归为同一组</td>\n</tr>\n<tr>\n<td align=\"left\">listenPort</td>\n<td align=\"left\">10911</td>\n<td align=\"left\">Broker对外服务的监听端口</td>\n</tr>\n<tr>\n<td align=\"left\">namesrvAddr</td>\n<td align=\"left\">Null</td>\n<td align=\"left\">Name Server地址</td>\n</tr>\n<tr>\n<td align=\"left\">brokerIP1</td>\n<td align=\"left\">本机IP</td>\n<td align=\"left\">本机IP地址，默认系统自动识别，但是某些多网卡机器会存在识别错误的情况，这种情况下可以人工配置。</td>\n</tr>\n<tr>\n<td align=\"left\">brokerName</td>\n<td align=\"left\">本机主机名</td>\n<td align=\"left\">无</td>\n</tr>\n<tr>\n<td align=\"left\">brokerClusterName</td>\n<td align=\"left\">DefaultCluster</td>\n<td align=\"left\">Broker所属哪个集群</td>\n</tr>\n<tr>\n<td align=\"left\">brokerId</td>\n<td align=\"left\">0</td>\n<td align=\"left\">BrokerId,必须是大等于0的整数，0表示Master，&gt;0表示Slave，一个Master可以挂多个Slave，Master和Slave通过BrokerName来配对</td>\n</tr>\n<tr>\n<td align=\"left\">storePathCommitLog</td>\n<td align=\"left\">$HOME/store/commitlog</td>\n<td align=\"left\">commitLog存储路径</td>\n</tr>\n<tr>\n<td align=\"left\">storePathConsumeQueue</td>\n<td align=\"left\">$HOME/store/consumequeue</td>\n<td align=\"left\">消费队列存储路径</td>\n</tr>\n<tr>\n<td align=\"left\">storePathIndex</td>\n<td align=\"left\">$HOME/store/index</td>\n<td align=\"left\">消息索引存储队列</td>\n</tr>\n<tr>\n<td align=\"left\">deleteWhen</td>\n<td align=\"left\">4</td>\n<td align=\"left\">删除时间时间点，默认凌晨4点</td>\n</tr>\n<tr>\n<td align=\"left\">fileReservedTime</td>\n<td align=\"left\">48</td>\n<td align=\"left\">文件保留时间，默认48小时</td>\n</tr>\n<tr>\n<td align=\"left\">maxTransferBytesOnMessageInMemory</td>\n<td align=\"left\">262144</td>\n<td align=\"left\">单次pull消息（内存）传输的最大字节数</td>\n</tr>\n<tr>\n<td align=\"left\">maxTransferCountOnMessageInMemory</td>\n<td align=\"left\">32</td>\n<td align=\"left\">单次pull消息（内存）传输的最大条数</td>\n</tr>\n<tr>\n<td align=\"left\">maxTransferBytesOnMessageInDisk</td>\n<td align=\"left\">65535</td>\n<td align=\"left\">单次pull消息（磁盘）传输的最大字节数</td>\n</tr>\n<tr>\n<td align=\"left\">maxTransferCountOnMessageInDisk</td>\n<td align=\"left\">8</td>\n<td align=\"left\">单次pull消息（磁盘）传输的最大条数</td>\n</tr>\n<tr>\n<td align=\"left\">messageIndexEnable</td>\n<td align=\"left\">TRUE</td>\n<td align=\"left\">是否开启消息索引功能</td>\n</tr>\n<tr>\n<td align=\"left\">messageIndexSafe</td>\n<td align=\"left\">FALSE</td>\n<td align=\"left\">是否提供安全的消息索引机制，索引保证不丢</td>\n</tr>\n<tr>\n<td align=\"left\">brokerRole</td>\n<td align=\"left\">ASYNC_MASTER</td>\n<td align=\"left\">Broker的角色 -ASYNC_MASTER异步复制Master -SYNC_MASTER同步双写Master -SLAVE</td>\n</tr>\n<tr>\n<td align=\"left\">flushDiskType</td>\n<td align=\"left\">ASYNC_FLUSH</td>\n<td align=\"left\">刷盘方式 -ASYNC_FLUSH异步刷盘 -SYNC_FLUSH同步刷盘</td>\n</tr>\n<tr>\n<td align=\"left\">cleanFileForciblyEnable</td>\n<td align=\"left\">TRUE</td>\n<td align=\"left\">磁盘满，且无过期文件情况下TRUE表示强制删除文件，优先保证服务可用 FALSE标记服务不可用，文件不删除</td>\n</tr>\n</tbody></table>\n<hr>\n<p><em>转自:<a href=\"https://www.cnblogs.com/xiaodf/p/5075167.html\">https://www.cnblogs.com/xiaodf/p/5075167.html</a></em></p>\n<p><em>观点仅代表自己，期待你的留言。</em></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"一、使用指南\"><a href=\"#一、使用指南\" class=\"headerlink\" title=\"一、使用指南\"></a>一、使用指南</h2><ul>\n<li> 客户端寻址方式</li>\n</ul>\n<p>在代码中指定NameServer地址</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Producer.setNamesrvAddr(“192.168.8.106:9876”);</span><br></pre></td></tr></table></figure>\n<p>或</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Consumer.setNamesrvAddr(“192.168.8.106:9876”);</span><br></pre></td></tr></table></figure>\n<p>Java启动参数中指定NameServer地址</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-Drocketmq.namesrv.addr=192.168.8.106:9876</span><br></pre></td></tr></table></figure>\n<p>环境变量指定NameServer地址·</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">export NAMESRV_ADDR=192.168.8.106:9876</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li> http静态服务器寻址</li>\n</ul>\n<p>客户端启动后，会定时访问一个静态的HTTP服务器，地址如下：</p>\n<p><a href=\"http://jmenv.tbsite.net:8080/rocketmq/msaddr\">http://jmenv.tbsite.net:8080/rocketmq/msaddr</a></p>\n<p>这个URL的返回内容如下：</p>\n<p>192.168.8.106:9876</p>\n<p>客户端默认每隔2分钟访问一次这个HTTP服务器，并更新本地的NameServer地址。URL已经在代码中写死，可通过修改/etc/hosts文件来改变要访问的服务器，例如在/etc/hosts增加如下配置：</p>\n<p>10.232.22.67   jmenv.taobao.net</p>\n<h2 id=\"二、参数详解\"><a href=\"#二、参数详解\" class=\"headerlink\" title=\"二、参数详解\"></a>二、参数详解</h2><ul>\n<li>客户端的公共配置类：ClientConfig</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th align=\"left\">参数名</th>\n<th align=\"left\">默认值</th>\n<th align=\"left\">说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">NamesrvAddr</td>\n<td align=\"left\">无</td>\n<td align=\"left\">NameServer地址列表，多个nameServer地址用分号隔开</td>\n</tr>\n<tr>\n<td align=\"left\">clientIP</td>\n<td align=\"left\">本机IP</td>\n<td align=\"left\">客户端本机IP地址，某些机器会发生无法识别客户端IP地址情况，需要应用在代码中强制指定</td>\n</tr>\n<tr>\n<td align=\"left\">instanceName</td>\n<td align=\"left\">DEFAULT</td>\n<td align=\"left\">客户端实例名称，客户端创建的多个Producer，Consumer实际是共用一个内部实例（这个实例包含网络连接，线程资源等）</td>\n</tr>\n<tr>\n<td align=\"left\">clientCallbackExecutorThreads</td>\n<td align=\"left\">4</td>\n<td align=\"left\">通信层异步回调线程数</td>\n</tr>\n<tr>\n<td align=\"left\">pollNameServerInteval</td>\n<td align=\"left\">30000</td>\n<td align=\"left\">轮训Name Server 间隔时间，单位毫秒</td>\n</tr>\n<tr>\n<td align=\"left\">heartbeatBrokerInterval</td>\n<td align=\"left\">30000</td>\n<td align=\"left\">向Broker发送心跳间隔时间，单位毫秒</td>\n</tr>\n<tr>\n<td align=\"left\">persistConsumerOffsetInterval</td>\n<td align=\"left\">5000</td>\n<td align=\"left\">持久化Consumer消费进度间隔时间，单位毫秒</td>\n</tr>\n</tbody></table>\n<ul>\n<li>Producer配置</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th align=\"left\">参数名</th>\n<th align=\"left\">默认值</th>\n<th align=\"left\">说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">producerGroup</td>\n<td align=\"left\">DEFAULT_PRODUCER</td>\n<td align=\"left\">Producer组名，多个Producer如果属于一个应用，发送同样的消息，则应该将它们归为同一组。</td>\n</tr>\n<tr>\n<td align=\"left\">createTopicKey</td>\n<td align=\"left\">TBW102</td>\n<td align=\"left\">在发送消息时，自动创建服务器不存在的topic，需要指定key</td>\n</tr>\n<tr>\n<td align=\"left\">defaultTopicQueueNums</td>\n<td align=\"left\">4</td>\n<td align=\"left\">在发送消息时，自动创建服务器不存在的topic，默认创建的队列数</td>\n</tr>\n<tr>\n<td align=\"left\">sendMsgTimeout</td>\n<td align=\"left\">10000</td>\n<td align=\"left\">发送消息超时时间，单位毫秒</td>\n</tr>\n<tr>\n<td align=\"left\">compressMsgBodyOverHowmuch</td>\n<td align=\"left\">4096</td>\n<td align=\"left\">消息Body超过多大开始压缩（Consumer收到消息会自动解压缩），单位字节</td>\n</tr>\n<tr>\n<td align=\"left\">retryAnotherBrokerWhenNotStoreOK</td>\n<td align=\"left\">FALSE</td>\n<td align=\"left\">如果发送消息返回sendResult,但是sendStatus!=SEND_OK,是否重试发送</td>\n</tr>\n<tr>\n<td align=\"left\">maxMessageSize</td>\n<td align=\"left\">131072</td>\n<td align=\"left\">客户端限制的消息大小，超过报错，同时服务端也会限制（默认128K）</td>\n</tr>\n<tr>\n<td align=\"left\">transactionCheckListener</td>\n<td align=\"left\">无</td>\n<td align=\"left\">事物消息回查监听器，如果发送事务消息，必须设置</td>\n</tr>\n<tr>\n<td align=\"left\">checkThreadPoolMinSize</td>\n<td align=\"left\">1</td>\n<td align=\"left\">Broker回查Producer事务状态时，线程池大小</td>\n</tr>\n<tr>\n<td align=\"left\">checkThreadPoolMaxSize</td>\n<td align=\"left\">1</td>\n<td align=\"left\">Broker回查Producer事务状态时，线程池大小</td>\n</tr>\n<tr>\n<td align=\"left\">checkRequestHoldMax</td>\n<td align=\"left\">2000</td>\n<td align=\"left\">Broker回查Producer事务状态时，Producer本地缓冲请求队列大小</td>\n</tr>\n</tbody></table>\n<ul>\n<li>PushConsumer配置</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th align=\"left\">参数名</th>\n<th align=\"left\">默认值</th>\n<th align=\"left\">说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">consumerGroup</td>\n<td align=\"left\">DEFAULT_CONSUMER</td>\n<td align=\"left\">Consumer组名，多个Consumer如果属于一个应用，订阅同样的消息，且消费逻辑一致，则应将它们归为同一组</td>\n</tr>\n<tr>\n<td align=\"left\">messageModel</td>\n<td align=\"left\">CLUSTERING</td>\n<td align=\"left\">消息模型，支持以下两种1.集群消费2.广播消费</td>\n</tr>\n<tr>\n<td align=\"left\">consumeFromWhere</td>\n<td align=\"left\">CONSUME_FROM_LAST_OFFSET</td>\n<td align=\"left\">Consumer启动后，默认从什么位置开始消费</td>\n</tr>\n<tr>\n<td align=\"left\">allocateMessageQueueStrategy</td>\n<td align=\"left\">AllocateMessageQueueAveragely</td>\n<td align=\"left\">Rebalance算法实现策略</td>\n</tr>\n<tr>\n<td align=\"left\">Subscription</td>\n<td align=\"left\">{}</td>\n<td align=\"left\">订阅关系</td>\n</tr>\n<tr>\n<td align=\"left\">messageListener</td>\n<td align=\"left\">无</td>\n<td align=\"left\">消息监听器</td>\n</tr>\n<tr>\n<td align=\"left\">offsetStore</td>\n<td align=\"left\">无</td>\n<td align=\"left\">消费进度存储</td>\n</tr>\n<tr>\n<td align=\"left\">consumeThreadMin</td>\n<td align=\"left\">10</td>\n<td align=\"left\">消费线程池数量</td>\n</tr>\n<tr>\n<td align=\"left\">consumeThreadMax</td>\n<td align=\"left\">20</td>\n<td align=\"left\">消费线程池数量</td>\n</tr>\n<tr>\n<td align=\"left\">consumeConcurrentlyMaxSpan</td>\n<td align=\"left\">2000</td>\n<td align=\"left\">单队列并行消费允许的最大跨度</td>\n</tr>\n<tr>\n<td align=\"left\">pullThresholdForQueue</td>\n<td align=\"left\">1000</td>\n<td align=\"left\">拉消息本地队列缓存消息最大数</td>\n</tr>\n<tr>\n<td align=\"left\">Pullinterval</td>\n<td align=\"left\">0</td>\n<td align=\"left\">拉消息间隔，由于是长轮询，所以为0，但是如果应用了流控，也可以设置大于0的值，单位毫秒</td>\n</tr>\n<tr>\n<td align=\"left\">consumeMessageBatchMaxSize</td>\n<td align=\"left\">1</td>\n<td align=\"left\">批量消费，一次消费多少条消息</td>\n</tr>\n<tr>\n<td align=\"left\">pullBatchSize</td>\n<td align=\"left\">32</td>\n<td align=\"left\">批量拉消息，一次最多拉多少条</td>\n</tr>\n</tbody></table>\n<ul>\n<li>PullConsumer配置</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th align=\"left\">参数名</th>\n<th align=\"left\">默认值</th>\n<th align=\"left\">说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">consumerGroup</td>\n<td align=\"left\">无</td>\n<td align=\"left\">Conusmer组名，多个Consumer如果属于一个应用，订阅同样的消息，且消费逻辑一致，则应该将它们归为同一组</td>\n</tr>\n<tr>\n<td align=\"left\">brokerSuspendMaxTimeMillis</td>\n<td align=\"left\">20000</td>\n<td align=\"left\">长轮询，Consumer拉消息请求在Broker挂起最长时间，单位毫秒</td>\n</tr>\n<tr>\n<td align=\"left\">consumerPullTimeoutMillis</td>\n<td align=\"left\">10000</td>\n<td align=\"left\">非长轮询，拉消息超时时间，单位毫秒</td>\n</tr>\n<tr>\n<td align=\"left\">consumerTimeoutMillisWhenSuspend</td>\n<td align=\"left\">30000</td>\n<td align=\"left\">长轮询，Consumer拉消息请求咋broker挂起超过指定时间，客户端认为超时，单位毫秒</td>\n</tr>\n<tr>\n<td align=\"left\">messageModel</td>\n<td align=\"left\">BROADCASTING</td>\n<td align=\"left\">消息模型，支持以下两种：1集群消费 2广播模式</td>\n</tr>\n<tr>\n<td align=\"left\">messageQueueListener</td>\n<td align=\"left\">无</td>\n<td align=\"left\">监听队列变化</td>\n</tr>\n<tr>\n<td align=\"left\">offsetStore</td>\n<td align=\"left\">无</td>\n<td align=\"left\">消费进度存储</td>\n</tr>\n<tr>\n<td align=\"left\">registerTopics</td>\n<td align=\"left\">无</td>\n<td align=\"left\">注册的topic集合</td>\n</tr>\n<tr>\n<td align=\"left\">allocateMessageQueueStrategy</td>\n<td align=\"left\">无</td>\n<td align=\"left\">Rebalance算法实现策略</td>\n</tr>\n</tbody></table>\n<ul>\n<li>Broker配置参数<br>查看Broker默认配置</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sh mqbroker -m</span><br></pre></td></tr></table></figure>\n\n<table>\n<thead>\n<tr>\n<th align=\"left\">参数名</th>\n<th align=\"left\">默认值</th>\n<th align=\"left\">说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">consumerGroup</td>\n<td align=\"left\">无</td>\n<td align=\"left\">Conusmer组名，多个Consumer如果属于一个应用，订阅同样的消息，且消费逻辑一致，则应该将它们归为同一组</td>\n</tr>\n<tr>\n<td align=\"left\">listenPort</td>\n<td align=\"left\">10911</td>\n<td align=\"left\">Broker对外服务的监听端口</td>\n</tr>\n<tr>\n<td align=\"left\">namesrvAddr</td>\n<td align=\"left\">Null</td>\n<td align=\"left\">Name Server地址</td>\n</tr>\n<tr>\n<td align=\"left\">brokerIP1</td>\n<td align=\"left\">本机IP</td>\n<td align=\"left\">本机IP地址，默认系统自动识别，但是某些多网卡机器会存在识别错误的情况，这种情况下可以人工配置。</td>\n</tr>\n<tr>\n<td align=\"left\">brokerName</td>\n<td align=\"left\">本机主机名</td>\n<td align=\"left\">无</td>\n</tr>\n<tr>\n<td align=\"left\">brokerClusterName</td>\n<td align=\"left\">DefaultCluster</td>\n<td align=\"left\">Broker所属哪个集群</td>\n</tr>\n<tr>\n<td align=\"left\">brokerId</td>\n<td align=\"left\">0</td>\n<td align=\"left\">BrokerId,必须是大等于0的整数，0表示Master，&gt;0表示Slave，一个Master可以挂多个Slave，Master和Slave通过BrokerName来配对</td>\n</tr>\n<tr>\n<td align=\"left\">storePathCommitLog</td>\n<td align=\"left\">$HOME/store/commitlog</td>\n<td align=\"left\">commitLog存储路径</td>\n</tr>\n<tr>\n<td align=\"left\">storePathConsumeQueue</td>\n<td align=\"left\">$HOME/store/consumequeue</td>\n<td align=\"left\">消费队列存储路径</td>\n</tr>\n<tr>\n<td align=\"left\">storePathIndex</td>\n<td align=\"left\">$HOME/store/index</td>\n<td align=\"left\">消息索引存储队列</td>\n</tr>\n<tr>\n<td align=\"left\">deleteWhen</td>\n<td align=\"left\">4</td>\n<td align=\"left\">删除时间时间点，默认凌晨4点</td>\n</tr>\n<tr>\n<td align=\"left\">fileReservedTime</td>\n<td align=\"left\">48</td>\n<td align=\"left\">文件保留时间，默认48小时</td>\n</tr>\n<tr>\n<td align=\"left\">maxTransferBytesOnMessageInMemory</td>\n<td align=\"left\">262144</td>\n<td align=\"left\">单次pull消息（内存）传输的最大字节数</td>\n</tr>\n<tr>\n<td align=\"left\">maxTransferCountOnMessageInMemory</td>\n<td align=\"left\">32</td>\n<td align=\"left\">单次pull消息（内存）传输的最大条数</td>\n</tr>\n<tr>\n<td align=\"left\">maxTransferBytesOnMessageInDisk</td>\n<td align=\"left\">65535</td>\n<td align=\"left\">单次pull消息（磁盘）传输的最大字节数</td>\n</tr>\n<tr>\n<td align=\"left\">maxTransferCountOnMessageInDisk</td>\n<td align=\"left\">8</td>\n<td align=\"left\">单次pull消息（磁盘）传输的最大条数</td>\n</tr>\n<tr>\n<td align=\"left\">messageIndexEnable</td>\n<td align=\"left\">TRUE</td>\n<td align=\"left\">是否开启消息索引功能</td>\n</tr>\n<tr>\n<td align=\"left\">messageIndexSafe</td>\n<td align=\"left\">FALSE</td>\n<td align=\"left\">是否提供安全的消息索引机制，索引保证不丢</td>\n</tr>\n<tr>\n<td align=\"left\">brokerRole</td>\n<td align=\"left\">ASYNC_MASTER</td>\n<td align=\"left\">Broker的角色 -ASYNC_MASTER异步复制Master -SYNC_MASTER同步双写Master -SLAVE</td>\n</tr>\n<tr>\n<td align=\"left\">flushDiskType</td>\n<td align=\"left\">ASYNC_FLUSH</td>\n<td align=\"left\">刷盘方式 -ASYNC_FLUSH异步刷盘 -SYNC_FLUSH同步刷盘</td>\n</tr>\n<tr>\n<td align=\"left\">cleanFileForciblyEnable</td>\n<td align=\"left\">TRUE</td>\n<td align=\"left\">磁盘满，且无过期文件情况下TRUE表示强制删除文件，优先保证服务可用 FALSE标记服务不可用，文件不删除</td>\n</tr>\n</tbody></table>\n<hr>\n<p><em>转自:<a href=\"https://www.cnblogs.com/xiaodf/p/5075167.html\">https://www.cnblogs.com/xiaodf/p/5075167.html</a></em></p>\n<p><em>观点仅代表自己，期待你的留言。</em></p>\n"},{"title":"RocketMQ各组件特性和HA集群方案","keywords":["Apache RocketMQ 组件"],"date":"2018-04-04T08:58:58.000Z","toc":true,"list_number":false,"_content":"## 一、简介\n\n- RocketMQ是一款分布式、队列模型的消息中间件，具有以下特点：\n\n- 能够保证严格的消息顺序\n\n- 提供丰富的消息拉取模式\n\n- 高效的订阅者水平扩展能力\n\n- 实时的消息订阅机制\n\n- 亿级消息堆积能力\n\n## 二、组件特性\n### 1. nameserver\n相对来说，nameserver的稳定性非常高。原因有二：\n\n+ nameserver互相独立，彼此没有通信关系，单台nameserver挂掉，不影响其他nameserver，即使全部挂掉，也不影响业务系统使用。\n\n+ nameserver不会有频繁的读写，所以性能开销非常小，稳定性很高。\n\n### 2. broker\n__与nameserver关系__\n__连接:__\n\n单个broker和所有nameserver保持长连接\n\n__心跳:__\n\n心跳间隔：每隔30秒（此时间无法更改）向所有nameserver发送心跳，心跳包含了自身的topic配置信息。\n\n心跳超时：nameserver每隔10秒钟（此时间无法更改），扫描所有还存活的broker连接，若某个连接2分钟内（当前时间与最后更新时间差值超过2分钟，此时间无法更改）没有发送心跳数据，则断开连接。\n\n__断开:__\n\n时机：broker挂掉；心跳超时导致nameserver主动关闭连接\n\n动作：一旦连接断开，nameserver会立即感知，更新topc与队列的对应关系，但不会通知生产者和消费者\n\n__负载均衡:__\n1. 一个topic分布在多个broker上，一个broker可以配置多个topic，它们是多对多的关系。\n\n2. 如果某个topic消息量很大，应该给它多配置几个队列，并且尽量多分布在不同broker上，减轻某个broker的压力。\n\n3. topic消息量都比较均匀的情况下，如果某个broker上的队列越多，则该broker压力越大。\n\n__可用性:__\n   由于消息分布在各个broker上，一旦某个broker宕机，则该broker上的消息读写都会受到影响。所以rocketmq提供了master/slave的结构，salve定时从master同步数据，如果master宕机，则slave提供消费服务，但是不能写入消息，此过程对应用透明，由rocketmq内部解决。\n\n这里有两个关键点：\n\n1. 一旦某个broker master宕机，生产者和消费者多久才能发现？受限于rocketmq的网络连接机制，默认情况下，最多需要30秒，但这个时间可由应用设定参数来缩短时间。这个时间段内，发往该broker的消息都是失败的，而且该broker的消息无法消费，因为此时消费者不知道该broker已经挂掉。\n\n2. 消费者得到master宕机通知后，转向slave消费，但是slave不能保证master的消息100%都同步过来了，因此会有少量的消息丢失。但是消息最终不会丢的，一旦master恢复，未同步过去的消息会被消费掉。\n\n__可靠性:__\n1. 所有发往broker的消息，有同步刷盘和异步刷盘机制，总的来说，可靠性非常高\n\n2. 同步刷盘时，消息写入物理文件才会返回成功，因此非常可靠\n\n3. 异步刷盘时，只有机器宕机，才会产生消息丢失，broker挂掉可能会发生，但是机器宕机崩溃是很少发生的，除非突然断电\n\n__消息清理:__\n+ 扫描间隔\n\n默认10秒，由broker配置参数cleanResourceInterval决定\n\n+ 空间阈值\n\n物理文件不能无限制的一直存储在磁盘，当磁盘空间达到阈值时，不再接受消息，broker打印出日志，消息发送失败，阈值为固定值85%\n\n+ 清理时机\n\n默认每天凌晨4点，由broker配置参数deleteWhen决定；或者磁盘空间达到阈值\n\n+ 文件保留时长\n\n默认72小时，由broker配置参数fileReservedTime决定\n\n__读写性能:__\n1. 文件内存映射方式操作文件，避免read/write系统调用和实时文件读写，性能非常高\n\n2. 永远一个文件在写，其他文件在读\n\n3. 顺序写，随机读\n\n4. 利用linux的sendfile机制，将消息内容直接输出到sokect管道，避免系统调用\n\n__系统特性:__\n1. 大内存，内存越大性能越高，否则系统swap会成为性能瓶颈\n\n2. IO密集\n\n3. cpu load高，使用率低，因为cpu占用后，大部分时间在IO WAIT\n\n4. 磁盘可靠性要求高，为了兼顾安全和性能，采用RAID10阵列\n\n5. 磁盘读取速度要求快，要求高转速大容量磁盘\n\n### 3. 消费者\n__与nameserver关系__\n__连接:__\n\n单个消费者和一台nameserver保持长连接，定时查询topic配置信息，如果该nameserver挂掉，消费者会自动连接下一个nameserver，直到有可用连接为止，并能自动重连。\n\n__心跳:__\n\n与nameserver没有心跳\n\n__轮询时间:__\n\n默认情况下，消费者每隔30秒从nameserver获取所有topic的最新队列情况，这意味着某个broker如果宕机，客户端最多要30秒才能感知。该时间由DefaultMQPushConsumer的pollNameServerInteval参数决定，可手动配置。\n\n__与broker关系__\n\n__连接:__\n\n单个消费者和该消费者关联的所有broker保持长连接。\n\n__心跳:__\n\n默认情况下，消费者每隔30秒向所有broker发送心跳，该时间由DefaultMQPushConsumer的heartbeatBrokerInterval参数决定，可手动配置。broker每隔10秒钟（此时间无法更改），扫描所有还存活的连接，若某个连接2分钟内（当前时间与最后更新时间差值超过2分钟，此时间无法更改）没有发送心跳数据，则关闭连接，并向该消费者分组的所有消费者发出通知，分组内消费者重新分配队列继续消费\n\n__断开:__\n\n时机：消费者挂掉；心跳超时导致broker主动关闭连接\n\n动作：一旦连接断开，broker会立即感知到，并向该消费者分组的所有消费者发出通知，分组内消费者重新分配队列继续消费\n\n__负载均衡:__\n集群消费模式下，一个消费者集群多台机器共同消费一个topic的多个队列，一个队列只会被一个消费者消费。如果某个消费者挂掉，分组内其它消费者会接替挂掉的消费者继续消费。\n\n__消费机制:__\n\n+ 本地队列\n消费者不间断的从broker拉取消息，消息拉取到本地队列，然后本地消费线程消费本地消息队列，只是一个异步过程，拉取线程不会等待本地消费线程，这种模式实时性非常高。对消费者对本地队列有一个保护，因此本地消息队列不能无限大，否则可能会占用大量内存，本地队列大小由DefaultMQPushConsumer的pullThresholdForQueue属性控制，默认1000，可手动设置。\n\n+ 轮询间隔\n\n消息拉取线程每隔多久拉取一次？间隔时间由DefaultMQPushConsumer的pullInterval属性控制，默认为0，可手动设置。\n\n+ 消息消费数量\n\n监听器每次接受本地队列的消息是多少条？这个参数由DefaultMQPushConsumer的consumeMessageBatchMaxSize属性控制，默认为1，可手动设置。\n\n__消费进度存储:__\n每隔一段时间将各个队列的消费进度存储到对应的broker上，该时间由DefaultMQPushConsumer的persistConsumerOffsetInterval属性控制，默认为5秒，可手动设置。\n\n如果一个topic在某broker上有3个队列，一个消费者消费这3个队列，那么该消费者和这个broker有几个连接？\n一个连接，消费单位与队列相关，消费连接只跟broker相关，事实上，消费者将所有队列的消息拉取任务放到本地的队列，挨个拉取，拉取完毕后，又将拉取任务放到队尾，然后执行下一个拉取任务\n\n### 4. 生产者\n__与nameserver关系__\n__连接:__\n\n单个生产者者和一台nameserver保持长连接，定时查询topic配置信息，如果该nameserver挂掉，生产者会自动连接下一个nameserver，直到有可用连接为止，并能自动重连。\n\n__轮询时间:__\n\n默认情况下，生产者每隔30秒从nameserver获取所有topic的最新队列情况，这意味着某个broker如果宕机，生产者最多要30秒才能感知，在此期间，发往该broker的消息发送失败。该时间由DefaultMQProducer的pollNameServerInteval参数决定，可手动配置。\n\n__心跳:__\n\n与nameserver没有心跳\n\n__与broker关系__\n__连接:__\n\n单个生产者和该生产者关联的所有broker保持长连接。\n\n__心跳:__\n\n默认情况下，生产者每隔30秒向所有broker发送心跳，该时间由DefaultMQProducer的heartbeatBrokerInterval参数决定，可手动配置。broker每隔10秒钟（此时间无法更改），扫描所有还存活的连接，若某个连接2分钟内（当前时间与最后更新时间差值超过2分钟，此时间无法更改）没有发送心跳数据，则关闭连接。\n\n__连接断开:__\n\n移除broker上的生产者信息\n\n__负载均衡:__\n生产者时间没有关系，每个生产者向队列轮流发送消息\n\n## 三、集群方案\n1. 单个 Master\n   这种方式风险较大，一旦Broker 重启或者宕机时，会导致整个服务不可用，不建议线上环境使用。\n\n2. 多 Master 模式\n   一个集群无 Slave，全是 Master，例如 2 个 Master 或者 3 个 Master\n\n   优点：配置简单，单个Master 宕机或重启维护对应用无影响，在磁盘配置为 RAID10 时，即使机器宕机不可恢复情况下，由与 RAID10 磁盘非常可靠，消息也不会丢（异步刷盘丢失少量消息，同步刷盘一条不丢）。性能最高。\n\n   缺点：单台机器宕机期间，这台机器上未被消费的消息在机器恢复之前不可订阅，消息实时性会受到受到影响。\n\n_先启动 NameServer，例如机器 IP 为：172.16.8.106:9876_\n\n```\nnohup sh mqnamesrv &\n```\n   _在机器 A，启动第一个 Master_\n\n```\nnohup sh mqbroker -n 172.16.8.106:9876 -c $ROCKETMQ_HOME/conf/2m-noslave/broker-a.properties &\n```\n   _在机器 B，启动第二个 Master_\n\n```\nnohup sh mqbroker -n 172.16.8.106:9876 -c $ROCKETMQ_HOME/conf/2m-noslave/broker-b.properties &\n```\n3. 多 Master 多 Slave 模式，异步复制\n   每个 Master 配置一个 Slave，有多对Master-Slave，HA 采用异步复制方式，主备有短暂消息延迟，毫秒级。\n\n   优点：即使磁盘损坏，消息丢失的非常少，且消息实时性不会受影响，因为 Master 宕机后，消费者仍然可以从 Slave 消费，此过程对应用透明。不需要人工干预。性能同多 Master 模式几乎一样。\n\n   缺点：Master 宕机，磁盘损坏情况，会丢失少量消息。\n\n\n_先启动 NameServer，例如机器 IP 为：172.16.8.106:9876_\n\n```\nnohup sh mqnamesrv &\n```\n   _在机器 A，启动第一个 Master_\n\n```\nnohup sh mqbroker -n 172.16.8.106:9876 -c $ROCKETMQ_HOME/conf/2m-2s-async/broker-a.properties &\n```\n   _在机器 B，启动第二个 Master_\n\n```\nnohup sh mqbroker -n 172.16.8.106:9876 -c $ROCKETMQ_HOME/conf/2m-2s-async/broker-b.properties &\n```\n   _在机器 C，启动第一个 Slave_\n\n```\nnohup sh mqbroker -n 172.16.8.106:9876 -c $ROCKETMQ_HOME/conf/2m-2s-async/broker-a-s.properties &\n```\n   _在机器 D，启动第二个 Slave_\n\n```\nnohup sh mqbroker -n 172.16.8.106:9876 -c $ROCKETMQ_HOME/conf/2m-2s-async/broker-b-s.properties &\n```\n4. 多 Master 多 Slave 模式，同步双写\n   每个 Master 配置一个 Slave，有多对Master-Slave，HA 采用同步双写方式，主备都写成功，向应用返回成功。\n\n   优点：数据与服务都无单点，Master宕机情况下，消息无延迟，服务可用性与数据可用性都非常高\n\n   缺点：性能比异步复制模式略低，大约低 10%左右，发送单个消息的 RT 会略高。目前主宕机后，备机不能自动切换为主机，后续会支持自动切换功能。\n\n\n_先启动 NameServer，例如机器 IP 为：172.16.8.106:9876_\n\n```\nnohup sh mqnamesrv &\n```\n   _在机器 A，启动第一个 Master_\n\n```\nnohup sh mqbroker -n 172.16.8.106:9876 -c $ROCKETMQ_HOME/conf/2m-2s-sync/broker-a.properties &\n```\n   _在机器 B，启动第二个 Master_\n\n```\nnohup sh mqbroker -n 172.16.8.106:9876 -c $ROCKETMQ_HOME/conf/2m-2s-sync/broker-b.properties &\n```\n   _在机器 C，启动第一个 Slave_\n\n```\nnohup sh mqbroker -n 172.16.8.106:9876 -c $ROCKETMQ_HOME/conf/2m-2s-sync/broker-a-s.properties &\n```\n   _在机器 D，启动第二个 Slave_\n\n```\nnohup sh mqbroker -n 172.16.8.106:9876 -c $ROCKETMQ_HOME/conf/2m-2s-sync/broker-b-s.properties &\n```\n   以上 Broker 与 Slave 配对是通过指定相同的brokerName 参数来配对，Master 的 BrokerId 必须是 0，Slave的BrokerId 必须是大与 0 的数。另外一个 Master 下面可以挂载多个 Slave，同一 Master 下的多个 Slave 通过指定不同的 BrokerId 来区分。\n\n-----\n_转自:https://www.cnblogs.com/xiaodf/p/5075167.html_\n\n*观点仅代表自己，期待你的留言。*\n","source":"_posts/mq-rocketmq-module.md","raw":"---\ntitle: RocketMQ各组件特性和HA集群方案\ntags:\n  - 转载\nkeywords:\n  - Apache RocketMQ 组件\ndate: 2018-04-04 16:58:58\ntoc: true\nlist_number: false\n---\n## 一、简介\n\n- RocketMQ是一款分布式、队列模型的消息中间件，具有以下特点：\n\n- 能够保证严格的消息顺序\n\n- 提供丰富的消息拉取模式\n\n- 高效的订阅者水平扩展能力\n\n- 实时的消息订阅机制\n\n- 亿级消息堆积能力\n\n## 二、组件特性\n### 1. nameserver\n相对来说，nameserver的稳定性非常高。原因有二：\n\n+ nameserver互相独立，彼此没有通信关系，单台nameserver挂掉，不影响其他nameserver，即使全部挂掉，也不影响业务系统使用。\n\n+ nameserver不会有频繁的读写，所以性能开销非常小，稳定性很高。\n\n### 2. broker\n__与nameserver关系__\n__连接:__\n\n单个broker和所有nameserver保持长连接\n\n__心跳:__\n\n心跳间隔：每隔30秒（此时间无法更改）向所有nameserver发送心跳，心跳包含了自身的topic配置信息。\n\n心跳超时：nameserver每隔10秒钟（此时间无法更改），扫描所有还存活的broker连接，若某个连接2分钟内（当前时间与最后更新时间差值超过2分钟，此时间无法更改）没有发送心跳数据，则断开连接。\n\n__断开:__\n\n时机：broker挂掉；心跳超时导致nameserver主动关闭连接\n\n动作：一旦连接断开，nameserver会立即感知，更新topc与队列的对应关系，但不会通知生产者和消费者\n\n__负载均衡:__\n1. 一个topic分布在多个broker上，一个broker可以配置多个topic，它们是多对多的关系。\n\n2. 如果某个topic消息量很大，应该给它多配置几个队列，并且尽量多分布在不同broker上，减轻某个broker的压力。\n\n3. topic消息量都比较均匀的情况下，如果某个broker上的队列越多，则该broker压力越大。\n\n__可用性:__\n   由于消息分布在各个broker上，一旦某个broker宕机，则该broker上的消息读写都会受到影响。所以rocketmq提供了master/slave的结构，salve定时从master同步数据，如果master宕机，则slave提供消费服务，但是不能写入消息，此过程对应用透明，由rocketmq内部解决。\n\n这里有两个关键点：\n\n1. 一旦某个broker master宕机，生产者和消费者多久才能发现？受限于rocketmq的网络连接机制，默认情况下，最多需要30秒，但这个时间可由应用设定参数来缩短时间。这个时间段内，发往该broker的消息都是失败的，而且该broker的消息无法消费，因为此时消费者不知道该broker已经挂掉。\n\n2. 消费者得到master宕机通知后，转向slave消费，但是slave不能保证master的消息100%都同步过来了，因此会有少量的消息丢失。但是消息最终不会丢的，一旦master恢复，未同步过去的消息会被消费掉。\n\n__可靠性:__\n1. 所有发往broker的消息，有同步刷盘和异步刷盘机制，总的来说，可靠性非常高\n\n2. 同步刷盘时，消息写入物理文件才会返回成功，因此非常可靠\n\n3. 异步刷盘时，只有机器宕机，才会产生消息丢失，broker挂掉可能会发生，但是机器宕机崩溃是很少发生的，除非突然断电\n\n__消息清理:__\n+ 扫描间隔\n\n默认10秒，由broker配置参数cleanResourceInterval决定\n\n+ 空间阈值\n\n物理文件不能无限制的一直存储在磁盘，当磁盘空间达到阈值时，不再接受消息，broker打印出日志，消息发送失败，阈值为固定值85%\n\n+ 清理时机\n\n默认每天凌晨4点，由broker配置参数deleteWhen决定；或者磁盘空间达到阈值\n\n+ 文件保留时长\n\n默认72小时，由broker配置参数fileReservedTime决定\n\n__读写性能:__\n1. 文件内存映射方式操作文件，避免read/write系统调用和实时文件读写，性能非常高\n\n2. 永远一个文件在写，其他文件在读\n\n3. 顺序写，随机读\n\n4. 利用linux的sendfile机制，将消息内容直接输出到sokect管道，避免系统调用\n\n__系统特性:__\n1. 大内存，内存越大性能越高，否则系统swap会成为性能瓶颈\n\n2. IO密集\n\n3. cpu load高，使用率低，因为cpu占用后，大部分时间在IO WAIT\n\n4. 磁盘可靠性要求高，为了兼顾安全和性能，采用RAID10阵列\n\n5. 磁盘读取速度要求快，要求高转速大容量磁盘\n\n### 3. 消费者\n__与nameserver关系__\n__连接:__\n\n单个消费者和一台nameserver保持长连接，定时查询topic配置信息，如果该nameserver挂掉，消费者会自动连接下一个nameserver，直到有可用连接为止，并能自动重连。\n\n__心跳:__\n\n与nameserver没有心跳\n\n__轮询时间:__\n\n默认情况下，消费者每隔30秒从nameserver获取所有topic的最新队列情况，这意味着某个broker如果宕机，客户端最多要30秒才能感知。该时间由DefaultMQPushConsumer的pollNameServerInteval参数决定，可手动配置。\n\n__与broker关系__\n\n__连接:__\n\n单个消费者和该消费者关联的所有broker保持长连接。\n\n__心跳:__\n\n默认情况下，消费者每隔30秒向所有broker发送心跳，该时间由DefaultMQPushConsumer的heartbeatBrokerInterval参数决定，可手动配置。broker每隔10秒钟（此时间无法更改），扫描所有还存活的连接，若某个连接2分钟内（当前时间与最后更新时间差值超过2分钟，此时间无法更改）没有发送心跳数据，则关闭连接，并向该消费者分组的所有消费者发出通知，分组内消费者重新分配队列继续消费\n\n__断开:__\n\n时机：消费者挂掉；心跳超时导致broker主动关闭连接\n\n动作：一旦连接断开，broker会立即感知到，并向该消费者分组的所有消费者发出通知，分组内消费者重新分配队列继续消费\n\n__负载均衡:__\n集群消费模式下，一个消费者集群多台机器共同消费一个topic的多个队列，一个队列只会被一个消费者消费。如果某个消费者挂掉，分组内其它消费者会接替挂掉的消费者继续消费。\n\n__消费机制:__\n\n+ 本地队列\n消费者不间断的从broker拉取消息，消息拉取到本地队列，然后本地消费线程消费本地消息队列，只是一个异步过程，拉取线程不会等待本地消费线程，这种模式实时性非常高。对消费者对本地队列有一个保护，因此本地消息队列不能无限大，否则可能会占用大量内存，本地队列大小由DefaultMQPushConsumer的pullThresholdForQueue属性控制，默认1000，可手动设置。\n\n+ 轮询间隔\n\n消息拉取线程每隔多久拉取一次？间隔时间由DefaultMQPushConsumer的pullInterval属性控制，默认为0，可手动设置。\n\n+ 消息消费数量\n\n监听器每次接受本地队列的消息是多少条？这个参数由DefaultMQPushConsumer的consumeMessageBatchMaxSize属性控制，默认为1，可手动设置。\n\n__消费进度存储:__\n每隔一段时间将各个队列的消费进度存储到对应的broker上，该时间由DefaultMQPushConsumer的persistConsumerOffsetInterval属性控制，默认为5秒，可手动设置。\n\n如果一个topic在某broker上有3个队列，一个消费者消费这3个队列，那么该消费者和这个broker有几个连接？\n一个连接，消费单位与队列相关，消费连接只跟broker相关，事实上，消费者将所有队列的消息拉取任务放到本地的队列，挨个拉取，拉取完毕后，又将拉取任务放到队尾，然后执行下一个拉取任务\n\n### 4. 生产者\n__与nameserver关系__\n__连接:__\n\n单个生产者者和一台nameserver保持长连接，定时查询topic配置信息，如果该nameserver挂掉，生产者会自动连接下一个nameserver，直到有可用连接为止，并能自动重连。\n\n__轮询时间:__\n\n默认情况下，生产者每隔30秒从nameserver获取所有topic的最新队列情况，这意味着某个broker如果宕机，生产者最多要30秒才能感知，在此期间，发往该broker的消息发送失败。该时间由DefaultMQProducer的pollNameServerInteval参数决定，可手动配置。\n\n__心跳:__\n\n与nameserver没有心跳\n\n__与broker关系__\n__连接:__\n\n单个生产者和该生产者关联的所有broker保持长连接。\n\n__心跳:__\n\n默认情况下，生产者每隔30秒向所有broker发送心跳，该时间由DefaultMQProducer的heartbeatBrokerInterval参数决定，可手动配置。broker每隔10秒钟（此时间无法更改），扫描所有还存活的连接，若某个连接2分钟内（当前时间与最后更新时间差值超过2分钟，此时间无法更改）没有发送心跳数据，则关闭连接。\n\n__连接断开:__\n\n移除broker上的生产者信息\n\n__负载均衡:__\n生产者时间没有关系，每个生产者向队列轮流发送消息\n\n## 三、集群方案\n1. 单个 Master\n   这种方式风险较大，一旦Broker 重启或者宕机时，会导致整个服务不可用，不建议线上环境使用。\n\n2. 多 Master 模式\n   一个集群无 Slave，全是 Master，例如 2 个 Master 或者 3 个 Master\n\n   优点：配置简单，单个Master 宕机或重启维护对应用无影响，在磁盘配置为 RAID10 时，即使机器宕机不可恢复情况下，由与 RAID10 磁盘非常可靠，消息也不会丢（异步刷盘丢失少量消息，同步刷盘一条不丢）。性能最高。\n\n   缺点：单台机器宕机期间，这台机器上未被消费的消息在机器恢复之前不可订阅，消息实时性会受到受到影响。\n\n_先启动 NameServer，例如机器 IP 为：172.16.8.106:9876_\n\n```\nnohup sh mqnamesrv &\n```\n   _在机器 A，启动第一个 Master_\n\n```\nnohup sh mqbroker -n 172.16.8.106:9876 -c $ROCKETMQ_HOME/conf/2m-noslave/broker-a.properties &\n```\n   _在机器 B，启动第二个 Master_\n\n```\nnohup sh mqbroker -n 172.16.8.106:9876 -c $ROCKETMQ_HOME/conf/2m-noslave/broker-b.properties &\n```\n3. 多 Master 多 Slave 模式，异步复制\n   每个 Master 配置一个 Slave，有多对Master-Slave，HA 采用异步复制方式，主备有短暂消息延迟，毫秒级。\n\n   优点：即使磁盘损坏，消息丢失的非常少，且消息实时性不会受影响，因为 Master 宕机后，消费者仍然可以从 Slave 消费，此过程对应用透明。不需要人工干预。性能同多 Master 模式几乎一样。\n\n   缺点：Master 宕机，磁盘损坏情况，会丢失少量消息。\n\n\n_先启动 NameServer，例如机器 IP 为：172.16.8.106:9876_\n\n```\nnohup sh mqnamesrv &\n```\n   _在机器 A，启动第一个 Master_\n\n```\nnohup sh mqbroker -n 172.16.8.106:9876 -c $ROCKETMQ_HOME/conf/2m-2s-async/broker-a.properties &\n```\n   _在机器 B，启动第二个 Master_\n\n```\nnohup sh mqbroker -n 172.16.8.106:9876 -c $ROCKETMQ_HOME/conf/2m-2s-async/broker-b.properties &\n```\n   _在机器 C，启动第一个 Slave_\n\n```\nnohup sh mqbroker -n 172.16.8.106:9876 -c $ROCKETMQ_HOME/conf/2m-2s-async/broker-a-s.properties &\n```\n   _在机器 D，启动第二个 Slave_\n\n```\nnohup sh mqbroker -n 172.16.8.106:9876 -c $ROCKETMQ_HOME/conf/2m-2s-async/broker-b-s.properties &\n```\n4. 多 Master 多 Slave 模式，同步双写\n   每个 Master 配置一个 Slave，有多对Master-Slave，HA 采用同步双写方式，主备都写成功，向应用返回成功。\n\n   优点：数据与服务都无单点，Master宕机情况下，消息无延迟，服务可用性与数据可用性都非常高\n\n   缺点：性能比异步复制模式略低，大约低 10%左右，发送单个消息的 RT 会略高。目前主宕机后，备机不能自动切换为主机，后续会支持自动切换功能。\n\n\n_先启动 NameServer，例如机器 IP 为：172.16.8.106:9876_\n\n```\nnohup sh mqnamesrv &\n```\n   _在机器 A，启动第一个 Master_\n\n```\nnohup sh mqbroker -n 172.16.8.106:9876 -c $ROCKETMQ_HOME/conf/2m-2s-sync/broker-a.properties &\n```\n   _在机器 B，启动第二个 Master_\n\n```\nnohup sh mqbroker -n 172.16.8.106:9876 -c $ROCKETMQ_HOME/conf/2m-2s-sync/broker-b.properties &\n```\n   _在机器 C，启动第一个 Slave_\n\n```\nnohup sh mqbroker -n 172.16.8.106:9876 -c $ROCKETMQ_HOME/conf/2m-2s-sync/broker-a-s.properties &\n```\n   _在机器 D，启动第二个 Slave_\n\n```\nnohup sh mqbroker -n 172.16.8.106:9876 -c $ROCKETMQ_HOME/conf/2m-2s-sync/broker-b-s.properties &\n```\n   以上 Broker 与 Slave 配对是通过指定相同的brokerName 参数来配对，Master 的 BrokerId 必须是 0，Slave的BrokerId 必须是大与 0 的数。另外一个 Master 下面可以挂载多个 Slave，同一 Master 下的多个 Slave 通过指定不同的 BrokerId 来区分。\n\n-----\n_转自:https://www.cnblogs.com/xiaodf/p/5075167.html_\n\n*观点仅代表自己，期待你的留言。*\n","slug":"mq-rocketmq-module","published":1,"updated":"2021-08-31T14:23:11.547Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cku52dynt0034bbin0f32da75","content":"<h2 id=\"一、简介\"><a href=\"#一、简介\" class=\"headerlink\" title=\"一、简介\"></a>一、简介</h2><ul>\n<li><p>RocketMQ是一款分布式、队列模型的消息中间件，具有以下特点：</p>\n</li>\n<li><p>能够保证严格的消息顺序</p>\n</li>\n<li><p>提供丰富的消息拉取模式</p>\n</li>\n<li><p>高效的订阅者水平扩展能力</p>\n</li>\n<li><p>实时的消息订阅机制</p>\n</li>\n<li><p>亿级消息堆积能力</p>\n</li>\n</ul>\n<h2 id=\"二、组件特性\"><a href=\"#二、组件特性\" class=\"headerlink\" title=\"二、组件特性\"></a>二、组件特性</h2><h3 id=\"1-nameserver\"><a href=\"#1-nameserver\" class=\"headerlink\" title=\"1. nameserver\"></a>1. nameserver</h3><p>相对来说，nameserver的稳定性非常高。原因有二：</p>\n<ul>\n<li><p>nameserver互相独立，彼此没有通信关系，单台nameserver挂掉，不影响其他nameserver，即使全部挂掉，也不影响业务系统使用。</p>\n</li>\n<li><p>nameserver不会有频繁的读写，所以性能开销非常小，稳定性很高。</p>\n</li>\n</ul>\n<h3 id=\"2-broker\"><a href=\"#2-broker\" class=\"headerlink\" title=\"2. broker\"></a>2. broker</h3><p><strong>与nameserver关系</strong><br><strong>连接:</strong></p>\n<p>单个broker和所有nameserver保持长连接</p>\n<p><strong>心跳:</strong></p>\n<p>心跳间隔：每隔30秒（此时间无法更改）向所有nameserver发送心跳，心跳包含了自身的topic配置信息。</p>\n<p>心跳超时：nameserver每隔10秒钟（此时间无法更改），扫描所有还存活的broker连接，若某个连接2分钟内（当前时间与最后更新时间差值超过2分钟，此时间无法更改）没有发送心跳数据，则断开连接。</p>\n<p><strong>断开:</strong></p>\n<p>时机：broker挂掉；心跳超时导致nameserver主动关闭连接</p>\n<p>动作：一旦连接断开，nameserver会立即感知，更新topc与队列的对应关系，但不会通知生产者和消费者</p>\n<p><strong>负载均衡:</strong></p>\n<ol>\n<li><p>一个topic分布在多个broker上，一个broker可以配置多个topic，它们是多对多的关系。</p>\n</li>\n<li><p>如果某个topic消息量很大，应该给它多配置几个队列，并且尽量多分布在不同broker上，减轻某个broker的压力。</p>\n</li>\n<li><p>topic消息量都比较均匀的情况下，如果某个broker上的队列越多，则该broker压力越大。</p>\n</li>\n</ol>\n<p><strong>可用性:</strong><br>   由于消息分布在各个broker上，一旦某个broker宕机，则该broker上的消息读写都会受到影响。所以rocketmq提供了master/slave的结构，salve定时从master同步数据，如果master宕机，则slave提供消费服务，但是不能写入消息，此过程对应用透明，由rocketmq内部解决。</p>\n<p>这里有两个关键点：</p>\n<ol>\n<li><p>一旦某个broker master宕机，生产者和消费者多久才能发现？受限于rocketmq的网络连接机制，默认情况下，最多需要30秒，但这个时间可由应用设定参数来缩短时间。这个时间段内，发往该broker的消息都是失败的，而且该broker的消息无法消费，因为此时消费者不知道该broker已经挂掉。</p>\n</li>\n<li><p>消费者得到master宕机通知后，转向slave消费，但是slave不能保证master的消息100%都同步过来了，因此会有少量的消息丢失。但是消息最终不会丢的，一旦master恢复，未同步过去的消息会被消费掉。</p>\n</li>\n</ol>\n<p><strong>可靠性:</strong></p>\n<ol>\n<li><p>所有发往broker的消息，有同步刷盘和异步刷盘机制，总的来说，可靠性非常高</p>\n</li>\n<li><p>同步刷盘时，消息写入物理文件才会返回成功，因此非常可靠</p>\n</li>\n<li><p>异步刷盘时，只有机器宕机，才会产生消息丢失，broker挂掉可能会发生，但是机器宕机崩溃是很少发生的，除非突然断电</p>\n</li>\n</ol>\n<p><strong>消息清理:</strong></p>\n<ul>\n<li>扫描间隔</li>\n</ul>\n<p>默认10秒，由broker配置参数cleanResourceInterval决定</p>\n<ul>\n<li>空间阈值</li>\n</ul>\n<p>物理文件不能无限制的一直存储在磁盘，当磁盘空间达到阈值时，不再接受消息，broker打印出日志，消息发送失败，阈值为固定值85%</p>\n<ul>\n<li>清理时机</li>\n</ul>\n<p>默认每天凌晨4点，由broker配置参数deleteWhen决定；或者磁盘空间达到阈值</p>\n<ul>\n<li>文件保留时长</li>\n</ul>\n<p>默认72小时，由broker配置参数fileReservedTime决定</p>\n<p><strong>读写性能:</strong></p>\n<ol>\n<li><p>文件内存映射方式操作文件，避免read/write系统调用和实时文件读写，性能非常高</p>\n</li>\n<li><p>永远一个文件在写，其他文件在读</p>\n</li>\n<li><p>顺序写，随机读</p>\n</li>\n<li><p>利用linux的sendfile机制，将消息内容直接输出到sokect管道，避免系统调用</p>\n</li>\n</ol>\n<p><strong>系统特性:</strong></p>\n<ol>\n<li><p>大内存，内存越大性能越高，否则系统swap会成为性能瓶颈</p>\n</li>\n<li><p>IO密集</p>\n</li>\n<li><p>cpu load高，使用率低，因为cpu占用后，大部分时间在IO WAIT</p>\n</li>\n<li><p>磁盘可靠性要求高，为了兼顾安全和性能，采用RAID10阵列</p>\n</li>\n<li><p>磁盘读取速度要求快，要求高转速大容量磁盘</p>\n</li>\n</ol>\n<h3 id=\"3-消费者\"><a href=\"#3-消费者\" class=\"headerlink\" title=\"3. 消费者\"></a>3. 消费者</h3><p><strong>与nameserver关系</strong><br><strong>连接:</strong></p>\n<p>单个消费者和一台nameserver保持长连接，定时查询topic配置信息，如果该nameserver挂掉，消费者会自动连接下一个nameserver，直到有可用连接为止，并能自动重连。</p>\n<p><strong>心跳:</strong></p>\n<p>与nameserver没有心跳</p>\n<p><strong>轮询时间:</strong></p>\n<p>默认情况下，消费者每隔30秒从nameserver获取所有topic的最新队列情况，这意味着某个broker如果宕机，客户端最多要30秒才能感知。该时间由DefaultMQPushConsumer的pollNameServerInteval参数决定，可手动配置。</p>\n<p><strong>与broker关系</strong></p>\n<p><strong>连接:</strong></p>\n<p>单个消费者和该消费者关联的所有broker保持长连接。</p>\n<p><strong>心跳:</strong></p>\n<p>默认情况下，消费者每隔30秒向所有broker发送心跳，该时间由DefaultMQPushConsumer的heartbeatBrokerInterval参数决定，可手动配置。broker每隔10秒钟（此时间无法更改），扫描所有还存活的连接，若某个连接2分钟内（当前时间与最后更新时间差值超过2分钟，此时间无法更改）没有发送心跳数据，则关闭连接，并向该消费者分组的所有消费者发出通知，分组内消费者重新分配队列继续消费</p>\n<p><strong>断开:</strong></p>\n<p>时机：消费者挂掉；心跳超时导致broker主动关闭连接</p>\n<p>动作：一旦连接断开，broker会立即感知到，并向该消费者分组的所有消费者发出通知，分组内消费者重新分配队列继续消费</p>\n<p><strong>负载均衡:</strong><br>集群消费模式下，一个消费者集群多台机器共同消费一个topic的多个队列，一个队列只会被一个消费者消费。如果某个消费者挂掉，分组内其它消费者会接替挂掉的消费者继续消费。</p>\n<p><strong>消费机制:</strong></p>\n<ul>\n<li><p>本地队列<br>消费者不间断的从broker拉取消息，消息拉取到本地队列，然后本地消费线程消费本地消息队列，只是一个异步过程，拉取线程不会等待本地消费线程，这种模式实时性非常高。对消费者对本地队列有一个保护，因此本地消息队列不能无限大，否则可能会占用大量内存，本地队列大小由DefaultMQPushConsumer的pullThresholdForQueue属性控制，默认1000，可手动设置。</p>\n</li>\n<li><p>轮询间隔</p>\n</li>\n</ul>\n<p>消息拉取线程每隔多久拉取一次？间隔时间由DefaultMQPushConsumer的pullInterval属性控制，默认为0，可手动设置。</p>\n<ul>\n<li>消息消费数量</li>\n</ul>\n<p>监听器每次接受本地队列的消息是多少条？这个参数由DefaultMQPushConsumer的consumeMessageBatchMaxSize属性控制，默认为1，可手动设置。</p>\n<p><strong>消费进度存储:</strong><br>每隔一段时间将各个队列的消费进度存储到对应的broker上，该时间由DefaultMQPushConsumer的persistConsumerOffsetInterval属性控制，默认为5秒，可手动设置。</p>\n<p>如果一个topic在某broker上有3个队列，一个消费者消费这3个队列，那么该消费者和这个broker有几个连接？<br>一个连接，消费单位与队列相关，消费连接只跟broker相关，事实上，消费者将所有队列的消息拉取任务放到本地的队列，挨个拉取，拉取完毕后，又将拉取任务放到队尾，然后执行下一个拉取任务</p>\n<h3 id=\"4-生产者\"><a href=\"#4-生产者\" class=\"headerlink\" title=\"4. 生产者\"></a>4. 生产者</h3><p><strong>与nameserver关系</strong><br><strong>连接:</strong></p>\n<p>单个生产者者和一台nameserver保持长连接，定时查询topic配置信息，如果该nameserver挂掉，生产者会自动连接下一个nameserver，直到有可用连接为止，并能自动重连。</p>\n<p><strong>轮询时间:</strong></p>\n<p>默认情况下，生产者每隔30秒从nameserver获取所有topic的最新队列情况，这意味着某个broker如果宕机，生产者最多要30秒才能感知，在此期间，发往该broker的消息发送失败。该时间由DefaultMQProducer的pollNameServerInteval参数决定，可手动配置。</p>\n<p><strong>心跳:</strong></p>\n<p>与nameserver没有心跳</p>\n<p><strong>与broker关系</strong><br><strong>连接:</strong></p>\n<p>单个生产者和该生产者关联的所有broker保持长连接。</p>\n<p><strong>心跳:</strong></p>\n<p>默认情况下，生产者每隔30秒向所有broker发送心跳，该时间由DefaultMQProducer的heartbeatBrokerInterval参数决定，可手动配置。broker每隔10秒钟（此时间无法更改），扫描所有还存活的连接，若某个连接2分钟内（当前时间与最后更新时间差值超过2分钟，此时间无法更改）没有发送心跳数据，则关闭连接。</p>\n<p><strong>连接断开:</strong></p>\n<p>移除broker上的生产者信息</p>\n<p><strong>负载均衡:</strong><br>生产者时间没有关系，每个生产者向队列轮流发送消息</p>\n<h2 id=\"三、集群方案\"><a href=\"#三、集群方案\" class=\"headerlink\" title=\"三、集群方案\"></a>三、集群方案</h2><ol>\n<li><p>单个 Master<br>这种方式风险较大，一旦Broker 重启或者宕机时，会导致整个服务不可用，不建议线上环境使用。</p>\n</li>\n<li><p>多 Master 模式<br>一个集群无 Slave，全是 Master，例如 2 个 Master 或者 3 个 Master</p>\n<p>优点：配置简单，单个Master 宕机或重启维护对应用无影响，在磁盘配置为 RAID10 时，即使机器宕机不可恢复情况下，由与 RAID10 磁盘非常可靠，消息也不会丢（异步刷盘丢失少量消息，同步刷盘一条不丢）。性能最高。</p>\n<p>缺点：单台机器宕机期间，这台机器上未被消费的消息在机器恢复之前不可订阅，消息实时性会受到受到影响。</p>\n</li>\n</ol>\n<p><em>先启动 NameServer，例如机器 IP 为：172.16.8.106:9876</em></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nohup sh mqnamesrv &amp;</span><br></pre></td></tr></table></figure>\n<p>   <em>在机器 A，启动第一个 Master</em></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nohup sh mqbroker -n 172.16.8.106:9876 -c $ROCKETMQ_HOME/conf/2m-noslave/broker-a.properties &amp;</span><br></pre></td></tr></table></figure>\n<p>   <em>在机器 B，启动第二个 Master</em></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nohup sh mqbroker -n 172.16.8.106:9876 -c $ROCKETMQ_HOME/conf/2m-noslave/broker-b.properties &amp;</span><br></pre></td></tr></table></figure>\n<ol start=\"3\">\n<li><p>多 Master 多 Slave 模式，异步复制<br>每个 Master 配置一个 Slave，有多对Master-Slave，HA 采用异步复制方式，主备有短暂消息延迟，毫秒级。</p>\n<p>优点：即使磁盘损坏，消息丢失的非常少，且消息实时性不会受影响，因为 Master 宕机后，消费者仍然可以从 Slave 消费，此过程对应用透明。不需要人工干预。性能同多 Master 模式几乎一样。</p>\n<p>缺点：Master 宕机，磁盘损坏情况，会丢失少量消息。</p>\n</li>\n</ol>\n<p><em>先启动 NameServer，例如机器 IP 为：172.16.8.106:9876</em></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nohup sh mqnamesrv &amp;</span><br></pre></td></tr></table></figure>\n<p>   <em>在机器 A，启动第一个 Master</em></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nohup sh mqbroker -n 172.16.8.106:9876 -c $ROCKETMQ_HOME/conf/2m-2s-async/broker-a.properties &amp;</span><br></pre></td></tr></table></figure>\n<p>   <em>在机器 B，启动第二个 Master</em></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nohup sh mqbroker -n 172.16.8.106:9876 -c $ROCKETMQ_HOME/conf/2m-2s-async/broker-b.properties &amp;</span><br></pre></td></tr></table></figure>\n<p>   <em>在机器 C，启动第一个 Slave</em></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nohup sh mqbroker -n 172.16.8.106:9876 -c $ROCKETMQ_HOME/conf/2m-2s-async/broker-a-s.properties &amp;</span><br></pre></td></tr></table></figure>\n<p>   <em>在机器 D，启动第二个 Slave</em></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nohup sh mqbroker -n 172.16.8.106:9876 -c $ROCKETMQ_HOME/conf/2m-2s-async/broker-b-s.properties &amp;</span><br></pre></td></tr></table></figure>\n<ol start=\"4\">\n<li><p>多 Master 多 Slave 模式，同步双写<br>每个 Master 配置一个 Slave，有多对Master-Slave，HA 采用同步双写方式，主备都写成功，向应用返回成功。</p>\n<p>优点：数据与服务都无单点，Master宕机情况下，消息无延迟，服务可用性与数据可用性都非常高</p>\n<p>缺点：性能比异步复制模式略低，大约低 10%左右，发送单个消息的 RT 会略高。目前主宕机后，备机不能自动切换为主机，后续会支持自动切换功能。</p>\n</li>\n</ol>\n<p><em>先启动 NameServer，例如机器 IP 为：172.16.8.106:9876</em></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nohup sh mqnamesrv &amp;</span><br></pre></td></tr></table></figure>\n<p>   <em>在机器 A，启动第一个 Master</em></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nohup sh mqbroker -n 172.16.8.106:9876 -c $ROCKETMQ_HOME/conf/2m-2s-sync/broker-a.properties &amp;</span><br></pre></td></tr></table></figure>\n<p>   <em>在机器 B，启动第二个 Master</em></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nohup sh mqbroker -n 172.16.8.106:9876 -c $ROCKETMQ_HOME/conf/2m-2s-sync/broker-b.properties &amp;</span><br></pre></td></tr></table></figure>\n<p>   <em>在机器 C，启动第一个 Slave</em></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nohup sh mqbroker -n 172.16.8.106:9876 -c $ROCKETMQ_HOME/conf/2m-2s-sync/broker-a-s.properties &amp;</span><br></pre></td></tr></table></figure>\n<p>   <em>在机器 D，启动第二个 Slave</em></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nohup sh mqbroker -n 172.16.8.106:9876 -c $ROCKETMQ_HOME/conf/2m-2s-sync/broker-b-s.properties &amp;</span><br></pre></td></tr></table></figure>\n<p>   以上 Broker 与 Slave 配对是通过指定相同的brokerName 参数来配对，Master 的 BrokerId 必须是 0，Slave的BrokerId 必须是大与 0 的数。另外一个 Master 下面可以挂载多个 Slave，同一 Master 下的多个 Slave 通过指定不同的 BrokerId 来区分。</p>\n<hr>\n<p><em>转自:<a href=\"https://www.cnblogs.com/xiaodf/p/5075167.html\">https://www.cnblogs.com/xiaodf/p/5075167.html</a></em></p>\n<p><em>观点仅代表自己，期待你的留言。</em></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"一、简介\"><a href=\"#一、简介\" class=\"headerlink\" title=\"一、简介\"></a>一、简介</h2><ul>\n<li><p>RocketMQ是一款分布式、队列模型的消息中间件，具有以下特点：</p>\n</li>\n<li><p>能够保证严格的消息顺序</p>\n</li>\n<li><p>提供丰富的消息拉取模式</p>\n</li>\n<li><p>高效的订阅者水平扩展能力</p>\n</li>\n<li><p>实时的消息订阅机制</p>\n</li>\n<li><p>亿级消息堆积能力</p>\n</li>\n</ul>\n<h2 id=\"二、组件特性\"><a href=\"#二、组件特性\" class=\"headerlink\" title=\"二、组件特性\"></a>二、组件特性</h2><h3 id=\"1-nameserver\"><a href=\"#1-nameserver\" class=\"headerlink\" title=\"1. nameserver\"></a>1. nameserver</h3><p>相对来说，nameserver的稳定性非常高。原因有二：</p>\n<ul>\n<li><p>nameserver互相独立，彼此没有通信关系，单台nameserver挂掉，不影响其他nameserver，即使全部挂掉，也不影响业务系统使用。</p>\n</li>\n<li><p>nameserver不会有频繁的读写，所以性能开销非常小，稳定性很高。</p>\n</li>\n</ul>\n<h3 id=\"2-broker\"><a href=\"#2-broker\" class=\"headerlink\" title=\"2. broker\"></a>2. broker</h3><p><strong>与nameserver关系</strong><br><strong>连接:</strong></p>\n<p>单个broker和所有nameserver保持长连接</p>\n<p><strong>心跳:</strong></p>\n<p>心跳间隔：每隔30秒（此时间无法更改）向所有nameserver发送心跳，心跳包含了自身的topic配置信息。</p>\n<p>心跳超时：nameserver每隔10秒钟（此时间无法更改），扫描所有还存活的broker连接，若某个连接2分钟内（当前时间与最后更新时间差值超过2分钟，此时间无法更改）没有发送心跳数据，则断开连接。</p>\n<p><strong>断开:</strong></p>\n<p>时机：broker挂掉；心跳超时导致nameserver主动关闭连接</p>\n<p>动作：一旦连接断开，nameserver会立即感知，更新topc与队列的对应关系，但不会通知生产者和消费者</p>\n<p><strong>负载均衡:</strong></p>\n<ol>\n<li><p>一个topic分布在多个broker上，一个broker可以配置多个topic，它们是多对多的关系。</p>\n</li>\n<li><p>如果某个topic消息量很大，应该给它多配置几个队列，并且尽量多分布在不同broker上，减轻某个broker的压力。</p>\n</li>\n<li><p>topic消息量都比较均匀的情况下，如果某个broker上的队列越多，则该broker压力越大。</p>\n</li>\n</ol>\n<p><strong>可用性:</strong><br>   由于消息分布在各个broker上，一旦某个broker宕机，则该broker上的消息读写都会受到影响。所以rocketmq提供了master/slave的结构，salve定时从master同步数据，如果master宕机，则slave提供消费服务，但是不能写入消息，此过程对应用透明，由rocketmq内部解决。</p>\n<p>这里有两个关键点：</p>\n<ol>\n<li><p>一旦某个broker master宕机，生产者和消费者多久才能发现？受限于rocketmq的网络连接机制，默认情况下，最多需要30秒，但这个时间可由应用设定参数来缩短时间。这个时间段内，发往该broker的消息都是失败的，而且该broker的消息无法消费，因为此时消费者不知道该broker已经挂掉。</p>\n</li>\n<li><p>消费者得到master宕机通知后，转向slave消费，但是slave不能保证master的消息100%都同步过来了，因此会有少量的消息丢失。但是消息最终不会丢的，一旦master恢复，未同步过去的消息会被消费掉。</p>\n</li>\n</ol>\n<p><strong>可靠性:</strong></p>\n<ol>\n<li><p>所有发往broker的消息，有同步刷盘和异步刷盘机制，总的来说，可靠性非常高</p>\n</li>\n<li><p>同步刷盘时，消息写入物理文件才会返回成功，因此非常可靠</p>\n</li>\n<li><p>异步刷盘时，只有机器宕机，才会产生消息丢失，broker挂掉可能会发生，但是机器宕机崩溃是很少发生的，除非突然断电</p>\n</li>\n</ol>\n<p><strong>消息清理:</strong></p>\n<ul>\n<li>扫描间隔</li>\n</ul>\n<p>默认10秒，由broker配置参数cleanResourceInterval决定</p>\n<ul>\n<li>空间阈值</li>\n</ul>\n<p>物理文件不能无限制的一直存储在磁盘，当磁盘空间达到阈值时，不再接受消息，broker打印出日志，消息发送失败，阈值为固定值85%</p>\n<ul>\n<li>清理时机</li>\n</ul>\n<p>默认每天凌晨4点，由broker配置参数deleteWhen决定；或者磁盘空间达到阈值</p>\n<ul>\n<li>文件保留时长</li>\n</ul>\n<p>默认72小时，由broker配置参数fileReservedTime决定</p>\n<p><strong>读写性能:</strong></p>\n<ol>\n<li><p>文件内存映射方式操作文件，避免read/write系统调用和实时文件读写，性能非常高</p>\n</li>\n<li><p>永远一个文件在写，其他文件在读</p>\n</li>\n<li><p>顺序写，随机读</p>\n</li>\n<li><p>利用linux的sendfile机制，将消息内容直接输出到sokect管道，避免系统调用</p>\n</li>\n</ol>\n<p><strong>系统特性:</strong></p>\n<ol>\n<li><p>大内存，内存越大性能越高，否则系统swap会成为性能瓶颈</p>\n</li>\n<li><p>IO密集</p>\n</li>\n<li><p>cpu load高，使用率低，因为cpu占用后，大部分时间在IO WAIT</p>\n</li>\n<li><p>磁盘可靠性要求高，为了兼顾安全和性能，采用RAID10阵列</p>\n</li>\n<li><p>磁盘读取速度要求快，要求高转速大容量磁盘</p>\n</li>\n</ol>\n<h3 id=\"3-消费者\"><a href=\"#3-消费者\" class=\"headerlink\" title=\"3. 消费者\"></a>3. 消费者</h3><p><strong>与nameserver关系</strong><br><strong>连接:</strong></p>\n<p>单个消费者和一台nameserver保持长连接，定时查询topic配置信息，如果该nameserver挂掉，消费者会自动连接下一个nameserver，直到有可用连接为止，并能自动重连。</p>\n<p><strong>心跳:</strong></p>\n<p>与nameserver没有心跳</p>\n<p><strong>轮询时间:</strong></p>\n<p>默认情况下，消费者每隔30秒从nameserver获取所有topic的最新队列情况，这意味着某个broker如果宕机，客户端最多要30秒才能感知。该时间由DefaultMQPushConsumer的pollNameServerInteval参数决定，可手动配置。</p>\n<p><strong>与broker关系</strong></p>\n<p><strong>连接:</strong></p>\n<p>单个消费者和该消费者关联的所有broker保持长连接。</p>\n<p><strong>心跳:</strong></p>\n<p>默认情况下，消费者每隔30秒向所有broker发送心跳，该时间由DefaultMQPushConsumer的heartbeatBrokerInterval参数决定，可手动配置。broker每隔10秒钟（此时间无法更改），扫描所有还存活的连接，若某个连接2分钟内（当前时间与最后更新时间差值超过2分钟，此时间无法更改）没有发送心跳数据，则关闭连接，并向该消费者分组的所有消费者发出通知，分组内消费者重新分配队列继续消费</p>\n<p><strong>断开:</strong></p>\n<p>时机：消费者挂掉；心跳超时导致broker主动关闭连接</p>\n<p>动作：一旦连接断开，broker会立即感知到，并向该消费者分组的所有消费者发出通知，分组内消费者重新分配队列继续消费</p>\n<p><strong>负载均衡:</strong><br>集群消费模式下，一个消费者集群多台机器共同消费一个topic的多个队列，一个队列只会被一个消费者消费。如果某个消费者挂掉，分组内其它消费者会接替挂掉的消费者继续消费。</p>\n<p><strong>消费机制:</strong></p>\n<ul>\n<li><p>本地队列<br>消费者不间断的从broker拉取消息，消息拉取到本地队列，然后本地消费线程消费本地消息队列，只是一个异步过程，拉取线程不会等待本地消费线程，这种模式实时性非常高。对消费者对本地队列有一个保护，因此本地消息队列不能无限大，否则可能会占用大量内存，本地队列大小由DefaultMQPushConsumer的pullThresholdForQueue属性控制，默认1000，可手动设置。</p>\n</li>\n<li><p>轮询间隔</p>\n</li>\n</ul>\n<p>消息拉取线程每隔多久拉取一次？间隔时间由DefaultMQPushConsumer的pullInterval属性控制，默认为0，可手动设置。</p>\n<ul>\n<li>消息消费数量</li>\n</ul>\n<p>监听器每次接受本地队列的消息是多少条？这个参数由DefaultMQPushConsumer的consumeMessageBatchMaxSize属性控制，默认为1，可手动设置。</p>\n<p><strong>消费进度存储:</strong><br>每隔一段时间将各个队列的消费进度存储到对应的broker上，该时间由DefaultMQPushConsumer的persistConsumerOffsetInterval属性控制，默认为5秒，可手动设置。</p>\n<p>如果一个topic在某broker上有3个队列，一个消费者消费这3个队列，那么该消费者和这个broker有几个连接？<br>一个连接，消费单位与队列相关，消费连接只跟broker相关，事实上，消费者将所有队列的消息拉取任务放到本地的队列，挨个拉取，拉取完毕后，又将拉取任务放到队尾，然后执行下一个拉取任务</p>\n<h3 id=\"4-生产者\"><a href=\"#4-生产者\" class=\"headerlink\" title=\"4. 生产者\"></a>4. 生产者</h3><p><strong>与nameserver关系</strong><br><strong>连接:</strong></p>\n<p>单个生产者者和一台nameserver保持长连接，定时查询topic配置信息，如果该nameserver挂掉，生产者会自动连接下一个nameserver，直到有可用连接为止，并能自动重连。</p>\n<p><strong>轮询时间:</strong></p>\n<p>默认情况下，生产者每隔30秒从nameserver获取所有topic的最新队列情况，这意味着某个broker如果宕机，生产者最多要30秒才能感知，在此期间，发往该broker的消息发送失败。该时间由DefaultMQProducer的pollNameServerInteval参数决定，可手动配置。</p>\n<p><strong>心跳:</strong></p>\n<p>与nameserver没有心跳</p>\n<p><strong>与broker关系</strong><br><strong>连接:</strong></p>\n<p>单个生产者和该生产者关联的所有broker保持长连接。</p>\n<p><strong>心跳:</strong></p>\n<p>默认情况下，生产者每隔30秒向所有broker发送心跳，该时间由DefaultMQProducer的heartbeatBrokerInterval参数决定，可手动配置。broker每隔10秒钟（此时间无法更改），扫描所有还存活的连接，若某个连接2分钟内（当前时间与最后更新时间差值超过2分钟，此时间无法更改）没有发送心跳数据，则关闭连接。</p>\n<p><strong>连接断开:</strong></p>\n<p>移除broker上的生产者信息</p>\n<p><strong>负载均衡:</strong><br>生产者时间没有关系，每个生产者向队列轮流发送消息</p>\n<h2 id=\"三、集群方案\"><a href=\"#三、集群方案\" class=\"headerlink\" title=\"三、集群方案\"></a>三、集群方案</h2><ol>\n<li><p>单个 Master<br>这种方式风险较大，一旦Broker 重启或者宕机时，会导致整个服务不可用，不建议线上环境使用。</p>\n</li>\n<li><p>多 Master 模式<br>一个集群无 Slave，全是 Master，例如 2 个 Master 或者 3 个 Master</p>\n<p>优点：配置简单，单个Master 宕机或重启维护对应用无影响，在磁盘配置为 RAID10 时，即使机器宕机不可恢复情况下，由与 RAID10 磁盘非常可靠，消息也不会丢（异步刷盘丢失少量消息，同步刷盘一条不丢）。性能最高。</p>\n<p>缺点：单台机器宕机期间，这台机器上未被消费的消息在机器恢复之前不可订阅，消息实时性会受到受到影响。</p>\n</li>\n</ol>\n<p><em>先启动 NameServer，例如机器 IP 为：172.16.8.106:9876</em></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nohup sh mqnamesrv &amp;</span><br></pre></td></tr></table></figure>\n<p>   <em>在机器 A，启动第一个 Master</em></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nohup sh mqbroker -n 172.16.8.106:9876 -c $ROCKETMQ_HOME/conf/2m-noslave/broker-a.properties &amp;</span><br></pre></td></tr></table></figure>\n<p>   <em>在机器 B，启动第二个 Master</em></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nohup sh mqbroker -n 172.16.8.106:9876 -c $ROCKETMQ_HOME/conf/2m-noslave/broker-b.properties &amp;</span><br></pre></td></tr></table></figure>\n<ol start=\"3\">\n<li><p>多 Master 多 Slave 模式，异步复制<br>每个 Master 配置一个 Slave，有多对Master-Slave，HA 采用异步复制方式，主备有短暂消息延迟，毫秒级。</p>\n<p>优点：即使磁盘损坏，消息丢失的非常少，且消息实时性不会受影响，因为 Master 宕机后，消费者仍然可以从 Slave 消费，此过程对应用透明。不需要人工干预。性能同多 Master 模式几乎一样。</p>\n<p>缺点：Master 宕机，磁盘损坏情况，会丢失少量消息。</p>\n</li>\n</ol>\n<p><em>先启动 NameServer，例如机器 IP 为：172.16.8.106:9876</em></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nohup sh mqnamesrv &amp;</span><br></pre></td></tr></table></figure>\n<p>   <em>在机器 A，启动第一个 Master</em></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nohup sh mqbroker -n 172.16.8.106:9876 -c $ROCKETMQ_HOME/conf/2m-2s-async/broker-a.properties &amp;</span><br></pre></td></tr></table></figure>\n<p>   <em>在机器 B，启动第二个 Master</em></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nohup sh mqbroker -n 172.16.8.106:9876 -c $ROCKETMQ_HOME/conf/2m-2s-async/broker-b.properties &amp;</span><br></pre></td></tr></table></figure>\n<p>   <em>在机器 C，启动第一个 Slave</em></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nohup sh mqbroker -n 172.16.8.106:9876 -c $ROCKETMQ_HOME/conf/2m-2s-async/broker-a-s.properties &amp;</span><br></pre></td></tr></table></figure>\n<p>   <em>在机器 D，启动第二个 Slave</em></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nohup sh mqbroker -n 172.16.8.106:9876 -c $ROCKETMQ_HOME/conf/2m-2s-async/broker-b-s.properties &amp;</span><br></pre></td></tr></table></figure>\n<ol start=\"4\">\n<li><p>多 Master 多 Slave 模式，同步双写<br>每个 Master 配置一个 Slave，有多对Master-Slave，HA 采用同步双写方式，主备都写成功，向应用返回成功。</p>\n<p>优点：数据与服务都无单点，Master宕机情况下，消息无延迟，服务可用性与数据可用性都非常高</p>\n<p>缺点：性能比异步复制模式略低，大约低 10%左右，发送单个消息的 RT 会略高。目前主宕机后，备机不能自动切换为主机，后续会支持自动切换功能。</p>\n</li>\n</ol>\n<p><em>先启动 NameServer，例如机器 IP 为：172.16.8.106:9876</em></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nohup sh mqnamesrv &amp;</span><br></pre></td></tr></table></figure>\n<p>   <em>在机器 A，启动第一个 Master</em></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nohup sh mqbroker -n 172.16.8.106:9876 -c $ROCKETMQ_HOME/conf/2m-2s-sync/broker-a.properties &amp;</span><br></pre></td></tr></table></figure>\n<p>   <em>在机器 B，启动第二个 Master</em></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nohup sh mqbroker -n 172.16.8.106:9876 -c $ROCKETMQ_HOME/conf/2m-2s-sync/broker-b.properties &amp;</span><br></pre></td></tr></table></figure>\n<p>   <em>在机器 C，启动第一个 Slave</em></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nohup sh mqbroker -n 172.16.8.106:9876 -c $ROCKETMQ_HOME/conf/2m-2s-sync/broker-a-s.properties &amp;</span><br></pre></td></tr></table></figure>\n<p>   <em>在机器 D，启动第二个 Slave</em></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nohup sh mqbroker -n 172.16.8.106:9876 -c $ROCKETMQ_HOME/conf/2m-2s-sync/broker-b-s.properties &amp;</span><br></pre></td></tr></table></figure>\n<p>   以上 Broker 与 Slave 配对是通过指定相同的brokerName 参数来配对，Master 的 BrokerId 必须是 0，Slave的BrokerId 必须是大与 0 的数。另外一个 Master 下面可以挂载多个 Slave，同一 Master 下的多个 Slave 通过指定不同的 BrokerId 来区分。</p>\n<hr>\n<p><em>转自:<a href=\"https://www.cnblogs.com/xiaodf/p/5075167.html\">https://www.cnblogs.com/xiaodf/p/5075167.html</a></em></p>\n<p><em>观点仅代表自己，期待你的留言。</em></p>\n"},{"title":"分布式系统下并发读取不重复数据","date":"2017-07-07T02:02:57.000Z","_content":"\n## 问题背景\n分布式系统模块存在定时任务，当模块被部署多个实例时，不同实例的定时任务在运行时就存在从数据源中获取相同数据的情况，\n虽然通过乐观锁(数据记录增加version,每次update则set verion+=1 where version=?)的处理方式可以避免多实例更新数据造成脏数据入库的问题，\n但这无疑是降低了分布式系统部署的初衷（通过横向部署多实例增加系统的处理能力）。\n\n经过分析，总结如下几种处理方式。\n\n## 处理方式\n###  1、数据置标识位\n在数据库记录中增加flag，当数据被读取后则更改flag的值，避免记录被再次读取。\n\n具体步骤如下：\n - 锁定分布式锁\n - 查询指定数量的数据\n - 更新已查询出数据的标识位\n - 释放分布式锁\n\n当处理完成时: 增加数据version,重置标识位\n\n### 2、单实例读取，多实例处理\n读取数据Job：利用Redis的分布式锁保障一个实例拥有读取数据的步骤，读取出来的数据再存放到Redis中的需处理数据队列。\n\n处理业务Job：所有部署实例通过监控Redis的需处理数据队列如果有数据则take一个数据出来进行业务处理。\n\n具体步骤如下：\n - 锁定分布式锁\n - 检查需要处理的数据队列是否为空，如为空，则跳过当前读取任务。\n - 获取需要处理的数据并存入Redis的处理队列中\n - 释放分布式锁\n_由于读取数据的步骤由单进程来获取，所以就避免了并发读取数据的问题_\n\n__add by 2017.8.10 :__ 增加处理中的数据队列，在读取数据job时需要排除到正在处理的数据。用于当有数据在处理且数据未更新时，加载数据进行加载时将数据加载出的Bug。\n__add by 2017.9.13 :__ 将锁定分布式锁扩展到第一步骤，防止并发情况下通过队列容量检查，成功获取到锁后加载到重复记录。\n\n### 3、利用自增ID\n利用分布式锁+Redis存储已处理ID+数据的自增ID来获取数据数据。\n\n具体步骤如下：\n - 锁定分布式锁\n - 从Redis中取出已处理数据的最大ID值(此处用x代替)\n - 从数据库中取出大于x获取出y(固定数据量)的数据\n - 更新Redis已处理的数据最大ID值\n - 释放分布式锁\n\n#### 存在的问题\n__问题描述：__ 数据任务在进行业务处理的过程中，如处理失败则再也不会被以上步骤再次获取。\n\n__解决方法1：__ 当业务处理失败时，在Redis中记录下失败的数据ID。在获取数据步骤中增加获取失败数据的步骤。\n\n__解决方法2：__ 当业务处理失败时，在Redis中记录下失败的数据信息。在业务处理环节增加处理已失败的数据重试步骤。\n\n### 4、数据取余\n利用zk获取到总实例数，计算模块实例需要处理的余值。\n\n具体步骤如下：\n - 模块启动注册到zk，并计算当前实例需要处理的余值为x (当前实例index % 总实例数)\n - 从数据库取数据时，将数据主键%总实例数，如果余值为x，则取出数据，否则忽略此数据。\n - 当模块总实例数变化时，重新计算当前实例需要处理的余值。\n\n_风险：_ 由于模块实例所需要处理的数据固定，当数据取余后的值可能会命中同一个实例，造成模块各实例处理压力不平均。\n\n-----\n\n*观点仅代表自己，期待你的留言。*\n","source":"_posts/multi-process-read.md","raw":"---\ntitle: 分布式系统下并发读取不重复数据\ntags:\n  - 原创\n  - 分布式\n  - 多进程\n  - 并发\ndate: 2017-07-07 10:02:57\n---\n\n## 问题背景\n分布式系统模块存在定时任务，当模块被部署多个实例时，不同实例的定时任务在运行时就存在从数据源中获取相同数据的情况，\n虽然通过乐观锁(数据记录增加version,每次update则set verion+=1 where version=?)的处理方式可以避免多实例更新数据造成脏数据入库的问题，\n但这无疑是降低了分布式系统部署的初衷（通过横向部署多实例增加系统的处理能力）。\n\n经过分析，总结如下几种处理方式。\n\n## 处理方式\n###  1、数据置标识位\n在数据库记录中增加flag，当数据被读取后则更改flag的值，避免记录被再次读取。\n\n具体步骤如下：\n - 锁定分布式锁\n - 查询指定数量的数据\n - 更新已查询出数据的标识位\n - 释放分布式锁\n\n当处理完成时: 增加数据version,重置标识位\n\n### 2、单实例读取，多实例处理\n读取数据Job：利用Redis的分布式锁保障一个实例拥有读取数据的步骤，读取出来的数据再存放到Redis中的需处理数据队列。\n\n处理业务Job：所有部署实例通过监控Redis的需处理数据队列如果有数据则take一个数据出来进行业务处理。\n\n具体步骤如下：\n - 锁定分布式锁\n - 检查需要处理的数据队列是否为空，如为空，则跳过当前读取任务。\n - 获取需要处理的数据并存入Redis的处理队列中\n - 释放分布式锁\n_由于读取数据的步骤由单进程来获取，所以就避免了并发读取数据的问题_\n\n__add by 2017.8.10 :__ 增加处理中的数据队列，在读取数据job时需要排除到正在处理的数据。用于当有数据在处理且数据未更新时，加载数据进行加载时将数据加载出的Bug。\n__add by 2017.9.13 :__ 将锁定分布式锁扩展到第一步骤，防止并发情况下通过队列容量检查，成功获取到锁后加载到重复记录。\n\n### 3、利用自增ID\n利用分布式锁+Redis存储已处理ID+数据的自增ID来获取数据数据。\n\n具体步骤如下：\n - 锁定分布式锁\n - 从Redis中取出已处理数据的最大ID值(此处用x代替)\n - 从数据库中取出大于x获取出y(固定数据量)的数据\n - 更新Redis已处理的数据最大ID值\n - 释放分布式锁\n\n#### 存在的问题\n__问题描述：__ 数据任务在进行业务处理的过程中，如处理失败则再也不会被以上步骤再次获取。\n\n__解决方法1：__ 当业务处理失败时，在Redis中记录下失败的数据ID。在获取数据步骤中增加获取失败数据的步骤。\n\n__解决方法2：__ 当业务处理失败时，在Redis中记录下失败的数据信息。在业务处理环节增加处理已失败的数据重试步骤。\n\n### 4、数据取余\n利用zk获取到总实例数，计算模块实例需要处理的余值。\n\n具体步骤如下：\n - 模块启动注册到zk，并计算当前实例需要处理的余值为x (当前实例index % 总实例数)\n - 从数据库取数据时，将数据主键%总实例数，如果余值为x，则取出数据，否则忽略此数据。\n - 当模块总实例数变化时，重新计算当前实例需要处理的余值。\n\n_风险：_ 由于模块实例所需要处理的数据固定，当数据取余后的值可能会命中同一个实例，造成模块各实例处理压力不平均。\n\n-----\n\n*观点仅代表自己，期待你的留言。*\n","slug":"multi-process-read","published":1,"updated":"2021-08-31T14:23:11.547Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cku52dynu0037bbinejvk3e4l","content":"<h2 id=\"问题背景\"><a href=\"#问题背景\" class=\"headerlink\" title=\"问题背景\"></a>问题背景</h2><p>分布式系统模块存在定时任务，当模块被部署多个实例时，不同实例的定时任务在运行时就存在从数据源中获取相同数据的情况，<br>虽然通过乐观锁(数据记录增加version,每次update则set verion+=1 where version=?)的处理方式可以避免多实例更新数据造成脏数据入库的问题，<br>但这无疑是降低了分布式系统部署的初衷（通过横向部署多实例增加系统的处理能力）。</p>\n<p>经过分析，总结如下几种处理方式。</p>\n<h2 id=\"处理方式\"><a href=\"#处理方式\" class=\"headerlink\" title=\"处理方式\"></a>处理方式</h2><h3 id=\"1、数据置标识位\"><a href=\"#1、数据置标识位\" class=\"headerlink\" title=\"1、数据置标识位\"></a>1、数据置标识位</h3><p>在数据库记录中增加flag，当数据被读取后则更改flag的值，避免记录被再次读取。</p>\n<p>具体步骤如下：</p>\n<ul>\n<li>锁定分布式锁</li>\n<li>查询指定数量的数据</li>\n<li>更新已查询出数据的标识位</li>\n<li>释放分布式锁</li>\n</ul>\n<p>当处理完成时: 增加数据version,重置标识位</p>\n<h3 id=\"2、单实例读取，多实例处理\"><a href=\"#2、单实例读取，多实例处理\" class=\"headerlink\" title=\"2、单实例读取，多实例处理\"></a>2、单实例读取，多实例处理</h3><p>读取数据Job：利用Redis的分布式锁保障一个实例拥有读取数据的步骤，读取出来的数据再存放到Redis中的需处理数据队列。</p>\n<p>处理业务Job：所有部署实例通过监控Redis的需处理数据队列如果有数据则take一个数据出来进行业务处理。</p>\n<p>具体步骤如下：</p>\n<ul>\n<li>锁定分布式锁</li>\n<li>检查需要处理的数据队列是否为空，如为空，则跳过当前读取任务。</li>\n<li>获取需要处理的数据并存入Redis的处理队列中</li>\n<li>释放分布式锁<br><em>由于读取数据的步骤由单进程来获取，所以就避免了并发读取数据的问题</em></li>\n</ul>\n<p><strong>add by 2017.8.10 :</strong> 增加处理中的数据队列，在读取数据job时需要排除到正在处理的数据。用于当有数据在处理且数据未更新时，加载数据进行加载时将数据加载出的Bug。<br><strong>add by 2017.9.13 :</strong> 将锁定分布式锁扩展到第一步骤，防止并发情况下通过队列容量检查，成功获取到锁后加载到重复记录。</p>\n<h3 id=\"3、利用自增ID\"><a href=\"#3、利用自增ID\" class=\"headerlink\" title=\"3、利用自增ID\"></a>3、利用自增ID</h3><p>利用分布式锁+Redis存储已处理ID+数据的自增ID来获取数据数据。</p>\n<p>具体步骤如下：</p>\n<ul>\n<li>锁定分布式锁</li>\n<li>从Redis中取出已处理数据的最大ID值(此处用x代替)</li>\n<li>从数据库中取出大于x获取出y(固定数据量)的数据</li>\n<li>更新Redis已处理的数据最大ID值</li>\n<li>释放分布式锁</li>\n</ul>\n<h4 id=\"存在的问题\"><a href=\"#存在的问题\" class=\"headerlink\" title=\"存在的问题\"></a>存在的问题</h4><p><strong>问题描述：</strong> 数据任务在进行业务处理的过程中，如处理失败则再也不会被以上步骤再次获取。</p>\n<p><strong>解决方法1：</strong> 当业务处理失败时，在Redis中记录下失败的数据ID。在获取数据步骤中增加获取失败数据的步骤。</p>\n<p><strong>解决方法2：</strong> 当业务处理失败时，在Redis中记录下失败的数据信息。在业务处理环节增加处理已失败的数据重试步骤。</p>\n<h3 id=\"4、数据取余\"><a href=\"#4、数据取余\" class=\"headerlink\" title=\"4、数据取余\"></a>4、数据取余</h3><p>利用zk获取到总实例数，计算模块实例需要处理的余值。</p>\n<p>具体步骤如下：</p>\n<ul>\n<li>模块启动注册到zk，并计算当前实例需要处理的余值为x (当前实例index % 总实例数)</li>\n<li>从数据库取数据时，将数据主键%总实例数，如果余值为x，则取出数据，否则忽略此数据。</li>\n<li>当模块总实例数变化时，重新计算当前实例需要处理的余值。</li>\n</ul>\n<p><em>风险：</em> 由于模块实例所需要处理的数据固定，当数据取余后的值可能会命中同一个实例，造成模块各实例处理压力不平均。</p>\n<hr>\n<p><em>观点仅代表自己，期待你的留言。</em></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"问题背景\"><a href=\"#问题背景\" class=\"headerlink\" title=\"问题背景\"></a>问题背景</h2><p>分布式系统模块存在定时任务，当模块被部署多个实例时，不同实例的定时任务在运行时就存在从数据源中获取相同数据的情况，<br>虽然通过乐观锁(数据记录增加version,每次update则set verion+=1 where version=?)的处理方式可以避免多实例更新数据造成脏数据入库的问题，<br>但这无疑是降低了分布式系统部署的初衷（通过横向部署多实例增加系统的处理能力）。</p>\n<p>经过分析，总结如下几种处理方式。</p>\n<h2 id=\"处理方式\"><a href=\"#处理方式\" class=\"headerlink\" title=\"处理方式\"></a>处理方式</h2><h3 id=\"1、数据置标识位\"><a href=\"#1、数据置标识位\" class=\"headerlink\" title=\"1、数据置标识位\"></a>1、数据置标识位</h3><p>在数据库记录中增加flag，当数据被读取后则更改flag的值，避免记录被再次读取。</p>\n<p>具体步骤如下：</p>\n<ul>\n<li>锁定分布式锁</li>\n<li>查询指定数量的数据</li>\n<li>更新已查询出数据的标识位</li>\n<li>释放分布式锁</li>\n</ul>\n<p>当处理完成时: 增加数据version,重置标识位</p>\n<h3 id=\"2、单实例读取，多实例处理\"><a href=\"#2、单实例读取，多实例处理\" class=\"headerlink\" title=\"2、单实例读取，多实例处理\"></a>2、单实例读取，多实例处理</h3><p>读取数据Job：利用Redis的分布式锁保障一个实例拥有读取数据的步骤，读取出来的数据再存放到Redis中的需处理数据队列。</p>\n<p>处理业务Job：所有部署实例通过监控Redis的需处理数据队列如果有数据则take一个数据出来进行业务处理。</p>\n<p>具体步骤如下：</p>\n<ul>\n<li>锁定分布式锁</li>\n<li>检查需要处理的数据队列是否为空，如为空，则跳过当前读取任务。</li>\n<li>获取需要处理的数据并存入Redis的处理队列中</li>\n<li>释放分布式锁<br><em>由于读取数据的步骤由单进程来获取，所以就避免了并发读取数据的问题</em></li>\n</ul>\n<p><strong>add by 2017.8.10 :</strong> 增加处理中的数据队列，在读取数据job时需要排除到正在处理的数据。用于当有数据在处理且数据未更新时，加载数据进行加载时将数据加载出的Bug。<br><strong>add by 2017.9.13 :</strong> 将锁定分布式锁扩展到第一步骤，防止并发情况下通过队列容量检查，成功获取到锁后加载到重复记录。</p>\n<h3 id=\"3、利用自增ID\"><a href=\"#3、利用自增ID\" class=\"headerlink\" title=\"3、利用自增ID\"></a>3、利用自增ID</h3><p>利用分布式锁+Redis存储已处理ID+数据的自增ID来获取数据数据。</p>\n<p>具体步骤如下：</p>\n<ul>\n<li>锁定分布式锁</li>\n<li>从Redis中取出已处理数据的最大ID值(此处用x代替)</li>\n<li>从数据库中取出大于x获取出y(固定数据量)的数据</li>\n<li>更新Redis已处理的数据最大ID值</li>\n<li>释放分布式锁</li>\n</ul>\n<h4 id=\"存在的问题\"><a href=\"#存在的问题\" class=\"headerlink\" title=\"存在的问题\"></a>存在的问题</h4><p><strong>问题描述：</strong> 数据任务在进行业务处理的过程中，如处理失败则再也不会被以上步骤再次获取。</p>\n<p><strong>解决方法1：</strong> 当业务处理失败时，在Redis中记录下失败的数据ID。在获取数据步骤中增加获取失败数据的步骤。</p>\n<p><strong>解决方法2：</strong> 当业务处理失败时，在Redis中记录下失败的数据信息。在业务处理环节增加处理已失败的数据重试步骤。</p>\n<h3 id=\"4、数据取余\"><a href=\"#4、数据取余\" class=\"headerlink\" title=\"4、数据取余\"></a>4、数据取余</h3><p>利用zk获取到总实例数，计算模块实例需要处理的余值。</p>\n<p>具体步骤如下：</p>\n<ul>\n<li>模块启动注册到zk，并计算当前实例需要处理的余值为x (当前实例index % 总实例数)</li>\n<li>从数据库取数据时，将数据主键%总实例数，如果余值为x，则取出数据，否则忽略此数据。</li>\n<li>当模块总实例数变化时，重新计算当前实例需要处理的余值。</li>\n</ul>\n<p><em>风险：</em> 由于模块实例所需要处理的数据固定，当数据取余后的值可能会命中同一个实例，造成模块各实例处理压力不平均。</p>\n<hr>\n<p><em>观点仅代表自己，期待你的留言。</em></p>\n"},{"title":"Nginx在CentOS7上源码编译安装","date":"2016-03-14T03:32:15.000Z","_content":"### 下载Nginx源码及依赖库\n```\n[root@localhost ~]# wget http://nginx.org/download/nginx-1.8.1.tar.gz\n[root@localhost ~]# yum install -y gcc gcc-c++\n[root@localhost ~]# wget http://jaist.dl.sourceforge.net/project/pcre/pcre/8.38/pcre-8.38.tar.gz\n[root@localhost ~]# wget http://zlib.net/zlib-1.2.8.tar.gz\n```\n### 下载Nginx模块\nNginx官网所有模块列表  [http://nginx.org/en/docs/](http://nginx.org/en/docs/)\n```\n[root@localhost ~]# yum -y install openssl openssl-devel\n[root@localhost ~]# git clone https://github.com/vozlt/nginx-module-vts.git \n[root@localhost ~]# git clone https://github.com/yaoweibin/nginx_tcp_proxy_module.git\n[root@localhost ~]# git clone https://github.com/yaoweibin/nginx_upstream_check_module.git\n```\n### 编译安装Nginx\n```\n[root@localhost ~]# tar xvf nginx-1.8.1.tar.gz\n[root@localhost ~]# tar xvf pcre-8.38.tar.gz\n[root@localhost ~]# tar xvf zlib-1.2.8.tar.gz\n[root@localhost ~]# cd nginx-1.8.1\n[root@localhost nginx-1.8.1]# patch -p1 < ../nginx_tcp_proxy_module/tcp.patch\n[root@localhost nginx-1.8.1]# patch -p1 < ../nginx_upstream_check_module/check_1.7.5+.patch //按nginx版本来执行不同的补丁文件\n[root@localhost nginx-1.8.1]# ./configure --with-pcre=../pcre-8.38 --with-zlib=../zlib-1.2.8 --with-http_gzip_static_module --with-http_ssl_module --add-module=../nginx_tcp_proxy_module/ \\--add-module=../nginx_upstream_check_module/ \\--add-module=../nginx-module-vts/\n[root@localhost nginx-1.8.1]# make \n[root@localhost nginx-1.8.1]# make install\n[root@localhost nginx-1.8.1]# /usr/local/nginx/sbin/nginx -V \nnginx version: nginx/1.8.1\nbuilt by gcc 4.8.5 20150623 (Red Hat 4.8.5-4) (GCC) \nbuilt with OpenSSL 1.0.1e-fips 11 Feb 2013\nTLS SNI support enabled\nconfigure arguments: --with-pcre=../pcre-8.38 --with-zlib=../zlib-1.2.8 --with-http_gzip_static_module --with-http_ssl_module --add-module=../nginx_tcp_proxy_module/ --add-module=../nginx_upstream_check_module/ --add-module=../nginx-module-vts/\n[root@localhost nginx-1.8.1]# /usr/local/nginx/sbin/nginx\n[root@localhost nginx-1.8.1]# systemctl stop firewalld.service //关闭防火墙，开放访问端口80\n```\n![Nginx Welcome](/images/nginx.png)\n\nnginx安装目录默认为: /usr/local/nginx, 可通过在configure时增加--prefix=\"path\"来更改。\n\nnginx启动时默认用户及用户组设置：\n* 通过在configure时增加--user=\"user name\"和--group=\"group name\"来更改。\n* 在nginx.conf里增加user \"user name\" \"group name\"来更改。\n\n__注意: 在configure时如需添加多个第三方module时，从第二个--add-module开始，在之前需要加“\\”__\n\n-----\n*观点仅代表自己，期待你的留言。*\n","source":"_posts/nginx-install.md","raw":"---\ntitle: Nginx在CentOS7上源码编译安装\ntags:\n  - 原创\n  - Nginx\ndate: 2016-03-14 11:32:15\n---\n### 下载Nginx源码及依赖库\n```\n[root@localhost ~]# wget http://nginx.org/download/nginx-1.8.1.tar.gz\n[root@localhost ~]# yum install -y gcc gcc-c++\n[root@localhost ~]# wget http://jaist.dl.sourceforge.net/project/pcre/pcre/8.38/pcre-8.38.tar.gz\n[root@localhost ~]# wget http://zlib.net/zlib-1.2.8.tar.gz\n```\n### 下载Nginx模块\nNginx官网所有模块列表  [http://nginx.org/en/docs/](http://nginx.org/en/docs/)\n```\n[root@localhost ~]# yum -y install openssl openssl-devel\n[root@localhost ~]# git clone https://github.com/vozlt/nginx-module-vts.git \n[root@localhost ~]# git clone https://github.com/yaoweibin/nginx_tcp_proxy_module.git\n[root@localhost ~]# git clone https://github.com/yaoweibin/nginx_upstream_check_module.git\n```\n### 编译安装Nginx\n```\n[root@localhost ~]# tar xvf nginx-1.8.1.tar.gz\n[root@localhost ~]# tar xvf pcre-8.38.tar.gz\n[root@localhost ~]# tar xvf zlib-1.2.8.tar.gz\n[root@localhost ~]# cd nginx-1.8.1\n[root@localhost nginx-1.8.1]# patch -p1 < ../nginx_tcp_proxy_module/tcp.patch\n[root@localhost nginx-1.8.1]# patch -p1 < ../nginx_upstream_check_module/check_1.7.5+.patch //按nginx版本来执行不同的补丁文件\n[root@localhost nginx-1.8.1]# ./configure --with-pcre=../pcre-8.38 --with-zlib=../zlib-1.2.8 --with-http_gzip_static_module --with-http_ssl_module --add-module=../nginx_tcp_proxy_module/ \\--add-module=../nginx_upstream_check_module/ \\--add-module=../nginx-module-vts/\n[root@localhost nginx-1.8.1]# make \n[root@localhost nginx-1.8.1]# make install\n[root@localhost nginx-1.8.1]# /usr/local/nginx/sbin/nginx -V \nnginx version: nginx/1.8.1\nbuilt by gcc 4.8.5 20150623 (Red Hat 4.8.5-4) (GCC) \nbuilt with OpenSSL 1.0.1e-fips 11 Feb 2013\nTLS SNI support enabled\nconfigure arguments: --with-pcre=../pcre-8.38 --with-zlib=../zlib-1.2.8 --with-http_gzip_static_module --with-http_ssl_module --add-module=../nginx_tcp_proxy_module/ --add-module=../nginx_upstream_check_module/ --add-module=../nginx-module-vts/\n[root@localhost nginx-1.8.1]# /usr/local/nginx/sbin/nginx\n[root@localhost nginx-1.8.1]# systemctl stop firewalld.service //关闭防火墙，开放访问端口80\n```\n![Nginx Welcome](/images/nginx.png)\n\nnginx安装目录默认为: /usr/local/nginx, 可通过在configure时增加--prefix=\"path\"来更改。\n\nnginx启动时默认用户及用户组设置：\n* 通过在configure时增加--user=\"user name\"和--group=\"group name\"来更改。\n* 在nginx.conf里增加user \"user name\" \"group name\"来更改。\n\n__注意: 在configure时如需添加多个第三方module时，从第二个--add-module开始，在之前需要加“\\”__\n\n-----\n*观点仅代表自己，期待你的留言。*\n","slug":"nginx-install","published":1,"updated":"2021-08-31T14:23:11.547Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cku52dynv0039bbin0w1qba0x","content":"<h3 id=\"下载Nginx源码及依赖库\"><a href=\"#下载Nginx源码及依赖库\" class=\"headerlink\" title=\"下载Nginx源码及依赖库\"></a>下载Nginx源码及依赖库</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@localhost ~]# wget http://nginx.org/download/nginx-1.8.1.tar.gz</span><br><span class=\"line\">[root@localhost ~]# yum install -y gcc gcc-c++</span><br><span class=\"line\">[root@localhost ~]# wget http://jaist.dl.sourceforge.net/project/pcre/pcre/8.38/pcre-8.38.tar.gz</span><br><span class=\"line\">[root@localhost ~]# wget http://zlib.net/zlib-1.2.8.tar.gz</span><br></pre></td></tr></table></figure>\n<h3 id=\"下载Nginx模块\"><a href=\"#下载Nginx模块\" class=\"headerlink\" title=\"下载Nginx模块\"></a>下载Nginx模块</h3><p>Nginx官网所有模块列表  <a href=\"http://nginx.org/en/docs/\">http://nginx.org/en/docs/</a></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@localhost ~]# yum -y install openssl openssl-devel</span><br><span class=\"line\">[root@localhost ~]# git clone https://github.com/vozlt/nginx-module-vts.git </span><br><span class=\"line\">[root@localhost ~]# git clone https://github.com/yaoweibin/nginx_tcp_proxy_module.git</span><br><span class=\"line\">[root@localhost ~]# git clone https://github.com/yaoweibin/nginx_upstream_check_module.git</span><br></pre></td></tr></table></figure>\n<h3 id=\"编译安装Nginx\"><a href=\"#编译安装Nginx\" class=\"headerlink\" title=\"编译安装Nginx\"></a>编译安装Nginx</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@localhost ~]# tar xvf nginx-1.8.1.tar.gz</span><br><span class=\"line\">[root@localhost ~]# tar xvf pcre-8.38.tar.gz</span><br><span class=\"line\">[root@localhost ~]# tar xvf zlib-1.2.8.tar.gz</span><br><span class=\"line\">[root@localhost ~]# cd nginx-1.8.1</span><br><span class=\"line\">[root@localhost nginx-1.8.1]# patch -p1 &lt; ../nginx_tcp_proxy_module/tcp.patch</span><br><span class=\"line\">[root@localhost nginx-1.8.1]# patch -p1 &lt; ../nginx_upstream_check_module/check_1.7.5+.patch //按nginx版本来执行不同的补丁文件</span><br><span class=\"line\">[root@localhost nginx-1.8.1]# ./configure --with-pcre=../pcre-8.38 --with-zlib=../zlib-1.2.8 --with-http_gzip_static_module --with-http_ssl_module --add-module=../nginx_tcp_proxy_module/ \\--add-module=../nginx_upstream_check_module/ \\--add-module=../nginx-module-vts/</span><br><span class=\"line\">[root@localhost nginx-1.8.1]# make </span><br><span class=\"line\">[root@localhost nginx-1.8.1]# make install</span><br><span class=\"line\">[root@localhost nginx-1.8.1]# /usr/local/nginx/sbin/nginx -V </span><br><span class=\"line\">nginx version: nginx/1.8.1</span><br><span class=\"line\">built by gcc 4.8.5 20150623 (Red Hat 4.8.5-4) (GCC) </span><br><span class=\"line\">built with OpenSSL 1.0.1e-fips 11 Feb 2013</span><br><span class=\"line\">TLS SNI support enabled</span><br><span class=\"line\">configure arguments: --with-pcre=../pcre-8.38 --with-zlib=../zlib-1.2.8 --with-http_gzip_static_module --with-http_ssl_module --add-module=../nginx_tcp_proxy_module/ --add-module=../nginx_upstream_check_module/ --add-module=../nginx-module-vts/</span><br><span class=\"line\">[root@localhost nginx-1.8.1]# /usr/local/nginx/sbin/nginx</span><br><span class=\"line\">[root@localhost nginx-1.8.1]# systemctl stop firewalld.service //关闭防火墙，开放访问端口80</span><br></pre></td></tr></table></figure>\n<p><img src=\"/images/nginx.png\" alt=\"Nginx Welcome\"></p>\n<p>nginx安装目录默认为: /usr/local/nginx, 可通过在configure时增加–prefix=”path”来更改。</p>\n<p>nginx启动时默认用户及用户组设置：</p>\n<ul>\n<li>通过在configure时增加–user=”user name”和–group=”group name”来更改。</li>\n<li>在nginx.conf里增加user “user name” “group name”来更改。</li>\n</ul>\n<p><strong>注意: 在configure时如需添加多个第三方module时，从第二个–add-module开始，在之前需要加“\\”</strong></p>\n<hr>\n<p><em>观点仅代表自己，期待你的留言。</em></p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"下载Nginx源码及依赖库\"><a href=\"#下载Nginx源码及依赖库\" class=\"headerlink\" title=\"下载Nginx源码及依赖库\"></a>下载Nginx源码及依赖库</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@localhost ~]# wget http://nginx.org/download/nginx-1.8.1.tar.gz</span><br><span class=\"line\">[root@localhost ~]# yum install -y gcc gcc-c++</span><br><span class=\"line\">[root@localhost ~]# wget http://jaist.dl.sourceforge.net/project/pcre/pcre/8.38/pcre-8.38.tar.gz</span><br><span class=\"line\">[root@localhost ~]# wget http://zlib.net/zlib-1.2.8.tar.gz</span><br></pre></td></tr></table></figure>\n<h3 id=\"下载Nginx模块\"><a href=\"#下载Nginx模块\" class=\"headerlink\" title=\"下载Nginx模块\"></a>下载Nginx模块</h3><p>Nginx官网所有模块列表  <a href=\"http://nginx.org/en/docs/\">http://nginx.org/en/docs/</a></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@localhost ~]# yum -y install openssl openssl-devel</span><br><span class=\"line\">[root@localhost ~]# git clone https://github.com/vozlt/nginx-module-vts.git </span><br><span class=\"line\">[root@localhost ~]# git clone https://github.com/yaoweibin/nginx_tcp_proxy_module.git</span><br><span class=\"line\">[root@localhost ~]# git clone https://github.com/yaoweibin/nginx_upstream_check_module.git</span><br></pre></td></tr></table></figure>\n<h3 id=\"编译安装Nginx\"><a href=\"#编译安装Nginx\" class=\"headerlink\" title=\"编译安装Nginx\"></a>编译安装Nginx</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@localhost ~]# tar xvf nginx-1.8.1.tar.gz</span><br><span class=\"line\">[root@localhost ~]# tar xvf pcre-8.38.tar.gz</span><br><span class=\"line\">[root@localhost ~]# tar xvf zlib-1.2.8.tar.gz</span><br><span class=\"line\">[root@localhost ~]# cd nginx-1.8.1</span><br><span class=\"line\">[root@localhost nginx-1.8.1]# patch -p1 &lt; ../nginx_tcp_proxy_module/tcp.patch</span><br><span class=\"line\">[root@localhost nginx-1.8.1]# patch -p1 &lt; ../nginx_upstream_check_module/check_1.7.5+.patch //按nginx版本来执行不同的补丁文件</span><br><span class=\"line\">[root@localhost nginx-1.8.1]# ./configure --with-pcre=../pcre-8.38 --with-zlib=../zlib-1.2.8 --with-http_gzip_static_module --with-http_ssl_module --add-module=../nginx_tcp_proxy_module/ \\--add-module=../nginx_upstream_check_module/ \\--add-module=../nginx-module-vts/</span><br><span class=\"line\">[root@localhost nginx-1.8.1]# make </span><br><span class=\"line\">[root@localhost nginx-1.8.1]# make install</span><br><span class=\"line\">[root@localhost nginx-1.8.1]# /usr/local/nginx/sbin/nginx -V </span><br><span class=\"line\">nginx version: nginx/1.8.1</span><br><span class=\"line\">built by gcc 4.8.5 20150623 (Red Hat 4.8.5-4) (GCC) </span><br><span class=\"line\">built with OpenSSL 1.0.1e-fips 11 Feb 2013</span><br><span class=\"line\">TLS SNI support enabled</span><br><span class=\"line\">configure arguments: --with-pcre=../pcre-8.38 --with-zlib=../zlib-1.2.8 --with-http_gzip_static_module --with-http_ssl_module --add-module=../nginx_tcp_proxy_module/ --add-module=../nginx_upstream_check_module/ --add-module=../nginx-module-vts/</span><br><span class=\"line\">[root@localhost nginx-1.8.1]# /usr/local/nginx/sbin/nginx</span><br><span class=\"line\">[root@localhost nginx-1.8.1]# systemctl stop firewalld.service //关闭防火墙，开放访问端口80</span><br></pre></td></tr></table></figure>\n<p><img src=\"/images/nginx.png\" alt=\"Nginx Welcome\"></p>\n<p>nginx安装目录默认为: /usr/local/nginx, 可通过在configure时增加–prefix=”path”来更改。</p>\n<p>nginx启动时默认用户及用户组设置：</p>\n<ul>\n<li>通过在configure时增加–user=”user name”和–group=”group name”来更改。</li>\n<li>在nginx.conf里增加user “user name” “group name”来更改。</li>\n</ul>\n<p><strong>注意: 在configure时如需添加多个第三方module时，从第二个–add-module开始，在之前需要加“\\”</strong></p>\n<hr>\n<p><em>观点仅代表自己，期待你的留言。</em></p>\n"},{"title":"nginx日志打印详解","date":"2020-05-04T02:18:42.000Z","_content":"\n## 文章内容\n```\nlog_format  access  '$remote_addr - $remote_user [$time_local] [$msec] [$request_time] [$http_host] \"$request\" '\n                          '$status $body_bytes_sent \"$request_body\" \"$http_referer\" '\n                          '\"$http_user_agent\" $http_x_forwarded_for';\n```\n$remote_addr  客户端IP地址\n$remote_user   客户端用户\n$time_local   访问时间与时区\n$msec   访问时间与时区字符串形式\n$request_time  请求开始到返回时间\n$http_host   请求域名\n$request   请求的url与http协议\n$status    请求状态,如成功200\n$body_bytes_sent    记录发送给客户端文件主体内容大小\n$request_body   访问url时参数\n$http_referer     记录从那个页面链接访问过来的\n$http_user_agent    记录客户浏览器的相关信息\n$http_x_forwarded_for  请求转发f过来的地址\n$upstream_response_time:从 Nginx 建立连接 到 接收完数据并关闭连接\n\n-----\n\n*观点仅代表自己，期待你的留言。*\n","source":"_posts/nginx-log-config.md","raw":"---\ntitle: nginx日志打印详解\ntags:\n  - 原创\ndate: 2020-05-04 10:18:42\n---\n\n## 文章内容\n```\nlog_format  access  '$remote_addr - $remote_user [$time_local] [$msec] [$request_time] [$http_host] \"$request\" '\n                          '$status $body_bytes_sent \"$request_body\" \"$http_referer\" '\n                          '\"$http_user_agent\" $http_x_forwarded_for';\n```\n$remote_addr  客户端IP地址\n$remote_user   客户端用户\n$time_local   访问时间与时区\n$msec   访问时间与时区字符串形式\n$request_time  请求开始到返回时间\n$http_host   请求域名\n$request   请求的url与http协议\n$status    请求状态,如成功200\n$body_bytes_sent    记录发送给客户端文件主体内容大小\n$request_body   访问url时参数\n$http_referer     记录从那个页面链接访问过来的\n$http_user_agent    记录客户浏览器的相关信息\n$http_x_forwarded_for  请求转发f过来的地址\n$upstream_response_time:从 Nginx 建立连接 到 接收完数据并关闭连接\n\n-----\n\n*观点仅代表自己，期待你的留言。*\n","slug":"nginx-log-config","published":1,"updated":"2021-09-01T01:40:17.385Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cku52dynw003cbbin6lc8hzzu","content":"<h2 id=\"文章内容\"><a href=\"#文章内容\" class=\"headerlink\" title=\"文章内容\"></a>文章内容</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">log_format  access  &#x27;$remote_addr - $remote_user [$time_local] [$msec] [$request_time] [$http_host] &quot;$request&quot; &#x27;</span><br><span class=\"line\">                          &#x27;$status $body_bytes_sent &quot;$request_body&quot; &quot;$http_referer&quot; &#x27;</span><br><span class=\"line\">                          &#x27;&quot;$http_user_agent&quot; $http_x_forwarded_for&#x27;;</span><br></pre></td></tr></table></figure>\n<p>$remote_addr  客户端IP地址<br>$remote_user   客户端用户<br>$time_local   访问时间与时区<br>$msec   访问时间与时区字符串形式<br>$request_time  请求开始到返回时间<br>$http_host   请求域名<br>$request   请求的url与http协议<br>$status    请求状态,如成功200<br>$body_bytes_sent    记录发送给客户端文件主体内容大小<br>$request_body   访问url时参数<br>$http_referer     记录从那个页面链接访问过来的<br>$http_user_agent    记录客户浏览器的相关信息<br>$http_x_forwarded_for  请求转发f过来的地址<br>$upstream_response_time:从 Nginx 建立连接 到 接收完数据并关闭连接</p>\n<hr>\n<p><em>观点仅代表自己，期待你的留言。</em></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"文章内容\"><a href=\"#文章内容\" class=\"headerlink\" title=\"文章内容\"></a>文章内容</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">log_format  access  &#x27;$remote_addr - $remote_user [$time_local] [$msec] [$request_time] [$http_host] &quot;$request&quot; &#x27;</span><br><span class=\"line\">                          &#x27;$status $body_bytes_sent &quot;$request_body&quot; &quot;$http_referer&quot; &#x27;</span><br><span class=\"line\">                          &#x27;&quot;$http_user_agent&quot; $http_x_forwarded_for&#x27;;</span><br></pre></td></tr></table></figure>\n<p>$remote_addr  客户端IP地址<br>$remote_user   客户端用户<br>$time_local   访问时间与时区<br>$msec   访问时间与时区字符串形式<br>$request_time  请求开始到返回时间<br>$http_host   请求域名<br>$request   请求的url与http协议<br>$status    请求状态,如成功200<br>$body_bytes_sent    记录发送给客户端文件主体内容大小<br>$request_body   访问url时参数<br>$http_referer     记录从那个页面链接访问过来的<br>$http_user_agent    记录客户浏览器的相关信息<br>$http_x_forwarded_for  请求转发f过来的地址<br>$upstream_response_time:从 Nginx 建立连接 到 接收完数据并关闭连接</p>\n<hr>\n<p><em>观点仅代表自己，期待你的留言。</em></p>\n"},{"title":"关于MariaDB事务阻塞等待及锁的实验笔记","keywords":["事务阻塞等待","MariaDB","InnoDB存储引擎"],"date":"2016-05-30T10:00:50.000Z","_content":"\n## 实验环境\nServer Version: 10.0.24-MariaDB\nSET GLOBAL tx_isolation='REPEATABLE-READ';\nSET SESSION tx_isolation='REPEATABLE-READ';\nSET @@autocommit=0;\n\nSHOW VARIABLES like 'autocommit';\nSELECT @@GLOBAL.tx_isolation, @@tx_isolation;\n\n## 实验结论\n### 幻读的概念是另一事务先完成的情况下判断\n\n|事务A     \t\t\t\t\t\t\t\t\t\t\t|    事务B\n|:- |:-\n| start TRANSACTION;\t\t\t\t\t\t\t\t|  \n| select * from t1;(查询出2条数据)\t                |  \n|               \t\t\t\t\t\t\t\t\t| start TRANSACTION;\n|               \t\t\t\t\t\t\t\t\t| insert into t1 values(null,'v222');\n| select * from t1;(查询出2条数据)\t                |\n|               \t\t\t\t\t\t\t\t\t| commit;(__这一步很关键，它标识了事务B的完成__)\n| select * from t1;(查询出3条数据)\t                |\n\n`InnoDB存储引擎在REPEATABLE-READ的隔离级别下解决了幻读情况，所以会造成以上的情况。`\n\n### 并发事务修改同一行数据时，后执行更新的事务会__阻塞等待__先执行更新事务先结束（rollback或commit）或者超时\n\n|事务A     \t\t\t\t\t\t\t\t\t\t\t|    事务B\n|:- |:-\n| start TRANSACTION;\t\t\t\t\t\t\t\t| start TRANSACTION;\n| update t1 SET da='v1111' where id=1;              |\n|               \t\t\t\t\t\t\t\t\t| update t1 SET da='v1111' where id=1;(此时会等待事务A执行完成 OR 等待超时)\n\n### 并发事务更新时只要被更新的数据存在交集，那么就会存在__阻塞等待__另一事务完成的现象\n\n|事务A     \t\t\t\t\t\t\t\t\t\t\t|    事务B\n|:- |:-\n| start TRANSACTION;\t\t\t\t\t\t\t\t|\n| select * from t1;(查询出2条数据)\t                |\n|               \t\t\t\t\t\t\t\t\t| start TRANSACTION;\n|               \t\t\t\t\t\t\t\t\t| insert into t1 values(null,'v222');\n| update t1 set da='updated'(此时会等事务B的完成)\t\t|\n|               \t\t\t\t\t\t\t\t\t| commit;\n\n\n### 并发事务更新时只要存在全表扫描(不管数据存在不存在交集)，那么就会存在__阻塞等待__另一事务完成的现象\n\n|事务A     \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t|    事务B\n|:- |:- \n| start TRANSACTION;\t\t\t\t\t\t\t\t\t\t\t\t\t\t|\n| select * from t1;(查询出2条数据)\t                \t\t\t\t\t\t|\n|               \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t| start TRANSACTION;\n|               \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t| update t1 SET da='v1113333331' where id=1\n| update t1 set da='updated' where da like '%0000%'(此时会等事务B的完成)\t\t|\n|               \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t| commit;\n\n\n-----\n\n*观点仅代表自己，期待你的留言。*\n","source":"_posts/mysql-lock-transaction.md","raw":"---\ntitle: 关于MariaDB事务阻塞等待及锁的实验笔记\nkeywords:\n  - 事务阻塞等待\n  - MariaDB\n  - InnoDB存储引擎\ntags:\n  - 原创\ndate: 2016-05-30 18:00:50\n---\n\n## 实验环境\nServer Version: 10.0.24-MariaDB\nSET GLOBAL tx_isolation='REPEATABLE-READ';\nSET SESSION tx_isolation='REPEATABLE-READ';\nSET @@autocommit=0;\n\nSHOW VARIABLES like 'autocommit';\nSELECT @@GLOBAL.tx_isolation, @@tx_isolation;\n\n## 实验结论\n### 幻读的概念是另一事务先完成的情况下判断\n\n|事务A     \t\t\t\t\t\t\t\t\t\t\t|    事务B\n|:- |:-\n| start TRANSACTION;\t\t\t\t\t\t\t\t|  \n| select * from t1;(查询出2条数据)\t                |  \n|               \t\t\t\t\t\t\t\t\t| start TRANSACTION;\n|               \t\t\t\t\t\t\t\t\t| insert into t1 values(null,'v222');\n| select * from t1;(查询出2条数据)\t                |\n|               \t\t\t\t\t\t\t\t\t| commit;(__这一步很关键，它标识了事务B的完成__)\n| select * from t1;(查询出3条数据)\t                |\n\n`InnoDB存储引擎在REPEATABLE-READ的隔离级别下解决了幻读情况，所以会造成以上的情况。`\n\n### 并发事务修改同一行数据时，后执行更新的事务会__阻塞等待__先执行更新事务先结束（rollback或commit）或者超时\n\n|事务A     \t\t\t\t\t\t\t\t\t\t\t|    事务B\n|:- |:-\n| start TRANSACTION;\t\t\t\t\t\t\t\t| start TRANSACTION;\n| update t1 SET da='v1111' where id=1;              |\n|               \t\t\t\t\t\t\t\t\t| update t1 SET da='v1111' where id=1;(此时会等待事务A执行完成 OR 等待超时)\n\n### 并发事务更新时只要被更新的数据存在交集，那么就会存在__阻塞等待__另一事务完成的现象\n\n|事务A     \t\t\t\t\t\t\t\t\t\t\t|    事务B\n|:- |:-\n| start TRANSACTION;\t\t\t\t\t\t\t\t|\n| select * from t1;(查询出2条数据)\t                |\n|               \t\t\t\t\t\t\t\t\t| start TRANSACTION;\n|               \t\t\t\t\t\t\t\t\t| insert into t1 values(null,'v222');\n| update t1 set da='updated'(此时会等事务B的完成)\t\t|\n|               \t\t\t\t\t\t\t\t\t| commit;\n\n\n### 并发事务更新时只要存在全表扫描(不管数据存在不存在交集)，那么就会存在__阻塞等待__另一事务完成的现象\n\n|事务A     \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t|    事务B\n|:- |:- \n| start TRANSACTION;\t\t\t\t\t\t\t\t\t\t\t\t\t\t|\n| select * from t1;(查询出2条数据)\t                \t\t\t\t\t\t|\n|               \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t| start TRANSACTION;\n|               \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t| update t1 SET da='v1113333331' where id=1\n| update t1 set da='updated' where da like '%0000%'(此时会等事务B的完成)\t\t|\n|               \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t| commit;\n\n\n-----\n\n*观点仅代表自己，期待你的留言。*\n","slug":"mysql-lock-transaction","published":1,"updated":"2021-09-18T03:05:18.704Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cku52dynx003ebbinab7l26eq","content":"<h2 id=\"实验环境\"><a href=\"#实验环境\" class=\"headerlink\" title=\"实验环境\"></a>实验环境</h2><p>Server Version: 10.0.24-MariaDB<br>SET GLOBAL tx_isolation=’REPEATABLE-READ’;<br>SET SESSION tx_isolation=’REPEATABLE-READ’;<br>SET @@autocommit=0;</p>\n<p>SHOW VARIABLES like ‘autocommit’;<br>SELECT @@GLOBAL.tx_isolation, @@tx_isolation;</p>\n<h2 id=\"实验结论\"><a href=\"#实验结论\" class=\"headerlink\" title=\"实验结论\"></a>实验结论</h2><h3 id=\"幻读的概念是另一事务先完成的情况下判断\"><a href=\"#幻读的概念是另一事务先完成的情况下判断\" class=\"headerlink\" title=\"幻读的概念是另一事务先完成的情况下判断\"></a>幻读的概念是另一事务先完成的情况下判断</h3><table>\n<thead>\n<tr>\n<th align=\"left\">事务A</th>\n<th align=\"left\">事务B</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">start TRANSACTION;</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">select * from t1;(查询出2条数据)</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\"></td>\n<td align=\"left\">start TRANSACTION;</td>\n</tr>\n<tr>\n<td align=\"left\"></td>\n<td align=\"left\">insert into t1 values(null,’v222’);</td>\n</tr>\n<tr>\n<td align=\"left\">select * from t1;(查询出2条数据)</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\"></td>\n<td align=\"left\">commit;(<strong>这一步很关键，它标识了事务B的完成</strong>)</td>\n</tr>\n<tr>\n<td align=\"left\">select * from t1;(查询出3条数据)</td>\n<td align=\"left\"></td>\n</tr>\n</tbody></table>\n<p><code>InnoDB存储引擎在REPEATABLE-READ的隔离级别下解决了幻读情况，所以会造成以上的情况。</code></p>\n<h3 id=\"并发事务修改同一行数据时，后执行更新的事务会-阻塞等待-先执行更新事务先结束（rollback或commit）或者超时\"><a href=\"#并发事务修改同一行数据时，后执行更新的事务会-阻塞等待-先执行更新事务先结束（rollback或commit）或者超时\" class=\"headerlink\" title=\"并发事务修改同一行数据时，后执行更新的事务会__阻塞等待__先执行更新事务先结束（rollback或commit）或者超时\"></a>并发事务修改同一行数据时，后执行更新的事务会__阻塞等待__先执行更新事务先结束（rollback或commit）或者超时</h3><table>\n<thead>\n<tr>\n<th align=\"left\">事务A</th>\n<th align=\"left\">事务B</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">start TRANSACTION;</td>\n<td align=\"left\">start TRANSACTION;</td>\n</tr>\n<tr>\n<td align=\"left\">update t1 SET da=’v1111’ where id=1;</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\"></td>\n<td align=\"left\">update t1 SET da=’v1111’ where id=1;(此时会等待事务A执行完成 OR 等待超时)</td>\n</tr>\n</tbody></table>\n<h3 id=\"并发事务更新时只要被更新的数据存在交集，那么就会存在-阻塞等待-另一事务完成的现象\"><a href=\"#并发事务更新时只要被更新的数据存在交集，那么就会存在-阻塞等待-另一事务完成的现象\" class=\"headerlink\" title=\"并发事务更新时只要被更新的数据存在交集，那么就会存在__阻塞等待__另一事务完成的现象\"></a>并发事务更新时只要被更新的数据存在交集，那么就会存在__阻塞等待__另一事务完成的现象</h3><table>\n<thead>\n<tr>\n<th align=\"left\">事务A</th>\n<th align=\"left\">事务B</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">start TRANSACTION;</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">select * from t1;(查询出2条数据)</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\"></td>\n<td align=\"left\">start TRANSACTION;</td>\n</tr>\n<tr>\n<td align=\"left\"></td>\n<td align=\"left\">insert into t1 values(null,’v222’);</td>\n</tr>\n<tr>\n<td align=\"left\">update t1 set da=’updated’(此时会等事务B的完成)</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\"></td>\n<td align=\"left\">commit;</td>\n</tr>\n</tbody></table>\n<h3 id=\"并发事务更新时只要存在全表扫描-不管数据存在不存在交集-，那么就会存在-阻塞等待-另一事务完成的现象\"><a href=\"#并发事务更新时只要存在全表扫描-不管数据存在不存在交集-，那么就会存在-阻塞等待-另一事务完成的现象\" class=\"headerlink\" title=\"并发事务更新时只要存在全表扫描(不管数据存在不存在交集)，那么就会存在__阻塞等待__另一事务完成的现象\"></a>并发事务更新时只要存在全表扫描(不管数据存在不存在交集)，那么就会存在__阻塞等待__另一事务完成的现象</h3><table>\n<thead>\n<tr>\n<th align=\"left\">事务A</th>\n<th align=\"left\">事务B</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">start TRANSACTION;</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">select * from t1;(查询出2条数据)</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\"></td>\n<td align=\"left\">start TRANSACTION;</td>\n</tr>\n<tr>\n<td align=\"left\"></td>\n<td align=\"left\">update t1 SET da=’v1113333331’ where id=1</td>\n</tr>\n<tr>\n<td align=\"left\">update t1 set da=’updated’ where da like ‘%0000%’(此时会等事务B的完成)</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\"></td>\n<td align=\"left\">commit;</td>\n</tr>\n</tbody></table>\n<hr>\n<p><em>观点仅代表自己，期待你的留言。</em></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"实验环境\"><a href=\"#实验环境\" class=\"headerlink\" title=\"实验环境\"></a>实验环境</h2><p>Server Version: 10.0.24-MariaDB<br>SET GLOBAL tx_isolation=’REPEATABLE-READ’;<br>SET SESSION tx_isolation=’REPEATABLE-READ’;<br>SET @@autocommit=0;</p>\n<p>SHOW VARIABLES like ‘autocommit’;<br>SELECT @@GLOBAL.tx_isolation, @@tx_isolation;</p>\n<h2 id=\"实验结论\"><a href=\"#实验结论\" class=\"headerlink\" title=\"实验结论\"></a>实验结论</h2><h3 id=\"幻读的概念是另一事务先完成的情况下判断\"><a href=\"#幻读的概念是另一事务先完成的情况下判断\" class=\"headerlink\" title=\"幻读的概念是另一事务先完成的情况下判断\"></a>幻读的概念是另一事务先完成的情况下判断</h3><table>\n<thead>\n<tr>\n<th align=\"left\">事务A</th>\n<th align=\"left\">事务B</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">start TRANSACTION;</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">select * from t1;(查询出2条数据)</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\"></td>\n<td align=\"left\">start TRANSACTION;</td>\n</tr>\n<tr>\n<td align=\"left\"></td>\n<td align=\"left\">insert into t1 values(null,’v222’);</td>\n</tr>\n<tr>\n<td align=\"left\">select * from t1;(查询出2条数据)</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\"></td>\n<td align=\"left\">commit;(<strong>这一步很关键，它标识了事务B的完成</strong>)</td>\n</tr>\n<tr>\n<td align=\"left\">select * from t1;(查询出3条数据)</td>\n<td align=\"left\"></td>\n</tr>\n</tbody></table>\n<p><code>InnoDB存储引擎在REPEATABLE-READ的隔离级别下解决了幻读情况，所以会造成以上的情况。</code></p>\n<h3 id=\"并发事务修改同一行数据时，后执行更新的事务会-阻塞等待-先执行更新事务先结束（rollback或commit）或者超时\"><a href=\"#并发事务修改同一行数据时，后执行更新的事务会-阻塞等待-先执行更新事务先结束（rollback或commit）或者超时\" class=\"headerlink\" title=\"并发事务修改同一行数据时，后执行更新的事务会__阻塞等待__先执行更新事务先结束（rollback或commit）或者超时\"></a>并发事务修改同一行数据时，后执行更新的事务会__阻塞等待__先执行更新事务先结束（rollback或commit）或者超时</h3><table>\n<thead>\n<tr>\n<th align=\"left\">事务A</th>\n<th align=\"left\">事务B</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">start TRANSACTION;</td>\n<td align=\"left\">start TRANSACTION;</td>\n</tr>\n<tr>\n<td align=\"left\">update t1 SET da=’v1111’ where id=1;</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\"></td>\n<td align=\"left\">update t1 SET da=’v1111’ where id=1;(此时会等待事务A执行完成 OR 等待超时)</td>\n</tr>\n</tbody></table>\n<h3 id=\"并发事务更新时只要被更新的数据存在交集，那么就会存在-阻塞等待-另一事务完成的现象\"><a href=\"#并发事务更新时只要被更新的数据存在交集，那么就会存在-阻塞等待-另一事务完成的现象\" class=\"headerlink\" title=\"并发事务更新时只要被更新的数据存在交集，那么就会存在__阻塞等待__另一事务完成的现象\"></a>并发事务更新时只要被更新的数据存在交集，那么就会存在__阻塞等待__另一事务完成的现象</h3><table>\n<thead>\n<tr>\n<th align=\"left\">事务A</th>\n<th align=\"left\">事务B</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">start TRANSACTION;</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">select * from t1;(查询出2条数据)</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\"></td>\n<td align=\"left\">start TRANSACTION;</td>\n</tr>\n<tr>\n<td align=\"left\"></td>\n<td align=\"left\">insert into t1 values(null,’v222’);</td>\n</tr>\n<tr>\n<td align=\"left\">update t1 set da=’updated’(此时会等事务B的完成)</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\"></td>\n<td align=\"left\">commit;</td>\n</tr>\n</tbody></table>\n<h3 id=\"并发事务更新时只要存在全表扫描-不管数据存在不存在交集-，那么就会存在-阻塞等待-另一事务完成的现象\"><a href=\"#并发事务更新时只要存在全表扫描-不管数据存在不存在交集-，那么就会存在-阻塞等待-另一事务完成的现象\" class=\"headerlink\" title=\"并发事务更新时只要存在全表扫描(不管数据存在不存在交集)，那么就会存在__阻塞等待__另一事务完成的现象\"></a>并发事务更新时只要存在全表扫描(不管数据存在不存在交集)，那么就会存在__阻塞等待__另一事务完成的现象</h3><table>\n<thead>\n<tr>\n<th align=\"left\">事务A</th>\n<th align=\"left\">事务B</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">start TRANSACTION;</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">select * from t1;(查询出2条数据)</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\"></td>\n<td align=\"left\">start TRANSACTION;</td>\n</tr>\n<tr>\n<td align=\"left\"></td>\n<td align=\"left\">update t1 SET da=’v1113333331’ where id=1</td>\n</tr>\n<tr>\n<td align=\"left\">update t1 set da=’updated’ where da like ‘%0000%’(此时会等事务B的完成)</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\"></td>\n<td align=\"left\">commit;</td>\n</tr>\n</tbody></table>\n<hr>\n<p><em>观点仅代表自己，期待你的留言。</em></p>\n"},{"title":"Nginx反向代理多个域名","date":"2016-03-18T08:43:49.000Z","_content":"\n## 简介\n由于公司内网有多台服务器的http服务要映射到公司外网静态IP，如果用路由的端口映射来做，就只能一台内网服务器的80端口映射到外网80端口，其他服务器的80端口只能映射到外网的非80端口。非80端口的映射在访问的时候要域名加上端口，比较麻烦。所以我们可以在内网搭建个nginx反向代理服务器，将nginx反向代理服务器的80映射到外网IP的80，这样指向到公司外网IP的域名的HTTP请求就会发送到nginx反向代理服务器，利用nginx反向代理将不同域名的请求转发给内网不同机器的端口，就起到了“根据域名自动转发到相应服务器的特定端口”的效果，而路由器的端口映射做到的只是“根据不同端口自动转发到相应服务器的特定端口”，真是喜大普奔啊。\n\n## Nginx配置\nvim /usr/local/nginx/conf/reverse-proxy.conf\n```\nserver {\n    listen 80;\n    server_name tomcat1.vip.com;\n    location /{\n        proxy_redirect off;\n        proxy_set_header Host $host;\n        proxy_set_header X-Real-IP $remote_addr;\n        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n        proxy_pass http://127.0.0.1:8081;\n        #proxy_pass http://tomcat;\n    }\n    access_log logs/tomcat1_access.log;\n}\n\nserver {\n    listen 80;\n    server_name tomcat2.vip.com;\n    location /{\n        proxy_redirect off;\n        proxy_set_header Host $host;\n        proxy_set_header X-Real-IP $remote_addr;\n        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n        proxy_pass http://127.0.0.1:8082;\n        #proxy_pass http://tomcat;\n    }\n    access_log logs/tomcat2_access.log;\n}\n```\n在nginx.conf的http节点中include配置文件reverse-proxy.conf\n```\nhttp {\n\tinclude reverse-proxy.conf;\n\n    #按server段顺序匹配，如果没有匹配到则可通过泛域名匹配返回错误码或错误页\n    server {\n        listen 80;\n        server_name *.vip.com;\n        location /{\n            return 404;\n        }\n    }\n}\n```\n## 测试生效\n热部署nginx配置\n```\n[root@localhost ~]# /usr/local/nginx/sbin/nginx -t; /usr/local/nginx/sbin/nginx -s reload;\nnginx: the configuration file /usr/local/nginx/conf/nginx.conf syntax is ok\nnginx: configuration file /usr/local/nginx/conf/nginx.conf test is successful\n```\n在客户机的hosts中配置tomcat1.vip.com和tomcat2.vip.com （如果是已申请好的域名，则可跳过此步骤）\n```\n10.28.10.218 tomcat1.vip.com\n10.28.10.218 tomcat2.vip.com\n```\n![](/images/QQ20160318-3.png)\n\n从以上访问结果来看，浏览器的请求会分别引导到了tomcat1和tomcat2上。\n\n\n-----\n\n*观点仅代表自己，期待你的留言。*","source":"_posts/nginx-muti-domain.md","raw":"---\ntitle: Nginx反向代理多个域名\ntags:\n  - 原创\n  - Nginx\ndate: 2016-03-18 16:43:49\n---\n\n## 简介\n由于公司内网有多台服务器的http服务要映射到公司外网静态IP，如果用路由的端口映射来做，就只能一台内网服务器的80端口映射到外网80端口，其他服务器的80端口只能映射到外网的非80端口。非80端口的映射在访问的时候要域名加上端口，比较麻烦。所以我们可以在内网搭建个nginx反向代理服务器，将nginx反向代理服务器的80映射到外网IP的80，这样指向到公司外网IP的域名的HTTP请求就会发送到nginx反向代理服务器，利用nginx反向代理将不同域名的请求转发给内网不同机器的端口，就起到了“根据域名自动转发到相应服务器的特定端口”的效果，而路由器的端口映射做到的只是“根据不同端口自动转发到相应服务器的特定端口”，真是喜大普奔啊。\n\n## Nginx配置\nvim /usr/local/nginx/conf/reverse-proxy.conf\n```\nserver {\n    listen 80;\n    server_name tomcat1.vip.com;\n    location /{\n        proxy_redirect off;\n        proxy_set_header Host $host;\n        proxy_set_header X-Real-IP $remote_addr;\n        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n        proxy_pass http://127.0.0.1:8081;\n        #proxy_pass http://tomcat;\n    }\n    access_log logs/tomcat1_access.log;\n}\n\nserver {\n    listen 80;\n    server_name tomcat2.vip.com;\n    location /{\n        proxy_redirect off;\n        proxy_set_header Host $host;\n        proxy_set_header X-Real-IP $remote_addr;\n        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n        proxy_pass http://127.0.0.1:8082;\n        #proxy_pass http://tomcat;\n    }\n    access_log logs/tomcat2_access.log;\n}\n```\n在nginx.conf的http节点中include配置文件reverse-proxy.conf\n```\nhttp {\n\tinclude reverse-proxy.conf;\n\n    #按server段顺序匹配，如果没有匹配到则可通过泛域名匹配返回错误码或错误页\n    server {\n        listen 80;\n        server_name *.vip.com;\n        location /{\n            return 404;\n        }\n    }\n}\n```\n## 测试生效\n热部署nginx配置\n```\n[root@localhost ~]# /usr/local/nginx/sbin/nginx -t; /usr/local/nginx/sbin/nginx -s reload;\nnginx: the configuration file /usr/local/nginx/conf/nginx.conf syntax is ok\nnginx: configuration file /usr/local/nginx/conf/nginx.conf test is successful\n```\n在客户机的hosts中配置tomcat1.vip.com和tomcat2.vip.com （如果是已申请好的域名，则可跳过此步骤）\n```\n10.28.10.218 tomcat1.vip.com\n10.28.10.218 tomcat2.vip.com\n```\n![](/images/QQ20160318-3.png)\n\n从以上访问结果来看，浏览器的请求会分别引导到了tomcat1和tomcat2上。\n\n\n-----\n\n*观点仅代表自己，期待你的留言。*","slug":"nginx-muti-domain","published":1,"updated":"2021-08-31T14:23:11.547Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cku52dyny003hbbinhxwddl0m","content":"<h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><p>由于公司内网有多台服务器的http服务要映射到公司外网静态IP，如果用路由的端口映射来做，就只能一台内网服务器的80端口映射到外网80端口，其他服务器的80端口只能映射到外网的非80端口。非80端口的映射在访问的时候要域名加上端口，比较麻烦。所以我们可以在内网搭建个nginx反向代理服务器，将nginx反向代理服务器的80映射到外网IP的80，这样指向到公司外网IP的域名的HTTP请求就会发送到nginx反向代理服务器，利用nginx反向代理将不同域名的请求转发给内网不同机器的端口，就起到了“根据域名自动转发到相应服务器的特定端口”的效果，而路由器的端口映射做到的只是“根据不同端口自动转发到相应服务器的特定端口”，真是喜大普奔啊。</p>\n<h2 id=\"Nginx配置\"><a href=\"#Nginx配置\" class=\"headerlink\" title=\"Nginx配置\"></a>Nginx配置</h2><p>vim /usr/local/nginx/conf/reverse-proxy.conf</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">server &#123;</span><br><span class=\"line\">    listen 80;</span><br><span class=\"line\">    server_name tomcat1.vip.com;</span><br><span class=\"line\">    location /&#123;</span><br><span class=\"line\">        proxy_redirect off;</span><br><span class=\"line\">        proxy_set_header Host $host;</span><br><span class=\"line\">        proxy_set_header X-Real-IP $remote_addr;</span><br><span class=\"line\">        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class=\"line\">        proxy_pass http://127.0.0.1:8081;</span><br><span class=\"line\">        #proxy_pass http://tomcat;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    access_log logs/tomcat1_access.log;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">server &#123;</span><br><span class=\"line\">    listen 80;</span><br><span class=\"line\">    server_name tomcat2.vip.com;</span><br><span class=\"line\">    location /&#123;</span><br><span class=\"line\">        proxy_redirect off;</span><br><span class=\"line\">        proxy_set_header Host $host;</span><br><span class=\"line\">        proxy_set_header X-Real-IP $remote_addr;</span><br><span class=\"line\">        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class=\"line\">        proxy_pass http://127.0.0.1:8082;</span><br><span class=\"line\">        #proxy_pass http://tomcat;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    access_log logs/tomcat2_access.log;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在nginx.conf的http节点中include配置文件reverse-proxy.conf</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">http &#123;</span><br><span class=\"line\">\tinclude reverse-proxy.conf;</span><br><span class=\"line\"></span><br><span class=\"line\">    #按server段顺序匹配，如果没有匹配到则可通过泛域名匹配返回错误码或错误页</span><br><span class=\"line\">    server &#123;</span><br><span class=\"line\">        listen 80;</span><br><span class=\"line\">        server_name *.vip.com;</span><br><span class=\"line\">        location /&#123;</span><br><span class=\"line\">            return 404;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"测试生效\"><a href=\"#测试生效\" class=\"headerlink\" title=\"测试生效\"></a>测试生效</h2><p>热部署nginx配置</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@localhost ~]# /usr/local/nginx/sbin/nginx -t; /usr/local/nginx/sbin/nginx -s reload;</span><br><span class=\"line\">nginx: the configuration file /usr/local/nginx/conf/nginx.conf syntax is ok</span><br><span class=\"line\">nginx: configuration file /usr/local/nginx/conf/nginx.conf test is successful</span><br></pre></td></tr></table></figure>\n<p>在客户机的hosts中配置tomcat1.vip.com和tomcat2.vip.com （如果是已申请好的域名，则可跳过此步骤）</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">10.28.10.218 tomcat1.vip.com</span><br><span class=\"line\">10.28.10.218 tomcat2.vip.com</span><br></pre></td></tr></table></figure>\n<p><img src=\"/images/QQ20160318-3.png\"></p>\n<p>从以上访问结果来看，浏览器的请求会分别引导到了tomcat1和tomcat2上。</p>\n<hr>\n<p><em>观点仅代表自己，期待你的留言。</em></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><p>由于公司内网有多台服务器的http服务要映射到公司外网静态IP，如果用路由的端口映射来做，就只能一台内网服务器的80端口映射到外网80端口，其他服务器的80端口只能映射到外网的非80端口。非80端口的映射在访问的时候要域名加上端口，比较麻烦。所以我们可以在内网搭建个nginx反向代理服务器，将nginx反向代理服务器的80映射到外网IP的80，这样指向到公司外网IP的域名的HTTP请求就会发送到nginx反向代理服务器，利用nginx反向代理将不同域名的请求转发给内网不同机器的端口，就起到了“根据域名自动转发到相应服务器的特定端口”的效果，而路由器的端口映射做到的只是“根据不同端口自动转发到相应服务器的特定端口”，真是喜大普奔啊。</p>\n<h2 id=\"Nginx配置\"><a href=\"#Nginx配置\" class=\"headerlink\" title=\"Nginx配置\"></a>Nginx配置</h2><p>vim /usr/local/nginx/conf/reverse-proxy.conf</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">server &#123;</span><br><span class=\"line\">    listen 80;</span><br><span class=\"line\">    server_name tomcat1.vip.com;</span><br><span class=\"line\">    location /&#123;</span><br><span class=\"line\">        proxy_redirect off;</span><br><span class=\"line\">        proxy_set_header Host $host;</span><br><span class=\"line\">        proxy_set_header X-Real-IP $remote_addr;</span><br><span class=\"line\">        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class=\"line\">        proxy_pass http://127.0.0.1:8081;</span><br><span class=\"line\">        #proxy_pass http://tomcat;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    access_log logs/tomcat1_access.log;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">server &#123;</span><br><span class=\"line\">    listen 80;</span><br><span class=\"line\">    server_name tomcat2.vip.com;</span><br><span class=\"line\">    location /&#123;</span><br><span class=\"line\">        proxy_redirect off;</span><br><span class=\"line\">        proxy_set_header Host $host;</span><br><span class=\"line\">        proxy_set_header X-Real-IP $remote_addr;</span><br><span class=\"line\">        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class=\"line\">        proxy_pass http://127.0.0.1:8082;</span><br><span class=\"line\">        #proxy_pass http://tomcat;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    access_log logs/tomcat2_access.log;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在nginx.conf的http节点中include配置文件reverse-proxy.conf</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">http &#123;</span><br><span class=\"line\">\tinclude reverse-proxy.conf;</span><br><span class=\"line\"></span><br><span class=\"line\">    #按server段顺序匹配，如果没有匹配到则可通过泛域名匹配返回错误码或错误页</span><br><span class=\"line\">    server &#123;</span><br><span class=\"line\">        listen 80;</span><br><span class=\"line\">        server_name *.vip.com;</span><br><span class=\"line\">        location /&#123;</span><br><span class=\"line\">            return 404;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"测试生效\"><a href=\"#测试生效\" class=\"headerlink\" title=\"测试生效\"></a>测试生效</h2><p>热部署nginx配置</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@localhost ~]# /usr/local/nginx/sbin/nginx -t; /usr/local/nginx/sbin/nginx -s reload;</span><br><span class=\"line\">nginx: the configuration file /usr/local/nginx/conf/nginx.conf syntax is ok</span><br><span class=\"line\">nginx: configuration file /usr/local/nginx/conf/nginx.conf test is successful</span><br></pre></td></tr></table></figure>\n<p>在客户机的hosts中配置tomcat1.vip.com和tomcat2.vip.com （如果是已申请好的域名，则可跳过此步骤）</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">10.28.10.218 tomcat1.vip.com</span><br><span class=\"line\">10.28.10.218 tomcat2.vip.com</span><br></pre></td></tr></table></figure>\n<p><img src=\"/images/QQ20160318-3.png\"></p>\n<p>从以上访问结果来看，浏览器的请求会分别引导到了tomcat1和tomcat2上。</p>\n<hr>\n<p><em>观点仅代表自己，期待你的留言。</em></p>\n"},{"title":"Linux下通过nginx实现直播间功能的实验","date":"2017-10-15T03:07:14.000Z","_content":"\n## 实验环境\n - 系统环境\n```\nwujianjun@wujianjun-work ~ $ uname -a\nLinux wujianjun-work 4.10.0-37-generic #41~16.04.1-Ubuntu SMP Fri Oct 6 22:42:59 UTC 2017 x86_64 x86_64 x86_64 GNU/Linux\n```\n - 软件环境\n OBS(Open Broadcaster Software) v20.0.1 (Linux)\n\n nginx version: nginx/1.13.6\n built by gcc 5.4.0 20160609 (Ubuntu 5.4.0-6ubuntu1~16.04.5)\n built with OpenSSL 1.0.2g  1 Mar 2016\n TLS SNI support enabled\n configure arguments: --with-pcre=pcre-8.38 --add-module=nginx-rtmp-module-1.1.11\n\n## Nginx+obs安装及配置\n### 安装obs\n```\nwujianjun@wujianjun-work ~ $ sudo add-apt-repository ppa:kirillshkrogalev/ffmpeg-next\nwujianjun@wujianjun-work ~ $ sudo apt-get update && sudo apt-get install ffmpeg\nwujianjun@wujianjun-work ~ $ sudo apt-get install obs-studio\nwujianjun@wujianjun-work ~ $ sudo add-apt-repository ppa:obsproject/obs-studio\nwujianjun@wujianjun-work ~ $ sudo apt-get update && sudo apt-get install obs-studio\n```\n### nginx加装rtmp模块\nnginx-rtmp-module (https://github.com/arut/nginx-rtmp-module)\n\n```\nwujianjun@wujianjun-work ~ $ sudo apt-get install build-essential\nwujianjun@wujianjun-work ~ $ wget wget http://nginx.org/download/nginx-1.13.6.tar.gz\nwujianjun@wujianjun-work ~/nginx-1.13.6 $ wget https://github.com/arut/nginx-rtmp-module/archive/v1.1.11.tar.gz\nwujianjun@wujianjun-work ~/nginx-1.13.6 $ tar -xvf v1.1.11.tar.gz\nwujianjun@wujianjun-work ~/nginx-1.13.6 $ wget http://jaist.dl.sourceforge.net/project/pcre/pcre/8.38/pcre-8.38.tar.gz\nwujianjun@wujianjun-work ~/nginx-1.13.6 $ tar -xvf pcre-8.38.tar.gz\nwujianjun@wujianjun-work ~/nginx-1.13.6 $ ls -all\n总用量 748\ndrwxr-xr-x  9 wujianjun wujianjun   4096 10月 15 11:39 .\ndrwxr-xr-x 63 wujianjun wujianjun   4096 10月 15 11:33 ..\ndrwxr-xr-x  6 wujianjun wujianjun   4096 10月 15 11:33 auto\n-rw-r--r--  1 wujianjun wujianjun 282456 10月 10 23:22 CHANGES\n-rw-r--r--  1 wujianjun wujianjun 430416 10月 10 23:22 CHANGES.ru\ndrwxr-xr-x  2 wujianjun wujianjun   4096 10月 15 11:33 conf\n-rwxr-xr-x  1 wujianjun wujianjun   2502 10月 10 23:22 configure\ndrwxr-xr-x  4 wujianjun wujianjun   4096 10月 15 11:33 contrib\ndrwxr-xr-x  2 wujianjun wujianjun   4096 10月 15 11:33 html\n-rw-r--r--  1 wujianjun wujianjun   1397 10月 10 23:22 LICENSE\ndrwxr-xr-x  2 wujianjun wujianjun   4096 10月 15 11:33 man\ndrwxrwxr-x  6 wujianjun wujianjun   4096 2月  13  2017 nginx-rtmp-module-1.1.11\ndrwxr-xr-x  7 wujianjun wujianjun   4096 11月 23  2015 pcre-8.38\n-rw-r--r--  1 wujianjun wujianjun     49 10月 10 23:22 README\ndrwxr-xr-x  9 wujianjun wujianjun   4096 10月 15 11:33 src\nwujianjun@wujianjun-work ~/nginx-1.13.6 $ ./configure --with-pcre=pcre-8.38 --add-module=nginx-rtmp-module-1.1.11\nwujianjun@wujianjun-work ~/nginx-1.13.6 $ make && sudo make install\nwujianjun@wujianjun-work ~/nginx-1.13.6 $ ls -all /usr/local/nginx/\n总用量 24\ndrwxr-xr-x  6 root root 4096 10月 15 16:11 .\ndrwxr-xr-x 11 root root 4096 10月 15 16:11 ..\ndrwxr-xr-x  2 root root 4096 10月 15 16:11 conf\ndrwxr-xr-x  2 root root 4096 10月 15 16:11 html\ndrwxr-xr-x  2 root root 4096 10月 15 16:11 logs\ndrwxr-xr-x  2 root root 4096 10月 15 16:11 sbin\n```\n\n### 增加rtmp协议配置\n```\nwujianjun@wujianjun-work ~/nginx-1.13.6 $ sudo vi /usr/local/nginx/conf/nginx.conf\n```\n在nginx.conf文件末尾增加以下rtmp协议的配置\n```\nrtmp {\n    server {\n        listen 1935;\n        chunk_size 4096;\n\n        application live {\n            live on;\n            record off;\n        }\n    }\n}\n```\n\n## 启动&测试\n - 启动nginx\n```\nwujianjun@wujianjun-work ~/nginx-1.13.6 $ sudo /usr/local/nginx/sbin/nginx\n```\n - 启动OBS\n 打开刚安装的OBS软件，在来源处配置图像的推送来源（我这里选择窗口捕获），点击右下角\"设置\"，进行如下图配置流推送地址\n ![](/images/obs-1.png)\n\n配置完成后，点击\"开始推流\"\n\n - 启动支持网络流播放的视频播放器(演示使用vlc播放器)\n 配置网络流播放的地址，如下图：\n ![](/images/vlc-1.png)\n\n 当点击\"播放\"后，稍等几秒，即可看到播放器显示了obs捕获的图像了。\n ![](/images/vlc-2.png)\n\n由于视频流需要通过网络进行传输，所以直播图像会有几秒的延迟。\n\n## http访问直播视频\n1、更改nginx.conf中配置，增加hls配置(hls是在流媒体服务器中用来存放流媒体的文件夹),再次hls所在目录设置为http协议访问目录即可，更改后的配置如下：\n```\nrtmp {\n    server {\n        listen 1935;\n        chunk_size 4096;\n\n        application live {\n            live on;\n            hls on;\n            hls_path /usr/share/nginx/html/hls;\n            hls_fragment 5s;\n        }\n    }\n}\n\nhttp {\n  server {\n    listen 80;\n    .....\n    location / {\n           #root   html;\n           root /usr/share/nginx/html;\n           index  index.html index.htm;\n    }\n    .....\n  }\n}\n```\n__注意：__ hls所在目录nginx的用户必须有写入权限。\n\n2、obs软件配置录制流名称\n 在配置obs推送流URL的下方有一个设置\"流名称\"的地方，这里可以随意填写一个名称（我这里示例填入\"test\"）\n\n3、重启一下nginx与obs软件，我们即可在手机浏览器中输入 http://ip/hls/test.m3u8 即可通过手机播放直播视频。（直播延迟有点大，后续出文章优化）\n![](/images/obs-2.png)\n\n-----\n\n*观点仅代表自己，期待你的留言。*\n","source":"_posts/nginx-rtmp-obs.md","raw":"---\ntitle: Linux下通过nginx实现直播间功能的实验\ntags:\n  - 原创\n  - nginx + obs\ndate: 2017-10-15 11:07:14\n---\n\n## 实验环境\n - 系统环境\n```\nwujianjun@wujianjun-work ~ $ uname -a\nLinux wujianjun-work 4.10.0-37-generic #41~16.04.1-Ubuntu SMP Fri Oct 6 22:42:59 UTC 2017 x86_64 x86_64 x86_64 GNU/Linux\n```\n - 软件环境\n OBS(Open Broadcaster Software) v20.0.1 (Linux)\n\n nginx version: nginx/1.13.6\n built by gcc 5.4.0 20160609 (Ubuntu 5.4.0-6ubuntu1~16.04.5)\n built with OpenSSL 1.0.2g  1 Mar 2016\n TLS SNI support enabled\n configure arguments: --with-pcre=pcre-8.38 --add-module=nginx-rtmp-module-1.1.11\n\n## Nginx+obs安装及配置\n### 安装obs\n```\nwujianjun@wujianjun-work ~ $ sudo add-apt-repository ppa:kirillshkrogalev/ffmpeg-next\nwujianjun@wujianjun-work ~ $ sudo apt-get update && sudo apt-get install ffmpeg\nwujianjun@wujianjun-work ~ $ sudo apt-get install obs-studio\nwujianjun@wujianjun-work ~ $ sudo add-apt-repository ppa:obsproject/obs-studio\nwujianjun@wujianjun-work ~ $ sudo apt-get update && sudo apt-get install obs-studio\n```\n### nginx加装rtmp模块\nnginx-rtmp-module (https://github.com/arut/nginx-rtmp-module)\n\n```\nwujianjun@wujianjun-work ~ $ sudo apt-get install build-essential\nwujianjun@wujianjun-work ~ $ wget wget http://nginx.org/download/nginx-1.13.6.tar.gz\nwujianjun@wujianjun-work ~/nginx-1.13.6 $ wget https://github.com/arut/nginx-rtmp-module/archive/v1.1.11.tar.gz\nwujianjun@wujianjun-work ~/nginx-1.13.6 $ tar -xvf v1.1.11.tar.gz\nwujianjun@wujianjun-work ~/nginx-1.13.6 $ wget http://jaist.dl.sourceforge.net/project/pcre/pcre/8.38/pcre-8.38.tar.gz\nwujianjun@wujianjun-work ~/nginx-1.13.6 $ tar -xvf pcre-8.38.tar.gz\nwujianjun@wujianjun-work ~/nginx-1.13.6 $ ls -all\n总用量 748\ndrwxr-xr-x  9 wujianjun wujianjun   4096 10月 15 11:39 .\ndrwxr-xr-x 63 wujianjun wujianjun   4096 10月 15 11:33 ..\ndrwxr-xr-x  6 wujianjun wujianjun   4096 10月 15 11:33 auto\n-rw-r--r--  1 wujianjun wujianjun 282456 10月 10 23:22 CHANGES\n-rw-r--r--  1 wujianjun wujianjun 430416 10月 10 23:22 CHANGES.ru\ndrwxr-xr-x  2 wujianjun wujianjun   4096 10月 15 11:33 conf\n-rwxr-xr-x  1 wujianjun wujianjun   2502 10月 10 23:22 configure\ndrwxr-xr-x  4 wujianjun wujianjun   4096 10月 15 11:33 contrib\ndrwxr-xr-x  2 wujianjun wujianjun   4096 10月 15 11:33 html\n-rw-r--r--  1 wujianjun wujianjun   1397 10月 10 23:22 LICENSE\ndrwxr-xr-x  2 wujianjun wujianjun   4096 10月 15 11:33 man\ndrwxrwxr-x  6 wujianjun wujianjun   4096 2月  13  2017 nginx-rtmp-module-1.1.11\ndrwxr-xr-x  7 wujianjun wujianjun   4096 11月 23  2015 pcre-8.38\n-rw-r--r--  1 wujianjun wujianjun     49 10月 10 23:22 README\ndrwxr-xr-x  9 wujianjun wujianjun   4096 10月 15 11:33 src\nwujianjun@wujianjun-work ~/nginx-1.13.6 $ ./configure --with-pcre=pcre-8.38 --add-module=nginx-rtmp-module-1.1.11\nwujianjun@wujianjun-work ~/nginx-1.13.6 $ make && sudo make install\nwujianjun@wujianjun-work ~/nginx-1.13.6 $ ls -all /usr/local/nginx/\n总用量 24\ndrwxr-xr-x  6 root root 4096 10月 15 16:11 .\ndrwxr-xr-x 11 root root 4096 10月 15 16:11 ..\ndrwxr-xr-x  2 root root 4096 10月 15 16:11 conf\ndrwxr-xr-x  2 root root 4096 10月 15 16:11 html\ndrwxr-xr-x  2 root root 4096 10月 15 16:11 logs\ndrwxr-xr-x  2 root root 4096 10月 15 16:11 sbin\n```\n\n### 增加rtmp协议配置\n```\nwujianjun@wujianjun-work ~/nginx-1.13.6 $ sudo vi /usr/local/nginx/conf/nginx.conf\n```\n在nginx.conf文件末尾增加以下rtmp协议的配置\n```\nrtmp {\n    server {\n        listen 1935;\n        chunk_size 4096;\n\n        application live {\n            live on;\n            record off;\n        }\n    }\n}\n```\n\n## 启动&测试\n - 启动nginx\n```\nwujianjun@wujianjun-work ~/nginx-1.13.6 $ sudo /usr/local/nginx/sbin/nginx\n```\n - 启动OBS\n 打开刚安装的OBS软件，在来源处配置图像的推送来源（我这里选择窗口捕获），点击右下角\"设置\"，进行如下图配置流推送地址\n ![](/images/obs-1.png)\n\n配置完成后，点击\"开始推流\"\n\n - 启动支持网络流播放的视频播放器(演示使用vlc播放器)\n 配置网络流播放的地址，如下图：\n ![](/images/vlc-1.png)\n\n 当点击\"播放\"后，稍等几秒，即可看到播放器显示了obs捕获的图像了。\n ![](/images/vlc-2.png)\n\n由于视频流需要通过网络进行传输，所以直播图像会有几秒的延迟。\n\n## http访问直播视频\n1、更改nginx.conf中配置，增加hls配置(hls是在流媒体服务器中用来存放流媒体的文件夹),再次hls所在目录设置为http协议访问目录即可，更改后的配置如下：\n```\nrtmp {\n    server {\n        listen 1935;\n        chunk_size 4096;\n\n        application live {\n            live on;\n            hls on;\n            hls_path /usr/share/nginx/html/hls;\n            hls_fragment 5s;\n        }\n    }\n}\n\nhttp {\n  server {\n    listen 80;\n    .....\n    location / {\n           #root   html;\n           root /usr/share/nginx/html;\n           index  index.html index.htm;\n    }\n    .....\n  }\n}\n```\n__注意：__ hls所在目录nginx的用户必须有写入权限。\n\n2、obs软件配置录制流名称\n 在配置obs推送流URL的下方有一个设置\"流名称\"的地方，这里可以随意填写一个名称（我这里示例填入\"test\"）\n\n3、重启一下nginx与obs软件，我们即可在手机浏览器中输入 http://ip/hls/test.m3u8 即可通过手机播放直播视频。（直播延迟有点大，后续出文章优化）\n![](/images/obs-2.png)\n\n-----\n\n*观点仅代表自己，期待你的留言。*\n","slug":"nginx-rtmp-obs","published":1,"updated":"2021-08-31T14:23:11.548Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cku52dyny003jbbin6woo3i8s","content":"<h2 id=\"实验环境\"><a href=\"#实验环境\" class=\"headerlink\" title=\"实验环境\"></a>实验环境</h2><ul>\n<li>系统环境<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wujianjun@wujianjun-work ~ $ uname -a</span><br><span class=\"line\">Linux wujianjun-work 4.10.0-37-generic #41~16.04.1-Ubuntu SMP Fri Oct 6 22:42:59 UTC 2017 x86_64 x86_64 x86_64 GNU/Linux</span><br></pre></td></tr></table></figure></li>\n<li>软件环境<br>OBS(Open Broadcaster Software) v20.0.1 (Linux)</li>\n</ul>\n<p> nginx version: nginx/1.13.6<br> built by gcc 5.4.0 20160609 (Ubuntu 5.4.0-6ubuntu1~16.04.5)<br> built with OpenSSL 1.0.2g  1 Mar 2016<br> TLS SNI support enabled<br> configure arguments: –with-pcre=pcre-8.38 –add-module=nginx-rtmp-module-1.1.11</p>\n<h2 id=\"Nginx-obs安装及配置\"><a href=\"#Nginx-obs安装及配置\" class=\"headerlink\" title=\"Nginx+obs安装及配置\"></a>Nginx+obs安装及配置</h2><h3 id=\"安装obs\"><a href=\"#安装obs\" class=\"headerlink\" title=\"安装obs\"></a>安装obs</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wujianjun@wujianjun-work ~ $ sudo add-apt-repository ppa:kirillshkrogalev/ffmpeg-next</span><br><span class=\"line\">wujianjun@wujianjun-work ~ $ sudo apt-get update &amp;&amp; sudo apt-get install ffmpeg</span><br><span class=\"line\">wujianjun@wujianjun-work ~ $ sudo apt-get install obs-studio</span><br><span class=\"line\">wujianjun@wujianjun-work ~ $ sudo add-apt-repository ppa:obsproject/obs-studio</span><br><span class=\"line\">wujianjun@wujianjun-work ~ $ sudo apt-get update &amp;&amp; sudo apt-get install obs-studio</span><br></pre></td></tr></table></figure>\n<h3 id=\"nginx加装rtmp模块\"><a href=\"#nginx加装rtmp模块\" class=\"headerlink\" title=\"nginx加装rtmp模块\"></a>nginx加装rtmp模块</h3><p>nginx-rtmp-module (<a href=\"https://github.com/arut/nginx-rtmp-module\">https://github.com/arut/nginx-rtmp-module</a>)</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wujianjun@wujianjun-work ~ $ sudo apt-get install build-essential</span><br><span class=\"line\">wujianjun@wujianjun-work ~ $ wget wget http://nginx.org/download/nginx-1.13.6.tar.gz</span><br><span class=\"line\">wujianjun@wujianjun-work ~/nginx-1.13.6 $ wget https://github.com/arut/nginx-rtmp-module/archive/v1.1.11.tar.gz</span><br><span class=\"line\">wujianjun@wujianjun-work ~/nginx-1.13.6 $ tar -xvf v1.1.11.tar.gz</span><br><span class=\"line\">wujianjun@wujianjun-work ~/nginx-1.13.6 $ wget http://jaist.dl.sourceforge.net/project/pcre/pcre/8.38/pcre-8.38.tar.gz</span><br><span class=\"line\">wujianjun@wujianjun-work ~/nginx-1.13.6 $ tar -xvf pcre-8.38.tar.gz</span><br><span class=\"line\">wujianjun@wujianjun-work ~/nginx-1.13.6 $ ls -all</span><br><span class=\"line\">总用量 748</span><br><span class=\"line\">drwxr-xr-x  9 wujianjun wujianjun   4096 10月 15 11:39 .</span><br><span class=\"line\">drwxr-xr-x 63 wujianjun wujianjun   4096 10月 15 11:33 ..</span><br><span class=\"line\">drwxr-xr-x  6 wujianjun wujianjun   4096 10月 15 11:33 auto</span><br><span class=\"line\">-rw-r--r--  1 wujianjun wujianjun 282456 10月 10 23:22 CHANGES</span><br><span class=\"line\">-rw-r--r--  1 wujianjun wujianjun 430416 10月 10 23:22 CHANGES.ru</span><br><span class=\"line\">drwxr-xr-x  2 wujianjun wujianjun   4096 10月 15 11:33 conf</span><br><span class=\"line\">-rwxr-xr-x  1 wujianjun wujianjun   2502 10月 10 23:22 configure</span><br><span class=\"line\">drwxr-xr-x  4 wujianjun wujianjun   4096 10月 15 11:33 contrib</span><br><span class=\"line\">drwxr-xr-x  2 wujianjun wujianjun   4096 10月 15 11:33 html</span><br><span class=\"line\">-rw-r--r--  1 wujianjun wujianjun   1397 10月 10 23:22 LICENSE</span><br><span class=\"line\">drwxr-xr-x  2 wujianjun wujianjun   4096 10月 15 11:33 man</span><br><span class=\"line\">drwxrwxr-x  6 wujianjun wujianjun   4096 2月  13  2017 nginx-rtmp-module-1.1.11</span><br><span class=\"line\">drwxr-xr-x  7 wujianjun wujianjun   4096 11月 23  2015 pcre-8.38</span><br><span class=\"line\">-rw-r--r--  1 wujianjun wujianjun     49 10月 10 23:22 README</span><br><span class=\"line\">drwxr-xr-x  9 wujianjun wujianjun   4096 10月 15 11:33 src</span><br><span class=\"line\">wujianjun@wujianjun-work ~/nginx-1.13.6 $ ./configure --with-pcre=pcre-8.38 --add-module=nginx-rtmp-module-1.1.11</span><br><span class=\"line\">wujianjun@wujianjun-work ~/nginx-1.13.6 $ make &amp;&amp; sudo make install</span><br><span class=\"line\">wujianjun@wujianjun-work ~/nginx-1.13.6 $ ls -all /usr/local/nginx/</span><br><span class=\"line\">总用量 24</span><br><span class=\"line\">drwxr-xr-x  6 root root 4096 10月 15 16:11 .</span><br><span class=\"line\">drwxr-xr-x 11 root root 4096 10月 15 16:11 ..</span><br><span class=\"line\">drwxr-xr-x  2 root root 4096 10月 15 16:11 conf</span><br><span class=\"line\">drwxr-xr-x  2 root root 4096 10月 15 16:11 html</span><br><span class=\"line\">drwxr-xr-x  2 root root 4096 10月 15 16:11 logs</span><br><span class=\"line\">drwxr-xr-x  2 root root 4096 10月 15 16:11 sbin</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"增加rtmp协议配置\"><a href=\"#增加rtmp协议配置\" class=\"headerlink\" title=\"增加rtmp协议配置\"></a>增加rtmp协议配置</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wujianjun@wujianjun-work ~/nginx-1.13.6 $ sudo vi /usr/local/nginx/conf/nginx.conf</span><br></pre></td></tr></table></figure>\n<p>在nginx.conf文件末尾增加以下rtmp协议的配置</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rtmp &#123;</span><br><span class=\"line\">    server &#123;</span><br><span class=\"line\">        listen 1935;</span><br><span class=\"line\">        chunk_size 4096;</span><br><span class=\"line\"></span><br><span class=\"line\">        application live &#123;</span><br><span class=\"line\">            live on;</span><br><span class=\"line\">            record off;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"启动-amp-测试\"><a href=\"#启动-amp-测试\" class=\"headerlink\" title=\"启动&amp;测试\"></a>启动&amp;测试</h2><ul>\n<li>启动nginx<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wujianjun@wujianjun-work ~/nginx-1.13.6 $ sudo /usr/local/nginx/sbin/nginx</span><br></pre></td></tr></table></figure></li>\n<li>启动OBS<br>打开刚安装的OBS软件，在来源处配置图像的推送来源（我这里选择窗口捕获），点击右下角”设置”，进行如下图配置流推送地址<br><img src=\"/images/obs-1.png\"></li>\n</ul>\n<p>配置完成后，点击”开始推流”</p>\n<ul>\n<li>启动支持网络流播放的视频播放器(演示使用vlc播放器)<br>配置网络流播放的地址，如下图：<br><img src=\"/images/vlc-1.png\"></li>\n</ul>\n<p> 当点击”播放”后，稍等几秒，即可看到播放器显示了obs捕获的图像了。<br> <img src=\"/images/vlc-2.png\"></p>\n<p>由于视频流需要通过网络进行传输，所以直播图像会有几秒的延迟。</p>\n<h2 id=\"http访问直播视频\"><a href=\"#http访问直播视频\" class=\"headerlink\" title=\"http访问直播视频\"></a>http访问直播视频</h2><p>1、更改nginx.conf中配置，增加hls配置(hls是在流媒体服务器中用来存放流媒体的文件夹),再次hls所在目录设置为http协议访问目录即可，更改后的配置如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rtmp &#123;</span><br><span class=\"line\">    server &#123;</span><br><span class=\"line\">        listen 1935;</span><br><span class=\"line\">        chunk_size 4096;</span><br><span class=\"line\"></span><br><span class=\"line\">        application live &#123;</span><br><span class=\"line\">            live on;</span><br><span class=\"line\">            hls on;</span><br><span class=\"line\">            hls_path /usr/share/nginx/html/hls;</span><br><span class=\"line\">            hls_fragment 5s;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">http &#123;</span><br><span class=\"line\">  server &#123;</span><br><span class=\"line\">    listen 80;</span><br><span class=\"line\">    .....</span><br><span class=\"line\">    location / &#123;</span><br><span class=\"line\">           #root   html;</span><br><span class=\"line\">           root /usr/share/nginx/html;</span><br><span class=\"line\">           index  index.html index.htm;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    .....</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>注意：</strong> hls所在目录nginx的用户必须有写入权限。</p>\n<p>2、obs软件配置录制流名称<br> 在配置obs推送流URL的下方有一个设置”流名称”的地方，这里可以随意填写一个名称（我这里示例填入”test”）</p>\n<p>3、重启一下nginx与obs软件，我们即可在手机浏览器中输入 <a href=\"http://ip/hls/test.m3u8\">http://ip/hls/test.m3u8</a> 即可通过手机播放直播视频。（直播延迟有点大，后续出文章优化）<br><img src=\"/images/obs-2.png\"></p>\n<hr>\n<p><em>观点仅代表自己，期待你的留言。</em></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"实验环境\"><a href=\"#实验环境\" class=\"headerlink\" title=\"实验环境\"></a>实验环境</h2><ul>\n<li>系统环境<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wujianjun@wujianjun-work ~ $ uname -a</span><br><span class=\"line\">Linux wujianjun-work 4.10.0-37-generic #41~16.04.1-Ubuntu SMP Fri Oct 6 22:42:59 UTC 2017 x86_64 x86_64 x86_64 GNU/Linux</span><br></pre></td></tr></table></figure></li>\n<li>软件环境<br>OBS(Open Broadcaster Software) v20.0.1 (Linux)</li>\n</ul>\n<p> nginx version: nginx/1.13.6<br> built by gcc 5.4.0 20160609 (Ubuntu 5.4.0-6ubuntu1~16.04.5)<br> built with OpenSSL 1.0.2g  1 Mar 2016<br> TLS SNI support enabled<br> configure arguments: –with-pcre=pcre-8.38 –add-module=nginx-rtmp-module-1.1.11</p>\n<h2 id=\"Nginx-obs安装及配置\"><a href=\"#Nginx-obs安装及配置\" class=\"headerlink\" title=\"Nginx+obs安装及配置\"></a>Nginx+obs安装及配置</h2><h3 id=\"安装obs\"><a href=\"#安装obs\" class=\"headerlink\" title=\"安装obs\"></a>安装obs</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wujianjun@wujianjun-work ~ $ sudo add-apt-repository ppa:kirillshkrogalev/ffmpeg-next</span><br><span class=\"line\">wujianjun@wujianjun-work ~ $ sudo apt-get update &amp;&amp; sudo apt-get install ffmpeg</span><br><span class=\"line\">wujianjun@wujianjun-work ~ $ sudo apt-get install obs-studio</span><br><span class=\"line\">wujianjun@wujianjun-work ~ $ sudo add-apt-repository ppa:obsproject/obs-studio</span><br><span class=\"line\">wujianjun@wujianjun-work ~ $ sudo apt-get update &amp;&amp; sudo apt-get install obs-studio</span><br></pre></td></tr></table></figure>\n<h3 id=\"nginx加装rtmp模块\"><a href=\"#nginx加装rtmp模块\" class=\"headerlink\" title=\"nginx加装rtmp模块\"></a>nginx加装rtmp模块</h3><p>nginx-rtmp-module (<a href=\"https://github.com/arut/nginx-rtmp-module\">https://github.com/arut/nginx-rtmp-module</a>)</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wujianjun@wujianjun-work ~ $ sudo apt-get install build-essential</span><br><span class=\"line\">wujianjun@wujianjun-work ~ $ wget wget http://nginx.org/download/nginx-1.13.6.tar.gz</span><br><span class=\"line\">wujianjun@wujianjun-work ~/nginx-1.13.6 $ wget https://github.com/arut/nginx-rtmp-module/archive/v1.1.11.tar.gz</span><br><span class=\"line\">wujianjun@wujianjun-work ~/nginx-1.13.6 $ tar -xvf v1.1.11.tar.gz</span><br><span class=\"line\">wujianjun@wujianjun-work ~/nginx-1.13.6 $ wget http://jaist.dl.sourceforge.net/project/pcre/pcre/8.38/pcre-8.38.tar.gz</span><br><span class=\"line\">wujianjun@wujianjun-work ~/nginx-1.13.6 $ tar -xvf pcre-8.38.tar.gz</span><br><span class=\"line\">wujianjun@wujianjun-work ~/nginx-1.13.6 $ ls -all</span><br><span class=\"line\">总用量 748</span><br><span class=\"line\">drwxr-xr-x  9 wujianjun wujianjun   4096 10月 15 11:39 .</span><br><span class=\"line\">drwxr-xr-x 63 wujianjun wujianjun   4096 10月 15 11:33 ..</span><br><span class=\"line\">drwxr-xr-x  6 wujianjun wujianjun   4096 10月 15 11:33 auto</span><br><span class=\"line\">-rw-r--r--  1 wujianjun wujianjun 282456 10月 10 23:22 CHANGES</span><br><span class=\"line\">-rw-r--r--  1 wujianjun wujianjun 430416 10月 10 23:22 CHANGES.ru</span><br><span class=\"line\">drwxr-xr-x  2 wujianjun wujianjun   4096 10月 15 11:33 conf</span><br><span class=\"line\">-rwxr-xr-x  1 wujianjun wujianjun   2502 10月 10 23:22 configure</span><br><span class=\"line\">drwxr-xr-x  4 wujianjun wujianjun   4096 10月 15 11:33 contrib</span><br><span class=\"line\">drwxr-xr-x  2 wujianjun wujianjun   4096 10月 15 11:33 html</span><br><span class=\"line\">-rw-r--r--  1 wujianjun wujianjun   1397 10月 10 23:22 LICENSE</span><br><span class=\"line\">drwxr-xr-x  2 wujianjun wujianjun   4096 10月 15 11:33 man</span><br><span class=\"line\">drwxrwxr-x  6 wujianjun wujianjun   4096 2月  13  2017 nginx-rtmp-module-1.1.11</span><br><span class=\"line\">drwxr-xr-x  7 wujianjun wujianjun   4096 11月 23  2015 pcre-8.38</span><br><span class=\"line\">-rw-r--r--  1 wujianjun wujianjun     49 10月 10 23:22 README</span><br><span class=\"line\">drwxr-xr-x  9 wujianjun wujianjun   4096 10月 15 11:33 src</span><br><span class=\"line\">wujianjun@wujianjun-work ~/nginx-1.13.6 $ ./configure --with-pcre=pcre-8.38 --add-module=nginx-rtmp-module-1.1.11</span><br><span class=\"line\">wujianjun@wujianjun-work ~/nginx-1.13.6 $ make &amp;&amp; sudo make install</span><br><span class=\"line\">wujianjun@wujianjun-work ~/nginx-1.13.6 $ ls -all /usr/local/nginx/</span><br><span class=\"line\">总用量 24</span><br><span class=\"line\">drwxr-xr-x  6 root root 4096 10月 15 16:11 .</span><br><span class=\"line\">drwxr-xr-x 11 root root 4096 10月 15 16:11 ..</span><br><span class=\"line\">drwxr-xr-x  2 root root 4096 10月 15 16:11 conf</span><br><span class=\"line\">drwxr-xr-x  2 root root 4096 10月 15 16:11 html</span><br><span class=\"line\">drwxr-xr-x  2 root root 4096 10月 15 16:11 logs</span><br><span class=\"line\">drwxr-xr-x  2 root root 4096 10月 15 16:11 sbin</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"增加rtmp协议配置\"><a href=\"#增加rtmp协议配置\" class=\"headerlink\" title=\"增加rtmp协议配置\"></a>增加rtmp协议配置</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wujianjun@wujianjun-work ~/nginx-1.13.6 $ sudo vi /usr/local/nginx/conf/nginx.conf</span><br></pre></td></tr></table></figure>\n<p>在nginx.conf文件末尾增加以下rtmp协议的配置</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rtmp &#123;</span><br><span class=\"line\">    server &#123;</span><br><span class=\"line\">        listen 1935;</span><br><span class=\"line\">        chunk_size 4096;</span><br><span class=\"line\"></span><br><span class=\"line\">        application live &#123;</span><br><span class=\"line\">            live on;</span><br><span class=\"line\">            record off;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"启动-amp-测试\"><a href=\"#启动-amp-测试\" class=\"headerlink\" title=\"启动&amp;测试\"></a>启动&amp;测试</h2><ul>\n<li>启动nginx<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wujianjun@wujianjun-work ~/nginx-1.13.6 $ sudo /usr/local/nginx/sbin/nginx</span><br></pre></td></tr></table></figure></li>\n<li>启动OBS<br>打开刚安装的OBS软件，在来源处配置图像的推送来源（我这里选择窗口捕获），点击右下角”设置”，进行如下图配置流推送地址<br><img src=\"/images/obs-1.png\"></li>\n</ul>\n<p>配置完成后，点击”开始推流”</p>\n<ul>\n<li>启动支持网络流播放的视频播放器(演示使用vlc播放器)<br>配置网络流播放的地址，如下图：<br><img src=\"/images/vlc-1.png\"></li>\n</ul>\n<p> 当点击”播放”后，稍等几秒，即可看到播放器显示了obs捕获的图像了。<br> <img src=\"/images/vlc-2.png\"></p>\n<p>由于视频流需要通过网络进行传输，所以直播图像会有几秒的延迟。</p>\n<h2 id=\"http访问直播视频\"><a href=\"#http访问直播视频\" class=\"headerlink\" title=\"http访问直播视频\"></a>http访问直播视频</h2><p>1、更改nginx.conf中配置，增加hls配置(hls是在流媒体服务器中用来存放流媒体的文件夹),再次hls所在目录设置为http协议访问目录即可，更改后的配置如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rtmp &#123;</span><br><span class=\"line\">    server &#123;</span><br><span class=\"line\">        listen 1935;</span><br><span class=\"line\">        chunk_size 4096;</span><br><span class=\"line\"></span><br><span class=\"line\">        application live &#123;</span><br><span class=\"line\">            live on;</span><br><span class=\"line\">            hls on;</span><br><span class=\"line\">            hls_path /usr/share/nginx/html/hls;</span><br><span class=\"line\">            hls_fragment 5s;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">http &#123;</span><br><span class=\"line\">  server &#123;</span><br><span class=\"line\">    listen 80;</span><br><span class=\"line\">    .....</span><br><span class=\"line\">    location / &#123;</span><br><span class=\"line\">           #root   html;</span><br><span class=\"line\">           root /usr/share/nginx/html;</span><br><span class=\"line\">           index  index.html index.htm;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    .....</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>注意：</strong> hls所在目录nginx的用户必须有写入权限。</p>\n<p>2、obs软件配置录制流名称<br> 在配置obs推送流URL的下方有一个设置”流名称”的地方，这里可以随意填写一个名称（我这里示例填入”test”）</p>\n<p>3、重启一下nginx与obs软件，我们即可在手机浏览器中输入 <a href=\"http://ip/hls/test.m3u8\">http://ip/hls/test.m3u8</a> 即可通过手机播放直播视频。（直播延迟有点大，后续出文章优化）<br><img src=\"/images/obs-2.png\"></p>\n<hr>\n<p><em>观点仅代表自己，期待你的留言。</em></p>\n"},{"title":"Nginx不停止服务下升级与Nginx服务监控","date":"2016-03-16T03:29:07.000Z","_content":"\n### 一、文章目的\n本文以添加新模块\"ngx_http_stub_status_module\"为例介绍Nginx如果在不停止服务的情况下进行升级。\n\n### 二、Nginx升级\n先查看一下目前现在模块：\n```\n[root@localhost sbin]# ./nginx -V\nnginx version: nginx/1.8.1\nbuilt by gcc 4.8.5 20150623 (Red Hat 4.8.5-4) (GCC) \nbuilt with OpenSSL 1.0.1e-fips 11 Feb 2013\nTLS SNI support enabled\nconfigure arguments: --with-pcre=../pcre-8.38 --with-zlib=../zlib-1.2.8 --with-http_gzip_static_module --with-http_ssl_module --add-module=../nginx_tcp_proxy_module/ --add-module=../nginx_upstream_check_module/ --add-module=../nginx-module-vts/\n```\n进入到nginx源码目录（或者直接从网络上下载。参见博文[ Nginx在CentOS7上源码编译安装 ]）,编译时增加所需添加的模块：\n```\n[root@localhost nginx-1.8.1]# cd ~/nginx-1.8.1\n[root@localhost nginx-1.8.1]# ./configure --with-pcre=../pcre-8.38 --with-zlib=../zlib-1.2.8 --with-http_gzip_static_module --with-http_stub_status_module --with-http_ssl_module --add-module=../nginx_tcp_proxy_module/ \\--add-module=../nginx_upstream_check_module/ \\--add-module=../nginx-module-vts/\n[root@localhost nginx-1.8.1]# make\n```\n将编译出的objs目录下及nginx运行文件直接copy到原nginx目录（注意备份）：\n```\n[root@localhost nginx-1.8.1]# mv /usr/local/nginx/sbin/nginx /usr/local/nginx/sbin/nginx.old\n[root@localhost nginx-1.8.1]# cp objs/nginx /usr/local/nginx/sbin/\n[root@localhost nginx-1.8.1]# make upgrade\n/usr/local/nginx/sbin/nginx -t\nnginx: the configuration file /usr/local/nginx/conf/nginx.conf syntax is ok\nnginx: configuration file /usr/local/nginx/conf/nginx.conf test is successful\nkill -USR2 `cat /usr/local/nginx/logs/nginx.pid`\nsleep 1\ntest -f /usr/local/nginx/logs/nginx.pid.oldbin\nkill -QUIT `cat /usr/local/nginx/logs/nginx.pid.oldbin`\n[root@localhost sbin]# ./nginx -V\nnginx version: nginx/1.8.1\nbuilt by gcc 4.8.5 20150623 (Red Hat 4.8.5-4) (GCC) \nbuilt with OpenSSL 1.0.1e-fips 11 Feb 2013\nTLS SNI support enabled\nconfigure arguments: --with-pcre=../pcre-8.38 --with-zlib=../zlib-1.2.8 --with-http_gzip_static_module --with-http_stub_status_module --with-http_ssl_module --add-module=../nginx_tcp_proxy_module/ --add-module=../nginx_upstream_check_module/ --add-module=../nginx-module-vts/\n```\n从以上的输出信息来看，nginx已经成功添加了http_stub_status_module模块。接下来，我们进行验证。\n### 验证ngx_http_stub_status_module模块是否生效\n在conf/nginx.conf的server节点下添加\n```\nlocation /status {\n    stub_status;\n}\n```\n重新load一下nginx配置\n```\n[root@localhost sbin]# ./nginx -t;./nginx -s reload\nnginx: the configuration file /usr/local/nginx/conf/nginx.conf syntax is ok\nnginx: configuration file /usr/local/nginx/conf/nginx.conf test is successful\n```\n\n然后通过浏览器访问http://10.28.10.218/status  就可以看到nginx的运行状态已经通过界面的方式显示出来了。\n\n由于http_stub_status_module模块监控的状态项非常有限，建议使用nginx-module-vts模块对nginx进行更全面的运行状态监控。\n![Nginx VTS](/images/vts.png)\n\nnginx.conf\n```\nhttp {\n\tvhost_traffic_status_zone;\n\tserver {\n\t\tlocation /vts {\n           vhost_traffic_status_display;\n           vhost_traffic_status_display_format html;\n        }\n\t}\n}\n```\n### 三、提高nginx监控页面的安全性\n由于nginx的运行状态为非常重要的数据，所以只允许有特定权限的人员才能有权访问，所以我们可以通过http_auth_basic_module模块来进行身份的验证。更为关键的是http_auth_basic_module模块默认已安装。\n\n通过“yum provides \\*bin/htpasswd”查看哪个库中有htpasswd命令，安装账户生成命令htpasswd，并添加一个用户admin\n```\n[root@localhost nginx-1.8.1]# yum provides \\*bin/htpasswd\n已加载插件：fastestmirror\nLoading mirror speeds from cached hostfile\n * base: mirrors.sina.cn\n * epel: ftp.cuhk.edu.hk\n * extras: mirrors.sina.cn\n * updates: mirrors.sina.cn\nbase/7/x86_64/filelists_db                                                                                                                                    | 6.2 MB  00:00:01     \nhttpd-tools-2.4.6-40.el7.centos.x86_64 : Tools for use with the Apache HTTP Server\n源    ：base\n匹配来源：\n文件名    ：/usr/bin/htpasswd\n\n\n[root@localhost nginx-1.8.1]# yum install httpd-tools\n[root@localhost nginx-1.8.1]# whereis htpasswd //查看是否安装成功\nhtpasswd: /usr/bin/htpasswd /usr/share/man/man1/htpasswd.1.gz\n[root@localhost nginx]# htpasswd -c ./nginx.auth admin //在nginx目录下会生成一个nginx.auth文件来存储账户信息,第二次添加用户就不需要加-c的参数了\nNew password: \nRe-type new password: \nAdding password for user admin\n```\n在conf/nginx.conf的location status节点内添加以下身份验证配置\n```\nhttp {\n\tvhost_traffic_status_zone;\n\tserver {\n\t\tlocation /vts {\n           auth_basic \"Restricted\";\n           auth_basic_user_file ../nginx.auth;\n           vhost_traffic_status_display;\n           vhost_traffic_status_display_format html;\n        }\n\t}\n}\n```\n重新热更新一下配置，再次通过浏览器访问时就会弹框提示你输入用户名和密码了。\n```\n[root@localhost sbin]# ./nginx -t;./nginx -s reload\nnginx: the configuration file /usr/local/nginx/conf/nginx.conf syntax is ok\nnginx: configuration file /usr/local/nginx/conf/nginx.conf test is successful\n```\n![Nginx Auth](/images/nginx_auth.png)\n\n\n-----\n\n*观点仅代表自己，期待你的留言。*\n","source":"_posts/nginx-upgrade.md","raw":"---\ntitle: Nginx不停止服务下升级与Nginx服务监控\ntags:\n  - 原创\n  - Nginx\ndate: 2016-03-16 11:29:07\n---\n\n### 一、文章目的\n本文以添加新模块\"ngx_http_stub_status_module\"为例介绍Nginx如果在不停止服务的情况下进行升级。\n\n### 二、Nginx升级\n先查看一下目前现在模块：\n```\n[root@localhost sbin]# ./nginx -V\nnginx version: nginx/1.8.1\nbuilt by gcc 4.8.5 20150623 (Red Hat 4.8.5-4) (GCC) \nbuilt with OpenSSL 1.0.1e-fips 11 Feb 2013\nTLS SNI support enabled\nconfigure arguments: --with-pcre=../pcre-8.38 --with-zlib=../zlib-1.2.8 --with-http_gzip_static_module --with-http_ssl_module --add-module=../nginx_tcp_proxy_module/ --add-module=../nginx_upstream_check_module/ --add-module=../nginx-module-vts/\n```\n进入到nginx源码目录（或者直接从网络上下载。参见博文[ Nginx在CentOS7上源码编译安装 ]）,编译时增加所需添加的模块：\n```\n[root@localhost nginx-1.8.1]# cd ~/nginx-1.8.1\n[root@localhost nginx-1.8.1]# ./configure --with-pcre=../pcre-8.38 --with-zlib=../zlib-1.2.8 --with-http_gzip_static_module --with-http_stub_status_module --with-http_ssl_module --add-module=../nginx_tcp_proxy_module/ \\--add-module=../nginx_upstream_check_module/ \\--add-module=../nginx-module-vts/\n[root@localhost nginx-1.8.1]# make\n```\n将编译出的objs目录下及nginx运行文件直接copy到原nginx目录（注意备份）：\n```\n[root@localhost nginx-1.8.1]# mv /usr/local/nginx/sbin/nginx /usr/local/nginx/sbin/nginx.old\n[root@localhost nginx-1.8.1]# cp objs/nginx /usr/local/nginx/sbin/\n[root@localhost nginx-1.8.1]# make upgrade\n/usr/local/nginx/sbin/nginx -t\nnginx: the configuration file /usr/local/nginx/conf/nginx.conf syntax is ok\nnginx: configuration file /usr/local/nginx/conf/nginx.conf test is successful\nkill -USR2 `cat /usr/local/nginx/logs/nginx.pid`\nsleep 1\ntest -f /usr/local/nginx/logs/nginx.pid.oldbin\nkill -QUIT `cat /usr/local/nginx/logs/nginx.pid.oldbin`\n[root@localhost sbin]# ./nginx -V\nnginx version: nginx/1.8.1\nbuilt by gcc 4.8.5 20150623 (Red Hat 4.8.5-4) (GCC) \nbuilt with OpenSSL 1.0.1e-fips 11 Feb 2013\nTLS SNI support enabled\nconfigure arguments: --with-pcre=../pcre-8.38 --with-zlib=../zlib-1.2.8 --with-http_gzip_static_module --with-http_stub_status_module --with-http_ssl_module --add-module=../nginx_tcp_proxy_module/ --add-module=../nginx_upstream_check_module/ --add-module=../nginx-module-vts/\n```\n从以上的输出信息来看，nginx已经成功添加了http_stub_status_module模块。接下来，我们进行验证。\n### 验证ngx_http_stub_status_module模块是否生效\n在conf/nginx.conf的server节点下添加\n```\nlocation /status {\n    stub_status;\n}\n```\n重新load一下nginx配置\n```\n[root@localhost sbin]# ./nginx -t;./nginx -s reload\nnginx: the configuration file /usr/local/nginx/conf/nginx.conf syntax is ok\nnginx: configuration file /usr/local/nginx/conf/nginx.conf test is successful\n```\n\n然后通过浏览器访问http://10.28.10.218/status  就可以看到nginx的运行状态已经通过界面的方式显示出来了。\n\n由于http_stub_status_module模块监控的状态项非常有限，建议使用nginx-module-vts模块对nginx进行更全面的运行状态监控。\n![Nginx VTS](/images/vts.png)\n\nnginx.conf\n```\nhttp {\n\tvhost_traffic_status_zone;\n\tserver {\n\t\tlocation /vts {\n           vhost_traffic_status_display;\n           vhost_traffic_status_display_format html;\n        }\n\t}\n}\n```\n### 三、提高nginx监控页面的安全性\n由于nginx的运行状态为非常重要的数据，所以只允许有特定权限的人员才能有权访问，所以我们可以通过http_auth_basic_module模块来进行身份的验证。更为关键的是http_auth_basic_module模块默认已安装。\n\n通过“yum provides \\*bin/htpasswd”查看哪个库中有htpasswd命令，安装账户生成命令htpasswd，并添加一个用户admin\n```\n[root@localhost nginx-1.8.1]# yum provides \\*bin/htpasswd\n已加载插件：fastestmirror\nLoading mirror speeds from cached hostfile\n * base: mirrors.sina.cn\n * epel: ftp.cuhk.edu.hk\n * extras: mirrors.sina.cn\n * updates: mirrors.sina.cn\nbase/7/x86_64/filelists_db                                                                                                                                    | 6.2 MB  00:00:01     \nhttpd-tools-2.4.6-40.el7.centos.x86_64 : Tools for use with the Apache HTTP Server\n源    ：base\n匹配来源：\n文件名    ：/usr/bin/htpasswd\n\n\n[root@localhost nginx-1.8.1]# yum install httpd-tools\n[root@localhost nginx-1.8.1]# whereis htpasswd //查看是否安装成功\nhtpasswd: /usr/bin/htpasswd /usr/share/man/man1/htpasswd.1.gz\n[root@localhost nginx]# htpasswd -c ./nginx.auth admin //在nginx目录下会生成一个nginx.auth文件来存储账户信息,第二次添加用户就不需要加-c的参数了\nNew password: \nRe-type new password: \nAdding password for user admin\n```\n在conf/nginx.conf的location status节点内添加以下身份验证配置\n```\nhttp {\n\tvhost_traffic_status_zone;\n\tserver {\n\t\tlocation /vts {\n           auth_basic \"Restricted\";\n           auth_basic_user_file ../nginx.auth;\n           vhost_traffic_status_display;\n           vhost_traffic_status_display_format html;\n        }\n\t}\n}\n```\n重新热更新一下配置，再次通过浏览器访问时就会弹框提示你输入用户名和密码了。\n```\n[root@localhost sbin]# ./nginx -t;./nginx -s reload\nnginx: the configuration file /usr/local/nginx/conf/nginx.conf syntax is ok\nnginx: configuration file /usr/local/nginx/conf/nginx.conf test is successful\n```\n![Nginx Auth](/images/nginx_auth.png)\n\n\n-----\n\n*观点仅代表自己，期待你的留言。*\n","slug":"nginx-upgrade","published":1,"updated":"2021-08-31T14:23:11.548Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cku52dynz003mbbinebw2akjc","content":"<h3 id=\"一、文章目的\"><a href=\"#一、文章目的\" class=\"headerlink\" title=\"一、文章目的\"></a>一、文章目的</h3><p>本文以添加新模块”ngx_http_stub_status_module”为例介绍Nginx如果在不停止服务的情况下进行升级。</p>\n<h3 id=\"二、Nginx升级\"><a href=\"#二、Nginx升级\" class=\"headerlink\" title=\"二、Nginx升级\"></a>二、Nginx升级</h3><p>先查看一下目前现在模块：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@localhost sbin]# ./nginx -V</span><br><span class=\"line\">nginx version: nginx/1.8.1</span><br><span class=\"line\">built by gcc 4.8.5 20150623 (Red Hat 4.8.5-4) (GCC) </span><br><span class=\"line\">built with OpenSSL 1.0.1e-fips 11 Feb 2013</span><br><span class=\"line\">TLS SNI support enabled</span><br><span class=\"line\">configure arguments: --with-pcre=../pcre-8.38 --with-zlib=../zlib-1.2.8 --with-http_gzip_static_module --with-http_ssl_module --add-module=../nginx_tcp_proxy_module/ --add-module=../nginx_upstream_check_module/ --add-module=../nginx-module-vts/</span><br></pre></td></tr></table></figure>\n<p>进入到nginx源码目录（或者直接从网络上下载。参见博文[ Nginx在CentOS7上源码编译安装 ]）,编译时增加所需添加的模块：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@localhost nginx-1.8.1]# cd ~/nginx-1.8.1</span><br><span class=\"line\">[root@localhost nginx-1.8.1]# ./configure --with-pcre=../pcre-8.38 --with-zlib=../zlib-1.2.8 --with-http_gzip_static_module --with-http_stub_status_module --with-http_ssl_module --add-module=../nginx_tcp_proxy_module/ \\--add-module=../nginx_upstream_check_module/ \\--add-module=../nginx-module-vts/</span><br><span class=\"line\">[root@localhost nginx-1.8.1]# make</span><br></pre></td></tr></table></figure>\n<p>将编译出的objs目录下及nginx运行文件直接copy到原nginx目录（注意备份）：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@localhost nginx-1.8.1]# mv /usr/local/nginx/sbin/nginx /usr/local/nginx/sbin/nginx.old</span><br><span class=\"line\">[root@localhost nginx-1.8.1]# cp objs/nginx /usr/local/nginx/sbin/</span><br><span class=\"line\">[root@localhost nginx-1.8.1]# make upgrade</span><br><span class=\"line\">/usr/local/nginx/sbin/nginx -t</span><br><span class=\"line\">nginx: the configuration file /usr/local/nginx/conf/nginx.conf syntax is ok</span><br><span class=\"line\">nginx: configuration file /usr/local/nginx/conf/nginx.conf test is successful</span><br><span class=\"line\">kill -USR2 `cat /usr/local/nginx/logs/nginx.pid`</span><br><span class=\"line\">sleep 1</span><br><span class=\"line\">test -f /usr/local/nginx/logs/nginx.pid.oldbin</span><br><span class=\"line\">kill -QUIT `cat /usr/local/nginx/logs/nginx.pid.oldbin`</span><br><span class=\"line\">[root@localhost sbin]# ./nginx -V</span><br><span class=\"line\">nginx version: nginx/1.8.1</span><br><span class=\"line\">built by gcc 4.8.5 20150623 (Red Hat 4.8.5-4) (GCC) </span><br><span class=\"line\">built with OpenSSL 1.0.1e-fips 11 Feb 2013</span><br><span class=\"line\">TLS SNI support enabled</span><br><span class=\"line\">configure arguments: --with-pcre=../pcre-8.38 --with-zlib=../zlib-1.2.8 --with-http_gzip_static_module --with-http_stub_status_module --with-http_ssl_module --add-module=../nginx_tcp_proxy_module/ --add-module=../nginx_upstream_check_module/ --add-module=../nginx-module-vts/</span><br></pre></td></tr></table></figure>\n<p>从以上的输出信息来看，nginx已经成功添加了http_stub_status_module模块。接下来，我们进行验证。</p>\n<h3 id=\"验证ngx-http-stub-status-module模块是否生效\"><a href=\"#验证ngx-http-stub-status-module模块是否生效\" class=\"headerlink\" title=\"验证ngx_http_stub_status_module模块是否生效\"></a>验证ngx_http_stub_status_module模块是否生效</h3><p>在conf/nginx.conf的server节点下添加</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">location /status &#123;</span><br><span class=\"line\">    stub_status;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>重新load一下nginx配置</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@localhost sbin]# ./nginx -t;./nginx -s reload</span><br><span class=\"line\">nginx: the configuration file /usr/local/nginx/conf/nginx.conf syntax is ok</span><br><span class=\"line\">nginx: configuration file /usr/local/nginx/conf/nginx.conf test is successful</span><br></pre></td></tr></table></figure>\n\n<p>然后通过浏览器访问<a href=\"http://10.28.10.218/status\">http://10.28.10.218/status</a>  就可以看到nginx的运行状态已经通过界面的方式显示出来了。</p>\n<p>由于http_stub_status_module模块监控的状态项非常有限，建议使用nginx-module-vts模块对nginx进行更全面的运行状态监控。<br><img src=\"/images/vts.png\" alt=\"Nginx VTS\"></p>\n<p>nginx.conf</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">http &#123;</span><br><span class=\"line\">\tvhost_traffic_status_zone;</span><br><span class=\"line\">\tserver &#123;</span><br><span class=\"line\">\t\tlocation /vts &#123;</span><br><span class=\"line\">           vhost_traffic_status_display;</span><br><span class=\"line\">           vhost_traffic_status_display_format html;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"三、提高nginx监控页面的安全性\"><a href=\"#三、提高nginx监控页面的安全性\" class=\"headerlink\" title=\"三、提高nginx监控页面的安全性\"></a>三、提高nginx监控页面的安全性</h3><p>由于nginx的运行状态为非常重要的数据，所以只允许有特定权限的人员才能有权访问，所以我们可以通过http_auth_basic_module模块来进行身份的验证。更为关键的是http_auth_basic_module模块默认已安装。</p>\n<p>通过“yum provides *bin/htpasswd”查看哪个库中有htpasswd命令，安装账户生成命令htpasswd，并添加一个用户admin</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@localhost nginx-1.8.1]# yum provides \\*bin/htpasswd</span><br><span class=\"line\">已加载插件：fastestmirror</span><br><span class=\"line\">Loading mirror speeds from cached hostfile</span><br><span class=\"line\"> * base: mirrors.sina.cn</span><br><span class=\"line\"> * epel: ftp.cuhk.edu.hk</span><br><span class=\"line\"> * extras: mirrors.sina.cn</span><br><span class=\"line\"> * updates: mirrors.sina.cn</span><br><span class=\"line\">base/7/x86_64/filelists_db                                                                                                                                    | 6.2 MB  00:00:01     </span><br><span class=\"line\">httpd-tools-2.4.6-40.el7.centos.x86_64 : Tools for use with the Apache HTTP Server</span><br><span class=\"line\">源    ：base</span><br><span class=\"line\">匹配来源：</span><br><span class=\"line\">文件名    ：/usr/bin/htpasswd</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">[root@localhost nginx-1.8.1]# yum install httpd-tools</span><br><span class=\"line\">[root@localhost nginx-1.8.1]# whereis htpasswd //查看是否安装成功</span><br><span class=\"line\">htpasswd: /usr/bin/htpasswd /usr/share/man/man1/htpasswd.1.gz</span><br><span class=\"line\">[root@localhost nginx]# htpasswd -c ./nginx.auth admin //在nginx目录下会生成一个nginx.auth文件来存储账户信息,第二次添加用户就不需要加-c的参数了</span><br><span class=\"line\">New password: </span><br><span class=\"line\">Re-type new password: </span><br><span class=\"line\">Adding password for user admin</span><br></pre></td></tr></table></figure>\n<p>在conf/nginx.conf的location status节点内添加以下身份验证配置</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">http &#123;</span><br><span class=\"line\">\tvhost_traffic_status_zone;</span><br><span class=\"line\">\tserver &#123;</span><br><span class=\"line\">\t\tlocation /vts &#123;</span><br><span class=\"line\">           auth_basic &quot;Restricted&quot;;</span><br><span class=\"line\">           auth_basic_user_file ../nginx.auth;</span><br><span class=\"line\">           vhost_traffic_status_display;</span><br><span class=\"line\">           vhost_traffic_status_display_format html;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>重新热更新一下配置，再次通过浏览器访问时就会弹框提示你输入用户名和密码了。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@localhost sbin]# ./nginx -t;./nginx -s reload</span><br><span class=\"line\">nginx: the configuration file /usr/local/nginx/conf/nginx.conf syntax is ok</span><br><span class=\"line\">nginx: configuration file /usr/local/nginx/conf/nginx.conf test is successful</span><br></pre></td></tr></table></figure>\n<p><img src=\"/images/nginx_auth.png\" alt=\"Nginx Auth\"></p>\n<hr>\n<p><em>观点仅代表自己，期待你的留言。</em></p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"一、文章目的\"><a href=\"#一、文章目的\" class=\"headerlink\" title=\"一、文章目的\"></a>一、文章目的</h3><p>本文以添加新模块”ngx_http_stub_status_module”为例介绍Nginx如果在不停止服务的情况下进行升级。</p>\n<h3 id=\"二、Nginx升级\"><a href=\"#二、Nginx升级\" class=\"headerlink\" title=\"二、Nginx升级\"></a>二、Nginx升级</h3><p>先查看一下目前现在模块：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@localhost sbin]# ./nginx -V</span><br><span class=\"line\">nginx version: nginx/1.8.1</span><br><span class=\"line\">built by gcc 4.8.5 20150623 (Red Hat 4.8.5-4) (GCC) </span><br><span class=\"line\">built with OpenSSL 1.0.1e-fips 11 Feb 2013</span><br><span class=\"line\">TLS SNI support enabled</span><br><span class=\"line\">configure arguments: --with-pcre=../pcre-8.38 --with-zlib=../zlib-1.2.8 --with-http_gzip_static_module --with-http_ssl_module --add-module=../nginx_tcp_proxy_module/ --add-module=../nginx_upstream_check_module/ --add-module=../nginx-module-vts/</span><br></pre></td></tr></table></figure>\n<p>进入到nginx源码目录（或者直接从网络上下载。参见博文[ Nginx在CentOS7上源码编译安装 ]）,编译时增加所需添加的模块：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@localhost nginx-1.8.1]# cd ~/nginx-1.8.1</span><br><span class=\"line\">[root@localhost nginx-1.8.1]# ./configure --with-pcre=../pcre-8.38 --with-zlib=../zlib-1.2.8 --with-http_gzip_static_module --with-http_stub_status_module --with-http_ssl_module --add-module=../nginx_tcp_proxy_module/ \\--add-module=../nginx_upstream_check_module/ \\--add-module=../nginx-module-vts/</span><br><span class=\"line\">[root@localhost nginx-1.8.1]# make</span><br></pre></td></tr></table></figure>\n<p>将编译出的objs目录下及nginx运行文件直接copy到原nginx目录（注意备份）：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@localhost nginx-1.8.1]# mv /usr/local/nginx/sbin/nginx /usr/local/nginx/sbin/nginx.old</span><br><span class=\"line\">[root@localhost nginx-1.8.1]# cp objs/nginx /usr/local/nginx/sbin/</span><br><span class=\"line\">[root@localhost nginx-1.8.1]# make upgrade</span><br><span class=\"line\">/usr/local/nginx/sbin/nginx -t</span><br><span class=\"line\">nginx: the configuration file /usr/local/nginx/conf/nginx.conf syntax is ok</span><br><span class=\"line\">nginx: configuration file /usr/local/nginx/conf/nginx.conf test is successful</span><br><span class=\"line\">kill -USR2 `cat /usr/local/nginx/logs/nginx.pid`</span><br><span class=\"line\">sleep 1</span><br><span class=\"line\">test -f /usr/local/nginx/logs/nginx.pid.oldbin</span><br><span class=\"line\">kill -QUIT `cat /usr/local/nginx/logs/nginx.pid.oldbin`</span><br><span class=\"line\">[root@localhost sbin]# ./nginx -V</span><br><span class=\"line\">nginx version: nginx/1.8.1</span><br><span class=\"line\">built by gcc 4.8.5 20150623 (Red Hat 4.8.5-4) (GCC) </span><br><span class=\"line\">built with OpenSSL 1.0.1e-fips 11 Feb 2013</span><br><span class=\"line\">TLS SNI support enabled</span><br><span class=\"line\">configure arguments: --with-pcre=../pcre-8.38 --with-zlib=../zlib-1.2.8 --with-http_gzip_static_module --with-http_stub_status_module --with-http_ssl_module --add-module=../nginx_tcp_proxy_module/ --add-module=../nginx_upstream_check_module/ --add-module=../nginx-module-vts/</span><br></pre></td></tr></table></figure>\n<p>从以上的输出信息来看，nginx已经成功添加了http_stub_status_module模块。接下来，我们进行验证。</p>\n<h3 id=\"验证ngx-http-stub-status-module模块是否生效\"><a href=\"#验证ngx-http-stub-status-module模块是否生效\" class=\"headerlink\" title=\"验证ngx_http_stub_status_module模块是否生效\"></a>验证ngx_http_stub_status_module模块是否生效</h3><p>在conf/nginx.conf的server节点下添加</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">location /status &#123;</span><br><span class=\"line\">    stub_status;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>重新load一下nginx配置</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@localhost sbin]# ./nginx -t;./nginx -s reload</span><br><span class=\"line\">nginx: the configuration file /usr/local/nginx/conf/nginx.conf syntax is ok</span><br><span class=\"line\">nginx: configuration file /usr/local/nginx/conf/nginx.conf test is successful</span><br></pre></td></tr></table></figure>\n\n<p>然后通过浏览器访问<a href=\"http://10.28.10.218/status\">http://10.28.10.218/status</a>  就可以看到nginx的运行状态已经通过界面的方式显示出来了。</p>\n<p>由于http_stub_status_module模块监控的状态项非常有限，建议使用nginx-module-vts模块对nginx进行更全面的运行状态监控。<br><img src=\"/images/vts.png\" alt=\"Nginx VTS\"></p>\n<p>nginx.conf</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">http &#123;</span><br><span class=\"line\">\tvhost_traffic_status_zone;</span><br><span class=\"line\">\tserver &#123;</span><br><span class=\"line\">\t\tlocation /vts &#123;</span><br><span class=\"line\">           vhost_traffic_status_display;</span><br><span class=\"line\">           vhost_traffic_status_display_format html;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"三、提高nginx监控页面的安全性\"><a href=\"#三、提高nginx监控页面的安全性\" class=\"headerlink\" title=\"三、提高nginx监控页面的安全性\"></a>三、提高nginx监控页面的安全性</h3><p>由于nginx的运行状态为非常重要的数据，所以只允许有特定权限的人员才能有权访问，所以我们可以通过http_auth_basic_module模块来进行身份的验证。更为关键的是http_auth_basic_module模块默认已安装。</p>\n<p>通过“yum provides *bin/htpasswd”查看哪个库中有htpasswd命令，安装账户生成命令htpasswd，并添加一个用户admin</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@localhost nginx-1.8.1]# yum provides \\*bin/htpasswd</span><br><span class=\"line\">已加载插件：fastestmirror</span><br><span class=\"line\">Loading mirror speeds from cached hostfile</span><br><span class=\"line\"> * base: mirrors.sina.cn</span><br><span class=\"line\"> * epel: ftp.cuhk.edu.hk</span><br><span class=\"line\"> * extras: mirrors.sina.cn</span><br><span class=\"line\"> * updates: mirrors.sina.cn</span><br><span class=\"line\">base/7/x86_64/filelists_db                                                                                                                                    | 6.2 MB  00:00:01     </span><br><span class=\"line\">httpd-tools-2.4.6-40.el7.centos.x86_64 : Tools for use with the Apache HTTP Server</span><br><span class=\"line\">源    ：base</span><br><span class=\"line\">匹配来源：</span><br><span class=\"line\">文件名    ：/usr/bin/htpasswd</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">[root@localhost nginx-1.8.1]# yum install httpd-tools</span><br><span class=\"line\">[root@localhost nginx-1.8.1]# whereis htpasswd //查看是否安装成功</span><br><span class=\"line\">htpasswd: /usr/bin/htpasswd /usr/share/man/man1/htpasswd.1.gz</span><br><span class=\"line\">[root@localhost nginx]# htpasswd -c ./nginx.auth admin //在nginx目录下会生成一个nginx.auth文件来存储账户信息,第二次添加用户就不需要加-c的参数了</span><br><span class=\"line\">New password: </span><br><span class=\"line\">Re-type new password: </span><br><span class=\"line\">Adding password for user admin</span><br></pre></td></tr></table></figure>\n<p>在conf/nginx.conf的location status节点内添加以下身份验证配置</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">http &#123;</span><br><span class=\"line\">\tvhost_traffic_status_zone;</span><br><span class=\"line\">\tserver &#123;</span><br><span class=\"line\">\t\tlocation /vts &#123;</span><br><span class=\"line\">           auth_basic &quot;Restricted&quot;;</span><br><span class=\"line\">           auth_basic_user_file ../nginx.auth;</span><br><span class=\"line\">           vhost_traffic_status_display;</span><br><span class=\"line\">           vhost_traffic_status_display_format html;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>重新热更新一下配置，再次通过浏览器访问时就会弹框提示你输入用户名和密码了。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@localhost sbin]# ./nginx -t;./nginx -s reload</span><br><span class=\"line\">nginx: the configuration file /usr/local/nginx/conf/nginx.conf syntax is ok</span><br><span class=\"line\">nginx: configuration file /usr/local/nginx/conf/nginx.conf test is successful</span><br></pre></td></tr></table></figure>\n<p><img src=\"/images/nginx_auth.png\" alt=\"Nginx Auth\"></p>\n<hr>\n<p><em>观点仅代表自己，期待你的留言。</em></p>\n"},{"title":"Nginx+tomcat+redis集群之session跟踪（nginx_upstream_jvm_route）","date":"2016-03-18T01:35:55.000Z","_content":"## 实验环境\nCentOS7, Tomcat7(tomcat-1, tomcat-2), Nginx1.8.1, redis3.0.7\n\ntomcat1：Server port=”8105”，Connector port=”8081”，ajp Connector port=”8109”\n\ntomcat2：Server port=”8205”，Connector port=”8082”，ajp Connector port=”8209”\n\n## 集群环境下tomcat的session处理方式\n### 一、upstream ip_hash（不推荐使用）\n nginx中的ip_hash技术能够将某个ip的请求定向到同一台后端，这样一来这个ip下的某个客户端和某个后端就能建立起稳固的session，ip_hash是在upstream配置中定义的： \n```\nupstream backend { \n    server 127.0.0.1:8081 ; \n    server 127.0.0.1:8082 ; \n    ip_hash; \n} \n```\n不推荐使用的原因如下：\n \n * __nginx不是最前端的服务器。__ ip_hash要求nginx一定是最前端的服务器，否则nginx得不到正确ip，就不能根据ip作hash。譬如使用的是squid为最前端，那么nginx取ip时只能得到squid的服务器ip地址，用这个地址来作分流是肯定错乱的。 \n \n * __nginx的后端还有其它方式的负载均衡。__\n   假如nginx后端又有其它负载均衡，将请求又通过另外的方式分流了，那么某个客户端的请求肯定不能定位到同一台session应用服务器上。\n \n * __多个外网出口。__\n    很多公司上网有多个出口，多个ip地址，用户访问互联网时候自动切换ip。而且这种情况不在少数。使用 ip_hash 的话对这种情况的用户无效，无法将某个用户绑定在固定的tomcat上 。\n### 二、nginx_upstream_jvm_route (nginx module， 无法故障转移)\nnginx_upstream_jvm_route 是一个nginx的扩展模块，用来实现基于 Cookie 的 Session Sticky 的功能。\n\n简单来说，它是基于cookie中的JSESSIONID来决定将请求发送给后端的哪个server，nginx_upstream_jvm_route会在用户第一次请求后端server时，将响应的server标识绑定到cookie中的JSESSIONID中，从而当用户发起下一次请求时，nginx会根据JSESSIONID来决定由哪个后端server来处理。\n\n但是当客户端对应的tomcat挂掉之后，客户端的请求将不能通过其它tomcat代替进行处理，也就是说 __nginx_upstream_jvm_route不支持故障转移__。\n### 三、tomcat-redis-session-manager （java lib， 推荐使用）\n通过集群实例tomcat连接到同一个redis，将sessionID存储在redis中完成session共享。由于session共享，所以支持故障转移。\n\n详见我的另一篇博文《Nginx+tomcat+redis集群之session共享》\n## nginx_upstream_jvm_route安装配置\ngithub地址：https://github.com/nulab/nginx-upstream-jvm-route\n\n安装方法如下：\n```\n[root@localhost ~]# git clone https://github.com/nulab/nginx-upstream-jvm-route.git\n[root@localhost ~]# cd nginx-1.8.1 //注意：一定是进入到nginx安装目录打补丁\n[root@localhost nginx-1.8.1]# patch -p0 < ../nginx-upstream-jvm-route/jvm_route.patch \npatching file src/http/ngx_http_upstream.c\nHunk #1 succeeded at 5281 (offset 672 lines).\nHunk #2 succeeded at 5380 (offset 678 lines).\nHunk #3 succeeded at 5397 (offset 656 lines).\nHunk #4 succeeded at 5434 (offset 656 lines).\nHunk #5 succeeded at 5467 (offset 656 lines).\nHunk #6 succeeded at 5527 (offset 671 lines).\npatching file src/http/ngx_http_upstream.h\nHunk #1 succeeded at 96 (offset 4 lines).\nHunk #2 succeeded at 110 (offset 4 lines).\n[root@localhost nginx-1.8.1]# ./configure --with-pcre=../pcre-8.38 --with-zlib=../zlib-1.2.8 --with-http_gzip_static_module --with-http_ssl_module --add-module=../nginx_tcp_proxy_module/ \\--add-module=../nginx_upstream_check_module/ \\--add-module=../nginx-module-vts/ \\--add-module=../nginx-upstream-jvm-route/\n[root@localhost nginx-1.8.1]# make\n[root@localhost nginx-1.8.1]# mv /usr/local/nginx/sbin/nginx /usr/local/nginx/sbin/nginx.old\nmv：是否覆盖\"/usr/local/nginx/sbin/nginx.old\"？ y\n[root@localhost nginx-1.8.1]# cp objs/nginx /usr/local/nginx/sbin/\n[root@localhost nginx-1.8.1]# make upgrade\n/usr/local/nginx/sbin/nginx -t\nnginx: the configuration file /usr/local/nginx/conf/nginx.conf syntax is ok\nnginx: configuration file /usr/local/nginx/conf/nginx.conf test is successful\nkill -USR2 `cat /usr/local/nginx/logs/nginx.pid`\nsleep 1\ntest -f /usr/local/nginx/logs/nginx.pid.oldbin\nkill -QUIT `cat /usr/local/nginx/logs/nginx.pid.oldbin`\n[root@localhost nginx-1.8.1]# /usr/local/nginx/sbin/nginx -V\nnginx version: nginx/1.8.1\nbuilt by gcc 4.8.5 20150623 (Red Hat 4.8.5-4) (GCC) \nbuilt with OpenSSL 1.0.1e-fips 11 Feb 2013\nTLS SNI support enabled\nconfigure arguments: --with-pcre=../pcre-8.38 --with-zlib=../zlib-1.2.8 --with-http_gzip_static_module --with-http_ssl_module --add-module=../nginx_tcp_proxy_module/ --add-module=../nginx_upstream_check_module/ --add-module=../nginx-module-vts/ --add-module=../nginx-upstream-jvm-route/\n```\n配置nginx.conf\n```\nhttp {\n    upstream  tomcats_jvm_route {\n        server   127.0.0.1:8081 srun_id=tomcat01; \n        server   127.0.0.1:8082 srun_id=tomcat02;\n        jvm_route $cookie_JSESSIONID|sessionid reverse;\n    }\n    server {\n        #....原有配置.....\n        location ~ .*\\.(do|jsp|action)?$ {\n            proxy_redirect          off;\n            proxy_set_header        Host            $host;\n            proxy_set_header        X-Real-IP       $remote_addr;\n            proxy_set_header        X-Forwarded-For $proxy_add_x_forwarded_for;\n            root   html;\n            index  index.html index.htm;\n            #proxy_pass http://tomcat;\n            proxy_pass http://tomcats_jvm_route;\n        }\n        #....原有配置.....\n    }\n}\n```\n修改tomcat的server.xml配置：\n```\n<Engine name=\"Catalina\" defaultHost=\"localhost\" jvmRoute=\"tomcat01\">\n<Engine name=\"Catalina\" defaultHost=\"localhost\" jvmRoute=\"tomcat02\">\n```\n验证生效\n```\n[root@localhost ~]# ps -ef |grep tomcat|grep -v grep|awk '{print $2}'\n19914\n20029\n[root@localhost ~]# ps -ef |grep tomcat|grep -v grep|awk '{print $2}'|xargs kill\n[root@localhost ~]# ps -ef |grep tomcat|grep -v grep|awk '{print $2}'\n[root@localhost ~]# cd tomcat-1/\n[root@localhost tomcat-1]# ./bin/startup.sh \nUsing CATALINA_BASE:   /root/tomcat-1\nUsing CATALINA_HOME:   /root/tomcat-1\nUsing CATALINA_TMPDIR: /root/tomcat-1/temp\nUsing JRE_HOME:        /usr/local/jdk1.7.0_60\nUsing CLASSPATH:       /root/tomcat-1/bin/bootstrap.jar:/root/tomcat-1/bin/tomcat-juli.jar\nTomcat started.\n[root@localhost tomcat-1]# cd ../tomcat-2\n-bash: cd: tomcat-2: 没有那个文件或目录\n[root@localhost tomcat-2]# ./bin/startup.sh \nUsing CATALINA_BASE:   /root/tomcat-1\nUsing CATALINA_HOME:   /root/tomcat-1\nUsing CATALINA_TMPDIR: /root/tomcat-1/temp\nUsing JRE_HOME:        /usr/local/jdk1.7.0_60\nUsing CLASSPATH:       /root/tomcat-1/bin/bootstrap.jar:/root/tomcat-1/bin/tomcat-juli.jar\nTomcat started.\n[root@localhost tomcat-2]# /usr/local/nginx/sbin/nginx -t;/usr/local/nginx/sbin/nginx -s reload;\n```\n![](/images/QQ20160318-0.png)\n![](/images/QQ20160318-1.png)\n![](/images/QQ20160318-2.png)\n\n从上图的结果来看：\n\n* 1: sessionID的后面增加了第一个为客户端服务的最终tomcat实例标识。\n* 2: 在不停的刷新页面的时候都是同一个tomcat实例返回的页面。从vts的监控图可以看出，请求都被导流到同一个tomcat实例上。\n* 3: 在停止tomcat1后，再对浏览器进行刷新操作，发现请求被导到tomcat2上，但对应的sessionId也发生了变化，说明服务器端认定这是一个新的客户端进行的请求操作。验证了我之前所说，__这种方式不支持故障转移__。\n\n\n-----\n\n*观点仅代表自己，期待你的留言。*","source":"_posts/nginx-upstream-jvm-route.md","raw":"---\ntitle: Nginx+tomcat+redis集群之session跟踪（nginx_upstream_jvm_route）\ntags:\n  - 原创\n  - Nginx\ndate: 2016-03-18 09:35:55\n---\n## 实验环境\nCentOS7, Tomcat7(tomcat-1, tomcat-2), Nginx1.8.1, redis3.0.7\n\ntomcat1：Server port=”8105”，Connector port=”8081”，ajp Connector port=”8109”\n\ntomcat2：Server port=”8205”，Connector port=”8082”，ajp Connector port=”8209”\n\n## 集群环境下tomcat的session处理方式\n### 一、upstream ip_hash（不推荐使用）\n nginx中的ip_hash技术能够将某个ip的请求定向到同一台后端，这样一来这个ip下的某个客户端和某个后端就能建立起稳固的session，ip_hash是在upstream配置中定义的： \n```\nupstream backend { \n    server 127.0.0.1:8081 ; \n    server 127.0.0.1:8082 ; \n    ip_hash; \n} \n```\n不推荐使用的原因如下：\n \n * __nginx不是最前端的服务器。__ ip_hash要求nginx一定是最前端的服务器，否则nginx得不到正确ip，就不能根据ip作hash。譬如使用的是squid为最前端，那么nginx取ip时只能得到squid的服务器ip地址，用这个地址来作分流是肯定错乱的。 \n \n * __nginx的后端还有其它方式的负载均衡。__\n   假如nginx后端又有其它负载均衡，将请求又通过另外的方式分流了，那么某个客户端的请求肯定不能定位到同一台session应用服务器上。\n \n * __多个外网出口。__\n    很多公司上网有多个出口，多个ip地址，用户访问互联网时候自动切换ip。而且这种情况不在少数。使用 ip_hash 的话对这种情况的用户无效，无法将某个用户绑定在固定的tomcat上 。\n### 二、nginx_upstream_jvm_route (nginx module， 无法故障转移)\nnginx_upstream_jvm_route 是一个nginx的扩展模块，用来实现基于 Cookie 的 Session Sticky 的功能。\n\n简单来说，它是基于cookie中的JSESSIONID来决定将请求发送给后端的哪个server，nginx_upstream_jvm_route会在用户第一次请求后端server时，将响应的server标识绑定到cookie中的JSESSIONID中，从而当用户发起下一次请求时，nginx会根据JSESSIONID来决定由哪个后端server来处理。\n\n但是当客户端对应的tomcat挂掉之后，客户端的请求将不能通过其它tomcat代替进行处理，也就是说 __nginx_upstream_jvm_route不支持故障转移__。\n### 三、tomcat-redis-session-manager （java lib， 推荐使用）\n通过集群实例tomcat连接到同一个redis，将sessionID存储在redis中完成session共享。由于session共享，所以支持故障转移。\n\n详见我的另一篇博文《Nginx+tomcat+redis集群之session共享》\n## nginx_upstream_jvm_route安装配置\ngithub地址：https://github.com/nulab/nginx-upstream-jvm-route\n\n安装方法如下：\n```\n[root@localhost ~]# git clone https://github.com/nulab/nginx-upstream-jvm-route.git\n[root@localhost ~]# cd nginx-1.8.1 //注意：一定是进入到nginx安装目录打补丁\n[root@localhost nginx-1.8.1]# patch -p0 < ../nginx-upstream-jvm-route/jvm_route.patch \npatching file src/http/ngx_http_upstream.c\nHunk #1 succeeded at 5281 (offset 672 lines).\nHunk #2 succeeded at 5380 (offset 678 lines).\nHunk #3 succeeded at 5397 (offset 656 lines).\nHunk #4 succeeded at 5434 (offset 656 lines).\nHunk #5 succeeded at 5467 (offset 656 lines).\nHunk #6 succeeded at 5527 (offset 671 lines).\npatching file src/http/ngx_http_upstream.h\nHunk #1 succeeded at 96 (offset 4 lines).\nHunk #2 succeeded at 110 (offset 4 lines).\n[root@localhost nginx-1.8.1]# ./configure --with-pcre=../pcre-8.38 --with-zlib=../zlib-1.2.8 --with-http_gzip_static_module --with-http_ssl_module --add-module=../nginx_tcp_proxy_module/ \\--add-module=../nginx_upstream_check_module/ \\--add-module=../nginx-module-vts/ \\--add-module=../nginx-upstream-jvm-route/\n[root@localhost nginx-1.8.1]# make\n[root@localhost nginx-1.8.1]# mv /usr/local/nginx/sbin/nginx /usr/local/nginx/sbin/nginx.old\nmv：是否覆盖\"/usr/local/nginx/sbin/nginx.old\"？ y\n[root@localhost nginx-1.8.1]# cp objs/nginx /usr/local/nginx/sbin/\n[root@localhost nginx-1.8.1]# make upgrade\n/usr/local/nginx/sbin/nginx -t\nnginx: the configuration file /usr/local/nginx/conf/nginx.conf syntax is ok\nnginx: configuration file /usr/local/nginx/conf/nginx.conf test is successful\nkill -USR2 `cat /usr/local/nginx/logs/nginx.pid`\nsleep 1\ntest -f /usr/local/nginx/logs/nginx.pid.oldbin\nkill -QUIT `cat /usr/local/nginx/logs/nginx.pid.oldbin`\n[root@localhost nginx-1.8.1]# /usr/local/nginx/sbin/nginx -V\nnginx version: nginx/1.8.1\nbuilt by gcc 4.8.5 20150623 (Red Hat 4.8.5-4) (GCC) \nbuilt with OpenSSL 1.0.1e-fips 11 Feb 2013\nTLS SNI support enabled\nconfigure arguments: --with-pcre=../pcre-8.38 --with-zlib=../zlib-1.2.8 --with-http_gzip_static_module --with-http_ssl_module --add-module=../nginx_tcp_proxy_module/ --add-module=../nginx_upstream_check_module/ --add-module=../nginx-module-vts/ --add-module=../nginx-upstream-jvm-route/\n```\n配置nginx.conf\n```\nhttp {\n    upstream  tomcats_jvm_route {\n        server   127.0.0.1:8081 srun_id=tomcat01; \n        server   127.0.0.1:8082 srun_id=tomcat02;\n        jvm_route $cookie_JSESSIONID|sessionid reverse;\n    }\n    server {\n        #....原有配置.....\n        location ~ .*\\.(do|jsp|action)?$ {\n            proxy_redirect          off;\n            proxy_set_header        Host            $host;\n            proxy_set_header        X-Real-IP       $remote_addr;\n            proxy_set_header        X-Forwarded-For $proxy_add_x_forwarded_for;\n            root   html;\n            index  index.html index.htm;\n            #proxy_pass http://tomcat;\n            proxy_pass http://tomcats_jvm_route;\n        }\n        #....原有配置.....\n    }\n}\n```\n修改tomcat的server.xml配置：\n```\n<Engine name=\"Catalina\" defaultHost=\"localhost\" jvmRoute=\"tomcat01\">\n<Engine name=\"Catalina\" defaultHost=\"localhost\" jvmRoute=\"tomcat02\">\n```\n验证生效\n```\n[root@localhost ~]# ps -ef |grep tomcat|grep -v grep|awk '{print $2}'\n19914\n20029\n[root@localhost ~]# ps -ef |grep tomcat|grep -v grep|awk '{print $2}'|xargs kill\n[root@localhost ~]# ps -ef |grep tomcat|grep -v grep|awk '{print $2}'\n[root@localhost ~]# cd tomcat-1/\n[root@localhost tomcat-1]# ./bin/startup.sh \nUsing CATALINA_BASE:   /root/tomcat-1\nUsing CATALINA_HOME:   /root/tomcat-1\nUsing CATALINA_TMPDIR: /root/tomcat-1/temp\nUsing JRE_HOME:        /usr/local/jdk1.7.0_60\nUsing CLASSPATH:       /root/tomcat-1/bin/bootstrap.jar:/root/tomcat-1/bin/tomcat-juli.jar\nTomcat started.\n[root@localhost tomcat-1]# cd ../tomcat-2\n-bash: cd: tomcat-2: 没有那个文件或目录\n[root@localhost tomcat-2]# ./bin/startup.sh \nUsing CATALINA_BASE:   /root/tomcat-1\nUsing CATALINA_HOME:   /root/tomcat-1\nUsing CATALINA_TMPDIR: /root/tomcat-1/temp\nUsing JRE_HOME:        /usr/local/jdk1.7.0_60\nUsing CLASSPATH:       /root/tomcat-1/bin/bootstrap.jar:/root/tomcat-1/bin/tomcat-juli.jar\nTomcat started.\n[root@localhost tomcat-2]# /usr/local/nginx/sbin/nginx -t;/usr/local/nginx/sbin/nginx -s reload;\n```\n![](/images/QQ20160318-0.png)\n![](/images/QQ20160318-1.png)\n![](/images/QQ20160318-2.png)\n\n从上图的结果来看：\n\n* 1: sessionID的后面增加了第一个为客户端服务的最终tomcat实例标识。\n* 2: 在不停的刷新页面的时候都是同一个tomcat实例返回的页面。从vts的监控图可以看出，请求都被导流到同一个tomcat实例上。\n* 3: 在停止tomcat1后，再对浏览器进行刷新操作，发现请求被导到tomcat2上，但对应的sessionId也发生了变化，说明服务器端认定这是一个新的客户端进行的请求操作。验证了我之前所说，__这种方式不支持故障转移__。\n\n\n-----\n\n*观点仅代表自己，期待你的留言。*","slug":"nginx-upstream-jvm-route","published":1,"updated":"2021-08-31T14:23:11.548Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cku52dyo0003obbin5xi5ed44","content":"<h2 id=\"实验环境\"><a href=\"#实验环境\" class=\"headerlink\" title=\"实验环境\"></a>实验环境</h2><p>CentOS7, Tomcat7(tomcat-1, tomcat-2), Nginx1.8.1, redis3.0.7</p>\n<p>tomcat1：Server port=”8105”，Connector port=”8081”，ajp Connector port=”8109”</p>\n<p>tomcat2：Server port=”8205”，Connector port=”8082”，ajp Connector port=”8209”</p>\n<h2 id=\"集群环境下tomcat的session处理方式\"><a href=\"#集群环境下tomcat的session处理方式\" class=\"headerlink\" title=\"集群环境下tomcat的session处理方式\"></a>集群环境下tomcat的session处理方式</h2><h3 id=\"一、upstream-ip-hash（不推荐使用）\"><a href=\"#一、upstream-ip-hash（不推荐使用）\" class=\"headerlink\" title=\"一、upstream ip_hash（不推荐使用）\"></a>一、upstream ip_hash（不推荐使用）</h3><p> nginx中的ip_hash技术能够将某个ip的请求定向到同一台后端，这样一来这个ip下的某个客户端和某个后端就能建立起稳固的session，ip_hash是在upstream配置中定义的： </p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">upstream backend &#123; </span><br><span class=\"line\">    server 127.0.0.1:8081 ; </span><br><span class=\"line\">    server 127.0.0.1:8082 ; </span><br><span class=\"line\">    ip_hash; </span><br><span class=\"line\">&#125; </span><br></pre></td></tr></table></figure>\n<p>不推荐使用的原因如下：</p>\n<ul>\n<li><strong>nginx不是最前端的服务器。</strong> ip_hash要求nginx一定是最前端的服务器，否则nginx得不到正确ip，就不能根据ip作hash。譬如使用的是squid为最前端，那么nginx取ip时只能得到squid的服务器ip地址，用这个地址来作分流是肯定错乱的。 </li>\n<li><strong>nginx的后端还有其它方式的负载均衡。</strong><br>假如nginx后端又有其它负载均衡，将请求又通过另外的方式分流了，那么某个客户端的请求肯定不能定位到同一台session应用服务器上。</li>\n<li><strong>多个外网出口。</strong><br> 很多公司上网有多个出口，多个ip地址，用户访问互联网时候自动切换ip。而且这种情况不在少数。使用 ip_hash 的话对这种情况的用户无效，无法将某个用户绑定在固定的tomcat上 。<h3 id=\"二、nginx-upstream-jvm-route-nginx-module，-无法故障转移\"><a href=\"#二、nginx-upstream-jvm-route-nginx-module，-无法故障转移\" class=\"headerlink\" title=\"二、nginx_upstream_jvm_route (nginx module， 无法故障转移)\"></a>二、nginx_upstream_jvm_route (nginx module， 无法故障转移)</h3>nginx_upstream_jvm_route 是一个nginx的扩展模块，用来实现基于 Cookie 的 Session Sticky 的功能。</li>\n</ul>\n<p>简单来说，它是基于cookie中的JSESSIONID来决定将请求发送给后端的哪个server，nginx_upstream_jvm_route会在用户第一次请求后端server时，将响应的server标识绑定到cookie中的JSESSIONID中，从而当用户发起下一次请求时，nginx会根据JSESSIONID来决定由哪个后端server来处理。</p>\n<p>但是当客户端对应的tomcat挂掉之后，客户端的请求将不能通过其它tomcat代替进行处理，也就是说 __nginx_upstream_jvm_route不支持故障转移__。</p>\n<h3 id=\"三、tomcat-redis-session-manager-（java-lib，-推荐使用）\"><a href=\"#三、tomcat-redis-session-manager-（java-lib，-推荐使用）\" class=\"headerlink\" title=\"三、tomcat-redis-session-manager （java lib， 推荐使用）\"></a>三、tomcat-redis-session-manager （java lib， 推荐使用）</h3><p>通过集群实例tomcat连接到同一个redis，将sessionID存储在redis中完成session共享。由于session共享，所以支持故障转移。</p>\n<p>详见我的另一篇博文《Nginx+tomcat+redis集群之session共享》</p>\n<h2 id=\"nginx-upstream-jvm-route安装配置\"><a href=\"#nginx-upstream-jvm-route安装配置\" class=\"headerlink\" title=\"nginx_upstream_jvm_route安装配置\"></a>nginx_upstream_jvm_route安装配置</h2><p>github地址：<a href=\"https://github.com/nulab/nginx-upstream-jvm-route\">https://github.com/nulab/nginx-upstream-jvm-route</a></p>\n<p>安装方法如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@localhost ~]# git clone https://github.com/nulab/nginx-upstream-jvm-route.git</span><br><span class=\"line\">[root@localhost ~]# cd nginx-1.8.1 //注意：一定是进入到nginx安装目录打补丁</span><br><span class=\"line\">[root@localhost nginx-1.8.1]# patch -p0 &lt; ../nginx-upstream-jvm-route/jvm_route.patch </span><br><span class=\"line\">patching file src/http/ngx_http_upstream.c</span><br><span class=\"line\">Hunk #1 succeeded at 5281 (offset 672 lines).</span><br><span class=\"line\">Hunk #2 succeeded at 5380 (offset 678 lines).</span><br><span class=\"line\">Hunk #3 succeeded at 5397 (offset 656 lines).</span><br><span class=\"line\">Hunk #4 succeeded at 5434 (offset 656 lines).</span><br><span class=\"line\">Hunk #5 succeeded at 5467 (offset 656 lines).</span><br><span class=\"line\">Hunk #6 succeeded at 5527 (offset 671 lines).</span><br><span class=\"line\">patching file src/http/ngx_http_upstream.h</span><br><span class=\"line\">Hunk #1 succeeded at 96 (offset 4 lines).</span><br><span class=\"line\">Hunk #2 succeeded at 110 (offset 4 lines).</span><br><span class=\"line\">[root@localhost nginx-1.8.1]# ./configure --with-pcre=../pcre-8.38 --with-zlib=../zlib-1.2.8 --with-http_gzip_static_module --with-http_ssl_module --add-module=../nginx_tcp_proxy_module/ \\--add-module=../nginx_upstream_check_module/ \\--add-module=../nginx-module-vts/ \\--add-module=../nginx-upstream-jvm-route/</span><br><span class=\"line\">[root@localhost nginx-1.8.1]# make</span><br><span class=\"line\">[root@localhost nginx-1.8.1]# mv /usr/local/nginx/sbin/nginx /usr/local/nginx/sbin/nginx.old</span><br><span class=\"line\">mv：是否覆盖&quot;/usr/local/nginx/sbin/nginx.old&quot;？ y</span><br><span class=\"line\">[root@localhost nginx-1.8.1]# cp objs/nginx /usr/local/nginx/sbin/</span><br><span class=\"line\">[root@localhost nginx-1.8.1]# make upgrade</span><br><span class=\"line\">/usr/local/nginx/sbin/nginx -t</span><br><span class=\"line\">nginx: the configuration file /usr/local/nginx/conf/nginx.conf syntax is ok</span><br><span class=\"line\">nginx: configuration file /usr/local/nginx/conf/nginx.conf test is successful</span><br><span class=\"line\">kill -USR2 `cat /usr/local/nginx/logs/nginx.pid`</span><br><span class=\"line\">sleep 1</span><br><span class=\"line\">test -f /usr/local/nginx/logs/nginx.pid.oldbin</span><br><span class=\"line\">kill -QUIT `cat /usr/local/nginx/logs/nginx.pid.oldbin`</span><br><span class=\"line\">[root@localhost nginx-1.8.1]# /usr/local/nginx/sbin/nginx -V</span><br><span class=\"line\">nginx version: nginx/1.8.1</span><br><span class=\"line\">built by gcc 4.8.5 20150623 (Red Hat 4.8.5-4) (GCC) </span><br><span class=\"line\">built with OpenSSL 1.0.1e-fips 11 Feb 2013</span><br><span class=\"line\">TLS SNI support enabled</span><br><span class=\"line\">configure arguments: --with-pcre=../pcre-8.38 --with-zlib=../zlib-1.2.8 --with-http_gzip_static_module --with-http_ssl_module --add-module=../nginx_tcp_proxy_module/ --add-module=../nginx_upstream_check_module/ --add-module=../nginx-module-vts/ --add-module=../nginx-upstream-jvm-route/</span><br></pre></td></tr></table></figure>\n<p>配置nginx.conf</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">http &#123;</span><br><span class=\"line\">    upstream  tomcats_jvm_route &#123;</span><br><span class=\"line\">        server   127.0.0.1:8081 srun_id=tomcat01; </span><br><span class=\"line\">        server   127.0.0.1:8082 srun_id=tomcat02;</span><br><span class=\"line\">        jvm_route $cookie_JSESSIONID|sessionid reverse;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    server &#123;</span><br><span class=\"line\">        #....原有配置.....</span><br><span class=\"line\">        location ~ .*\\.(do|jsp|action)?$ &#123;</span><br><span class=\"line\">            proxy_redirect          off;</span><br><span class=\"line\">            proxy_set_header        Host            $host;</span><br><span class=\"line\">            proxy_set_header        X-Real-IP       $remote_addr;</span><br><span class=\"line\">            proxy_set_header        X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class=\"line\">            root   html;</span><br><span class=\"line\">            index  index.html index.htm;</span><br><span class=\"line\">            #proxy_pass http://tomcat;</span><br><span class=\"line\">            proxy_pass http://tomcats_jvm_route;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        #....原有配置.....</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>修改tomcat的server.xml配置：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;Engine name=&quot;Catalina&quot; defaultHost=&quot;localhost&quot; jvmRoute=&quot;tomcat01&quot;&gt;</span><br><span class=\"line\">&lt;Engine name=&quot;Catalina&quot; defaultHost=&quot;localhost&quot; jvmRoute=&quot;tomcat02&quot;&gt;</span><br></pre></td></tr></table></figure>\n<p>验证生效</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@localhost ~]# ps -ef |grep tomcat|grep -v grep|awk &#x27;&#123;print $2&#125;&#x27;</span><br><span class=\"line\">19914</span><br><span class=\"line\">20029</span><br><span class=\"line\">[root@localhost ~]# ps -ef |grep tomcat|grep -v grep|awk &#x27;&#123;print $2&#125;&#x27;|xargs kill</span><br><span class=\"line\">[root@localhost ~]# ps -ef |grep tomcat|grep -v grep|awk &#x27;&#123;print $2&#125;&#x27;</span><br><span class=\"line\">[root@localhost ~]# cd tomcat-1/</span><br><span class=\"line\">[root@localhost tomcat-1]# ./bin/startup.sh </span><br><span class=\"line\">Using CATALINA_BASE:   /root/tomcat-1</span><br><span class=\"line\">Using CATALINA_HOME:   /root/tomcat-1</span><br><span class=\"line\">Using CATALINA_TMPDIR: /root/tomcat-1/temp</span><br><span class=\"line\">Using JRE_HOME:        /usr/local/jdk1.7.0_60</span><br><span class=\"line\">Using CLASSPATH:       /root/tomcat-1/bin/bootstrap.jar:/root/tomcat-1/bin/tomcat-juli.jar</span><br><span class=\"line\">Tomcat started.</span><br><span class=\"line\">[root@localhost tomcat-1]# cd ../tomcat-2</span><br><span class=\"line\">-bash: cd: tomcat-2: 没有那个文件或目录</span><br><span class=\"line\">[root@localhost tomcat-2]# ./bin/startup.sh </span><br><span class=\"line\">Using CATALINA_BASE:   /root/tomcat-1</span><br><span class=\"line\">Using CATALINA_HOME:   /root/tomcat-1</span><br><span class=\"line\">Using CATALINA_TMPDIR: /root/tomcat-1/temp</span><br><span class=\"line\">Using JRE_HOME:        /usr/local/jdk1.7.0_60</span><br><span class=\"line\">Using CLASSPATH:       /root/tomcat-1/bin/bootstrap.jar:/root/tomcat-1/bin/tomcat-juli.jar</span><br><span class=\"line\">Tomcat started.</span><br><span class=\"line\">[root@localhost tomcat-2]# /usr/local/nginx/sbin/nginx -t;/usr/local/nginx/sbin/nginx -s reload;</span><br></pre></td></tr></table></figure>\n<p><img src=\"/images/QQ20160318-0.png\"><br><img src=\"/images/QQ20160318-1.png\"><br><img src=\"/images/QQ20160318-2.png\"></p>\n<p>从上图的结果来看：</p>\n<ul>\n<li>1: sessionID的后面增加了第一个为客户端服务的最终tomcat实例标识。</li>\n<li>2: 在不停的刷新页面的时候都是同一个tomcat实例返回的页面。从vts的监控图可以看出，请求都被导流到同一个tomcat实例上。</li>\n<li>3: 在停止tomcat1后，再对浏览器进行刷新操作，发现请求被导到tomcat2上，但对应的sessionId也发生了变化，说明服务器端认定这是一个新的客户端进行的请求操作。验证了我之前所说，__这种方式不支持故障转移__。</li>\n</ul>\n<hr>\n<p><em>观点仅代表自己，期待你的留言。</em></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"实验环境\"><a href=\"#实验环境\" class=\"headerlink\" title=\"实验环境\"></a>实验环境</h2><p>CentOS7, Tomcat7(tomcat-1, tomcat-2), Nginx1.8.1, redis3.0.7</p>\n<p>tomcat1：Server port=”8105”，Connector port=”8081”，ajp Connector port=”8109”</p>\n<p>tomcat2：Server port=”8205”，Connector port=”8082”，ajp Connector port=”8209”</p>\n<h2 id=\"集群环境下tomcat的session处理方式\"><a href=\"#集群环境下tomcat的session处理方式\" class=\"headerlink\" title=\"集群环境下tomcat的session处理方式\"></a>集群环境下tomcat的session处理方式</h2><h3 id=\"一、upstream-ip-hash（不推荐使用）\"><a href=\"#一、upstream-ip-hash（不推荐使用）\" class=\"headerlink\" title=\"一、upstream ip_hash（不推荐使用）\"></a>一、upstream ip_hash（不推荐使用）</h3><p> nginx中的ip_hash技术能够将某个ip的请求定向到同一台后端，这样一来这个ip下的某个客户端和某个后端就能建立起稳固的session，ip_hash是在upstream配置中定义的： </p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">upstream backend &#123; </span><br><span class=\"line\">    server 127.0.0.1:8081 ; </span><br><span class=\"line\">    server 127.0.0.1:8082 ; </span><br><span class=\"line\">    ip_hash; </span><br><span class=\"line\">&#125; </span><br></pre></td></tr></table></figure>\n<p>不推荐使用的原因如下：</p>\n<ul>\n<li><strong>nginx不是最前端的服务器。</strong> ip_hash要求nginx一定是最前端的服务器，否则nginx得不到正确ip，就不能根据ip作hash。譬如使用的是squid为最前端，那么nginx取ip时只能得到squid的服务器ip地址，用这个地址来作分流是肯定错乱的。 </li>\n<li><strong>nginx的后端还有其它方式的负载均衡。</strong><br>假如nginx后端又有其它负载均衡，将请求又通过另外的方式分流了，那么某个客户端的请求肯定不能定位到同一台session应用服务器上。</li>\n<li><strong>多个外网出口。</strong><br> 很多公司上网有多个出口，多个ip地址，用户访问互联网时候自动切换ip。而且这种情况不在少数。使用 ip_hash 的话对这种情况的用户无效，无法将某个用户绑定在固定的tomcat上 。<h3 id=\"二、nginx-upstream-jvm-route-nginx-module，-无法故障转移\"><a href=\"#二、nginx-upstream-jvm-route-nginx-module，-无法故障转移\" class=\"headerlink\" title=\"二、nginx_upstream_jvm_route (nginx module， 无法故障转移)\"></a>二、nginx_upstream_jvm_route (nginx module， 无法故障转移)</h3>nginx_upstream_jvm_route 是一个nginx的扩展模块，用来实现基于 Cookie 的 Session Sticky 的功能。</li>\n</ul>\n<p>简单来说，它是基于cookie中的JSESSIONID来决定将请求发送给后端的哪个server，nginx_upstream_jvm_route会在用户第一次请求后端server时，将响应的server标识绑定到cookie中的JSESSIONID中，从而当用户发起下一次请求时，nginx会根据JSESSIONID来决定由哪个后端server来处理。</p>\n<p>但是当客户端对应的tomcat挂掉之后，客户端的请求将不能通过其它tomcat代替进行处理，也就是说 __nginx_upstream_jvm_route不支持故障转移__。</p>\n<h3 id=\"三、tomcat-redis-session-manager-（java-lib，-推荐使用）\"><a href=\"#三、tomcat-redis-session-manager-（java-lib，-推荐使用）\" class=\"headerlink\" title=\"三、tomcat-redis-session-manager （java lib， 推荐使用）\"></a>三、tomcat-redis-session-manager （java lib， 推荐使用）</h3><p>通过集群实例tomcat连接到同一个redis，将sessionID存储在redis中完成session共享。由于session共享，所以支持故障转移。</p>\n<p>详见我的另一篇博文《Nginx+tomcat+redis集群之session共享》</p>\n<h2 id=\"nginx-upstream-jvm-route安装配置\"><a href=\"#nginx-upstream-jvm-route安装配置\" class=\"headerlink\" title=\"nginx_upstream_jvm_route安装配置\"></a>nginx_upstream_jvm_route安装配置</h2><p>github地址：<a href=\"https://github.com/nulab/nginx-upstream-jvm-route\">https://github.com/nulab/nginx-upstream-jvm-route</a></p>\n<p>安装方法如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@localhost ~]# git clone https://github.com/nulab/nginx-upstream-jvm-route.git</span><br><span class=\"line\">[root@localhost ~]# cd nginx-1.8.1 //注意：一定是进入到nginx安装目录打补丁</span><br><span class=\"line\">[root@localhost nginx-1.8.1]# patch -p0 &lt; ../nginx-upstream-jvm-route/jvm_route.patch </span><br><span class=\"line\">patching file src/http/ngx_http_upstream.c</span><br><span class=\"line\">Hunk #1 succeeded at 5281 (offset 672 lines).</span><br><span class=\"line\">Hunk #2 succeeded at 5380 (offset 678 lines).</span><br><span class=\"line\">Hunk #3 succeeded at 5397 (offset 656 lines).</span><br><span class=\"line\">Hunk #4 succeeded at 5434 (offset 656 lines).</span><br><span class=\"line\">Hunk #5 succeeded at 5467 (offset 656 lines).</span><br><span class=\"line\">Hunk #6 succeeded at 5527 (offset 671 lines).</span><br><span class=\"line\">patching file src/http/ngx_http_upstream.h</span><br><span class=\"line\">Hunk #1 succeeded at 96 (offset 4 lines).</span><br><span class=\"line\">Hunk #2 succeeded at 110 (offset 4 lines).</span><br><span class=\"line\">[root@localhost nginx-1.8.1]# ./configure --with-pcre=../pcre-8.38 --with-zlib=../zlib-1.2.8 --with-http_gzip_static_module --with-http_ssl_module --add-module=../nginx_tcp_proxy_module/ \\--add-module=../nginx_upstream_check_module/ \\--add-module=../nginx-module-vts/ \\--add-module=../nginx-upstream-jvm-route/</span><br><span class=\"line\">[root@localhost nginx-1.8.1]# make</span><br><span class=\"line\">[root@localhost nginx-1.8.1]# mv /usr/local/nginx/sbin/nginx /usr/local/nginx/sbin/nginx.old</span><br><span class=\"line\">mv：是否覆盖&quot;/usr/local/nginx/sbin/nginx.old&quot;？ y</span><br><span class=\"line\">[root@localhost nginx-1.8.1]# cp objs/nginx /usr/local/nginx/sbin/</span><br><span class=\"line\">[root@localhost nginx-1.8.1]# make upgrade</span><br><span class=\"line\">/usr/local/nginx/sbin/nginx -t</span><br><span class=\"line\">nginx: the configuration file /usr/local/nginx/conf/nginx.conf syntax is ok</span><br><span class=\"line\">nginx: configuration file /usr/local/nginx/conf/nginx.conf test is successful</span><br><span class=\"line\">kill -USR2 `cat /usr/local/nginx/logs/nginx.pid`</span><br><span class=\"line\">sleep 1</span><br><span class=\"line\">test -f /usr/local/nginx/logs/nginx.pid.oldbin</span><br><span class=\"line\">kill -QUIT `cat /usr/local/nginx/logs/nginx.pid.oldbin`</span><br><span class=\"line\">[root@localhost nginx-1.8.1]# /usr/local/nginx/sbin/nginx -V</span><br><span class=\"line\">nginx version: nginx/1.8.1</span><br><span class=\"line\">built by gcc 4.8.5 20150623 (Red Hat 4.8.5-4) (GCC) </span><br><span class=\"line\">built with OpenSSL 1.0.1e-fips 11 Feb 2013</span><br><span class=\"line\">TLS SNI support enabled</span><br><span class=\"line\">configure arguments: --with-pcre=../pcre-8.38 --with-zlib=../zlib-1.2.8 --with-http_gzip_static_module --with-http_ssl_module --add-module=../nginx_tcp_proxy_module/ --add-module=../nginx_upstream_check_module/ --add-module=../nginx-module-vts/ --add-module=../nginx-upstream-jvm-route/</span><br></pre></td></tr></table></figure>\n<p>配置nginx.conf</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">http &#123;</span><br><span class=\"line\">    upstream  tomcats_jvm_route &#123;</span><br><span class=\"line\">        server   127.0.0.1:8081 srun_id=tomcat01; </span><br><span class=\"line\">        server   127.0.0.1:8082 srun_id=tomcat02;</span><br><span class=\"line\">        jvm_route $cookie_JSESSIONID|sessionid reverse;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    server &#123;</span><br><span class=\"line\">        #....原有配置.....</span><br><span class=\"line\">        location ~ .*\\.(do|jsp|action)?$ &#123;</span><br><span class=\"line\">            proxy_redirect          off;</span><br><span class=\"line\">            proxy_set_header        Host            $host;</span><br><span class=\"line\">            proxy_set_header        X-Real-IP       $remote_addr;</span><br><span class=\"line\">            proxy_set_header        X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class=\"line\">            root   html;</span><br><span class=\"line\">            index  index.html index.htm;</span><br><span class=\"line\">            #proxy_pass http://tomcat;</span><br><span class=\"line\">            proxy_pass http://tomcats_jvm_route;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        #....原有配置.....</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>修改tomcat的server.xml配置：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;Engine name=&quot;Catalina&quot; defaultHost=&quot;localhost&quot; jvmRoute=&quot;tomcat01&quot;&gt;</span><br><span class=\"line\">&lt;Engine name=&quot;Catalina&quot; defaultHost=&quot;localhost&quot; jvmRoute=&quot;tomcat02&quot;&gt;</span><br></pre></td></tr></table></figure>\n<p>验证生效</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@localhost ~]# ps -ef |grep tomcat|grep -v grep|awk &#x27;&#123;print $2&#125;&#x27;</span><br><span class=\"line\">19914</span><br><span class=\"line\">20029</span><br><span class=\"line\">[root@localhost ~]# ps -ef |grep tomcat|grep -v grep|awk &#x27;&#123;print $2&#125;&#x27;|xargs kill</span><br><span class=\"line\">[root@localhost ~]# ps -ef |grep tomcat|grep -v grep|awk &#x27;&#123;print $2&#125;&#x27;</span><br><span class=\"line\">[root@localhost ~]# cd tomcat-1/</span><br><span class=\"line\">[root@localhost tomcat-1]# ./bin/startup.sh </span><br><span class=\"line\">Using CATALINA_BASE:   /root/tomcat-1</span><br><span class=\"line\">Using CATALINA_HOME:   /root/tomcat-1</span><br><span class=\"line\">Using CATALINA_TMPDIR: /root/tomcat-1/temp</span><br><span class=\"line\">Using JRE_HOME:        /usr/local/jdk1.7.0_60</span><br><span class=\"line\">Using CLASSPATH:       /root/tomcat-1/bin/bootstrap.jar:/root/tomcat-1/bin/tomcat-juli.jar</span><br><span class=\"line\">Tomcat started.</span><br><span class=\"line\">[root@localhost tomcat-1]# cd ../tomcat-2</span><br><span class=\"line\">-bash: cd: tomcat-2: 没有那个文件或目录</span><br><span class=\"line\">[root@localhost tomcat-2]# ./bin/startup.sh </span><br><span class=\"line\">Using CATALINA_BASE:   /root/tomcat-1</span><br><span class=\"line\">Using CATALINA_HOME:   /root/tomcat-1</span><br><span class=\"line\">Using CATALINA_TMPDIR: /root/tomcat-1/temp</span><br><span class=\"line\">Using JRE_HOME:        /usr/local/jdk1.7.0_60</span><br><span class=\"line\">Using CLASSPATH:       /root/tomcat-1/bin/bootstrap.jar:/root/tomcat-1/bin/tomcat-juli.jar</span><br><span class=\"line\">Tomcat started.</span><br><span class=\"line\">[root@localhost tomcat-2]# /usr/local/nginx/sbin/nginx -t;/usr/local/nginx/sbin/nginx -s reload;</span><br></pre></td></tr></table></figure>\n<p><img src=\"/images/QQ20160318-0.png\"><br><img src=\"/images/QQ20160318-1.png\"><br><img src=\"/images/QQ20160318-2.png\"></p>\n<p>从上图的结果来看：</p>\n<ul>\n<li>1: sessionID的后面增加了第一个为客户端服务的最终tomcat实例标识。</li>\n<li>2: 在不停的刷新页面的时候都是同一个tomcat实例返回的页面。从vts的监控图可以看出，请求都被导流到同一个tomcat实例上。</li>\n<li>3: 在停止tomcat1后，再对浏览器进行刷新操作，发现请求被导到tomcat2上，但对应的sessionId也发生了变化，说明服务器端认定这是一个新的客户端进行的请求操作。验证了我之前所说，__这种方式不支持故障转移__。</li>\n</ul>\n<hr>\n<p><em>观点仅代表自己，期待你的留言。</em></p>\n"},{"title":"问题分析 之 no transaction is in progress","date":"2017-07-21T09:55:05.000Z","_content":"\n## 问题现象\n```java\njavax.persistence.TransactionRequiredException: no transaction is in progress\n\tat org.hibernate.ejb.AbstractEntityManagerImpl.flush(AbstractEntityManagerImpl.java:301)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)\n\tat java.lang.reflect.Method.invoke(Method.java:597)\n\tat org.springframework.orm.jpa.ExtendedEntityManagerCreator$ExtendedEntityManagerInvocationHandler.invoke(ExtendedEntityManagerCreator.java:365)\n\tat $Proxy34.flush(Unknown Source)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)\n\tat java.lang.reflect.Method.invoke(Method.java:597)\n\tat org.springframework.orm.jpa.SharedEntityManagerCreator$SharedEntityManagerInvocationHandler.invoke(SharedEntityManagerCreator.java:240)\n\tat $Proxy34.flush(Unknown Source)\n  ... 53 more\n```\n## 示例代码 - Proxy\n```java\npublic class classA {\n\n  public void doA {\n    this.doB();\n  }\n\n  @Transaction\n  public void doB{\n    // do save or update\n  }\n}\n```\n__问题分析：__\n如上代码段，由于doB为对象内方法，而Spring事务的开启依赖到AOP（Proxy），在doA方法调用doB方法时，\n由于是对象内的方法调用，造成doB方法的@Transaction不会被Proxy对象代理，进而造成Transaction失效。\n\n__解决方法：__\n```java\npublic class ClassA {\n  private ClassB classB;\n\n  public void doA() {\n    classB.doB();\n  }\n}\n\npublic class ClassB {\n\n  @Transaction\n  public void doB() {\n    // do save or update\n  }\n\n}\n```\n将需要事务的方法doB通过Proxy进行代理，doA在使用时则是通过Spring开启事务的代理进行的调用。\n\n-----\n\n*观点仅代表自己，期待你的留言。*\n","source":"_posts/no-transaction.md","raw":"---\ntitle: 问题分析 之 no transaction is in progress\ntags:\n  - 原创\n  - spring\n  - transaction\ndate: 2017-07-21 17:55:05\n---\n\n## 问题现象\n```java\njavax.persistence.TransactionRequiredException: no transaction is in progress\n\tat org.hibernate.ejb.AbstractEntityManagerImpl.flush(AbstractEntityManagerImpl.java:301)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)\n\tat java.lang.reflect.Method.invoke(Method.java:597)\n\tat org.springframework.orm.jpa.ExtendedEntityManagerCreator$ExtendedEntityManagerInvocationHandler.invoke(ExtendedEntityManagerCreator.java:365)\n\tat $Proxy34.flush(Unknown Source)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)\n\tat java.lang.reflect.Method.invoke(Method.java:597)\n\tat org.springframework.orm.jpa.SharedEntityManagerCreator$SharedEntityManagerInvocationHandler.invoke(SharedEntityManagerCreator.java:240)\n\tat $Proxy34.flush(Unknown Source)\n  ... 53 more\n```\n## 示例代码 - Proxy\n```java\npublic class classA {\n\n  public void doA {\n    this.doB();\n  }\n\n  @Transaction\n  public void doB{\n    // do save or update\n  }\n}\n```\n__问题分析：__\n如上代码段，由于doB为对象内方法，而Spring事务的开启依赖到AOP（Proxy），在doA方法调用doB方法时，\n由于是对象内的方法调用，造成doB方法的@Transaction不会被Proxy对象代理，进而造成Transaction失效。\n\n__解决方法：__\n```java\npublic class ClassA {\n  private ClassB classB;\n\n  public void doA() {\n    classB.doB();\n  }\n}\n\npublic class ClassB {\n\n  @Transaction\n  public void doB() {\n    // do save or update\n  }\n\n}\n```\n将需要事务的方法doB通过Proxy进行代理，doA在使用时则是通过Spring开启事务的代理进行的调用。\n\n-----\n\n*观点仅代表自己，期待你的留言。*\n","slug":"no-transaction","published":1,"updated":"2021-08-31T14:23:11.548Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cku52dyo1003qbbin24pf98nx","content":"<h2 id=\"问题现象\"><a href=\"#问题现象\" class=\"headerlink\" title=\"问题现象\"></a>问题现象</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">javax.persistence.TransactionRequiredException: no transaction is in progress</span><br><span class=\"line\">\tat org.hibernate.ejb.AbstractEntityManagerImpl.flush(AbstractEntityManagerImpl.java:<span class=\"number\">301</span>)</span><br><span class=\"line\">\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)</span><br><span class=\"line\">\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:<span class=\"number\">39</span>)</span><br><span class=\"line\">\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:<span class=\"number\">25</span>)</span><br><span class=\"line\">\tat java.lang.reflect.Method.invoke(Method.java:<span class=\"number\">597</span>)</span><br><span class=\"line\">\tat org.springframework.orm.jpa.ExtendedEntityManagerCreator$ExtendedEntityManagerInvocationHandler.invoke(ExtendedEntityManagerCreator.java:<span class=\"number\">365</span>)</span><br><span class=\"line\">\tat $Proxy34.flush(Unknown Source)</span><br><span class=\"line\">\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)</span><br><span class=\"line\">\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:<span class=\"number\">39</span>)</span><br><span class=\"line\">\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:<span class=\"number\">25</span>)</span><br><span class=\"line\">\tat java.lang.reflect.Method.invoke(Method.java:<span class=\"number\">597</span>)</span><br><span class=\"line\">\tat org.springframework.orm.jpa.SharedEntityManagerCreator$SharedEntityManagerInvocationHandler.invoke(SharedEntityManagerCreator.java:<span class=\"number\">240</span>)</span><br><span class=\"line\">\tat $Proxy34.flush(Unknown Source)</span><br><span class=\"line\">  ... <span class=\"number\">53</span> more</span><br></pre></td></tr></table></figure>\n<h2 id=\"示例代码-Proxy\"><a href=\"#示例代码-Proxy\" class=\"headerlink\" title=\"示例代码 - Proxy\"></a>示例代码 - Proxy</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">classA</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> doA &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.doB();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@Transaction</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> doB&#123;</span><br><span class=\"line\">    <span class=\"comment\">// do save or update</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>问题分析：</strong><br>如上代码段，由于doB为对象内方法，而Spring事务的开启依赖到AOP（Proxy），在doA方法调用doB方法时，<br>由于是对象内的方法调用，造成doB方法的@Transaction不会被Proxy对象代理，进而造成Transaction失效。</p>\n<p><strong>解决方法：</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ClassA</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> ClassB classB;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">doA</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    classB.doB();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ClassB</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@Transaction</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">doB</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// do save or update</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>将需要事务的方法doB通过Proxy进行代理，doA在使用时则是通过Spring开启事务的代理进行的调用。</p>\n<hr>\n<p><em>观点仅代表自己，期待你的留言。</em></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"问题现象\"><a href=\"#问题现象\" class=\"headerlink\" title=\"问题现象\"></a>问题现象</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">javax.persistence.TransactionRequiredException: no transaction is in progress</span><br><span class=\"line\">\tat org.hibernate.ejb.AbstractEntityManagerImpl.flush(AbstractEntityManagerImpl.java:<span class=\"number\">301</span>)</span><br><span class=\"line\">\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)</span><br><span class=\"line\">\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:<span class=\"number\">39</span>)</span><br><span class=\"line\">\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:<span class=\"number\">25</span>)</span><br><span class=\"line\">\tat java.lang.reflect.Method.invoke(Method.java:<span class=\"number\">597</span>)</span><br><span class=\"line\">\tat org.springframework.orm.jpa.ExtendedEntityManagerCreator$ExtendedEntityManagerInvocationHandler.invoke(ExtendedEntityManagerCreator.java:<span class=\"number\">365</span>)</span><br><span class=\"line\">\tat $Proxy34.flush(Unknown Source)</span><br><span class=\"line\">\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)</span><br><span class=\"line\">\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:<span class=\"number\">39</span>)</span><br><span class=\"line\">\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:<span class=\"number\">25</span>)</span><br><span class=\"line\">\tat java.lang.reflect.Method.invoke(Method.java:<span class=\"number\">597</span>)</span><br><span class=\"line\">\tat org.springframework.orm.jpa.SharedEntityManagerCreator$SharedEntityManagerInvocationHandler.invoke(SharedEntityManagerCreator.java:<span class=\"number\">240</span>)</span><br><span class=\"line\">\tat $Proxy34.flush(Unknown Source)</span><br><span class=\"line\">  ... <span class=\"number\">53</span> more</span><br></pre></td></tr></table></figure>\n<h2 id=\"示例代码-Proxy\"><a href=\"#示例代码-Proxy\" class=\"headerlink\" title=\"示例代码 - Proxy\"></a>示例代码 - Proxy</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">classA</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> doA &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.doB();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@Transaction</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> doB&#123;</span><br><span class=\"line\">    <span class=\"comment\">// do save or update</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>问题分析：</strong><br>如上代码段，由于doB为对象内方法，而Spring事务的开启依赖到AOP（Proxy），在doA方法调用doB方法时，<br>由于是对象内的方法调用，造成doB方法的@Transaction不会被Proxy对象代理，进而造成Transaction失效。</p>\n<p><strong>解决方法：</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ClassA</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> ClassB classB;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">doA</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    classB.doB();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ClassB</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@Transaction</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">doB</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// do save or update</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>将需要事务的方法doB通过Proxy进行代理，doA在使用时则是通过Spring开启事务的代理进行的调用。</p>\n<hr>\n<p><em>观点仅代表自己，期待你的留言。</em></p>\n"},{"title":"使用端口转发解决80端口使用问题","keywords":["MacOS端口转发","Linux端口转发","80端口使用","java.net.BindException: Permission denied:80"],"date":"2016-05-26T03:07:35.000Z","_content":"\n## 简介\n当我用在使用linux非root用户进行应用发布时，如遇到应用程序需要占用80端口时总会由于权限不足遇到`java.net.BindException: Permission denied:80`的错误报出。\nLinux为保证系统安全，限制了非root用户对1024以下的端口进行占用。\n那么，本文将通过端口转发的方式解决80端口在Linux和MacOSX系统上占用的问题。\n\n## linux非Root用户使用80端口\nlinux操作系统的可以通过iptables来进行端口转发，将流向80端口的数据内部转发到大于1024的端口上。那么非root用户就可以通过占用大于1024的端口进行程序应用的功能处理。\n以80转发到8080端口为例：\n```\n[root@localhost ~]# sudo iptables -t nat -A PREROUTING -p tcp -m tcp --dport 80 -j REDIRECT --to-ports 8080\n[root@localhost ~]# sudo iptables -t nat -A OUTPUT -d localhost -p tcp -m tcp --dport 80 -j REDIRECT --to-ports 8080\n[root@localhost ~]# iptables -t filter -F\n[root@localhost ~]# iptables-save\n[root@localhost ~]# service iptables restart\n[root@localhost ~]# chkconfig iptables on \n```\niptables -t filter -F : 为清除所有的过滤规则。\nchkconfig iptables on : 设置iptables开机启动。\n\niptables存储文件：/etc/sysconfig/iptables\n\n## MacOSX使用80端口\nMacOS操作系统下则使用`pf`来进行端口转发。\npf启动时会自动装载/etc/pf.conf文件，因此，我们可以通过修改这个文件进行80端口数据的转发。\n修改后的文件内容如下：\n```\nscrub-anchor \"com.apple/*\"\nnat-anchor \"com.apple/*\"\nrdr-anchor \"com.apple/*\"\nrdr on lo0 inet proto tcp from any to 127.0.0.1 port 80 -> 127.0.0.1 port 8080\ndummynet-anchor \"com.apple/*\"\nanchor \"com.apple/*\"\nload anchor \"com.apple\" from \"/etc/pf.anchors/com.apple\"\n```\n使用 pfctl使用重新加载pf.conf配置，并启动pf\n```\nJianjun:~ Jianjun$ sudo pfctl -f /etc/pf.conf\nJianjun:~ Jianjun$ sudo pfctl -e\n```\n另，关闭pf的命令为：`sudo pfctl -d`\n\n\n-----\n\n*观点仅代表自己，期待你的留言。*","source":"_posts/os-port-forward.md","raw":"---\ntitle: 使用端口转发解决80端口使用问题\nkeywords:\n  - \"MacOS端口转发\"\n  - \"Linux端口转发\"\n  - \"80端口使用\"\n  - \"java.net.BindException: Permission denied:80\"\ntags:\n  - 原创\n  - 操作系统\ndate: 2016-05-26 11:07:35\n---\n\n## 简介\n当我用在使用linux非root用户进行应用发布时，如遇到应用程序需要占用80端口时总会由于权限不足遇到`java.net.BindException: Permission denied:80`的错误报出。\nLinux为保证系统安全，限制了非root用户对1024以下的端口进行占用。\n那么，本文将通过端口转发的方式解决80端口在Linux和MacOSX系统上占用的问题。\n\n## linux非Root用户使用80端口\nlinux操作系统的可以通过iptables来进行端口转发，将流向80端口的数据内部转发到大于1024的端口上。那么非root用户就可以通过占用大于1024的端口进行程序应用的功能处理。\n以80转发到8080端口为例：\n```\n[root@localhost ~]# sudo iptables -t nat -A PREROUTING -p tcp -m tcp --dport 80 -j REDIRECT --to-ports 8080\n[root@localhost ~]# sudo iptables -t nat -A OUTPUT -d localhost -p tcp -m tcp --dport 80 -j REDIRECT --to-ports 8080\n[root@localhost ~]# iptables -t filter -F\n[root@localhost ~]# iptables-save\n[root@localhost ~]# service iptables restart\n[root@localhost ~]# chkconfig iptables on \n```\niptables -t filter -F : 为清除所有的过滤规则。\nchkconfig iptables on : 设置iptables开机启动。\n\niptables存储文件：/etc/sysconfig/iptables\n\n## MacOSX使用80端口\nMacOS操作系统下则使用`pf`来进行端口转发。\npf启动时会自动装载/etc/pf.conf文件，因此，我们可以通过修改这个文件进行80端口数据的转发。\n修改后的文件内容如下：\n```\nscrub-anchor \"com.apple/*\"\nnat-anchor \"com.apple/*\"\nrdr-anchor \"com.apple/*\"\nrdr on lo0 inet proto tcp from any to 127.0.0.1 port 80 -> 127.0.0.1 port 8080\ndummynet-anchor \"com.apple/*\"\nanchor \"com.apple/*\"\nload anchor \"com.apple\" from \"/etc/pf.anchors/com.apple\"\n```\n使用 pfctl使用重新加载pf.conf配置，并启动pf\n```\nJianjun:~ Jianjun$ sudo pfctl -f /etc/pf.conf\nJianjun:~ Jianjun$ sudo pfctl -e\n```\n另，关闭pf的命令为：`sudo pfctl -d`\n\n\n-----\n\n*观点仅代表自己，期待你的留言。*","slug":"os-port-forward","published":1,"updated":"2021-08-31T14:23:11.548Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cku52dyo5003tbbin1iq031tr","content":"<h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><p>当我用在使用linux非root用户进行应用发布时，如遇到应用程序需要占用80端口时总会由于权限不足遇到<code>java.net.BindException: Permission denied:80</code>的错误报出。<br>Linux为保证系统安全，限制了非root用户对1024以下的端口进行占用。<br>那么，本文将通过端口转发的方式解决80端口在Linux和MacOSX系统上占用的问题。</p>\n<h2 id=\"linux非Root用户使用80端口\"><a href=\"#linux非Root用户使用80端口\" class=\"headerlink\" title=\"linux非Root用户使用80端口\"></a>linux非Root用户使用80端口</h2><p>linux操作系统的可以通过iptables来进行端口转发，将流向80端口的数据内部转发到大于1024的端口上。那么非root用户就可以通过占用大于1024的端口进行程序应用的功能处理。<br>以80转发到8080端口为例：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@localhost ~]# sudo iptables -t nat -A PREROUTING -p tcp -m tcp --dport 80 -j REDIRECT --to-ports 8080</span><br><span class=\"line\">[root@localhost ~]# sudo iptables -t nat -A OUTPUT -d localhost -p tcp -m tcp --dport 80 -j REDIRECT --to-ports 8080</span><br><span class=\"line\">[root@localhost ~]# iptables -t filter -F</span><br><span class=\"line\">[root@localhost ~]# iptables-save</span><br><span class=\"line\">[root@localhost ~]# service iptables restart</span><br><span class=\"line\">[root@localhost ~]# chkconfig iptables on </span><br></pre></td></tr></table></figure>\n<p>iptables -t filter -F : 为清除所有的过滤规则。<br>chkconfig iptables on : 设置iptables开机启动。</p>\n<p>iptables存储文件：/etc/sysconfig/iptables</p>\n<h2 id=\"MacOSX使用80端口\"><a href=\"#MacOSX使用80端口\" class=\"headerlink\" title=\"MacOSX使用80端口\"></a>MacOSX使用80端口</h2><p>MacOS操作系统下则使用<code>pf</code>来进行端口转发。<br>pf启动时会自动装载/etc/pf.conf文件，因此，我们可以通过修改这个文件进行80端口数据的转发。<br>修改后的文件内容如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">scrub-anchor &quot;com.apple/*&quot;</span><br><span class=\"line\">nat-anchor &quot;com.apple/*&quot;</span><br><span class=\"line\">rdr-anchor &quot;com.apple/*&quot;</span><br><span class=\"line\">rdr on lo0 inet proto tcp from any to 127.0.0.1 port 80 -&gt; 127.0.0.1 port 8080</span><br><span class=\"line\">dummynet-anchor &quot;com.apple/*&quot;</span><br><span class=\"line\">anchor &quot;com.apple/*&quot;</span><br><span class=\"line\">load anchor &quot;com.apple&quot; from &quot;/etc/pf.anchors/com.apple&quot;</span><br></pre></td></tr></table></figure>\n<p>使用 pfctl使用重新加载pf.conf配置，并启动pf</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Jianjun:~ Jianjun$ sudo pfctl -f /etc/pf.conf</span><br><span class=\"line\">Jianjun:~ Jianjun$ sudo pfctl -e</span><br></pre></td></tr></table></figure>\n<p>另，关闭pf的命令为：<code>sudo pfctl -d</code></p>\n<hr>\n<p><em>观点仅代表自己，期待你的留言。</em></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><p>当我用在使用linux非root用户进行应用发布时，如遇到应用程序需要占用80端口时总会由于权限不足遇到<code>java.net.BindException: Permission denied:80</code>的错误报出。<br>Linux为保证系统安全，限制了非root用户对1024以下的端口进行占用。<br>那么，本文将通过端口转发的方式解决80端口在Linux和MacOSX系统上占用的问题。</p>\n<h2 id=\"linux非Root用户使用80端口\"><a href=\"#linux非Root用户使用80端口\" class=\"headerlink\" title=\"linux非Root用户使用80端口\"></a>linux非Root用户使用80端口</h2><p>linux操作系统的可以通过iptables来进行端口转发，将流向80端口的数据内部转发到大于1024的端口上。那么非root用户就可以通过占用大于1024的端口进行程序应用的功能处理。<br>以80转发到8080端口为例：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@localhost ~]# sudo iptables -t nat -A PREROUTING -p tcp -m tcp --dport 80 -j REDIRECT --to-ports 8080</span><br><span class=\"line\">[root@localhost ~]# sudo iptables -t nat -A OUTPUT -d localhost -p tcp -m tcp --dport 80 -j REDIRECT --to-ports 8080</span><br><span class=\"line\">[root@localhost ~]# iptables -t filter -F</span><br><span class=\"line\">[root@localhost ~]# iptables-save</span><br><span class=\"line\">[root@localhost ~]# service iptables restart</span><br><span class=\"line\">[root@localhost ~]# chkconfig iptables on </span><br></pre></td></tr></table></figure>\n<p>iptables -t filter -F : 为清除所有的过滤规则。<br>chkconfig iptables on : 设置iptables开机启动。</p>\n<p>iptables存储文件：/etc/sysconfig/iptables</p>\n<h2 id=\"MacOSX使用80端口\"><a href=\"#MacOSX使用80端口\" class=\"headerlink\" title=\"MacOSX使用80端口\"></a>MacOSX使用80端口</h2><p>MacOS操作系统下则使用<code>pf</code>来进行端口转发。<br>pf启动时会自动装载/etc/pf.conf文件，因此，我们可以通过修改这个文件进行80端口数据的转发。<br>修改后的文件内容如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">scrub-anchor &quot;com.apple/*&quot;</span><br><span class=\"line\">nat-anchor &quot;com.apple/*&quot;</span><br><span class=\"line\">rdr-anchor &quot;com.apple/*&quot;</span><br><span class=\"line\">rdr on lo0 inet proto tcp from any to 127.0.0.1 port 80 -&gt; 127.0.0.1 port 8080</span><br><span class=\"line\">dummynet-anchor &quot;com.apple/*&quot;</span><br><span class=\"line\">anchor &quot;com.apple/*&quot;</span><br><span class=\"line\">load anchor &quot;com.apple&quot; from &quot;/etc/pf.anchors/com.apple&quot;</span><br></pre></td></tr></table></figure>\n<p>使用 pfctl使用重新加载pf.conf配置，并启动pf</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Jianjun:~ Jianjun$ sudo pfctl -f /etc/pf.conf</span><br><span class=\"line\">Jianjun:~ Jianjun$ sudo pfctl -e</span><br></pre></td></tr></table></figure>\n<p>另，关闭pf的命令为：<code>sudo pfctl -d</code></p>\n<hr>\n<p><em>观点仅代表自己，期待你的留言。</em></p>\n"},{"title":"Nginx+php-fpm替代apache服务器","date":"2016-03-21T07:01:31.000Z","_content":"\n## 简介\nnginx本身不能处理PHP，它只是个web服务器，当接收到请求后，如果是php请求，则发给php解释器处理，并把结果返回给客户端。\n\nnginx一般是把请求发fastcgi管理进程处理，fascgi管理进程选择cgi子进程处理结果并返回被nginx\n\n本文以php-fpm为例介绍如何使nginx支持PHP\n一、编译安装php-fpm\n\n什么是PHP-FPM\n\nPHP-FPM是一个PHP FastCGI管理器，是只用于PHP的,可以在 http://php-fpm.org/download 下载得到.\n\nPHP-FPM其实是PHP源代码的一个补丁，旨在将FastCGI进程管理整合进PHP包中。必须将它patch到你的PHP源代码中，在编译安装PHP后才可以使用。\n\n新版PHP已经集成php-fpm了，不再是第三方的包了，推荐使用。PHP-FPM提供了更好的PHP进程管理方式，可以有效控制内存和进程、可以平滑重载PHP配置，比spawn-fcgi具有更多有点，所以被PHP官方收录了。在./configure的时候带 –enable-fpm参数即可开启PHP-FPM。\n\n新版php-fpm安装(推荐安装方式)\n```\nwget http://cn2.php.net/distributions/php-5.4.7.tar.gz\ntar zvxf php-5.4.7.tar.gz\ncd php-5.4.7\n./configure --prefix=/usr/local/php --enable-fastcgi --enable-fpm --with-mcrypt --with-zlib --enable-mbstring --disable-pdo --with-curl --disable-debug --enable-pic --disable-rpath --enable-inline-optimization --with-bz2 --with-xml --with-zlib --enable-sockets --enable-sysvsem --enable-sysvshm --enable-pcntl --enable-mbregex --with-mhash --enable-xslt --enable-memcache --enable-zip --with-pcre-regex --with-mysql\nmake all install\n```\n旧版手动打补丁php-fpm安装\n```\nwget http://cn2.php.net/get/php-5.2.17.tar.gz\nwget http://php-fpm.org/downloads/php-5.2.17-fpm-0.5.14.diff.gz\n\ntar zvxf php-5.2.17.tar.gz\ngzip -cd php-5.2.17-fpm-0.5.14.diff.gz | patch -d php-5.2.17 -p1\ncd php-5.2.17\n./configure --prefix=/usr/local/php  --enable-fpm --with-mcrypt --enable-mbstring --disable-pdo --with-curl --disable-debug  --disable-rpath --enable-inline-optimization --with-bz2  --with-zlib --enable-sockets --enable-sysvsem --enable-sysvshm --enable-pcntl --enable-mbregex --with-mhash --enable-zip --with-pcre-regex --with-mysql --with-mysqli --with-gd --with-jpeg-dir\nmake all install\ncd /usr/local/php\ncp etc/php-fpm.conf.default etc/php-fpm.conf\n/usr/local/php/sbin/php-fpm\n```\n以上两种方式都可以安装php-fpm，安装后内容放在/usr/local/php目录下\n\n二、修改nginx配置文件以支持php-fpm\nnginx安装完成后，修改nginx配置文件为,nginx.conf\n\n其中server段增加如下配置，注意标红内容配置，否则会出现No input file specified.错误\n\n#pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000\n```\nlocation ~ \\.php$ {\nroot html;\nfastcgi_pass 127.0.0.1:9000;\nfastcgi_index index.php;\nfastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;\ninclude fastcgi_params;\n}\n```\n\n\n转自：http://www.cnblogs.com/hujiong/archive/2013/02/20/2918509.html \n\n-----\n\n","source":"_posts/php-fpm.md","raw":"---\ntitle: Nginx+php-fpm替代apache服务器\ntags:\n  - 转载\n  - php-fpm\n  - Nginx\ndate: 2016-03-21 15:01:31\n---\n\n## 简介\nnginx本身不能处理PHP，它只是个web服务器，当接收到请求后，如果是php请求，则发给php解释器处理，并把结果返回给客户端。\n\nnginx一般是把请求发fastcgi管理进程处理，fascgi管理进程选择cgi子进程处理结果并返回被nginx\n\n本文以php-fpm为例介绍如何使nginx支持PHP\n一、编译安装php-fpm\n\n什么是PHP-FPM\n\nPHP-FPM是一个PHP FastCGI管理器，是只用于PHP的,可以在 http://php-fpm.org/download 下载得到.\n\nPHP-FPM其实是PHP源代码的一个补丁，旨在将FastCGI进程管理整合进PHP包中。必须将它patch到你的PHP源代码中，在编译安装PHP后才可以使用。\n\n新版PHP已经集成php-fpm了，不再是第三方的包了，推荐使用。PHP-FPM提供了更好的PHP进程管理方式，可以有效控制内存和进程、可以平滑重载PHP配置，比spawn-fcgi具有更多有点，所以被PHP官方收录了。在./configure的时候带 –enable-fpm参数即可开启PHP-FPM。\n\n新版php-fpm安装(推荐安装方式)\n```\nwget http://cn2.php.net/distributions/php-5.4.7.tar.gz\ntar zvxf php-5.4.7.tar.gz\ncd php-5.4.7\n./configure --prefix=/usr/local/php --enable-fastcgi --enable-fpm --with-mcrypt --with-zlib --enable-mbstring --disable-pdo --with-curl --disable-debug --enable-pic --disable-rpath --enable-inline-optimization --with-bz2 --with-xml --with-zlib --enable-sockets --enable-sysvsem --enable-sysvshm --enable-pcntl --enable-mbregex --with-mhash --enable-xslt --enable-memcache --enable-zip --with-pcre-regex --with-mysql\nmake all install\n```\n旧版手动打补丁php-fpm安装\n```\nwget http://cn2.php.net/get/php-5.2.17.tar.gz\nwget http://php-fpm.org/downloads/php-5.2.17-fpm-0.5.14.diff.gz\n\ntar zvxf php-5.2.17.tar.gz\ngzip -cd php-5.2.17-fpm-0.5.14.diff.gz | patch -d php-5.2.17 -p1\ncd php-5.2.17\n./configure --prefix=/usr/local/php  --enable-fpm --with-mcrypt --enable-mbstring --disable-pdo --with-curl --disable-debug  --disable-rpath --enable-inline-optimization --with-bz2  --with-zlib --enable-sockets --enable-sysvsem --enable-sysvshm --enable-pcntl --enable-mbregex --with-mhash --enable-zip --with-pcre-regex --with-mysql --with-mysqli --with-gd --with-jpeg-dir\nmake all install\ncd /usr/local/php\ncp etc/php-fpm.conf.default etc/php-fpm.conf\n/usr/local/php/sbin/php-fpm\n```\n以上两种方式都可以安装php-fpm，安装后内容放在/usr/local/php目录下\n\n二、修改nginx配置文件以支持php-fpm\nnginx安装完成后，修改nginx配置文件为,nginx.conf\n\n其中server段增加如下配置，注意标红内容配置，否则会出现No input file specified.错误\n\n#pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000\n```\nlocation ~ \\.php$ {\nroot html;\nfastcgi_pass 127.0.0.1:9000;\nfastcgi_index index.php;\nfastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;\ninclude fastcgi_params;\n}\n```\n\n\n转自：http://www.cnblogs.com/hujiong/archive/2013/02/20/2918509.html \n\n-----\n\n","slug":"php-fpm","published":1,"updated":"2021-08-31T14:23:11.549Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cku52dyo6003vbbingebwduhn","content":"<h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><p>nginx本身不能处理PHP，它只是个web服务器，当接收到请求后，如果是php请求，则发给php解释器处理，并把结果返回给客户端。</p>\n<p>nginx一般是把请求发fastcgi管理进程处理，fascgi管理进程选择cgi子进程处理结果并返回被nginx</p>\n<p>本文以php-fpm为例介绍如何使nginx支持PHP<br>一、编译安装php-fpm</p>\n<p>什么是PHP-FPM</p>\n<p>PHP-FPM是一个PHP FastCGI管理器，是只用于PHP的,可以在 <a href=\"http://php-fpm.org/download\">http://php-fpm.org/download</a> 下载得到.</p>\n<p>PHP-FPM其实是PHP源代码的一个补丁，旨在将FastCGI进程管理整合进PHP包中。必须将它patch到你的PHP源代码中，在编译安装PHP后才可以使用。</p>\n<p>新版PHP已经集成php-fpm了，不再是第三方的包了，推荐使用。PHP-FPM提供了更好的PHP进程管理方式，可以有效控制内存和进程、可以平滑重载PHP配置，比spawn-fcgi具有更多有点，所以被PHP官方收录了。在./configure的时候带 –enable-fpm参数即可开启PHP-FPM。</p>\n<p>新版php-fpm安装(推荐安装方式)</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wget http://cn2.php.net/distributions/php-5.4.7.tar.gz</span><br><span class=\"line\">tar zvxf php-5.4.7.tar.gz</span><br><span class=\"line\">cd php-5.4.7</span><br><span class=\"line\">./configure --prefix=/usr/local/php --enable-fastcgi --enable-fpm --with-mcrypt --with-zlib --enable-mbstring --disable-pdo --with-curl --disable-debug --enable-pic --disable-rpath --enable-inline-optimization --with-bz2 --with-xml --with-zlib --enable-sockets --enable-sysvsem --enable-sysvshm --enable-pcntl --enable-mbregex --with-mhash --enable-xslt --enable-memcache --enable-zip --with-pcre-regex --with-mysql</span><br><span class=\"line\">make all install</span><br></pre></td></tr></table></figure>\n<p>旧版手动打补丁php-fpm安装</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wget http://cn2.php.net/get/php-5.2.17.tar.gz</span><br><span class=\"line\">wget http://php-fpm.org/downloads/php-5.2.17-fpm-0.5.14.diff.gz</span><br><span class=\"line\"></span><br><span class=\"line\">tar zvxf php-5.2.17.tar.gz</span><br><span class=\"line\">gzip -cd php-5.2.17-fpm-0.5.14.diff.gz | patch -d php-5.2.17 -p1</span><br><span class=\"line\">cd php-5.2.17</span><br><span class=\"line\">./configure --prefix=/usr/local/php  --enable-fpm --with-mcrypt --enable-mbstring --disable-pdo --with-curl --disable-debug  --disable-rpath --enable-inline-optimization --with-bz2  --with-zlib --enable-sockets --enable-sysvsem --enable-sysvshm --enable-pcntl --enable-mbregex --with-mhash --enable-zip --with-pcre-regex --with-mysql --with-mysqli --with-gd --with-jpeg-dir</span><br><span class=\"line\">make all install</span><br><span class=\"line\">cd /usr/local/php</span><br><span class=\"line\">cp etc/php-fpm.conf.default etc/php-fpm.conf</span><br><span class=\"line\">/usr/local/php/sbin/php-fpm</span><br></pre></td></tr></table></figure>\n<p>以上两种方式都可以安装php-fpm，安装后内容放在/usr/local/php目录下</p>\n<p>二、修改nginx配置文件以支持php-fpm<br>nginx安装完成后，修改nginx配置文件为,nginx.conf</p>\n<p>其中server段增加如下配置，注意标红内容配置，否则会出现No input file specified.错误</p>\n<p>#pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">location ~ \\.php$ &#123;</span><br><span class=\"line\">root html;</span><br><span class=\"line\">fastcgi_pass 127.0.0.1:9000;</span><br><span class=\"line\">fastcgi_index index.php;</span><br><span class=\"line\">fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;</span><br><span class=\"line\">include fastcgi_params;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<p>转自：<a href=\"http://www.cnblogs.com/hujiong/archive/2013/02/20/2918509.html\">http://www.cnblogs.com/hujiong/archive/2013/02/20/2918509.html</a> </p>\n<hr>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><p>nginx本身不能处理PHP，它只是个web服务器，当接收到请求后，如果是php请求，则发给php解释器处理，并把结果返回给客户端。</p>\n<p>nginx一般是把请求发fastcgi管理进程处理，fascgi管理进程选择cgi子进程处理结果并返回被nginx</p>\n<p>本文以php-fpm为例介绍如何使nginx支持PHP<br>一、编译安装php-fpm</p>\n<p>什么是PHP-FPM</p>\n<p>PHP-FPM是一个PHP FastCGI管理器，是只用于PHP的,可以在 <a href=\"http://php-fpm.org/download\">http://php-fpm.org/download</a> 下载得到.</p>\n<p>PHP-FPM其实是PHP源代码的一个补丁，旨在将FastCGI进程管理整合进PHP包中。必须将它patch到你的PHP源代码中，在编译安装PHP后才可以使用。</p>\n<p>新版PHP已经集成php-fpm了，不再是第三方的包了，推荐使用。PHP-FPM提供了更好的PHP进程管理方式，可以有效控制内存和进程、可以平滑重载PHP配置，比spawn-fcgi具有更多有点，所以被PHP官方收录了。在./configure的时候带 –enable-fpm参数即可开启PHP-FPM。</p>\n<p>新版php-fpm安装(推荐安装方式)</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wget http://cn2.php.net/distributions/php-5.4.7.tar.gz</span><br><span class=\"line\">tar zvxf php-5.4.7.tar.gz</span><br><span class=\"line\">cd php-5.4.7</span><br><span class=\"line\">./configure --prefix=/usr/local/php --enable-fastcgi --enable-fpm --with-mcrypt --with-zlib --enable-mbstring --disable-pdo --with-curl --disable-debug --enable-pic --disable-rpath --enable-inline-optimization --with-bz2 --with-xml --with-zlib --enable-sockets --enable-sysvsem --enable-sysvshm --enable-pcntl --enable-mbregex --with-mhash --enable-xslt --enable-memcache --enable-zip --with-pcre-regex --with-mysql</span><br><span class=\"line\">make all install</span><br></pre></td></tr></table></figure>\n<p>旧版手动打补丁php-fpm安装</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wget http://cn2.php.net/get/php-5.2.17.tar.gz</span><br><span class=\"line\">wget http://php-fpm.org/downloads/php-5.2.17-fpm-0.5.14.diff.gz</span><br><span class=\"line\"></span><br><span class=\"line\">tar zvxf php-5.2.17.tar.gz</span><br><span class=\"line\">gzip -cd php-5.2.17-fpm-0.5.14.diff.gz | patch -d php-5.2.17 -p1</span><br><span class=\"line\">cd php-5.2.17</span><br><span class=\"line\">./configure --prefix=/usr/local/php  --enable-fpm --with-mcrypt --enable-mbstring --disable-pdo --with-curl --disable-debug  --disable-rpath --enable-inline-optimization --with-bz2  --with-zlib --enable-sockets --enable-sysvsem --enable-sysvshm --enable-pcntl --enable-mbregex --with-mhash --enable-zip --with-pcre-regex --with-mysql --with-mysqli --with-gd --with-jpeg-dir</span><br><span class=\"line\">make all install</span><br><span class=\"line\">cd /usr/local/php</span><br><span class=\"line\">cp etc/php-fpm.conf.default etc/php-fpm.conf</span><br><span class=\"line\">/usr/local/php/sbin/php-fpm</span><br></pre></td></tr></table></figure>\n<p>以上两种方式都可以安装php-fpm，安装后内容放在/usr/local/php目录下</p>\n<p>二、修改nginx配置文件以支持php-fpm<br>nginx安装完成后，修改nginx配置文件为,nginx.conf</p>\n<p>其中server段增加如下配置，注意标红内容配置，否则会出现No input file specified.错误</p>\n<p>#pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">location ~ \\.php$ &#123;</span><br><span class=\"line\">root html;</span><br><span class=\"line\">fastcgi_pass 127.0.0.1:9000;</span><br><span class=\"line\">fastcgi_index index.php;</span><br><span class=\"line\">fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;</span><br><span class=\"line\">include fastcgi_params;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<p>转自：<a href=\"http://www.cnblogs.com/hujiong/archive/2013/02/20/2918509.html\">http://www.cnblogs.com/hujiong/archive/2013/02/20/2918509.html</a> </p>\n<hr>\n"},{"title":"Podman系列之通过Maven插件dockerfile-maven-plugin完成镜像打包","keywords":["Podman","dockerfile-maven-plugin","unix://localhost:80: No such file or directory"],"date":"2021-09-28T10:35:30.000Z","_content":"\n## pom中添加插件\n```\n<plugin>\n    <groupId>com.spotify</groupId>\n    <artifactId>dockerfile-maven-plugin</artifactId>\n    <version>1.4.13</version>\n    <executions>\n        <execution>\n            <id>default</id>\n            <goals>\n                <goal>build</goal>\n                <goal>push</goal>\n            </goals>\n        </execution>\n    </executions>\n    <configuration>\n        <repository>myrepo.gpluslife.com/${project.artifactId}</repository>\n        <tag>${project.version}</tag>\n        <useMavenSettingsForAuth>true</useMavenSettingsForAuth>\n        <buildArgs>\n            <MODULE_FILE_NAME>${project.build.finalName}</MODULE_FILE_NAME>\n        </buildArgs>\n    </configuration>\n</plugin>\n```\n## 打包镜像\n\n```bash\nwujianjun@wujianjun-work:~$ clean package -U  -Dmaven.test.skip=true\n```\n通过在Dockerfile文件所在目录执行以上命令成功后，则会自动在远程podman服务端创建镜像\n```bash\nwujianjun@wujianjun-work:~$ podman images\nREPOSITORY                                     TAG                         IMAGE ID      CREATED         SIZE\nmyrepo.gpluslife.com/service-gateway-biz       1.0.0-SNAPSHOT              aa26ce31b312  20 seconds ago  294 MB\ndocker.io/library/nginx                        1.20.1                      3456bc6a1c48  3 weeks ago     137 MB\ndocker.io/adoptopenjdk/openjdk8                x86_64-ubuntu-jre8u292-b10  48b3b187af57  5 weeks ago     229 MB\n```\n\n## 常见问题\n\n1. mvn package时抛错\n\n```\n[INFO] I/O exception (java.io.IOException) caught when processing request to {}->unix://localhost:80: No such file or directory\n[INFO] Retrying request to {}->unix://localhost:80\n[INFO] I/O exception (java.io.IOException) caught when processing request to {}->unix://localhost:80: No such file or directory\n[INFO] Retrying request to {}->unix://localhost:80\n[INFO] I/O exception (java.io.IOException) caught when processing request to {}->unix://localhost:80: No such file or directory\n[INFO] Retrying request to {}->unix://localhost:80\n```\n\n根因分析：由于未正确配置DOCKER_HOST环境变量导致走了本机默认的连接地址\n解决方案：在环境变量上配置以下地址\n\n```\nDOCKER_HOST=\"tcp://host:2375\"\n```\n\n附插件官网地址： https://github.com/spotify/dockerfile-maven\n\n-----\n\n*观点仅代表自己，期待你的留言。*\n","source":"_posts/podman-dockerfile-maven-plugin.md","raw":"---\ntitle: Podman系列之通过Maven插件dockerfile-maven-plugin完成镜像打包\ntags:\n  - 原创\n  - podman\nkeywords:\n  - Podman\n  - dockerfile-maven-plugin\n  - \"unix://localhost:80: No such file or directory\"\ndate: 2021-09-28 18:35:30\n---\n\n## pom中添加插件\n```\n<plugin>\n    <groupId>com.spotify</groupId>\n    <artifactId>dockerfile-maven-plugin</artifactId>\n    <version>1.4.13</version>\n    <executions>\n        <execution>\n            <id>default</id>\n            <goals>\n                <goal>build</goal>\n                <goal>push</goal>\n            </goals>\n        </execution>\n    </executions>\n    <configuration>\n        <repository>myrepo.gpluslife.com/${project.artifactId}</repository>\n        <tag>${project.version}</tag>\n        <useMavenSettingsForAuth>true</useMavenSettingsForAuth>\n        <buildArgs>\n            <MODULE_FILE_NAME>${project.build.finalName}</MODULE_FILE_NAME>\n        </buildArgs>\n    </configuration>\n</plugin>\n```\n## 打包镜像\n\n```bash\nwujianjun@wujianjun-work:~$ clean package -U  -Dmaven.test.skip=true\n```\n通过在Dockerfile文件所在目录执行以上命令成功后，则会自动在远程podman服务端创建镜像\n```bash\nwujianjun@wujianjun-work:~$ podman images\nREPOSITORY                                     TAG                         IMAGE ID      CREATED         SIZE\nmyrepo.gpluslife.com/service-gateway-biz       1.0.0-SNAPSHOT              aa26ce31b312  20 seconds ago  294 MB\ndocker.io/library/nginx                        1.20.1                      3456bc6a1c48  3 weeks ago     137 MB\ndocker.io/adoptopenjdk/openjdk8                x86_64-ubuntu-jre8u292-b10  48b3b187af57  5 weeks ago     229 MB\n```\n\n## 常见问题\n\n1. mvn package时抛错\n\n```\n[INFO] I/O exception (java.io.IOException) caught when processing request to {}->unix://localhost:80: No such file or directory\n[INFO] Retrying request to {}->unix://localhost:80\n[INFO] I/O exception (java.io.IOException) caught when processing request to {}->unix://localhost:80: No such file or directory\n[INFO] Retrying request to {}->unix://localhost:80\n[INFO] I/O exception (java.io.IOException) caught when processing request to {}->unix://localhost:80: No such file or directory\n[INFO] Retrying request to {}->unix://localhost:80\n```\n\n根因分析：由于未正确配置DOCKER_HOST环境变量导致走了本机默认的连接地址\n解决方案：在环境变量上配置以下地址\n\n```\nDOCKER_HOST=\"tcp://host:2375\"\n```\n\n附插件官网地址： https://github.com/spotify/dockerfile-maven\n\n-----\n\n*观点仅代表自己，期待你的留言。*\n","slug":"podman-dockerfile-maven-plugin","published":1,"updated":"2021-09-28T10:43:29.187Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cku52dyo7003ybbina83ufnaz","content":"<h2 id=\"pom中添加插件\"><a href=\"#pom中添加插件\" class=\"headerlink\" title=\"pom中添加插件\"></a>pom中添加插件</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;plugin&gt;</span><br><span class=\"line\">    &lt;groupId&gt;com.spotify&lt;/groupId&gt;</span><br><span class=\"line\">    &lt;artifactId&gt;dockerfile-maven-plugin&lt;/artifactId&gt;</span><br><span class=\"line\">    &lt;version&gt;1.4.13&lt;/version&gt;</span><br><span class=\"line\">    &lt;executions&gt;</span><br><span class=\"line\">        &lt;execution&gt;</span><br><span class=\"line\">            &lt;id&gt;default&lt;/id&gt;</span><br><span class=\"line\">            &lt;goals&gt;</span><br><span class=\"line\">                &lt;goal&gt;build&lt;/goal&gt;</span><br><span class=\"line\">                &lt;goal&gt;push&lt;/goal&gt;</span><br><span class=\"line\">            &lt;/goals&gt;</span><br><span class=\"line\">        &lt;/execution&gt;</span><br><span class=\"line\">    &lt;/executions&gt;</span><br><span class=\"line\">    &lt;configuration&gt;</span><br><span class=\"line\">        &lt;repository&gt;myrepo.gpluslife.com/$&#123;project.artifactId&#125;&lt;/repository&gt;</span><br><span class=\"line\">        &lt;tag&gt;$&#123;project.version&#125;&lt;/tag&gt;</span><br><span class=\"line\">        &lt;useMavenSettingsForAuth&gt;true&lt;/useMavenSettingsForAuth&gt;</span><br><span class=\"line\">        &lt;buildArgs&gt;</span><br><span class=\"line\">            &lt;MODULE_FILE_NAME&gt;$&#123;project.build.finalName&#125;&lt;/MODULE_FILE_NAME&gt;</span><br><span class=\"line\">        &lt;/buildArgs&gt;</span><br><span class=\"line\">    &lt;/configuration&gt;</span><br><span class=\"line\">&lt;/plugin&gt;</span><br></pre></td></tr></table></figure>\n<h2 id=\"打包镜像\"><a href=\"#打包镜像\" class=\"headerlink\" title=\"打包镜像\"></a>打包镜像</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wujianjun@wujianjun-work:~$ clean package -U  -Dmaven.test.skip=<span class=\"literal\">true</span></span><br></pre></td></tr></table></figure>\n<p>通过在Dockerfile文件所在目录执行以上命令成功后，则会自动在远程podman服务端创建镜像</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wujianjun@wujianjun-work:~$ podman images</span><br><span class=\"line\">REPOSITORY                                     TAG                         IMAGE ID      CREATED         SIZE</span><br><span class=\"line\">myrepo.gpluslife.com/service-gateway-biz       1.0.0-SNAPSHOT              aa26ce31b312  20 seconds ago  294 MB</span><br><span class=\"line\">docker.io/library/nginx                        1.20.1                      3456bc6a1c48  3 weeks ago     137 MB</span><br><span class=\"line\">docker.io/adoptopenjdk/openjdk8                x86_64-ubuntu-jre8u292-b10  48b3b187af57  5 weeks ago     229 MB</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"常见问题\"><a href=\"#常见问题\" class=\"headerlink\" title=\"常见问题\"></a>常见问题</h2><ol>\n<li>mvn package时抛错</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[INFO] I/O exception (java.io.IOException) caught when processing request to &#123;&#125;-&gt;unix://localhost:80: No such file or directory</span><br><span class=\"line\">[INFO] Retrying request to &#123;&#125;-&gt;unix://localhost:80</span><br><span class=\"line\">[INFO] I/O exception (java.io.IOException) caught when processing request to &#123;&#125;-&gt;unix://localhost:80: No such file or directory</span><br><span class=\"line\">[INFO] Retrying request to &#123;&#125;-&gt;unix://localhost:80</span><br><span class=\"line\">[INFO] I/O exception (java.io.IOException) caught when processing request to &#123;&#125;-&gt;unix://localhost:80: No such file or directory</span><br><span class=\"line\">[INFO] Retrying request to &#123;&#125;-&gt;unix://localhost:80</span><br></pre></td></tr></table></figure>\n\n<p>根因分析：由于未正确配置DOCKER_HOST环境变量导致走了本机默认的连接地址<br>解决方案：在环境变量上配置以下地址</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DOCKER_HOST=&quot;tcp://host:2375&quot;</span><br></pre></td></tr></table></figure>\n\n<p>附插件官网地址： <a href=\"https://github.com/spotify/dockerfile-maven\">https://github.com/spotify/dockerfile-maven</a></p>\n<hr>\n<p><em>观点仅代表自己，期待你的留言。</em></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"pom中添加插件\"><a href=\"#pom中添加插件\" class=\"headerlink\" title=\"pom中添加插件\"></a>pom中添加插件</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;plugin&gt;</span><br><span class=\"line\">    &lt;groupId&gt;com.spotify&lt;/groupId&gt;</span><br><span class=\"line\">    &lt;artifactId&gt;dockerfile-maven-plugin&lt;/artifactId&gt;</span><br><span class=\"line\">    &lt;version&gt;1.4.13&lt;/version&gt;</span><br><span class=\"line\">    &lt;executions&gt;</span><br><span class=\"line\">        &lt;execution&gt;</span><br><span class=\"line\">            &lt;id&gt;default&lt;/id&gt;</span><br><span class=\"line\">            &lt;goals&gt;</span><br><span class=\"line\">                &lt;goal&gt;build&lt;/goal&gt;</span><br><span class=\"line\">                &lt;goal&gt;push&lt;/goal&gt;</span><br><span class=\"line\">            &lt;/goals&gt;</span><br><span class=\"line\">        &lt;/execution&gt;</span><br><span class=\"line\">    &lt;/executions&gt;</span><br><span class=\"line\">    &lt;configuration&gt;</span><br><span class=\"line\">        &lt;repository&gt;myrepo.gpluslife.com/$&#123;project.artifactId&#125;&lt;/repository&gt;</span><br><span class=\"line\">        &lt;tag&gt;$&#123;project.version&#125;&lt;/tag&gt;</span><br><span class=\"line\">        &lt;useMavenSettingsForAuth&gt;true&lt;/useMavenSettingsForAuth&gt;</span><br><span class=\"line\">        &lt;buildArgs&gt;</span><br><span class=\"line\">            &lt;MODULE_FILE_NAME&gt;$&#123;project.build.finalName&#125;&lt;/MODULE_FILE_NAME&gt;</span><br><span class=\"line\">        &lt;/buildArgs&gt;</span><br><span class=\"line\">    &lt;/configuration&gt;</span><br><span class=\"line\">&lt;/plugin&gt;</span><br></pre></td></tr></table></figure>\n<h2 id=\"打包镜像\"><a href=\"#打包镜像\" class=\"headerlink\" title=\"打包镜像\"></a>打包镜像</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wujianjun@wujianjun-work:~$ clean package -U  -Dmaven.test.skip=<span class=\"literal\">true</span></span><br></pre></td></tr></table></figure>\n<p>通过在Dockerfile文件所在目录执行以上命令成功后，则会自动在远程podman服务端创建镜像</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wujianjun@wujianjun-work:~$ podman images</span><br><span class=\"line\">REPOSITORY                                     TAG                         IMAGE ID      CREATED         SIZE</span><br><span class=\"line\">myrepo.gpluslife.com/service-gateway-biz       1.0.0-SNAPSHOT              aa26ce31b312  20 seconds ago  294 MB</span><br><span class=\"line\">docker.io/library/nginx                        1.20.1                      3456bc6a1c48  3 weeks ago     137 MB</span><br><span class=\"line\">docker.io/adoptopenjdk/openjdk8                x86_64-ubuntu-jre8u292-b10  48b3b187af57  5 weeks ago     229 MB</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"常见问题\"><a href=\"#常见问题\" class=\"headerlink\" title=\"常见问题\"></a>常见问题</h2><ol>\n<li>mvn package时抛错</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[INFO] I/O exception (java.io.IOException) caught when processing request to &#123;&#125;-&gt;unix://localhost:80: No such file or directory</span><br><span class=\"line\">[INFO] Retrying request to &#123;&#125;-&gt;unix://localhost:80</span><br><span class=\"line\">[INFO] I/O exception (java.io.IOException) caught when processing request to &#123;&#125;-&gt;unix://localhost:80: No such file or directory</span><br><span class=\"line\">[INFO] Retrying request to &#123;&#125;-&gt;unix://localhost:80</span><br><span class=\"line\">[INFO] I/O exception (java.io.IOException) caught when processing request to &#123;&#125;-&gt;unix://localhost:80: No such file or directory</span><br><span class=\"line\">[INFO] Retrying request to &#123;&#125;-&gt;unix://localhost:80</span><br></pre></td></tr></table></figure>\n\n<p>根因分析：由于未正确配置DOCKER_HOST环境变量导致走了本机默认的连接地址<br>解决方案：在环境变量上配置以下地址</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DOCKER_HOST=&quot;tcp://host:2375&quot;</span><br></pre></td></tr></table></figure>\n\n<p>附插件官网地址： <a href=\"https://github.com/spotify/dockerfile-maven\">https://github.com/spotify/dockerfile-maven</a></p>\n<hr>\n<p><em>观点仅代表自己，期待你的留言。</em></p>\n"},{"title":"podman系列之ubuntu下podman环境搭建","keywords":["docker","podman"],"date":"2021-09-03T14:33:31.000Z","_content":"\n## Linux环境信息\n```\nwujianjun@wujianjun-work:~$ cat /etc/os-release\nNAME=\"Ubuntu\"\nVERSION=\"20.04.3 LTS (Focal Fossa)\"\nID=ubuntu\nID_LIKE=debian\nPRETTY_NAME=\"Ubuntu 20.04.3 LTS\"\nVERSION_ID=\"20.04\"\nHOME_URL=\"https://www.ubuntu.com/\"\nSUPPORT_URL=\"https://help.ubuntu.com/\"\nBUG_REPORT_URL=\"https://bugs.launchpad.net/ubuntu/\"\nPRIVACY_POLICY_URL=\"https://www.ubuntu.com/legal/terms-and-policies/privacy-policy\"\nVERSION_CODENAME=focal\nUBUNTU_CODENAME=focal\n```\n\n## 安装podman\n```\nwujianjun@wujianjun-work:~$ echo \"deb https://download.opensuse.org/repositories/devel:/kubic:/libcontainers:/stable/xUbuntu_20.04/ /\" | sudo tee /etc/apt/sources.list.d/devel:kubic:libcontainers:stable.list\nwujianjun@wujianjun-work:~$ curl -L \"https://download.opensuse.org/repositories/devel:/kubic:/libcontainers:/stable/xUbuntu_20.04/Release.key\" | sudo apt-key add -\nwujianjun@wujianjun-work:~$ sudo apt update\nwujianjun@wujianjun-work:~$ sudo apt -y upgrade\nwujianjun@wujianjun-work:~$ sudo apt -y install podman\n```\n速度有点慢。。。\n\n## 设置国内镜像源\n由于访问速度慢，可为默认的docker.io添加加速镜像（如果后续自己搭建私服，可将镜像地址设置为私服，则每次pull时会将镜像在私服上保存一份）。\n详细配置如下：\n```\nwujianjun@wujianjun-work:~$ vi /etc/containers/registries.conf 后面增加\n`\n[[registry]]\nprefix = \"docker.io\" #需要加速的镜像地址\nlocation = \"hub-mirror.c.163.com\" #加速器地址，可以为私服地址\ninsecure = true #支持加速器地址使用http进行访问\n`\nwujianjun@wujianjun-work:~$ sudo systemctl restart podman\n```\n\n## 开机自己podman\n```\nwujianjun@wujianjun-work:~$ sudo systemctl start podman\n```\n\n## 验证安装版本\n```\nwujianjun@wujianjun-work:~$ podman version\nVersion:      3.2.3\nAPI Version:  3.2.3\nGo Version:   go1.15.2\nBuilt:        Thu Jan  1 00:00:00 1970\nOS/Arch:      linux/amd64\n\n```\n\n-----\n\n*观点仅代表自己，期待你的留言。*\n","source":"_posts/podman-env-install.md","raw":"---\ntitle: podman系列之ubuntu下podman环境搭建\ntags:\n  - 原创\n  - podman\nkeywords:\n  - docker\n  - podman\ndate: 2021-09-03 22:33:31\n---\n\n## Linux环境信息\n```\nwujianjun@wujianjun-work:~$ cat /etc/os-release\nNAME=\"Ubuntu\"\nVERSION=\"20.04.3 LTS (Focal Fossa)\"\nID=ubuntu\nID_LIKE=debian\nPRETTY_NAME=\"Ubuntu 20.04.3 LTS\"\nVERSION_ID=\"20.04\"\nHOME_URL=\"https://www.ubuntu.com/\"\nSUPPORT_URL=\"https://help.ubuntu.com/\"\nBUG_REPORT_URL=\"https://bugs.launchpad.net/ubuntu/\"\nPRIVACY_POLICY_URL=\"https://www.ubuntu.com/legal/terms-and-policies/privacy-policy\"\nVERSION_CODENAME=focal\nUBUNTU_CODENAME=focal\n```\n\n## 安装podman\n```\nwujianjun@wujianjun-work:~$ echo \"deb https://download.opensuse.org/repositories/devel:/kubic:/libcontainers:/stable/xUbuntu_20.04/ /\" | sudo tee /etc/apt/sources.list.d/devel:kubic:libcontainers:stable.list\nwujianjun@wujianjun-work:~$ curl -L \"https://download.opensuse.org/repositories/devel:/kubic:/libcontainers:/stable/xUbuntu_20.04/Release.key\" | sudo apt-key add -\nwujianjun@wujianjun-work:~$ sudo apt update\nwujianjun@wujianjun-work:~$ sudo apt -y upgrade\nwujianjun@wujianjun-work:~$ sudo apt -y install podman\n```\n速度有点慢。。。\n\n## 设置国内镜像源\n由于访问速度慢，可为默认的docker.io添加加速镜像（如果后续自己搭建私服，可将镜像地址设置为私服，则每次pull时会将镜像在私服上保存一份）。\n详细配置如下：\n```\nwujianjun@wujianjun-work:~$ vi /etc/containers/registries.conf 后面增加\n`\n[[registry]]\nprefix = \"docker.io\" #需要加速的镜像地址\nlocation = \"hub-mirror.c.163.com\" #加速器地址，可以为私服地址\ninsecure = true #支持加速器地址使用http进行访问\n`\nwujianjun@wujianjun-work:~$ sudo systemctl restart podman\n```\n\n## 开机自己podman\n```\nwujianjun@wujianjun-work:~$ sudo systemctl start podman\n```\n\n## 验证安装版本\n```\nwujianjun@wujianjun-work:~$ podman version\nVersion:      3.2.3\nAPI Version:  3.2.3\nGo Version:   go1.15.2\nBuilt:        Thu Jan  1 00:00:00 1970\nOS/Arch:      linux/amd64\n\n```\n\n-----\n\n*观点仅代表自己，期待你的留言。*\n","slug":"podman-env-install","published":1,"updated":"2021-09-27T03:46:41.296Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cku52dyo80040bbin90hl3fzu","content":"<h2 id=\"Linux环境信息\"><a href=\"#Linux环境信息\" class=\"headerlink\" title=\"Linux环境信息\"></a>Linux环境信息</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wujianjun@wujianjun-work:~$ cat /etc/os-release</span><br><span class=\"line\">NAME=&quot;Ubuntu&quot;</span><br><span class=\"line\">VERSION=&quot;20.04.3 LTS (Focal Fossa)&quot;</span><br><span class=\"line\">ID=ubuntu</span><br><span class=\"line\">ID_LIKE=debian</span><br><span class=\"line\">PRETTY_NAME=&quot;Ubuntu 20.04.3 LTS&quot;</span><br><span class=\"line\">VERSION_ID=&quot;20.04&quot;</span><br><span class=\"line\">HOME_URL=&quot;https://www.ubuntu.com/&quot;</span><br><span class=\"line\">SUPPORT_URL=&quot;https://help.ubuntu.com/&quot;</span><br><span class=\"line\">BUG_REPORT_URL=&quot;https://bugs.launchpad.net/ubuntu/&quot;</span><br><span class=\"line\">PRIVACY_POLICY_URL=&quot;https://www.ubuntu.com/legal/terms-and-policies/privacy-policy&quot;</span><br><span class=\"line\">VERSION_CODENAME=focal</span><br><span class=\"line\">UBUNTU_CODENAME=focal</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"安装podman\"><a href=\"#安装podman\" class=\"headerlink\" title=\"安装podman\"></a>安装podman</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wujianjun@wujianjun-work:~$ echo &quot;deb https://download.opensuse.org/repositories/devel:/kubic:/libcontainers:/stable/xUbuntu_20.04/ /&quot; | sudo tee /etc/apt/sources.list.d/devel:kubic:libcontainers:stable.list</span><br><span class=\"line\">wujianjun@wujianjun-work:~$ curl -L &quot;https://download.opensuse.org/repositories/devel:/kubic:/libcontainers:/stable/xUbuntu_20.04/Release.key&quot; | sudo apt-key add -</span><br><span class=\"line\">wujianjun@wujianjun-work:~$ sudo apt update</span><br><span class=\"line\">wujianjun@wujianjun-work:~$ sudo apt -y upgrade</span><br><span class=\"line\">wujianjun@wujianjun-work:~$ sudo apt -y install podman</span><br></pre></td></tr></table></figure>\n<p>速度有点慢。。。</p>\n<h2 id=\"设置国内镜像源\"><a href=\"#设置国内镜像源\" class=\"headerlink\" title=\"设置国内镜像源\"></a>设置国内镜像源</h2><p>由于访问速度慢，可为默认的docker.io添加加速镜像（如果后续自己搭建私服，可将镜像地址设置为私服，则每次pull时会将镜像在私服上保存一份）。<br>详细配置如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wujianjun@wujianjun-work:~$ vi /etc/containers/registries.conf 后面增加</span><br><span class=\"line\">`</span><br><span class=\"line\">[[registry]]</span><br><span class=\"line\">prefix = &quot;docker.io&quot; #需要加速的镜像地址</span><br><span class=\"line\">location = &quot;hub-mirror.c.163.com&quot; #加速器地址，可以为私服地址</span><br><span class=\"line\">insecure = true #支持加速器地址使用http进行访问</span><br><span class=\"line\">`</span><br><span class=\"line\">wujianjun@wujianjun-work:~$ sudo systemctl restart podman</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"开机自己podman\"><a href=\"#开机自己podman\" class=\"headerlink\" title=\"开机自己podman\"></a>开机自己podman</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wujianjun@wujianjun-work:~$ sudo systemctl start podman</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"验证安装版本\"><a href=\"#验证安装版本\" class=\"headerlink\" title=\"验证安装版本\"></a>验证安装版本</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wujianjun@wujianjun-work:~$ podman version</span><br><span class=\"line\">Version:      3.2.3</span><br><span class=\"line\">API Version:  3.2.3</span><br><span class=\"line\">Go Version:   go1.15.2</span><br><span class=\"line\">Built:        Thu Jan  1 00:00:00 1970</span><br><span class=\"line\">OS/Arch:      linux/amd64</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<hr>\n<p><em>观点仅代表自己，期待你的留言。</em></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"Linux环境信息\"><a href=\"#Linux环境信息\" class=\"headerlink\" title=\"Linux环境信息\"></a>Linux环境信息</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wujianjun@wujianjun-work:~$ cat /etc/os-release</span><br><span class=\"line\">NAME=&quot;Ubuntu&quot;</span><br><span class=\"line\">VERSION=&quot;20.04.3 LTS (Focal Fossa)&quot;</span><br><span class=\"line\">ID=ubuntu</span><br><span class=\"line\">ID_LIKE=debian</span><br><span class=\"line\">PRETTY_NAME=&quot;Ubuntu 20.04.3 LTS&quot;</span><br><span class=\"line\">VERSION_ID=&quot;20.04&quot;</span><br><span class=\"line\">HOME_URL=&quot;https://www.ubuntu.com/&quot;</span><br><span class=\"line\">SUPPORT_URL=&quot;https://help.ubuntu.com/&quot;</span><br><span class=\"line\">BUG_REPORT_URL=&quot;https://bugs.launchpad.net/ubuntu/&quot;</span><br><span class=\"line\">PRIVACY_POLICY_URL=&quot;https://www.ubuntu.com/legal/terms-and-policies/privacy-policy&quot;</span><br><span class=\"line\">VERSION_CODENAME=focal</span><br><span class=\"line\">UBUNTU_CODENAME=focal</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"安装podman\"><a href=\"#安装podman\" class=\"headerlink\" title=\"安装podman\"></a>安装podman</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wujianjun@wujianjun-work:~$ echo &quot;deb https://download.opensuse.org/repositories/devel:/kubic:/libcontainers:/stable/xUbuntu_20.04/ /&quot; | sudo tee /etc/apt/sources.list.d/devel:kubic:libcontainers:stable.list</span><br><span class=\"line\">wujianjun@wujianjun-work:~$ curl -L &quot;https://download.opensuse.org/repositories/devel:/kubic:/libcontainers:/stable/xUbuntu_20.04/Release.key&quot; | sudo apt-key add -</span><br><span class=\"line\">wujianjun@wujianjun-work:~$ sudo apt update</span><br><span class=\"line\">wujianjun@wujianjun-work:~$ sudo apt -y upgrade</span><br><span class=\"line\">wujianjun@wujianjun-work:~$ sudo apt -y install podman</span><br></pre></td></tr></table></figure>\n<p>速度有点慢。。。</p>\n<h2 id=\"设置国内镜像源\"><a href=\"#设置国内镜像源\" class=\"headerlink\" title=\"设置国内镜像源\"></a>设置国内镜像源</h2><p>由于访问速度慢，可为默认的docker.io添加加速镜像（如果后续自己搭建私服，可将镜像地址设置为私服，则每次pull时会将镜像在私服上保存一份）。<br>详细配置如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wujianjun@wujianjun-work:~$ vi /etc/containers/registries.conf 后面增加</span><br><span class=\"line\">`</span><br><span class=\"line\">[[registry]]</span><br><span class=\"line\">prefix = &quot;docker.io&quot; #需要加速的镜像地址</span><br><span class=\"line\">location = &quot;hub-mirror.c.163.com&quot; #加速器地址，可以为私服地址</span><br><span class=\"line\">insecure = true #支持加速器地址使用http进行访问</span><br><span class=\"line\">`</span><br><span class=\"line\">wujianjun@wujianjun-work:~$ sudo systemctl restart podman</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"开机自己podman\"><a href=\"#开机自己podman\" class=\"headerlink\" title=\"开机自己podman\"></a>开机自己podman</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wujianjun@wujianjun-work:~$ sudo systemctl start podman</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"验证安装版本\"><a href=\"#验证安装版本\" class=\"headerlink\" title=\"验证安装版本\"></a>验证安装版本</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wujianjun@wujianjun-work:~$ podman version</span><br><span class=\"line\">Version:      3.2.3</span><br><span class=\"line\">API Version:  3.2.3</span><br><span class=\"line\">Go Version:   go1.15.2</span><br><span class=\"line\">Built:        Thu Jan  1 00:00:00 1970</span><br><span class=\"line\">OS/Arch:      linux/amd64</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<hr>\n<p><em>观点仅代表自己，期待你的留言。</em></p>\n"},{"title":"Podman系列之通过docker插件完成研发机镜像创建和运行","keywords":["Podman","Docker plug-in","Can't retrieve image ID from build stream"],"date":"2021-09-27T05:51:42.000Z","_content":"\n## MacOS连接Linux的Podman REST API service\n由于Podman与Docker一样，不支持在windows和macos上运行。故可以通过在linux系统下的podman开启REST API service。由windows与macos进行远程连接。\n\n1. Linux下开启Podman REST API service\n```bash\nwujianjun@wujianjun-work:~$ podman system service -t 0 tcp:0.0.0.0:2375 &\nwujianjun@wujianjun-work:~$ podman --remote info\nhost:\n  arch: amd64\n  buildahVersion: 1.22.3\n  cgroupControllers: []\n  cgroupManager: cgroupfs\n  cgroupVersion: v1\nwujianjun@wujianjun-work:~$ podman system connection list #查看当前机器远程连接的列表\n```\n接下来MacOS或Windows就可以通过tcp://host:2375进行连接了\n\n2. 通过Ideaj下Docker Plug-in完成远程连接\n\n![Docker插件远程连接](/images/docker-plugin-remote-connect.png)\n\n## 程序打包\n\n1. 在需要打包的模块pom.xml的同级目录创建 __Dockerfile__ 文件，内容如下：\n```\nFROM adoptopenjdk/openjdk8:x86_64-ubuntu-jre8u292-b10\nARG MODULE_FILE_NAME\nADD target/${MODULE_FILE_NAME}.tar.gz /opt/\nENV TZ=Asia/Shanghai MODULE_FILE_NAME=${MODULE_FILE_NAME}\nCMD cd /opt/${MODULE_FILE_NAME} && ./bin/app restart && tail -f ./logs/console.log\n```\n\n2. 在上一步的Docker远程连接下配置打包镜像\n\n![Docker远程连接](/images/docker-plugin-image-configuration.png)\n\n`注意`：如果Dockerfile里出现错误（如Add的文件不存在时）会抛出`Dockerfile: service-gateway-biz/Dockerfile': Can't retrieve image ID from build stream`的错误。\n\n![Docker插件使用](/images/docker-plugin-notice.png)\n\n![Podman远程仓库镜像](/images/podman-images.png)\n\n通过登录进Podman仓库来看，两边的镜像与运行容器实例是一致的。\n\n-----\n\n*观点仅代表自己，期待你的留言。*\n","source":"_posts/podman-ideaj-docker-plugin.md","raw":"---\ntitle: Podman系列之通过docker插件完成研发机镜像创建和运行\ntags:\n  - 原创\n  - Podman\nkeywords:\n  - Podman\n  - Docker plug-in\n  - Can't retrieve image ID from build stream\ndate: 2021-09-27 13:51:42\n---\n\n## MacOS连接Linux的Podman REST API service\n由于Podman与Docker一样，不支持在windows和macos上运行。故可以通过在linux系统下的podman开启REST API service。由windows与macos进行远程连接。\n\n1. Linux下开启Podman REST API service\n```bash\nwujianjun@wujianjun-work:~$ podman system service -t 0 tcp:0.0.0.0:2375 &\nwujianjun@wujianjun-work:~$ podman --remote info\nhost:\n  arch: amd64\n  buildahVersion: 1.22.3\n  cgroupControllers: []\n  cgroupManager: cgroupfs\n  cgroupVersion: v1\nwujianjun@wujianjun-work:~$ podman system connection list #查看当前机器远程连接的列表\n```\n接下来MacOS或Windows就可以通过tcp://host:2375进行连接了\n\n2. 通过Ideaj下Docker Plug-in完成远程连接\n\n![Docker插件远程连接](/images/docker-plugin-remote-connect.png)\n\n## 程序打包\n\n1. 在需要打包的模块pom.xml的同级目录创建 __Dockerfile__ 文件，内容如下：\n```\nFROM adoptopenjdk/openjdk8:x86_64-ubuntu-jre8u292-b10\nARG MODULE_FILE_NAME\nADD target/${MODULE_FILE_NAME}.tar.gz /opt/\nENV TZ=Asia/Shanghai MODULE_FILE_NAME=${MODULE_FILE_NAME}\nCMD cd /opt/${MODULE_FILE_NAME} && ./bin/app restart && tail -f ./logs/console.log\n```\n\n2. 在上一步的Docker远程连接下配置打包镜像\n\n![Docker远程连接](/images/docker-plugin-image-configuration.png)\n\n`注意`：如果Dockerfile里出现错误（如Add的文件不存在时）会抛出`Dockerfile: service-gateway-biz/Dockerfile': Can't retrieve image ID from build stream`的错误。\n\n![Docker插件使用](/images/docker-plugin-notice.png)\n\n![Podman远程仓库镜像](/images/podman-images.png)\n\n通过登录进Podman仓库来看，两边的镜像与运行容器实例是一致的。\n\n-----\n\n*观点仅代表自己，期待你的留言。*\n","slug":"podman-ideaj-docker-plugin","published":1,"updated":"2021-09-28T10:36:47.639Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cku52dyo90043bbindj6o87kh","content":"<h2 id=\"MacOS连接Linux的Podman-REST-API-service\"><a href=\"#MacOS连接Linux的Podman-REST-API-service\" class=\"headerlink\" title=\"MacOS连接Linux的Podman REST API service\"></a>MacOS连接Linux的Podman REST API service</h2><p>由于Podman与Docker一样，不支持在windows和macos上运行。故可以通过在linux系统下的podman开启REST API service。由windows与macos进行远程连接。</p>\n<ol>\n<li><p>Linux下开启Podman REST API service</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wujianjun@wujianjun-work:~$ podman system service -t 0 tcp:0.0.0.0:2375 &amp;</span><br><span class=\"line\">wujianjun@wujianjun-work:~$ podman --remote info</span><br><span class=\"line\">host:</span><br><span class=\"line\">  arch: amd64</span><br><span class=\"line\">  buildahVersion: 1.22.3</span><br><span class=\"line\">  cgroupControllers: []</span><br><span class=\"line\">  cgroupManager: cgroupfs</span><br><span class=\"line\">  cgroupVersion: v1</span><br><span class=\"line\">wujianjun@wujianjun-work:~$ podman system connection list <span class=\"comment\">#查看当前机器远程连接的列表</span></span><br></pre></td></tr></table></figure>\n<p>接下来MacOS或Windows就可以通过tcp://host:2375进行连接了</p>\n</li>\n<li><p>通过Ideaj下Docker Plug-in完成远程连接</p>\n</li>\n</ol>\n<p><img src=\"/images/docker-plugin-remote-connect.png\" alt=\"Docker插件远程连接\"></p>\n<h2 id=\"程序打包\"><a href=\"#程序打包\" class=\"headerlink\" title=\"程序打包\"></a>程序打包</h2><ol>\n<li><p>在需要打包的模块pom.xml的同级目录创建 <strong>Dockerfile</strong> 文件，内容如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">FROM adoptopenjdk/openjdk8:x86_64-ubuntu-jre8u292-b10</span><br><span class=\"line\">ARG MODULE_FILE_NAME</span><br><span class=\"line\">ADD target/$&#123;MODULE_FILE_NAME&#125;.tar.gz /opt/</span><br><span class=\"line\">ENV TZ=Asia/Shanghai MODULE_FILE_NAME=$&#123;MODULE_FILE_NAME&#125;</span><br><span class=\"line\">CMD cd /opt/$&#123;MODULE_FILE_NAME&#125; &amp;&amp; ./bin/app restart &amp;&amp; tail -f ./logs/console.log</span><br></pre></td></tr></table></figure></li>\n<li><p>在上一步的Docker远程连接下配置打包镜像</p>\n</li>\n</ol>\n<p><img src=\"/images/docker-plugin-image-configuration.png\" alt=\"Docker远程连接\"></p>\n<p><code>注意</code>：如果Dockerfile里出现错误（如Add的文件不存在时）会抛出<code>Dockerfile: service-gateway-biz/Dockerfile&#39;: Can&#39;t retrieve image ID from build stream</code>的错误。</p>\n<p><img src=\"/images/docker-plugin-notice.png\" alt=\"Docker插件使用\"></p>\n<p><img src=\"/images/podman-images.png\" alt=\"Podman远程仓库镜像\"></p>\n<p>通过登录进Podman仓库来看，两边的镜像与运行容器实例是一致的。</p>\n<hr>\n<p><em>观点仅代表自己，期待你的留言。</em></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"MacOS连接Linux的Podman-REST-API-service\"><a href=\"#MacOS连接Linux的Podman-REST-API-service\" class=\"headerlink\" title=\"MacOS连接Linux的Podman REST API service\"></a>MacOS连接Linux的Podman REST API service</h2><p>由于Podman与Docker一样，不支持在windows和macos上运行。故可以通过在linux系统下的podman开启REST API service。由windows与macos进行远程连接。</p>\n<ol>\n<li><p>Linux下开启Podman REST API service</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wujianjun@wujianjun-work:~$ podman system service -t 0 tcp:0.0.0.0:2375 &amp;</span><br><span class=\"line\">wujianjun@wujianjun-work:~$ podman --remote info</span><br><span class=\"line\">host:</span><br><span class=\"line\">  arch: amd64</span><br><span class=\"line\">  buildahVersion: 1.22.3</span><br><span class=\"line\">  cgroupControllers: []</span><br><span class=\"line\">  cgroupManager: cgroupfs</span><br><span class=\"line\">  cgroupVersion: v1</span><br><span class=\"line\">wujianjun@wujianjun-work:~$ podman system connection list <span class=\"comment\">#查看当前机器远程连接的列表</span></span><br></pre></td></tr></table></figure>\n<p>接下来MacOS或Windows就可以通过tcp://host:2375进行连接了</p>\n</li>\n<li><p>通过Ideaj下Docker Plug-in完成远程连接</p>\n</li>\n</ol>\n<p><img src=\"/images/docker-plugin-remote-connect.png\" alt=\"Docker插件远程连接\"></p>\n<h2 id=\"程序打包\"><a href=\"#程序打包\" class=\"headerlink\" title=\"程序打包\"></a>程序打包</h2><ol>\n<li><p>在需要打包的模块pom.xml的同级目录创建 <strong>Dockerfile</strong> 文件，内容如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">FROM adoptopenjdk/openjdk8:x86_64-ubuntu-jre8u292-b10</span><br><span class=\"line\">ARG MODULE_FILE_NAME</span><br><span class=\"line\">ADD target/$&#123;MODULE_FILE_NAME&#125;.tar.gz /opt/</span><br><span class=\"line\">ENV TZ=Asia/Shanghai MODULE_FILE_NAME=$&#123;MODULE_FILE_NAME&#125;</span><br><span class=\"line\">CMD cd /opt/$&#123;MODULE_FILE_NAME&#125; &amp;&amp; ./bin/app restart &amp;&amp; tail -f ./logs/console.log</span><br></pre></td></tr></table></figure></li>\n<li><p>在上一步的Docker远程连接下配置打包镜像</p>\n</li>\n</ol>\n<p><img src=\"/images/docker-plugin-image-configuration.png\" alt=\"Docker远程连接\"></p>\n<p><code>注意</code>：如果Dockerfile里出现错误（如Add的文件不存在时）会抛出<code>Dockerfile: service-gateway-biz/Dockerfile&#39;: Can&#39;t retrieve image ID from build stream</code>的错误。</p>\n<p><img src=\"/images/docker-plugin-notice.png\" alt=\"Docker插件使用\"></p>\n<p><img src=\"/images/podman-images.png\" alt=\"Podman远程仓库镜像\"></p>\n<p>通过登录进Podman仓库来看，两边的镜像与运行容器实例是一致的。</p>\n<hr>\n<p><em>观点仅代表自己，期待你的留言。</em></p>\n"},{"title":"Podman系列之Nexus3私服搭建与使用","keywords":["Podman","manifest unknown","invalid status code from registry 403","server gave HTTP response to HTTPS client"],"date":"2021-09-27T03:42:20.000Z","_content":"\n## Nexus新建docker仓库\nNexus的仓库分三类\n1. docker（proxy）：用于代理其它的hub，类似mirror。\n2. docker（hosted）：用于上传本地镜像到仓库。\n3. docker（group）：可将proxy类型和hosted类型的仓库对外统一访问入口（注意不能使用这个地址进行镜像的上传）。\n\n以下为我的配置：\n\n`docker（proxy）`\n![proxy](/images/docker-proxy.png)\n\n`docker（hosted）`\n![hosted](/images/docker-hosted.png)\n\n`docker（group）`\n![group](/images/docker-group.png)\n\n`配置权限`\n![realms](/images/docker-realms.png)\n\n## podman客户端配置\n\n1. 注册私服\n\n```bash\nwujianjun@wujianjun-work:~$ vi /etc/containers/registries.conf\n`\nunqualified-search-registries = [\"docker.io\", \"quay.io\"]\n#更改docker.io镜像加速器为私服统一访问地址\n[[registry]]\nprefix = \"docker.io\"\nlocation = \"10.84.102.90:7791\"\ninsecure = true\n#更改quay.io镜像加速器为私服统一访问地址\n[[registry]]\nprefix = \"quay.io\"\nlocation = \"10.84.102.90:7791\"\ninsecure = true\n#注册group访问地址\n[[registry]]\nprefix = \"10.84.102.90:7791\"\nlocation = \"10.84.102.90:7791\"\ninsecure = true\n#注册hosted上传地址\n[[registry]]\nprefix = \"10.84.102.90:7792\"\nlocation = \"10.84.102.90:7792\"\ninsecure = true\n`\n```\n注意：`insecure`设置为true，表示支持http访问\n\n2. 重新加载\n\n```bash\nwujianjun@wujianjun-work:~$ sudo systemctl daemon-reload\nwujianjun@wujianjun-work:~$ sudo systemctl restart podman\n```\n## 测试生效\n\n接下来以redis镜像来演示效果\n![docker-images-redis](/images/docker-images-redis.png)\n\n1. 拉取镜像\n\n```bash\nwujianjun@wujianjun-work:~$ podman pull redis:latest\nResolved \"redis\" as an alias (/home/wujianjun/.cache/containers/short-name-aliases.conf)\nTrying to pull docker.io/library/redis:latest...\nGetting image source signatures\nCopying blob a330b6cecb98 skipped: already exists  \nCopying blob 4f9efe5b47a5 done  \nCopying blob 6af3a5ca4596 done  \nCopying blob 14bfbab96d75 done  \nCopying blob 8b3e2d14a955 done  \nCopying blob 5da5e1b21a2f done  \nCopying config 02c7f20544 done  \nWriting manifest to image destination\nStoring signatures\n02c7f2054405dadaf295fac7281034e998646996e9768e65a78f90af62218be3\n```\n此时再去私服上可以看到镜像已被镜像到私服上了\n\n2. 推送到私服\n\n```bash\nwujianjun@wujianjun-work:~$ podman tag redis 10.84.102.90:7792/library/myredis:1.0.0\nwujianjun@wujianjun-work:~$ podman push 10.84.102.90:7792/library/myredis:1.0.0\nGetting image source signatures\nCopying blob be5818ef2907 done  \nCopying blob c54e0c16ea22 done  \nCopying blob bdad86443e47 done  \nCopying blob 6a7992ac4800 done  \nCopying blob be43d2475cf8 done  \nCopying blob d000633a5681 done  \nCopying config 02c7f20544 done  \nWriting manifest to image destination\nStoring signatures\n```\n注意：这里要通过7792的docker-hosted上传地址进行自有镜像的上传。`library`是指镜像的basePath（这里与docker.io/的镜像保持统一便于直接拉于自上传的镜像）\n此时再去私服上可以看到myredis镜像已经可以查看到了。\n\n3. 从私服拉取\n\n```bash\nwujianjun@wujianjun-work:~$ podman pull myredis:1.0.0\n✔ docker.io/library/myredis:1.0.0\nTrying to pull docker.io/library/myredis:1.0.0...\nGetting image source signatures\nCopying blob dec078b46822 skipped: already exists  \nCopying blob c10395c8d924 done  \nCopying blob 3c4c5d2db949 done  \nCopying blob 6f8bb7da49ba done  \nCopying blob 64906f58d083 done  \nCopying blob 991f02c53ad6 done  \nCopying config 02c7f20544 done  \nWriting manifest to image destination\nStoring signatures\n02c7f2054405dadaf295fac7281034e998646996e9768e65a78f90af62218be3\nwujianjun@wujianjun-work:~$ podman images\nREPOSITORY                      TAG         IMAGE ID      CREATED      SIZE\ndocker.io/library/myredis       1.0.0       02c7f2054405  3 weeks ago  109 MB\n```\n\n## 常见问题\n1. 未登录私服\n```bash\nwujianjun@wujianjun-work:~$ podman pull redis:latest\nResolved \"redis\" as an alias (/home/wujianjun/.cache/containers/short-name-aliases.conf)\nTrying to pull docker.io/library/redis:latest...\nError: initializing source docker://redis:latest: Requesting bear token: invalid status code from registry 403 (Forbidden)\nwujianjun@wujianjun-work:~$ podman login 10.84.102.90:7791\nUsername: de^Cwujianjun@wujianjun-work:~$ podman login -u developer 10.84.102.90:7791\nPassword:\nLogin Succeeded!\nwujianjun@wujianjun-work:~$ podman pull redis:latest\nResolved \"redis\" as an alias (/home/wujianjun/.cache/containers/short-name-aliases.conf)\nTrying to pull docker.io/library/redis:latest...\nGetting image source signatures\nCopying blob a330b6cecb98 skipped: already exists  \nCopying blob 4f9efe5b47a5 done  \nCopying blob 6af3a5ca4596 done  \nCopying blob 14bfbab96d75 done  \nCopying blob 8b3e2d14a955 done  \nCopying blob 5da5e1b21a2f done  \nCopying config 02c7f20544 done  \nWriting manifest to image destination\nStoring signatures\n02c7f2054405dadaf295fac7281034e998646996e9768e65a78f90af62218be3\nwujianjun@wujianjun-work:~$\nwujianjun@wujianjun-work:~$ podman images\nREPOSITORY                      TAG         IMAGE ID      CREATED      SIZE\ndocker.io/library/redis         latest      02c7f2054405  3 weeks ago  109 MB\n```\n根因分析：由于未登录私服故返回403的错误，已登录的信息会保存在`/run/user/1000/containers/auth.json`文件中\n\n2. tag没有对应\n```bash\nwujianjun@wujianjun-work:~$ podman pull myredis:v1.0.0\n✔ docker.io/library/myredis:v1.0.0\nTrying to pull docker.io/library/myredis:v1.0.0...\nError: initializing source docker://myredis:v1.0.0: reading manifest v1.0.0 in 10.84.102.90:7791/library/myredis: manifest unknown: manifest unknown\n```\n根因分析：由于tag为v1.0.0的myredis镜像没有找到\n\n3. 未开启http访问\n```bash\nwujianjun@wujianjun-work:~$ podman pull myredis:1.0.0\n✔ docker.io/library/myredis:v1.0.0\nTrying to pull docker.io/library/myredis:1.0.0...\n  Get https://10.84.102.90:7791/v2/: http: server gave HTTP response to HTTPS client\nError: error pulling image \"10.84.102.90:7791/library/myredis\": unable to pull 10.84.102.90:7791/library/myredis: unable to pull image: Error initializing source docker://10.84.102.90:7791/library/myredis:1.0.0: error pinging docker registry 10.84.102.90:7791: Get https://10.84.102.90:7791/v2/: http: server gave HTTP response to HTTPS client\n```\n根因分析：由于在注册私服地址时没有开启`insecure = true`\n\n-----\n\n*观点仅代表自己，期待你的留言。*\n","source":"_posts/podman-private-svr.md","raw":"---\ntitle: Podman系列之Nexus3私服搭建与使用\ntags:\n  - 原创\n  - Podman\nkeywords:\n  - Podman\n  - manifest unknown\n  - invalid status code from registry 403\n  - server gave HTTP response to HTTPS client\ndate: 2021-09-27 11:42:20\n---\n\n## Nexus新建docker仓库\nNexus的仓库分三类\n1. docker（proxy）：用于代理其它的hub，类似mirror。\n2. docker（hosted）：用于上传本地镜像到仓库。\n3. docker（group）：可将proxy类型和hosted类型的仓库对外统一访问入口（注意不能使用这个地址进行镜像的上传）。\n\n以下为我的配置：\n\n`docker（proxy）`\n![proxy](/images/docker-proxy.png)\n\n`docker（hosted）`\n![hosted](/images/docker-hosted.png)\n\n`docker（group）`\n![group](/images/docker-group.png)\n\n`配置权限`\n![realms](/images/docker-realms.png)\n\n## podman客户端配置\n\n1. 注册私服\n\n```bash\nwujianjun@wujianjun-work:~$ vi /etc/containers/registries.conf\n`\nunqualified-search-registries = [\"docker.io\", \"quay.io\"]\n#更改docker.io镜像加速器为私服统一访问地址\n[[registry]]\nprefix = \"docker.io\"\nlocation = \"10.84.102.90:7791\"\ninsecure = true\n#更改quay.io镜像加速器为私服统一访问地址\n[[registry]]\nprefix = \"quay.io\"\nlocation = \"10.84.102.90:7791\"\ninsecure = true\n#注册group访问地址\n[[registry]]\nprefix = \"10.84.102.90:7791\"\nlocation = \"10.84.102.90:7791\"\ninsecure = true\n#注册hosted上传地址\n[[registry]]\nprefix = \"10.84.102.90:7792\"\nlocation = \"10.84.102.90:7792\"\ninsecure = true\n`\n```\n注意：`insecure`设置为true，表示支持http访问\n\n2. 重新加载\n\n```bash\nwujianjun@wujianjun-work:~$ sudo systemctl daemon-reload\nwujianjun@wujianjun-work:~$ sudo systemctl restart podman\n```\n## 测试生效\n\n接下来以redis镜像来演示效果\n![docker-images-redis](/images/docker-images-redis.png)\n\n1. 拉取镜像\n\n```bash\nwujianjun@wujianjun-work:~$ podman pull redis:latest\nResolved \"redis\" as an alias (/home/wujianjun/.cache/containers/short-name-aliases.conf)\nTrying to pull docker.io/library/redis:latest...\nGetting image source signatures\nCopying blob a330b6cecb98 skipped: already exists  \nCopying blob 4f9efe5b47a5 done  \nCopying blob 6af3a5ca4596 done  \nCopying blob 14bfbab96d75 done  \nCopying blob 8b3e2d14a955 done  \nCopying blob 5da5e1b21a2f done  \nCopying config 02c7f20544 done  \nWriting manifest to image destination\nStoring signatures\n02c7f2054405dadaf295fac7281034e998646996e9768e65a78f90af62218be3\n```\n此时再去私服上可以看到镜像已被镜像到私服上了\n\n2. 推送到私服\n\n```bash\nwujianjun@wujianjun-work:~$ podman tag redis 10.84.102.90:7792/library/myredis:1.0.0\nwujianjun@wujianjun-work:~$ podman push 10.84.102.90:7792/library/myredis:1.0.0\nGetting image source signatures\nCopying blob be5818ef2907 done  \nCopying blob c54e0c16ea22 done  \nCopying blob bdad86443e47 done  \nCopying blob 6a7992ac4800 done  \nCopying blob be43d2475cf8 done  \nCopying blob d000633a5681 done  \nCopying config 02c7f20544 done  \nWriting manifest to image destination\nStoring signatures\n```\n注意：这里要通过7792的docker-hosted上传地址进行自有镜像的上传。`library`是指镜像的basePath（这里与docker.io/的镜像保持统一便于直接拉于自上传的镜像）\n此时再去私服上可以看到myredis镜像已经可以查看到了。\n\n3. 从私服拉取\n\n```bash\nwujianjun@wujianjun-work:~$ podman pull myredis:1.0.0\n✔ docker.io/library/myredis:1.0.0\nTrying to pull docker.io/library/myredis:1.0.0...\nGetting image source signatures\nCopying blob dec078b46822 skipped: already exists  \nCopying blob c10395c8d924 done  \nCopying blob 3c4c5d2db949 done  \nCopying blob 6f8bb7da49ba done  \nCopying blob 64906f58d083 done  \nCopying blob 991f02c53ad6 done  \nCopying config 02c7f20544 done  \nWriting manifest to image destination\nStoring signatures\n02c7f2054405dadaf295fac7281034e998646996e9768e65a78f90af62218be3\nwujianjun@wujianjun-work:~$ podman images\nREPOSITORY                      TAG         IMAGE ID      CREATED      SIZE\ndocker.io/library/myredis       1.0.0       02c7f2054405  3 weeks ago  109 MB\n```\n\n## 常见问题\n1. 未登录私服\n```bash\nwujianjun@wujianjun-work:~$ podman pull redis:latest\nResolved \"redis\" as an alias (/home/wujianjun/.cache/containers/short-name-aliases.conf)\nTrying to pull docker.io/library/redis:latest...\nError: initializing source docker://redis:latest: Requesting bear token: invalid status code from registry 403 (Forbidden)\nwujianjun@wujianjun-work:~$ podman login 10.84.102.90:7791\nUsername: de^Cwujianjun@wujianjun-work:~$ podman login -u developer 10.84.102.90:7791\nPassword:\nLogin Succeeded!\nwujianjun@wujianjun-work:~$ podman pull redis:latest\nResolved \"redis\" as an alias (/home/wujianjun/.cache/containers/short-name-aliases.conf)\nTrying to pull docker.io/library/redis:latest...\nGetting image source signatures\nCopying blob a330b6cecb98 skipped: already exists  \nCopying blob 4f9efe5b47a5 done  \nCopying blob 6af3a5ca4596 done  \nCopying blob 14bfbab96d75 done  \nCopying blob 8b3e2d14a955 done  \nCopying blob 5da5e1b21a2f done  \nCopying config 02c7f20544 done  \nWriting manifest to image destination\nStoring signatures\n02c7f2054405dadaf295fac7281034e998646996e9768e65a78f90af62218be3\nwujianjun@wujianjun-work:~$\nwujianjun@wujianjun-work:~$ podman images\nREPOSITORY                      TAG         IMAGE ID      CREATED      SIZE\ndocker.io/library/redis         latest      02c7f2054405  3 weeks ago  109 MB\n```\n根因分析：由于未登录私服故返回403的错误，已登录的信息会保存在`/run/user/1000/containers/auth.json`文件中\n\n2. tag没有对应\n```bash\nwujianjun@wujianjun-work:~$ podman pull myredis:v1.0.0\n✔ docker.io/library/myredis:v1.0.0\nTrying to pull docker.io/library/myredis:v1.0.0...\nError: initializing source docker://myredis:v1.0.0: reading manifest v1.0.0 in 10.84.102.90:7791/library/myredis: manifest unknown: manifest unknown\n```\n根因分析：由于tag为v1.0.0的myredis镜像没有找到\n\n3. 未开启http访问\n```bash\nwujianjun@wujianjun-work:~$ podman pull myredis:1.0.0\n✔ docker.io/library/myredis:v1.0.0\nTrying to pull docker.io/library/myredis:1.0.0...\n  Get https://10.84.102.90:7791/v2/: http: server gave HTTP response to HTTPS client\nError: error pulling image \"10.84.102.90:7791/library/myredis\": unable to pull 10.84.102.90:7791/library/myredis: unable to pull image: Error initializing source docker://10.84.102.90:7791/library/myredis:1.0.0: error pinging docker registry 10.84.102.90:7791: Get https://10.84.102.90:7791/v2/: http: server gave HTTP response to HTTPS client\n```\n根因分析：由于在注册私服地址时没有开启`insecure = true`\n\n-----\n\n*观点仅代表自己，期待你的留言。*\n","slug":"podman-private-svr","published":1,"updated":"2021-09-28T08:26:16.938Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cku52dyoa0045bbindsum40go","content":"<h2 id=\"Nexus新建docker仓库\"><a href=\"#Nexus新建docker仓库\" class=\"headerlink\" title=\"Nexus新建docker仓库\"></a>Nexus新建docker仓库</h2><p>Nexus的仓库分三类</p>\n<ol>\n<li>docker（proxy）：用于代理其它的hub，类似mirror。</li>\n<li>docker（hosted）：用于上传本地镜像到仓库。</li>\n<li>docker（group）：可将proxy类型和hosted类型的仓库对外统一访问入口（注意不能使用这个地址进行镜像的上传）。</li>\n</ol>\n<p>以下为我的配置：</p>\n<p><code>docker（proxy）</code><br><img src=\"/images/docker-proxy.png\" alt=\"proxy\"></p>\n<p><code>docker（hosted）</code><br><img src=\"/images/docker-hosted.png\" alt=\"hosted\"></p>\n<p><code>docker（group）</code><br><img src=\"/images/docker-group.png\" alt=\"group\"></p>\n<p><code>配置权限</code><br><img src=\"/images/docker-realms.png\" alt=\"realms\"></p>\n<h2 id=\"podman客户端配置\"><a href=\"#podman客户端配置\" class=\"headerlink\" title=\"podman客户端配置\"></a>podman客户端配置</h2><ol>\n<li>注册私服</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wujianjun@wujianjun-work:~$ vi /etc/containers/registries.conf</span><br><span class=\"line\">`</span><br><span class=\"line\">unqualified-search-registries = [<span class=\"string\">&quot;docker.io&quot;</span>, <span class=\"string\">&quot;quay.io&quot;</span>]</span><br><span class=\"line\"><span class=\"comment\">#更改docker.io镜像加速器为私服统一访问地址</span></span><br><span class=\"line\">[[registry]]</span><br><span class=\"line\">prefix = <span class=\"string\">&quot;docker.io&quot;</span></span><br><span class=\"line\">location = <span class=\"string\">&quot;10.84.102.90:7791&quot;</span></span><br><span class=\"line\">insecure = <span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"comment\">#更改quay.io镜像加速器为私服统一访问地址</span></span><br><span class=\"line\">[[registry]]</span><br><span class=\"line\">prefix = <span class=\"string\">&quot;quay.io&quot;</span></span><br><span class=\"line\">location = <span class=\"string\">&quot;10.84.102.90:7791&quot;</span></span><br><span class=\"line\">insecure = <span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"comment\">#注册group访问地址</span></span><br><span class=\"line\">[[registry]]</span><br><span class=\"line\">prefix = <span class=\"string\">&quot;10.84.102.90:7791&quot;</span></span><br><span class=\"line\">location = <span class=\"string\">&quot;10.84.102.90:7791&quot;</span></span><br><span class=\"line\">insecure = <span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"comment\">#注册hosted上传地址</span></span><br><span class=\"line\">[[registry]]</span><br><span class=\"line\">prefix = <span class=\"string\">&quot;10.84.102.90:7792&quot;</span></span><br><span class=\"line\">location = <span class=\"string\">&quot;10.84.102.90:7792&quot;</span></span><br><span class=\"line\">insecure = <span class=\"literal\">true</span></span><br><span class=\"line\">`</span><br></pre></td></tr></table></figure>\n<p>注意：<code>insecure</code>设置为true，表示支持http访问</p>\n<ol start=\"2\">\n<li>重新加载</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wujianjun@wujianjun-work:~$ sudo systemctl daemon-reload</span><br><span class=\"line\">wujianjun@wujianjun-work:~$ sudo systemctl restart podman</span><br></pre></td></tr></table></figure>\n<h2 id=\"测试生效\"><a href=\"#测试生效\" class=\"headerlink\" title=\"测试生效\"></a>测试生效</h2><p>接下来以redis镜像来演示效果<br><img src=\"/images/docker-images-redis.png\" alt=\"docker-images-redis\"></p>\n<ol>\n<li>拉取镜像</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wujianjun@wujianjun-work:~$ podman pull redis:latest</span><br><span class=\"line\">Resolved <span class=\"string\">&quot;redis&quot;</span> as an <span class=\"built_in\">alias</span> (/home/wujianjun/.cache/containers/short-name-aliases.conf)</span><br><span class=\"line\">Trying to pull docker.io/library/redis:latest...</span><br><span class=\"line\">Getting image <span class=\"built_in\">source</span> signatures</span><br><span class=\"line\">Copying blob a330b6cecb98 skipped: already exists  </span><br><span class=\"line\">Copying blob 4f9efe5b47a5 <span class=\"keyword\">done</span>  </span><br><span class=\"line\">Copying blob 6af3a5ca4596 <span class=\"keyword\">done</span>  </span><br><span class=\"line\">Copying blob 14bfbab96d75 <span class=\"keyword\">done</span>  </span><br><span class=\"line\">Copying blob 8b3e2d14a955 <span class=\"keyword\">done</span>  </span><br><span class=\"line\">Copying blob 5da5e1b21a2f <span class=\"keyword\">done</span>  </span><br><span class=\"line\">Copying config 02c7f20544 <span class=\"keyword\">done</span>  </span><br><span class=\"line\">Writing manifest to image destination</span><br><span class=\"line\">Storing signatures</span><br><span class=\"line\">02c7f2054405dadaf295fac7281034e998646996e9768e65a78f90af62218be3</span><br></pre></td></tr></table></figure>\n<p>此时再去私服上可以看到镜像已被镜像到私服上了</p>\n<ol start=\"2\">\n<li>推送到私服</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wujianjun@wujianjun-work:~$ podman tag redis 10.84.102.90:7792/library/myredis:1.0.0</span><br><span class=\"line\">wujianjun@wujianjun-work:~$ podman push 10.84.102.90:7792/library/myredis:1.0.0</span><br><span class=\"line\">Getting image <span class=\"built_in\">source</span> signatures</span><br><span class=\"line\">Copying blob be5818ef2907 <span class=\"keyword\">done</span>  </span><br><span class=\"line\">Copying blob c54e0c16ea22 <span class=\"keyword\">done</span>  </span><br><span class=\"line\">Copying blob bdad86443e47 <span class=\"keyword\">done</span>  </span><br><span class=\"line\">Copying blob 6a7992ac4800 <span class=\"keyword\">done</span>  </span><br><span class=\"line\">Copying blob be43d2475cf8 <span class=\"keyword\">done</span>  </span><br><span class=\"line\">Copying blob d000633a5681 <span class=\"keyword\">done</span>  </span><br><span class=\"line\">Copying config 02c7f20544 <span class=\"keyword\">done</span>  </span><br><span class=\"line\">Writing manifest to image destination</span><br><span class=\"line\">Storing signatures</span><br></pre></td></tr></table></figure>\n<p>注意：这里要通过7792的docker-hosted上传地址进行自有镜像的上传。<code>library</code>是指镜像的basePath（这里与docker.io/的镜像保持统一便于直接拉于自上传的镜像）<br>此时再去私服上可以看到myredis镜像已经可以查看到了。</p>\n<ol start=\"3\">\n<li>从私服拉取</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wujianjun@wujianjun-work:~$ podman pull myredis:1.0.0</span><br><span class=\"line\">✔ docker.io/library/myredis:1.0.0</span><br><span class=\"line\">Trying to pull docker.io/library/myredis:1.0.0...</span><br><span class=\"line\">Getting image <span class=\"built_in\">source</span> signatures</span><br><span class=\"line\">Copying blob dec078b46822 skipped: already exists  </span><br><span class=\"line\">Copying blob c10395c8d924 <span class=\"keyword\">done</span>  </span><br><span class=\"line\">Copying blob 3c4c5d2db949 <span class=\"keyword\">done</span>  </span><br><span class=\"line\">Copying blob 6f8bb7da49ba <span class=\"keyword\">done</span>  </span><br><span class=\"line\">Copying blob 64906f58d083 <span class=\"keyword\">done</span>  </span><br><span class=\"line\">Copying blob 991f02c53ad6 <span class=\"keyword\">done</span>  </span><br><span class=\"line\">Copying config 02c7f20544 <span class=\"keyword\">done</span>  </span><br><span class=\"line\">Writing manifest to image destination</span><br><span class=\"line\">Storing signatures</span><br><span class=\"line\">02c7f2054405dadaf295fac7281034e998646996e9768e65a78f90af62218be3</span><br><span class=\"line\">wujianjun@wujianjun-work:~$ podman images</span><br><span class=\"line\">REPOSITORY                      TAG         IMAGE ID      CREATED      SIZE</span><br><span class=\"line\">docker.io/library/myredis       1.0.0       02c7f2054405  3 weeks ago  109 MB</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"常见问题\"><a href=\"#常见问题\" class=\"headerlink\" title=\"常见问题\"></a>常见问题</h2><ol>\n<li><p>未登录私服</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wujianjun@wujianjun-work:~$ podman pull redis:latest</span><br><span class=\"line\">Resolved <span class=\"string\">&quot;redis&quot;</span> as an <span class=\"built_in\">alias</span> (/home/wujianjun/.cache/containers/short-name-aliases.conf)</span><br><span class=\"line\">Trying to pull docker.io/library/redis:latest...</span><br><span class=\"line\">Error: initializing <span class=\"built_in\">source</span> docker://redis:latest: Requesting bear token: invalid status code from registry 403 (Forbidden)</span><br><span class=\"line\">wujianjun@wujianjun-work:~$ podman login 10.84.102.90:7791</span><br><span class=\"line\">Username: de^Cwujianjun@wujianjun-work:~$ podman login -u developer 10.84.102.90:7791</span><br><span class=\"line\">Password:</span><br><span class=\"line\">Login Succeeded!</span><br><span class=\"line\">wujianjun@wujianjun-work:~$ podman pull redis:latest</span><br><span class=\"line\">Resolved <span class=\"string\">&quot;redis&quot;</span> as an <span class=\"built_in\">alias</span> (/home/wujianjun/.cache/containers/short-name-aliases.conf)</span><br><span class=\"line\">Trying to pull docker.io/library/redis:latest...</span><br><span class=\"line\">Getting image <span class=\"built_in\">source</span> signatures</span><br><span class=\"line\">Copying blob a330b6cecb98 skipped: already exists  </span><br><span class=\"line\">Copying blob 4f9efe5b47a5 <span class=\"keyword\">done</span>  </span><br><span class=\"line\">Copying blob 6af3a5ca4596 <span class=\"keyword\">done</span>  </span><br><span class=\"line\">Copying blob 14bfbab96d75 <span class=\"keyword\">done</span>  </span><br><span class=\"line\">Copying blob 8b3e2d14a955 <span class=\"keyword\">done</span>  </span><br><span class=\"line\">Copying blob 5da5e1b21a2f <span class=\"keyword\">done</span>  </span><br><span class=\"line\">Copying config 02c7f20544 <span class=\"keyword\">done</span>  </span><br><span class=\"line\">Writing manifest to image destination</span><br><span class=\"line\">Storing signatures</span><br><span class=\"line\">02c7f2054405dadaf295fac7281034e998646996e9768e65a78f90af62218be3</span><br><span class=\"line\">wujianjun@wujianjun-work:~$</span><br><span class=\"line\">wujianjun@wujianjun-work:~$ podman images</span><br><span class=\"line\">REPOSITORY                      TAG         IMAGE ID      CREATED      SIZE</span><br><span class=\"line\">docker.io/library/redis         latest      02c7f2054405  3 weeks ago  109 MB</span><br></pre></td></tr></table></figure>\n<p>根因分析：由于未登录私服故返回403的错误，已登录的信息会保存在<code>/run/user/1000/containers/auth.json</code>文件中</p>\n</li>\n<li><p>tag没有对应</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wujianjun@wujianjun-work:~$ podman pull myredis:v1.0.0</span><br><span class=\"line\">✔ docker.io/library/myredis:v1.0.0</span><br><span class=\"line\">Trying to pull docker.io/library/myredis:v1.0.0...</span><br><span class=\"line\">Error: initializing <span class=\"built_in\">source</span> docker://myredis:v1.0.0: reading manifest v1.0.0 <span class=\"keyword\">in</span> 10.84.102.90:7791/library/myredis: manifest unknown: manifest unknown</span><br></pre></td></tr></table></figure>\n<p>根因分析：由于tag为v1.0.0的myredis镜像没有找到</p>\n</li>\n<li><p>未开启http访问</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wujianjun@wujianjun-work:~$ podman pull myredis:1.0.0</span><br><span class=\"line\">✔ docker.io/library/myredis:v1.0.0</span><br><span class=\"line\">Trying to pull docker.io/library/myredis:1.0.0...</span><br><span class=\"line\">  Get https://10.84.102.90:7791/v2/: http: server gave HTTP response to HTTPS client</span><br><span class=\"line\">Error: error pulling image <span class=\"string\">&quot;10.84.102.90:7791/library/myredis&quot;</span>: unable to pull 10.84.102.90:7791/library/myredis: unable to pull image: Error initializing <span class=\"built_in\">source</span> docker://10.84.102.90:7791/library/myredis:1.0.0: error pinging docker registry 10.84.102.90:7791: Get https://10.84.102.90:7791/v2/: http: server gave HTTP response to HTTPS client</span><br></pre></td></tr></table></figure>\n<p>根因分析：由于在注册私服地址时没有开启<code>insecure = true</code></p>\n</li>\n</ol>\n<hr>\n<p><em>观点仅代表自己，期待你的留言。</em></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"Nexus新建docker仓库\"><a href=\"#Nexus新建docker仓库\" class=\"headerlink\" title=\"Nexus新建docker仓库\"></a>Nexus新建docker仓库</h2><p>Nexus的仓库分三类</p>\n<ol>\n<li>docker（proxy）：用于代理其它的hub，类似mirror。</li>\n<li>docker（hosted）：用于上传本地镜像到仓库。</li>\n<li>docker（group）：可将proxy类型和hosted类型的仓库对外统一访问入口（注意不能使用这个地址进行镜像的上传）。</li>\n</ol>\n<p>以下为我的配置：</p>\n<p><code>docker（proxy）</code><br><img src=\"/images/docker-proxy.png\" alt=\"proxy\"></p>\n<p><code>docker（hosted）</code><br><img src=\"/images/docker-hosted.png\" alt=\"hosted\"></p>\n<p><code>docker（group）</code><br><img src=\"/images/docker-group.png\" alt=\"group\"></p>\n<p><code>配置权限</code><br><img src=\"/images/docker-realms.png\" alt=\"realms\"></p>\n<h2 id=\"podman客户端配置\"><a href=\"#podman客户端配置\" class=\"headerlink\" title=\"podman客户端配置\"></a>podman客户端配置</h2><ol>\n<li>注册私服</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wujianjun@wujianjun-work:~$ vi /etc/containers/registries.conf</span><br><span class=\"line\">`</span><br><span class=\"line\">unqualified-search-registries = [<span class=\"string\">&quot;docker.io&quot;</span>, <span class=\"string\">&quot;quay.io&quot;</span>]</span><br><span class=\"line\"><span class=\"comment\">#更改docker.io镜像加速器为私服统一访问地址</span></span><br><span class=\"line\">[[registry]]</span><br><span class=\"line\">prefix = <span class=\"string\">&quot;docker.io&quot;</span></span><br><span class=\"line\">location = <span class=\"string\">&quot;10.84.102.90:7791&quot;</span></span><br><span class=\"line\">insecure = <span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"comment\">#更改quay.io镜像加速器为私服统一访问地址</span></span><br><span class=\"line\">[[registry]]</span><br><span class=\"line\">prefix = <span class=\"string\">&quot;quay.io&quot;</span></span><br><span class=\"line\">location = <span class=\"string\">&quot;10.84.102.90:7791&quot;</span></span><br><span class=\"line\">insecure = <span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"comment\">#注册group访问地址</span></span><br><span class=\"line\">[[registry]]</span><br><span class=\"line\">prefix = <span class=\"string\">&quot;10.84.102.90:7791&quot;</span></span><br><span class=\"line\">location = <span class=\"string\">&quot;10.84.102.90:7791&quot;</span></span><br><span class=\"line\">insecure = <span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"comment\">#注册hosted上传地址</span></span><br><span class=\"line\">[[registry]]</span><br><span class=\"line\">prefix = <span class=\"string\">&quot;10.84.102.90:7792&quot;</span></span><br><span class=\"line\">location = <span class=\"string\">&quot;10.84.102.90:7792&quot;</span></span><br><span class=\"line\">insecure = <span class=\"literal\">true</span></span><br><span class=\"line\">`</span><br></pre></td></tr></table></figure>\n<p>注意：<code>insecure</code>设置为true，表示支持http访问</p>\n<ol start=\"2\">\n<li>重新加载</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wujianjun@wujianjun-work:~$ sudo systemctl daemon-reload</span><br><span class=\"line\">wujianjun@wujianjun-work:~$ sudo systemctl restart podman</span><br></pre></td></tr></table></figure>\n<h2 id=\"测试生效\"><a href=\"#测试生效\" class=\"headerlink\" title=\"测试生效\"></a>测试生效</h2><p>接下来以redis镜像来演示效果<br><img src=\"/images/docker-images-redis.png\" alt=\"docker-images-redis\"></p>\n<ol>\n<li>拉取镜像</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wujianjun@wujianjun-work:~$ podman pull redis:latest</span><br><span class=\"line\">Resolved <span class=\"string\">&quot;redis&quot;</span> as an <span class=\"built_in\">alias</span> (/home/wujianjun/.cache/containers/short-name-aliases.conf)</span><br><span class=\"line\">Trying to pull docker.io/library/redis:latest...</span><br><span class=\"line\">Getting image <span class=\"built_in\">source</span> signatures</span><br><span class=\"line\">Copying blob a330b6cecb98 skipped: already exists  </span><br><span class=\"line\">Copying blob 4f9efe5b47a5 <span class=\"keyword\">done</span>  </span><br><span class=\"line\">Copying blob 6af3a5ca4596 <span class=\"keyword\">done</span>  </span><br><span class=\"line\">Copying blob 14bfbab96d75 <span class=\"keyword\">done</span>  </span><br><span class=\"line\">Copying blob 8b3e2d14a955 <span class=\"keyword\">done</span>  </span><br><span class=\"line\">Copying blob 5da5e1b21a2f <span class=\"keyword\">done</span>  </span><br><span class=\"line\">Copying config 02c7f20544 <span class=\"keyword\">done</span>  </span><br><span class=\"line\">Writing manifest to image destination</span><br><span class=\"line\">Storing signatures</span><br><span class=\"line\">02c7f2054405dadaf295fac7281034e998646996e9768e65a78f90af62218be3</span><br></pre></td></tr></table></figure>\n<p>此时再去私服上可以看到镜像已被镜像到私服上了</p>\n<ol start=\"2\">\n<li>推送到私服</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wujianjun@wujianjun-work:~$ podman tag redis 10.84.102.90:7792/library/myredis:1.0.0</span><br><span class=\"line\">wujianjun@wujianjun-work:~$ podman push 10.84.102.90:7792/library/myredis:1.0.0</span><br><span class=\"line\">Getting image <span class=\"built_in\">source</span> signatures</span><br><span class=\"line\">Copying blob be5818ef2907 <span class=\"keyword\">done</span>  </span><br><span class=\"line\">Copying blob c54e0c16ea22 <span class=\"keyword\">done</span>  </span><br><span class=\"line\">Copying blob bdad86443e47 <span class=\"keyword\">done</span>  </span><br><span class=\"line\">Copying blob 6a7992ac4800 <span class=\"keyword\">done</span>  </span><br><span class=\"line\">Copying blob be43d2475cf8 <span class=\"keyword\">done</span>  </span><br><span class=\"line\">Copying blob d000633a5681 <span class=\"keyword\">done</span>  </span><br><span class=\"line\">Copying config 02c7f20544 <span class=\"keyword\">done</span>  </span><br><span class=\"line\">Writing manifest to image destination</span><br><span class=\"line\">Storing signatures</span><br></pre></td></tr></table></figure>\n<p>注意：这里要通过7792的docker-hosted上传地址进行自有镜像的上传。<code>library</code>是指镜像的basePath（这里与docker.io/的镜像保持统一便于直接拉于自上传的镜像）<br>此时再去私服上可以看到myredis镜像已经可以查看到了。</p>\n<ol start=\"3\">\n<li>从私服拉取</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wujianjun@wujianjun-work:~$ podman pull myredis:1.0.0</span><br><span class=\"line\">✔ docker.io/library/myredis:1.0.0</span><br><span class=\"line\">Trying to pull docker.io/library/myredis:1.0.0...</span><br><span class=\"line\">Getting image <span class=\"built_in\">source</span> signatures</span><br><span class=\"line\">Copying blob dec078b46822 skipped: already exists  </span><br><span class=\"line\">Copying blob c10395c8d924 <span class=\"keyword\">done</span>  </span><br><span class=\"line\">Copying blob 3c4c5d2db949 <span class=\"keyword\">done</span>  </span><br><span class=\"line\">Copying blob 6f8bb7da49ba <span class=\"keyword\">done</span>  </span><br><span class=\"line\">Copying blob 64906f58d083 <span class=\"keyword\">done</span>  </span><br><span class=\"line\">Copying blob 991f02c53ad6 <span class=\"keyword\">done</span>  </span><br><span class=\"line\">Copying config 02c7f20544 <span class=\"keyword\">done</span>  </span><br><span class=\"line\">Writing manifest to image destination</span><br><span class=\"line\">Storing signatures</span><br><span class=\"line\">02c7f2054405dadaf295fac7281034e998646996e9768e65a78f90af62218be3</span><br><span class=\"line\">wujianjun@wujianjun-work:~$ podman images</span><br><span class=\"line\">REPOSITORY                      TAG         IMAGE ID      CREATED      SIZE</span><br><span class=\"line\">docker.io/library/myredis       1.0.0       02c7f2054405  3 weeks ago  109 MB</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"常见问题\"><a href=\"#常见问题\" class=\"headerlink\" title=\"常见问题\"></a>常见问题</h2><ol>\n<li><p>未登录私服</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wujianjun@wujianjun-work:~$ podman pull redis:latest</span><br><span class=\"line\">Resolved <span class=\"string\">&quot;redis&quot;</span> as an <span class=\"built_in\">alias</span> (/home/wujianjun/.cache/containers/short-name-aliases.conf)</span><br><span class=\"line\">Trying to pull docker.io/library/redis:latest...</span><br><span class=\"line\">Error: initializing <span class=\"built_in\">source</span> docker://redis:latest: Requesting bear token: invalid status code from registry 403 (Forbidden)</span><br><span class=\"line\">wujianjun@wujianjun-work:~$ podman login 10.84.102.90:7791</span><br><span class=\"line\">Username: de^Cwujianjun@wujianjun-work:~$ podman login -u developer 10.84.102.90:7791</span><br><span class=\"line\">Password:</span><br><span class=\"line\">Login Succeeded!</span><br><span class=\"line\">wujianjun@wujianjun-work:~$ podman pull redis:latest</span><br><span class=\"line\">Resolved <span class=\"string\">&quot;redis&quot;</span> as an <span class=\"built_in\">alias</span> (/home/wujianjun/.cache/containers/short-name-aliases.conf)</span><br><span class=\"line\">Trying to pull docker.io/library/redis:latest...</span><br><span class=\"line\">Getting image <span class=\"built_in\">source</span> signatures</span><br><span class=\"line\">Copying blob a330b6cecb98 skipped: already exists  </span><br><span class=\"line\">Copying blob 4f9efe5b47a5 <span class=\"keyword\">done</span>  </span><br><span class=\"line\">Copying blob 6af3a5ca4596 <span class=\"keyword\">done</span>  </span><br><span class=\"line\">Copying blob 14bfbab96d75 <span class=\"keyword\">done</span>  </span><br><span class=\"line\">Copying blob 8b3e2d14a955 <span class=\"keyword\">done</span>  </span><br><span class=\"line\">Copying blob 5da5e1b21a2f <span class=\"keyword\">done</span>  </span><br><span class=\"line\">Copying config 02c7f20544 <span class=\"keyword\">done</span>  </span><br><span class=\"line\">Writing manifest to image destination</span><br><span class=\"line\">Storing signatures</span><br><span class=\"line\">02c7f2054405dadaf295fac7281034e998646996e9768e65a78f90af62218be3</span><br><span class=\"line\">wujianjun@wujianjun-work:~$</span><br><span class=\"line\">wujianjun@wujianjun-work:~$ podman images</span><br><span class=\"line\">REPOSITORY                      TAG         IMAGE ID      CREATED      SIZE</span><br><span class=\"line\">docker.io/library/redis         latest      02c7f2054405  3 weeks ago  109 MB</span><br></pre></td></tr></table></figure>\n<p>根因分析：由于未登录私服故返回403的错误，已登录的信息会保存在<code>/run/user/1000/containers/auth.json</code>文件中</p>\n</li>\n<li><p>tag没有对应</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wujianjun@wujianjun-work:~$ podman pull myredis:v1.0.0</span><br><span class=\"line\">✔ docker.io/library/myredis:v1.0.0</span><br><span class=\"line\">Trying to pull docker.io/library/myredis:v1.0.0...</span><br><span class=\"line\">Error: initializing <span class=\"built_in\">source</span> docker://myredis:v1.0.0: reading manifest v1.0.0 <span class=\"keyword\">in</span> 10.84.102.90:7791/library/myredis: manifest unknown: manifest unknown</span><br></pre></td></tr></table></figure>\n<p>根因分析：由于tag为v1.0.0的myredis镜像没有找到</p>\n</li>\n<li><p>未开启http访问</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wujianjun@wujianjun-work:~$ podman pull myredis:1.0.0</span><br><span class=\"line\">✔ docker.io/library/myredis:v1.0.0</span><br><span class=\"line\">Trying to pull docker.io/library/myredis:1.0.0...</span><br><span class=\"line\">  Get https://10.84.102.90:7791/v2/: http: server gave HTTP response to HTTPS client</span><br><span class=\"line\">Error: error pulling image <span class=\"string\">&quot;10.84.102.90:7791/library/myredis&quot;</span>: unable to pull 10.84.102.90:7791/library/myredis: unable to pull image: Error initializing <span class=\"built_in\">source</span> docker://10.84.102.90:7791/library/myredis:1.0.0: error pinging docker registry 10.84.102.90:7791: Get https://10.84.102.90:7791/v2/: http: server gave HTTP response to HTTPS client</span><br></pre></td></tr></table></figure>\n<p>根因分析：由于在注册私服地址时没有开启<code>insecure = true</code></p>\n</li>\n</ol>\n<hr>\n<p><em>观点仅代表自己，期待你的留言。</em></p>\n"},{"title":"redis进阶","keywords":["redis","集群"],"date":"2018-04-10T08:30:13.000Z","_content":"## redis主从（读写分离）\n__问题：__\n - redis为单进程程序，只能占用单核，无法充分使用多核的系统资源。\n - 单节点redis在出现故障时则无法继续提供数据存储服务，无法达到高可用要求。\n__解决方法：__\n - 增加redis slave节点通过replicas进行`master-slave`的数据复制，故障时手动恢复。\n - 通过增加`sentinel(哨兵)`监控redis master-slave节点的存活状态，当master出现故障时自动将slave升级为master继续提供服务。\n\n## data sharding（数据分片）\n__问题：__\n  单台redis节点的内存总量有限，达到上限后想要扩容除了增加内存别无它法\n__解决方法：__\n - redis client (部署多个独立的redis节点，通过在`客户端代码中针对key进行hash`，然后将数据按hash映射存储到不同的redis中)\n - Twemproxy (部署多个独立的redis节点，通过引入twitter开源中间件封装key的hash操作，最终将数据存储到不同的redis中)\n\n## redis cluster集群\n__问题：__\n  单台redis节点的内存容量有限，达到上限后想要扩容除了增加内存别无它法\n__解决方法：__\n - 将所有的redis节点的内存总容量划分为n个`哈希槽(hash slot)`(默认为16384个)，每一个redis节点负责一段solt，存取数据时通过CRC16算法对key进行取余来决定应该从哪一个redis节点进行存取操作。\n   redis节点两两连接共同形成一个集群，客户端代码连接集群中`任意节点`进行存取服务，集群中的节点会通过`CRC16算法`来将存取请求`转发`到目标redis节点完成数据的存取。\n - 通过在集群内挑选一部分节点设置为slave节点，通过master-slave构建高可用redis服务\n","source":"_posts/redis-advanced.md","raw":"---\ntitle: redis进阶\nkeywords:\n  - redis\n  - 集群\ntags:\n  - 原创\ndate: 2018-04-10 16:30:13\n---\n## redis主从（读写分离）\n__问题：__\n - redis为单进程程序，只能占用单核，无法充分使用多核的系统资源。\n - 单节点redis在出现故障时则无法继续提供数据存储服务，无法达到高可用要求。\n__解决方法：__\n - 增加redis slave节点通过replicas进行`master-slave`的数据复制，故障时手动恢复。\n - 通过增加`sentinel(哨兵)`监控redis master-slave节点的存活状态，当master出现故障时自动将slave升级为master继续提供服务。\n\n## data sharding（数据分片）\n__问题：__\n  单台redis节点的内存总量有限，达到上限后想要扩容除了增加内存别无它法\n__解决方法：__\n - redis client (部署多个独立的redis节点，通过在`客户端代码中针对key进行hash`，然后将数据按hash映射存储到不同的redis中)\n - Twemproxy (部署多个独立的redis节点，通过引入twitter开源中间件封装key的hash操作，最终将数据存储到不同的redis中)\n\n## redis cluster集群\n__问题：__\n  单台redis节点的内存容量有限，达到上限后想要扩容除了增加内存别无它法\n__解决方法：__\n - 将所有的redis节点的内存总容量划分为n个`哈希槽(hash slot)`(默认为16384个)，每一个redis节点负责一段solt，存取数据时通过CRC16算法对key进行取余来决定应该从哪一个redis节点进行存取操作。\n   redis节点两两连接共同形成一个集群，客户端代码连接集群中`任意节点`进行存取服务，集群中的节点会通过`CRC16算法`来将存取请求`转发`到目标redis节点完成数据的存取。\n - 通过在集群内挑选一部分节点设置为slave节点，通过master-slave构建高可用redis服务\n","slug":"redis-advanced","published":1,"updated":"2021-08-31T14:23:11.549Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cku52dyob0048bbin4oo5eama","content":"<h2 id=\"redis主从（读写分离）\"><a href=\"#redis主从（读写分离）\" class=\"headerlink\" title=\"redis主从（读写分离）\"></a>redis主从（读写分离）</h2><p><strong>问题：</strong></p>\n<ul>\n<li>redis为单进程程序，只能占用单核，无法充分使用多核的系统资源。</li>\n<li>单节点redis在出现故障时则无法继续提供数据存储服务，无法达到高可用要求。<br><strong>解决方法：</strong></li>\n<li>增加redis slave节点通过replicas进行<code>master-slave</code>的数据复制，故障时手动恢复。</li>\n<li>通过增加<code>sentinel(哨兵)</code>监控redis master-slave节点的存活状态，当master出现故障时自动将slave升级为master继续提供服务。</li>\n</ul>\n<h2 id=\"data-sharding（数据分片）\"><a href=\"#data-sharding（数据分片）\" class=\"headerlink\" title=\"data sharding（数据分片）\"></a>data sharding（数据分片）</h2><p><strong>问题：</strong><br>  单台redis节点的内存总量有限，达到上限后想要扩容除了增加内存别无它法<br><strong>解决方法：</strong></p>\n<ul>\n<li>redis client (部署多个独立的redis节点，通过在<code>客户端代码中针对key进行hash</code>，然后将数据按hash映射存储到不同的redis中)</li>\n<li>Twemproxy (部署多个独立的redis节点，通过引入twitter开源中间件封装key的hash操作，最终将数据存储到不同的redis中)</li>\n</ul>\n<h2 id=\"redis-cluster集群\"><a href=\"#redis-cluster集群\" class=\"headerlink\" title=\"redis cluster集群\"></a>redis cluster集群</h2><p><strong>问题：</strong><br>  单台redis节点的内存容量有限，达到上限后想要扩容除了增加内存别无它法<br><strong>解决方法：</strong></p>\n<ul>\n<li>将所有的redis节点的内存总容量划分为n个<code>哈希槽(hash slot)</code>(默认为16384个)，每一个redis节点负责一段solt，存取数据时通过CRC16算法对key进行取余来决定应该从哪一个redis节点进行存取操作。<br>redis节点两两连接共同形成一个集群，客户端代码连接集群中<code>任意节点</code>进行存取服务，集群中的节点会通过<code>CRC16算法</code>来将存取请求<code>转发</code>到目标redis节点完成数据的存取。</li>\n<li>通过在集群内挑选一部分节点设置为slave节点，通过master-slave构建高可用redis服务</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"redis主从（读写分离）\"><a href=\"#redis主从（读写分离）\" class=\"headerlink\" title=\"redis主从（读写分离）\"></a>redis主从（读写分离）</h2><p><strong>问题：</strong></p>\n<ul>\n<li>redis为单进程程序，只能占用单核，无法充分使用多核的系统资源。</li>\n<li>单节点redis在出现故障时则无法继续提供数据存储服务，无法达到高可用要求。<br><strong>解决方法：</strong></li>\n<li>增加redis slave节点通过replicas进行<code>master-slave</code>的数据复制，故障时手动恢复。</li>\n<li>通过增加<code>sentinel(哨兵)</code>监控redis master-slave节点的存活状态，当master出现故障时自动将slave升级为master继续提供服务。</li>\n</ul>\n<h2 id=\"data-sharding（数据分片）\"><a href=\"#data-sharding（数据分片）\" class=\"headerlink\" title=\"data sharding（数据分片）\"></a>data sharding（数据分片）</h2><p><strong>问题：</strong><br>  单台redis节点的内存总量有限，达到上限后想要扩容除了增加内存别无它法<br><strong>解决方法：</strong></p>\n<ul>\n<li>redis client (部署多个独立的redis节点，通过在<code>客户端代码中针对key进行hash</code>，然后将数据按hash映射存储到不同的redis中)</li>\n<li>Twemproxy (部署多个独立的redis节点，通过引入twitter开源中间件封装key的hash操作，最终将数据存储到不同的redis中)</li>\n</ul>\n<h2 id=\"redis-cluster集群\"><a href=\"#redis-cluster集群\" class=\"headerlink\" title=\"redis cluster集群\"></a>redis cluster集群</h2><p><strong>问题：</strong><br>  单台redis节点的内存容量有限，达到上限后想要扩容除了增加内存别无它法<br><strong>解决方法：</strong></p>\n<ul>\n<li>将所有的redis节点的内存总容量划分为n个<code>哈希槽(hash slot)</code>(默认为16384个)，每一个redis节点负责一段solt，存取数据时通过CRC16算法对key进行取余来决定应该从哪一个redis节点进行存取操作。<br>redis节点两两连接共同形成一个集群，客户端代码连接集群中<code>任意节点</code>进行存取服务，集群中的节点会通过<code>CRC16算法</code>来将存取请求<code>转发</code>到目标redis节点完成数据的存取。</li>\n<li>通过在集群内挑选一部分节点设置为slave节点，通过master-slave构建高可用redis服务</li>\n</ul>\n"},{"title":"Redis集群备注","keywords":["Redis集群"],"date":"2016-05-31T10:16:13.000Z","_content":"## 介绍\n1. Redis集群是一个可以在多个Redis节点之间进行数据共享的设施（installation）。\n2. Redis集群不支持那些需要同时处理多个键的Redis命令，因为执行这些命令需要在多个Redis节点之间移动数据，并且在高负载的情况下，这些命令将降低Redis集群的性能，并导致不可预测的行为。\n3. Redis集群通过分区（partition）来提供一定程度的可用性（availability）：即使集群中有一部份分节点失效或者无法进行通讯，集群也可以继续处理命令请求。\n\nRedis集群提供了以下两个好处：\n1、将数据自动切分(split)到多个节点的能力。\n2、当集群中的一部份节点失效或者无法进行通讯时，仍然可以继续处理命令请求的能力。\n\n## 数据节点分配\nRedis 集群没有并使用传统的一致性哈希来分配数据，而是采用另外一种叫做哈希槽 (hash slot)的方式来分配的。redis cluster 默认分配了 16384 个slot，当我们set一个key 时，会用CRC16算法来取模得到所属的slot，然后将这个key 分到哈希槽区间的节点上，具体算法就是：CRC16(key) % 16384。集群中的每个节点负责处理一部分哈希槽。\n\n这种将哈希槽分布到不同节点的做法使得用户可以很容易地向集群中添加或者删除节点。\n当添加集群节点时，需要将已有节点的哈希槽移动到新的节点上进行处理。\n当删除集群节点时，需要先将节点上已分配的哈希槽移动到其它的节点上再进行删除。\n## 客户端存储分配\n当客户端向集群节点中任一节点发出存储或读取请求时，redis节点先根据KeyHash出来的值判断是否属于当前集群节点能进行处理，如果不能处理则会将能完成这一请求的Redis节点信息返回给客户端。客户端将再次向能处理请求的Redis节点发出请求。\n```\n$ redis-cli -c -p 7000\nredis 127.0.0.1:7000> set foo bar\n-> Redirected to slot [12182] located at 127.0.0.1:7002\nOK\nredis 127.0.0.1:7002> set hello world\n-> Redirected to slot [866] located at 127.0.0.1:7000\nOK\nredis 127.0.0.1:7000> get foo\n-> Redirected to slot [12182] located at 127.0.0.1:7002\n\"bar\"\nredis 127.0.0.1:7000> get hello\n-> Redirected to slot [866] located at 127.0.0.1:7000\n\"world\"\n```\n\n## 集群节点故障\n采用数据分片的处理集群数据分配就存在无法避免的问题，当其中一个集群节点挂掉时，分配到此节点上哈希槽的数据将无法处理。\n为了使得集群在一部分节点下线或者无法与集群的大多数（majority）节点进行通讯的情况下， 仍然可以正常运作，\nRedis 集群对每个集群节点都提供了了主从复制功能： 集群中的每个节点都有 1 个至 N 个复制品（replica）， 其中一个复制品为主节点（master）， 而其余的 N-1 个复制品为从节点（slave）。\n\n-----\n\n*观点仅代表自己，期待你的留言。*","source":"_posts/redis-cluster-note.md","raw":"---\ntitle: Redis集群备注\nkeywords:\n  - Redis集群\ntags:\n  - 原创\n  - Redis\ndate: 2016-05-31 18:16:13\n---\n## 介绍\n1. Redis集群是一个可以在多个Redis节点之间进行数据共享的设施（installation）。\n2. Redis集群不支持那些需要同时处理多个键的Redis命令，因为执行这些命令需要在多个Redis节点之间移动数据，并且在高负载的情况下，这些命令将降低Redis集群的性能，并导致不可预测的行为。\n3. Redis集群通过分区（partition）来提供一定程度的可用性（availability）：即使集群中有一部份分节点失效或者无法进行通讯，集群也可以继续处理命令请求。\n\nRedis集群提供了以下两个好处：\n1、将数据自动切分(split)到多个节点的能力。\n2、当集群中的一部份节点失效或者无法进行通讯时，仍然可以继续处理命令请求的能力。\n\n## 数据节点分配\nRedis 集群没有并使用传统的一致性哈希来分配数据，而是采用另外一种叫做哈希槽 (hash slot)的方式来分配的。redis cluster 默认分配了 16384 个slot，当我们set一个key 时，会用CRC16算法来取模得到所属的slot，然后将这个key 分到哈希槽区间的节点上，具体算法就是：CRC16(key) % 16384。集群中的每个节点负责处理一部分哈希槽。\n\n这种将哈希槽分布到不同节点的做法使得用户可以很容易地向集群中添加或者删除节点。\n当添加集群节点时，需要将已有节点的哈希槽移动到新的节点上进行处理。\n当删除集群节点时，需要先将节点上已分配的哈希槽移动到其它的节点上再进行删除。\n## 客户端存储分配\n当客户端向集群节点中任一节点发出存储或读取请求时，redis节点先根据KeyHash出来的值判断是否属于当前集群节点能进行处理，如果不能处理则会将能完成这一请求的Redis节点信息返回给客户端。客户端将再次向能处理请求的Redis节点发出请求。\n```\n$ redis-cli -c -p 7000\nredis 127.0.0.1:7000> set foo bar\n-> Redirected to slot [12182] located at 127.0.0.1:7002\nOK\nredis 127.0.0.1:7002> set hello world\n-> Redirected to slot [866] located at 127.0.0.1:7000\nOK\nredis 127.0.0.1:7000> get foo\n-> Redirected to slot [12182] located at 127.0.0.1:7002\n\"bar\"\nredis 127.0.0.1:7000> get hello\n-> Redirected to slot [866] located at 127.0.0.1:7000\n\"world\"\n```\n\n## 集群节点故障\n采用数据分片的处理集群数据分配就存在无法避免的问题，当其中一个集群节点挂掉时，分配到此节点上哈希槽的数据将无法处理。\n为了使得集群在一部分节点下线或者无法与集群的大多数（majority）节点进行通讯的情况下， 仍然可以正常运作，\nRedis 集群对每个集群节点都提供了了主从复制功能： 集群中的每个节点都有 1 个至 N 个复制品（replica）， 其中一个复制品为主节点（master）， 而其余的 N-1 个复制品为从节点（slave）。\n\n-----\n\n*观点仅代表自己，期待你的留言。*","slug":"redis-cluster-note","published":1,"updated":"2021-08-31T14:23:11.549Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cku52dyoc004abbin0ran30m8","content":"<h2 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h2><ol>\n<li>Redis集群是一个可以在多个Redis节点之间进行数据共享的设施（installation）。</li>\n<li>Redis集群不支持那些需要同时处理多个键的Redis命令，因为执行这些命令需要在多个Redis节点之间移动数据，并且在高负载的情况下，这些命令将降低Redis集群的性能，并导致不可预测的行为。</li>\n<li>Redis集群通过分区（partition）来提供一定程度的可用性（availability）：即使集群中有一部份分节点失效或者无法进行通讯，集群也可以继续处理命令请求。</li>\n</ol>\n<p>Redis集群提供了以下两个好处：<br>1、将数据自动切分(split)到多个节点的能力。<br>2、当集群中的一部份节点失效或者无法进行通讯时，仍然可以继续处理命令请求的能力。</p>\n<h2 id=\"数据节点分配\"><a href=\"#数据节点分配\" class=\"headerlink\" title=\"数据节点分配\"></a>数据节点分配</h2><p>Redis 集群没有并使用传统的一致性哈希来分配数据，而是采用另外一种叫做哈希槽 (hash slot)的方式来分配的。redis cluster 默认分配了 16384 个slot，当我们set一个key 时，会用CRC16算法来取模得到所属的slot，然后将这个key 分到哈希槽区间的节点上，具体算法就是：CRC16(key) % 16384。集群中的每个节点负责处理一部分哈希槽。</p>\n<p>这种将哈希槽分布到不同节点的做法使得用户可以很容易地向集群中添加或者删除节点。<br>当添加集群节点时，需要将已有节点的哈希槽移动到新的节点上进行处理。<br>当删除集群节点时，需要先将节点上已分配的哈希槽移动到其它的节点上再进行删除。</p>\n<h2 id=\"客户端存储分配\"><a href=\"#客户端存储分配\" class=\"headerlink\" title=\"客户端存储分配\"></a>客户端存储分配</h2><p>当客户端向集群节点中任一节点发出存储或读取请求时，redis节点先根据KeyHash出来的值判断是否属于当前集群节点能进行处理，如果不能处理则会将能完成这一请求的Redis节点信息返回给客户端。客户端将再次向能处理请求的Redis节点发出请求。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ redis-cli -c -p 7000</span><br><span class=\"line\">redis 127.0.0.1:7000&gt; set foo bar</span><br><span class=\"line\">-&gt; Redirected to slot [12182] located at 127.0.0.1:7002</span><br><span class=\"line\">OK</span><br><span class=\"line\">redis 127.0.0.1:7002&gt; set hello world</span><br><span class=\"line\">-&gt; Redirected to slot [866] located at 127.0.0.1:7000</span><br><span class=\"line\">OK</span><br><span class=\"line\">redis 127.0.0.1:7000&gt; get foo</span><br><span class=\"line\">-&gt; Redirected to slot [12182] located at 127.0.0.1:7002</span><br><span class=\"line\">&quot;bar&quot;</span><br><span class=\"line\">redis 127.0.0.1:7000&gt; get hello</span><br><span class=\"line\">-&gt; Redirected to slot [866] located at 127.0.0.1:7000</span><br><span class=\"line\">&quot;world&quot;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"集群节点故障\"><a href=\"#集群节点故障\" class=\"headerlink\" title=\"集群节点故障\"></a>集群节点故障</h2><p>采用数据分片的处理集群数据分配就存在无法避免的问题，当其中一个集群节点挂掉时，分配到此节点上哈希槽的数据将无法处理。<br>为了使得集群在一部分节点下线或者无法与集群的大多数（majority）节点进行通讯的情况下， 仍然可以正常运作，<br>Redis 集群对每个集群节点都提供了了主从复制功能： 集群中的每个节点都有 1 个至 N 个复制品（replica）， 其中一个复制品为主节点（master）， 而其余的 N-1 个复制品为从节点（slave）。</p>\n<hr>\n<p><em>观点仅代表自己，期待你的留言。</em></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h2><ol>\n<li>Redis集群是一个可以在多个Redis节点之间进行数据共享的设施（installation）。</li>\n<li>Redis集群不支持那些需要同时处理多个键的Redis命令，因为执行这些命令需要在多个Redis节点之间移动数据，并且在高负载的情况下，这些命令将降低Redis集群的性能，并导致不可预测的行为。</li>\n<li>Redis集群通过分区（partition）来提供一定程度的可用性（availability）：即使集群中有一部份分节点失效或者无法进行通讯，集群也可以继续处理命令请求。</li>\n</ol>\n<p>Redis集群提供了以下两个好处：<br>1、将数据自动切分(split)到多个节点的能力。<br>2、当集群中的一部份节点失效或者无法进行通讯时，仍然可以继续处理命令请求的能力。</p>\n<h2 id=\"数据节点分配\"><a href=\"#数据节点分配\" class=\"headerlink\" title=\"数据节点分配\"></a>数据节点分配</h2><p>Redis 集群没有并使用传统的一致性哈希来分配数据，而是采用另外一种叫做哈希槽 (hash slot)的方式来分配的。redis cluster 默认分配了 16384 个slot，当我们set一个key 时，会用CRC16算法来取模得到所属的slot，然后将这个key 分到哈希槽区间的节点上，具体算法就是：CRC16(key) % 16384。集群中的每个节点负责处理一部分哈希槽。</p>\n<p>这种将哈希槽分布到不同节点的做法使得用户可以很容易地向集群中添加或者删除节点。<br>当添加集群节点时，需要将已有节点的哈希槽移动到新的节点上进行处理。<br>当删除集群节点时，需要先将节点上已分配的哈希槽移动到其它的节点上再进行删除。</p>\n<h2 id=\"客户端存储分配\"><a href=\"#客户端存储分配\" class=\"headerlink\" title=\"客户端存储分配\"></a>客户端存储分配</h2><p>当客户端向集群节点中任一节点发出存储或读取请求时，redis节点先根据KeyHash出来的值判断是否属于当前集群节点能进行处理，如果不能处理则会将能完成这一请求的Redis节点信息返回给客户端。客户端将再次向能处理请求的Redis节点发出请求。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ redis-cli -c -p 7000</span><br><span class=\"line\">redis 127.0.0.1:7000&gt; set foo bar</span><br><span class=\"line\">-&gt; Redirected to slot [12182] located at 127.0.0.1:7002</span><br><span class=\"line\">OK</span><br><span class=\"line\">redis 127.0.0.1:7002&gt; set hello world</span><br><span class=\"line\">-&gt; Redirected to slot [866] located at 127.0.0.1:7000</span><br><span class=\"line\">OK</span><br><span class=\"line\">redis 127.0.0.1:7000&gt; get foo</span><br><span class=\"line\">-&gt; Redirected to slot [12182] located at 127.0.0.1:7002</span><br><span class=\"line\">&quot;bar&quot;</span><br><span class=\"line\">redis 127.0.0.1:7000&gt; get hello</span><br><span class=\"line\">-&gt; Redirected to slot [866] located at 127.0.0.1:7000</span><br><span class=\"line\">&quot;world&quot;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"集群节点故障\"><a href=\"#集群节点故障\" class=\"headerlink\" title=\"集群节点故障\"></a>集群节点故障</h2><p>采用数据分片的处理集群数据分配就存在无法避免的问题，当其中一个集群节点挂掉时，分配到此节点上哈希槽的数据将无法处理。<br>为了使得集群在一部分节点下线或者无法与集群的大多数（majority）节点进行通讯的情况下， 仍然可以正常运作，<br>Redis 集群对每个集群节点都提供了了主从复制功能： 集群中的每个节点都有 1 个至 N 个复制品（replica）， 其中一个复制品为主节点（master）， 而其余的 N-1 个复制品为从节点（slave）。</p>\n<hr>\n<p><em>观点仅代表自己，期待你的留言。</em></p>\n"},{"title":"Shiro完成RestfulApi的会话保持实例","keywords":["前后端分离","shiro","RestfulApi","会话保持"],"date":"2018-10-24T07:00:30.000Z","_content":"\n## 背景\n针对用户身份权限管理包含账户权限登录认证+会话保持两个部分，在 __移动端+服务平台__ 或 __前后端分离__ 的项目框架下，一般会涉及到通过token来进行用户登录会话的保持。\n以下我将通过在HTTP Header中增加token的方式在RestfulApi的服务端进行权限校验与会话保持。\n\n## 扩展分析\n1. 扩展`org.apache.shiro.session.mgt.eis.EnterpriseCacheSessionDAO`: 完成用户Session的存取。\n2. 扩展`org.apache.shiro.web.session.mgt.DefaultWebSessionManager`: 完成用户Session标识的获取。\n\n## 源码\n__org.wujianjun.apps.web.auth.TokenSessionManager__\n```java\npublic class TokenSessionManager extends DefaultWebSessionManager {\n\n    public static final String ACCESS_TOKEN = \"x-access-token\";\n    private final Logger logger = LoggerFactory.getLogger(getClass());\n\n    @Override\n    protected Serializable getSessionId(ServletRequest request, ServletResponse response) {\n        final String accessToken = WebUtils.toHttp(request).getHeader(this.ACCESS_TOKEN);\n        if (StringUtils.isBlank(accessToken)) {\n            return null;\n        }\n        // 设置当前session状态\n        request.setAttribute(ShiroHttpServletRequest.REFERENCED_SESSION_ID_SOURCE, ShiroHttpServletRequest.URL_SESSION_ID_SOURCE);\n        request.setAttribute(ShiroHttpServletRequest.REFERENCED_SESSION_ID, accessToken);\n        request.setAttribute(ShiroHttpServletRequest.REFERENCED_SESSION_ID_IS_VALID, Boolean.TRUE);\n        return accessToken;\n    }\n}\n```\n\n__org.wujianjun.apps.web.auth.RedisSessionDAO__\n```java\n@Component\npublic class RedisSessionDAO extends EnterpriseCacheSessionDAO {\n\n    @Resource\n    private RedisTemplate<String, String> redisTemplate;\n\n    public RedisSessionDAO(RedisTemplate<String, String> redisTemplate) {\n        this.redisTemplate = redisTemplate;\n    }\n\n    public RedisTemplate<String, String> getRedisTemplate() {\n        return redisTemplate;\n    }\n\n    public void setRedisTemplate(RedisTemplate<String, String> redisTemplate) {\n        this.redisTemplate = redisTemplate;\n    }\n\n    @Override\n    protected Session doReadSession(Serializable serializable) {\n        final Object validAccessToken = redisTemplate.opsForHash().get(RedisConst.REDIS_ACCESS_TOKEN_KEY, serializable);\n        if (validAccessToken == null) {\n            return null;\n        }\n        final SimpleSession simpleSession = new SimpleSession();\n        simpleSession.setId(serializable);\n        final SysUser sysUser = JSON.parseObject(validAccessToken.toString(), SysUser.class);\n        simpleSession.setAttribute(DefaultSubjectContext.PRINCIPALS_SESSION_KEY, new SimplePrincipalCollection(sysUser, \"authorRealm\"));\n        simpleSession.setAttribute(DefaultSubjectContext.AUTHENTICATED_SESSION_KEY, Boolean.TRUE);\n        return simpleSession;\n    }\n\n    @Override\n    protected void doUpdate(Session session) {\n        PrincipalCollection existingPrincipals = (PrincipalCollection)session.getAttribute(DefaultSubjectContext.PRINCIPALS_SESSION_KEY);\n        if (existingPrincipals == null) {\n            return;\n        }\n        final Object primaryPrincipal = existingPrincipals.getPrimaryPrincipal();\n        if (primaryPrincipal instanceof SysUser) {\n            final SysUser sysUser = (SysUser)primaryPrincipal;\n            redisTemplate.opsForHash().put(RedisConst.REDIS_ACCESS_TOKEN_KEY, session.getId(), JSON.toJSONString(sysUser));\n        }\n    }\n\n    @Override\n    protected void doDelete(Session session) {\n        redisTemplate.opsForHash().delete(RedisConst.REDIS_ACCESS_TOKEN_KEY, session.getId());\n    }\n}\n```\n\n__spring-shiro.xml__\n```xml\n<bean id=\"securityManager\" class=\"org.apache.shiro.web.mgt.DefaultWebSecurityManager\" p:realm-ref=\"authorRealm\">\n    <property name=\"cacheManager\">\n       <bean class=\"org.apache.shiro.cache.ehcache.EhCacheManager\" />\n    </property>\n    <property name=\"sessionManager\">\n       <bean class=\"org.wujianjun.apps.web.auth.TokenSessionManager\" p:sessionDAO-ref=\"redisSessionDAO\"\n             p:deleteInvalidSessions=\"false\" p:sessionIdCookieEnabled=\"false\" p:sessionValidationSchedulerEnabled=\"false\"/>\n    </property>\n</bean>\n```\n\n## SessoinId扩展\n如果需要自己定义sessionId的生成，只需要给 __org.apache.shiro.session.mgt.eis.AbstractSessionDAO__ 设置`sessionIdGenerator`的属性值即可。\n```xml\n<bean class=\"org.wujianjun.apps.web.auth.RedisSessionDAO\">\n  <property name=\"sessionIdGenerator\">\n    <bean class=\"org.wujianjun.apps.web.auth.JWTSessionIdGenerator\" />\n  </property>\n</bean>\n```\n\n-----\n\n*观点仅代表自己，期待你的留言。*\n","source":"_posts/shiro-restful-api-session.md","raw":"---\ntitle: Shiro完成RestfulApi的会话保持实例\ntags:\n  - 原创\n  - shiro\nkeywords:\n  - 前后端分离\n  - shiro\n  - RestfulApi\n  - 会话保持\ndate: 2018-10-24 15:00:30\n---\n\n## 背景\n针对用户身份权限管理包含账户权限登录认证+会话保持两个部分，在 __移动端+服务平台__ 或 __前后端分离__ 的项目框架下，一般会涉及到通过token来进行用户登录会话的保持。\n以下我将通过在HTTP Header中增加token的方式在RestfulApi的服务端进行权限校验与会话保持。\n\n## 扩展分析\n1. 扩展`org.apache.shiro.session.mgt.eis.EnterpriseCacheSessionDAO`: 完成用户Session的存取。\n2. 扩展`org.apache.shiro.web.session.mgt.DefaultWebSessionManager`: 完成用户Session标识的获取。\n\n## 源码\n__org.wujianjun.apps.web.auth.TokenSessionManager__\n```java\npublic class TokenSessionManager extends DefaultWebSessionManager {\n\n    public static final String ACCESS_TOKEN = \"x-access-token\";\n    private final Logger logger = LoggerFactory.getLogger(getClass());\n\n    @Override\n    protected Serializable getSessionId(ServletRequest request, ServletResponse response) {\n        final String accessToken = WebUtils.toHttp(request).getHeader(this.ACCESS_TOKEN);\n        if (StringUtils.isBlank(accessToken)) {\n            return null;\n        }\n        // 设置当前session状态\n        request.setAttribute(ShiroHttpServletRequest.REFERENCED_SESSION_ID_SOURCE, ShiroHttpServletRequest.URL_SESSION_ID_SOURCE);\n        request.setAttribute(ShiroHttpServletRequest.REFERENCED_SESSION_ID, accessToken);\n        request.setAttribute(ShiroHttpServletRequest.REFERENCED_SESSION_ID_IS_VALID, Boolean.TRUE);\n        return accessToken;\n    }\n}\n```\n\n__org.wujianjun.apps.web.auth.RedisSessionDAO__\n```java\n@Component\npublic class RedisSessionDAO extends EnterpriseCacheSessionDAO {\n\n    @Resource\n    private RedisTemplate<String, String> redisTemplate;\n\n    public RedisSessionDAO(RedisTemplate<String, String> redisTemplate) {\n        this.redisTemplate = redisTemplate;\n    }\n\n    public RedisTemplate<String, String> getRedisTemplate() {\n        return redisTemplate;\n    }\n\n    public void setRedisTemplate(RedisTemplate<String, String> redisTemplate) {\n        this.redisTemplate = redisTemplate;\n    }\n\n    @Override\n    protected Session doReadSession(Serializable serializable) {\n        final Object validAccessToken = redisTemplate.opsForHash().get(RedisConst.REDIS_ACCESS_TOKEN_KEY, serializable);\n        if (validAccessToken == null) {\n            return null;\n        }\n        final SimpleSession simpleSession = new SimpleSession();\n        simpleSession.setId(serializable);\n        final SysUser sysUser = JSON.parseObject(validAccessToken.toString(), SysUser.class);\n        simpleSession.setAttribute(DefaultSubjectContext.PRINCIPALS_SESSION_KEY, new SimplePrincipalCollection(sysUser, \"authorRealm\"));\n        simpleSession.setAttribute(DefaultSubjectContext.AUTHENTICATED_SESSION_KEY, Boolean.TRUE);\n        return simpleSession;\n    }\n\n    @Override\n    protected void doUpdate(Session session) {\n        PrincipalCollection existingPrincipals = (PrincipalCollection)session.getAttribute(DefaultSubjectContext.PRINCIPALS_SESSION_KEY);\n        if (existingPrincipals == null) {\n            return;\n        }\n        final Object primaryPrincipal = existingPrincipals.getPrimaryPrincipal();\n        if (primaryPrincipal instanceof SysUser) {\n            final SysUser sysUser = (SysUser)primaryPrincipal;\n            redisTemplate.opsForHash().put(RedisConst.REDIS_ACCESS_TOKEN_KEY, session.getId(), JSON.toJSONString(sysUser));\n        }\n    }\n\n    @Override\n    protected void doDelete(Session session) {\n        redisTemplate.opsForHash().delete(RedisConst.REDIS_ACCESS_TOKEN_KEY, session.getId());\n    }\n}\n```\n\n__spring-shiro.xml__\n```xml\n<bean id=\"securityManager\" class=\"org.apache.shiro.web.mgt.DefaultWebSecurityManager\" p:realm-ref=\"authorRealm\">\n    <property name=\"cacheManager\">\n       <bean class=\"org.apache.shiro.cache.ehcache.EhCacheManager\" />\n    </property>\n    <property name=\"sessionManager\">\n       <bean class=\"org.wujianjun.apps.web.auth.TokenSessionManager\" p:sessionDAO-ref=\"redisSessionDAO\"\n             p:deleteInvalidSessions=\"false\" p:sessionIdCookieEnabled=\"false\" p:sessionValidationSchedulerEnabled=\"false\"/>\n    </property>\n</bean>\n```\n\n## SessoinId扩展\n如果需要自己定义sessionId的生成，只需要给 __org.apache.shiro.session.mgt.eis.AbstractSessionDAO__ 设置`sessionIdGenerator`的属性值即可。\n```xml\n<bean class=\"org.wujianjun.apps.web.auth.RedisSessionDAO\">\n  <property name=\"sessionIdGenerator\">\n    <bean class=\"org.wujianjun.apps.web.auth.JWTSessionIdGenerator\" />\n  </property>\n</bean>\n```\n\n-----\n\n*观点仅代表自己，期待你的留言。*\n","slug":"shiro-restful-api-session","published":1,"updated":"2021-08-31T14:23:11.549Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cku52dyoc004dbbin12ru4e1a","content":"<h2 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h2><p>针对用户身份权限管理包含账户权限登录认证+会话保持两个部分，在 <strong>移动端+服务平台</strong> 或 <strong>前后端分离</strong> 的项目框架下，一般会涉及到通过token来进行用户登录会话的保持。<br>以下我将通过在HTTP Header中增加token的方式在RestfulApi的服务端进行权限校验与会话保持。</p>\n<h2 id=\"扩展分析\"><a href=\"#扩展分析\" class=\"headerlink\" title=\"扩展分析\"></a>扩展分析</h2><ol>\n<li>扩展<code>org.apache.shiro.session.mgt.eis.EnterpriseCacheSessionDAO</code>: 完成用户Session的存取。</li>\n<li>扩展<code>org.apache.shiro.web.session.mgt.DefaultWebSessionManager</code>: 完成用户Session标识的获取。</li>\n</ol>\n<h2 id=\"源码\"><a href=\"#源码\" class=\"headerlink\" title=\"源码\"></a>源码</h2><p><strong>org.wujianjun.apps.web.auth.TokenSessionManager</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TokenSessionManager</span> <span class=\"keyword\">extends</span> <span class=\"title\">DefaultWebSessionManager</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String ACCESS_TOKEN = <span class=\"string\">&quot;x-access-token&quot;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Logger logger = LoggerFactory.getLogger(getClass());</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> Serializable <span class=\"title\">getSessionId</span><span class=\"params\">(ServletRequest request, ServletResponse response)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> String accessToken = WebUtils.toHttp(request).getHeader(<span class=\"keyword\">this</span>.ACCESS_TOKEN);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (StringUtils.isBlank(accessToken)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 设置当前session状态</span></span><br><span class=\"line\">        request.setAttribute(ShiroHttpServletRequest.REFERENCED_SESSION_ID_SOURCE, ShiroHttpServletRequest.URL_SESSION_ID_SOURCE);</span><br><span class=\"line\">        request.setAttribute(ShiroHttpServletRequest.REFERENCED_SESSION_ID, accessToken);</span><br><span class=\"line\">        request.setAttribute(ShiroHttpServletRequest.REFERENCED_SESSION_ID_IS_VALID, Boolean.TRUE);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> accessToken;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>org.wujianjun.apps.web.auth.RedisSessionDAO</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RedisSessionDAO</span> <span class=\"keyword\">extends</span> <span class=\"title\">EnterpriseCacheSessionDAO</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Resource</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> RedisTemplate&lt;String, String&gt; redisTemplate;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">RedisSessionDAO</span><span class=\"params\">(RedisTemplate&lt;String, String&gt; redisTemplate)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.redisTemplate = redisTemplate;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> RedisTemplate&lt;String, String&gt; <span class=\"title\">getRedisTemplate</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> redisTemplate;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setRedisTemplate</span><span class=\"params\">(RedisTemplate&lt;String, String&gt; redisTemplate)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.redisTemplate = redisTemplate;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> Session <span class=\"title\">doReadSession</span><span class=\"params\">(Serializable serializable)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> Object validAccessToken = redisTemplate.opsForHash().get(RedisConst.REDIS_ACCESS_TOKEN_KEY, serializable);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (validAccessToken == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> SimpleSession simpleSession = <span class=\"keyword\">new</span> SimpleSession();</span><br><span class=\"line\">        simpleSession.setId(serializable);</span><br><span class=\"line\">        <span class=\"keyword\">final</span> SysUser sysUser = JSON.parseObject(validAccessToken.toString(), SysUser.class);</span><br><span class=\"line\">        simpleSession.setAttribute(DefaultSubjectContext.PRINCIPALS_SESSION_KEY, <span class=\"keyword\">new</span> SimplePrincipalCollection(sysUser, <span class=\"string\">&quot;authorRealm&quot;</span>));</span><br><span class=\"line\">        simpleSession.setAttribute(DefaultSubjectContext.AUTHENTICATED_SESSION_KEY, Boolean.TRUE);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> simpleSession;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">doUpdate</span><span class=\"params\">(Session session)</span> </span>&#123;</span><br><span class=\"line\">        PrincipalCollection existingPrincipals = (PrincipalCollection)session.getAttribute(DefaultSubjectContext.PRINCIPALS_SESSION_KEY);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (existingPrincipals == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> Object primaryPrincipal = existingPrincipals.getPrimaryPrincipal();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (primaryPrincipal <span class=\"keyword\">instanceof</span> SysUser) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">final</span> SysUser sysUser = (SysUser)primaryPrincipal;</span><br><span class=\"line\">            redisTemplate.opsForHash().put(RedisConst.REDIS_ACCESS_TOKEN_KEY, session.getId(), JSON.toJSONString(sysUser));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">doDelete</span><span class=\"params\">(Session session)</span> </span>&#123;</span><br><span class=\"line\">        redisTemplate.opsForHash().delete(RedisConst.REDIS_ACCESS_TOKEN_KEY, session.getId());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>spring-shiro.xml</strong></p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;securityManager&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;org.apache.shiro.web.mgt.DefaultWebSecurityManager&quot;</span> <span class=\"attr\">p:realm-ref</span>=<span class=\"string\">&quot;authorRealm&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;cacheManager&quot;</span>&gt;</span></span><br><span class=\"line\">       <span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;org.apache.shiro.cache.ehcache.EhCacheManager&quot;</span> /&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;sessionManager&quot;</span>&gt;</span></span><br><span class=\"line\">       <span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;org.wujianjun.apps.web.auth.TokenSessionManager&quot;</span> <span class=\"attr\">p:sessionDAO-ref</span>=<span class=\"string\">&quot;redisSessionDAO&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">             <span class=\"attr\">p:deleteInvalidSessions</span>=<span class=\"string\">&quot;false&quot;</span> <span class=\"attr\">p:sessionIdCookieEnabled</span>=<span class=\"string\">&quot;false&quot;</span> <span class=\"attr\">p:sessionValidationSchedulerEnabled</span>=<span class=\"string\">&quot;false&quot;</span>/&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"SessoinId扩展\"><a href=\"#SessoinId扩展\" class=\"headerlink\" title=\"SessoinId扩展\"></a>SessoinId扩展</h2><p>如果需要自己定义sessionId的生成，只需要给 <strong>org.apache.shiro.session.mgt.eis.AbstractSessionDAO</strong> 设置<code>sessionIdGenerator</code>的属性值即可。</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;org.wujianjun.apps.web.auth.RedisSessionDAO&quot;</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;sessionIdGenerator&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;org.wujianjun.apps.web.auth.JWTSessionIdGenerator&quot;</span> /&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<hr>\n<p><em>观点仅代表自己，期待你的留言。</em></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h2><p>针对用户身份权限管理包含账户权限登录认证+会话保持两个部分，在 <strong>移动端+服务平台</strong> 或 <strong>前后端分离</strong> 的项目框架下，一般会涉及到通过token来进行用户登录会话的保持。<br>以下我将通过在HTTP Header中增加token的方式在RestfulApi的服务端进行权限校验与会话保持。</p>\n<h2 id=\"扩展分析\"><a href=\"#扩展分析\" class=\"headerlink\" title=\"扩展分析\"></a>扩展分析</h2><ol>\n<li>扩展<code>org.apache.shiro.session.mgt.eis.EnterpriseCacheSessionDAO</code>: 完成用户Session的存取。</li>\n<li>扩展<code>org.apache.shiro.web.session.mgt.DefaultWebSessionManager</code>: 完成用户Session标识的获取。</li>\n</ol>\n<h2 id=\"源码\"><a href=\"#源码\" class=\"headerlink\" title=\"源码\"></a>源码</h2><p><strong>org.wujianjun.apps.web.auth.TokenSessionManager</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TokenSessionManager</span> <span class=\"keyword\">extends</span> <span class=\"title\">DefaultWebSessionManager</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String ACCESS_TOKEN = <span class=\"string\">&quot;x-access-token&quot;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Logger logger = LoggerFactory.getLogger(getClass());</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> Serializable <span class=\"title\">getSessionId</span><span class=\"params\">(ServletRequest request, ServletResponse response)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> String accessToken = WebUtils.toHttp(request).getHeader(<span class=\"keyword\">this</span>.ACCESS_TOKEN);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (StringUtils.isBlank(accessToken)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 设置当前session状态</span></span><br><span class=\"line\">        request.setAttribute(ShiroHttpServletRequest.REFERENCED_SESSION_ID_SOURCE, ShiroHttpServletRequest.URL_SESSION_ID_SOURCE);</span><br><span class=\"line\">        request.setAttribute(ShiroHttpServletRequest.REFERENCED_SESSION_ID, accessToken);</span><br><span class=\"line\">        request.setAttribute(ShiroHttpServletRequest.REFERENCED_SESSION_ID_IS_VALID, Boolean.TRUE);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> accessToken;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>org.wujianjun.apps.web.auth.RedisSessionDAO</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RedisSessionDAO</span> <span class=\"keyword\">extends</span> <span class=\"title\">EnterpriseCacheSessionDAO</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Resource</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> RedisTemplate&lt;String, String&gt; redisTemplate;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">RedisSessionDAO</span><span class=\"params\">(RedisTemplate&lt;String, String&gt; redisTemplate)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.redisTemplate = redisTemplate;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> RedisTemplate&lt;String, String&gt; <span class=\"title\">getRedisTemplate</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> redisTemplate;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setRedisTemplate</span><span class=\"params\">(RedisTemplate&lt;String, String&gt; redisTemplate)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.redisTemplate = redisTemplate;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> Session <span class=\"title\">doReadSession</span><span class=\"params\">(Serializable serializable)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> Object validAccessToken = redisTemplate.opsForHash().get(RedisConst.REDIS_ACCESS_TOKEN_KEY, serializable);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (validAccessToken == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> SimpleSession simpleSession = <span class=\"keyword\">new</span> SimpleSession();</span><br><span class=\"line\">        simpleSession.setId(serializable);</span><br><span class=\"line\">        <span class=\"keyword\">final</span> SysUser sysUser = JSON.parseObject(validAccessToken.toString(), SysUser.class);</span><br><span class=\"line\">        simpleSession.setAttribute(DefaultSubjectContext.PRINCIPALS_SESSION_KEY, <span class=\"keyword\">new</span> SimplePrincipalCollection(sysUser, <span class=\"string\">&quot;authorRealm&quot;</span>));</span><br><span class=\"line\">        simpleSession.setAttribute(DefaultSubjectContext.AUTHENTICATED_SESSION_KEY, Boolean.TRUE);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> simpleSession;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">doUpdate</span><span class=\"params\">(Session session)</span> </span>&#123;</span><br><span class=\"line\">        PrincipalCollection existingPrincipals = (PrincipalCollection)session.getAttribute(DefaultSubjectContext.PRINCIPALS_SESSION_KEY);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (existingPrincipals == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> Object primaryPrincipal = existingPrincipals.getPrimaryPrincipal();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (primaryPrincipal <span class=\"keyword\">instanceof</span> SysUser) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">final</span> SysUser sysUser = (SysUser)primaryPrincipal;</span><br><span class=\"line\">            redisTemplate.opsForHash().put(RedisConst.REDIS_ACCESS_TOKEN_KEY, session.getId(), JSON.toJSONString(sysUser));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">doDelete</span><span class=\"params\">(Session session)</span> </span>&#123;</span><br><span class=\"line\">        redisTemplate.opsForHash().delete(RedisConst.REDIS_ACCESS_TOKEN_KEY, session.getId());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>spring-shiro.xml</strong></p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;securityManager&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;org.apache.shiro.web.mgt.DefaultWebSecurityManager&quot;</span> <span class=\"attr\">p:realm-ref</span>=<span class=\"string\">&quot;authorRealm&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;cacheManager&quot;</span>&gt;</span></span><br><span class=\"line\">       <span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;org.apache.shiro.cache.ehcache.EhCacheManager&quot;</span> /&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;sessionManager&quot;</span>&gt;</span></span><br><span class=\"line\">       <span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;org.wujianjun.apps.web.auth.TokenSessionManager&quot;</span> <span class=\"attr\">p:sessionDAO-ref</span>=<span class=\"string\">&quot;redisSessionDAO&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">             <span class=\"attr\">p:deleteInvalidSessions</span>=<span class=\"string\">&quot;false&quot;</span> <span class=\"attr\">p:sessionIdCookieEnabled</span>=<span class=\"string\">&quot;false&quot;</span> <span class=\"attr\">p:sessionValidationSchedulerEnabled</span>=<span class=\"string\">&quot;false&quot;</span>/&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"SessoinId扩展\"><a href=\"#SessoinId扩展\" class=\"headerlink\" title=\"SessoinId扩展\"></a>SessoinId扩展</h2><p>如果需要自己定义sessionId的生成，只需要给 <strong>org.apache.shiro.session.mgt.eis.AbstractSessionDAO</strong> 设置<code>sessionIdGenerator</code>的属性值即可。</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;org.wujianjun.apps.web.auth.RedisSessionDAO&quot;</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;sessionIdGenerator&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;org.wujianjun.apps.web.auth.JWTSessionIdGenerator&quot;</span> /&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<hr>\n<p><em>观点仅代表自己，期待你的留言。</em></p>\n"},{"title":"Redis数据类型特点","date":"2018-12-25T14:49:58.000Z","_content":"\n## Redis数据类型特点\n1. string：可独立设置expire time。\n2. list：特有的LPUSH、RPUSH、LPOP、RPOP、LPOPRPUSH等函数可以无缝的支持生产者、消费者架构模式。\n3. hash：基于Hash算法的，对于项的查找时间复杂度是O(1)。\n4. set：最大的特点就是集合的计算能力，inter交集、union并集、diff差集，这些特点可以用来做高性能的交叉计算或者剔除数据。SINTERSTORE命令将交集计算后的结果存储在一个目标集合中。\n5. zset：在set的基础上提供了排序的功能，可用于多维度算法计算得分后找最佳结果的场景。\n\n由于Redis是Signle-Thread单线程模型，基于这个特性我们就可以使用Redis提供的pipeline管道来提交一连串带有逻辑的命令集合，这些命令在处理期间不会被其他客户端的命令干扰。\n\n-----\n\n*观点仅代表自己，期待你的留言。*\n","source":"_posts/redis-data-type.md","raw":"---\ntitle: Redis数据类型特点\ntags:\n  - 原创\ndate: 2018-12-25 22:49:58\n---\n\n## Redis数据类型特点\n1. string：可独立设置expire time。\n2. list：特有的LPUSH、RPUSH、LPOP、RPOP、LPOPRPUSH等函数可以无缝的支持生产者、消费者架构模式。\n3. hash：基于Hash算法的，对于项的查找时间复杂度是O(1)。\n4. set：最大的特点就是集合的计算能力，inter交集、union并集、diff差集，这些特点可以用来做高性能的交叉计算或者剔除数据。SINTERSTORE命令将交集计算后的结果存储在一个目标集合中。\n5. zset：在set的基础上提供了排序的功能，可用于多维度算法计算得分后找最佳结果的场景。\n\n由于Redis是Signle-Thread单线程模型，基于这个特性我们就可以使用Redis提供的pipeline管道来提交一连串带有逻辑的命令集合，这些命令在处理期间不会被其他客户端的命令干扰。\n\n-----\n\n*观点仅代表自己，期待你的留言。*\n","slug":"redis-data-type","published":1,"updated":"2021-08-31T14:23:11.549Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cku52dyod004fbbin00ny6yu6","content":"<h2 id=\"Redis数据类型特点\"><a href=\"#Redis数据类型特点\" class=\"headerlink\" title=\"Redis数据类型特点\"></a>Redis数据类型特点</h2><ol>\n<li>string：可独立设置expire time。</li>\n<li>list：特有的LPUSH、RPUSH、LPOP、RPOP、LPOPRPUSH等函数可以无缝的支持生产者、消费者架构模式。</li>\n<li>hash：基于Hash算法的，对于项的查找时间复杂度是O(1)。</li>\n<li>set：最大的特点就是集合的计算能力，inter交集、union并集、diff差集，这些特点可以用来做高性能的交叉计算或者剔除数据。SINTERSTORE命令将交集计算后的结果存储在一个目标集合中。</li>\n<li>zset：在set的基础上提供了排序的功能，可用于多维度算法计算得分后找最佳结果的场景。</li>\n</ol>\n<p>由于Redis是Signle-Thread单线程模型，基于这个特性我们就可以使用Redis提供的pipeline管道来提交一连串带有逻辑的命令集合，这些命令在处理期间不会被其他客户端的命令干扰。</p>\n<hr>\n<p><em>观点仅代表自己，期待你的留言。</em></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"Redis数据类型特点\"><a href=\"#Redis数据类型特点\" class=\"headerlink\" title=\"Redis数据类型特点\"></a>Redis数据类型特点</h2><ol>\n<li>string：可独立设置expire time。</li>\n<li>list：特有的LPUSH、RPUSH、LPOP、RPOP、LPOPRPUSH等函数可以无缝的支持生产者、消费者架构模式。</li>\n<li>hash：基于Hash算法的，对于项的查找时间复杂度是O(1)。</li>\n<li>set：最大的特点就是集合的计算能力，inter交集、union并集、diff差集，这些特点可以用来做高性能的交叉计算或者剔除数据。SINTERSTORE命令将交集计算后的结果存储在一个目标集合中。</li>\n<li>zset：在set的基础上提供了排序的功能，可用于多维度算法计算得分后找最佳结果的场景。</li>\n</ol>\n<p>由于Redis是Signle-Thread单线程模型，基于这个特性我们就可以使用Redis提供的pipeline管道来提交一连串带有逻辑的命令集合，这些命令在处理期间不会被其他客户端的命令干扰。</p>\n<hr>\n<p><em>观点仅代表自己，期待你的留言。</em></p>\n"},{"title":"Shiro完成短信验证码登录的实例","keywords":["短信验证码登录","shiro","RestfulApi","身份校验"],"date":"2018-08-30T09:44:47.000Z","_content":"\n## 分析\nShiro通过`org.apache.shiro.realm.Realm`进行身份与权限的校验，通过`org.apache.shiro.realm.jdbc.JdbcRealm`来查看，\n我决定继承自`org.apache.shiro.realm.AuthorizingRealm`来实现身份校验逻辑和权限标识符获取的逻辑。\n\n`org.apache.shiro.realm.AuthorizingRealm`\n两个抽象方法：\n1、 `protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principalCollection)`:\n  主要用于通过当前身份来获取Permissions。\n\n2、 `protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken authenticationToken) throws AuthenticationException`\n  主要是用户在登录时调用此方法完成用户身份初步校验，注意：校验凭证(密码、验证码等)由Shiro进行校验不需要手动在此进行校验。\n\n## 源码\n`spring-shiro.xml`\n\n```xml\n<bean id=\"securityManager\" class=\"org.apache.shiro.web.mgt.DefaultWebSecurityManager\">\n    <property name=\"realm\">\n       <bean class=\"com.smzc.apps.order.web.auth.OrderAuthorizingRealm\" />\n    </property>\n    <property name=\"cacheManager\">\n       <bean class=\"org.apache.shiro.cache.ehcache.EhCacheManager\" />\n    </property>\n    <property name=\"sessionManager\">\n       <bean class=\"org.apache.shiro.web.session.mgt.DefaultWebSessionManager\">\n           <property name=\"sessionIdCookie\">\n               <bean class=\"org.apache.shiro.web.servlet.SimpleCookie\">\n                   <constructor-arg value=\"SESSIONID\"/>\n                   <property name=\"httpOnly\" value=\"true\"/>\n                   <property name=\"maxAge\" value=\"-1\"/>\n               </bean>\n           </property>\n       </bean>\n    </property>\n</bean>\n\n<bean class=\"org.springframework.beans.factory.config.MethodInvokingFactoryBean\">\n    <property name=\"staticMethod\" value=\"org.apache.shiro.SecurityUtils.setSecurityManager\" />\n    <property name=\"arguments\">\n        <list>\n            <ref bean=\"securityManager\"/>\n        </list>\n    </property>\n</bean>\n\n<!-- shiroFilter -->\n<bean id=\"shiroFilterFactoryBean\" class=\"org.apache.shiro.spring.web.ShiroFilterFactoryBean\">\n    <!-- Shiro的核心安全接口,这个属性是必须的 -->\n    <property name=\"securityManager\" ref=\"securityManager\" />\n    <!-- 要求登录时的链接,非必须的属性,默认会自动寻找Web工程根目录下的\"/login.jsp\"页面 -->\n    <property name=\"loginUrl\" value=\"/views/login\" />\n    <!-- 登录成功后要跳转的连接 -->\n    <property name=\"successUrl\" value=\"/views/index\" />\n    <!-- 用户访问未对其授权的资源时,所显示的连接 -->\n    <property name=\"unauthorizedUrl\" value=\"/views/common/unauthorized\" />\n    <property name=\"filters\">\n        <map>\n            <entry key=\"logout\">\n                <bean class=\"org.apache.shiro.web.filter.authc.LogoutFilter\">\n                    <property name=\"redirectUrl\" value=\"/views/login\"/>\n                </bean>\n            </entry>\n        </map>\n    </property>\n    <!-- 配置Shiro过滤链 -->\n    <property name=\"filterChainDefinitions\">\n        <value>\n            /api/user/login/** = anon\n            /api/** = authc\n            /logout = logout\n            /** = anon\n        </value>\n    </property>\n</bean>\n```\n\n`OrderAuthorizingRealm.java`\n```java\npublic class OrderAuthorizingRealm extends AuthorizingRealm implements InitializingBean {\n    @Resource\n    private AuthorizingService authorizingService;\n    @Value(\"${app.role.permissions:}\")\n    private String rolePermissionsString;\n    private Map<String, Set<String>> rolePermissions;\n\n    @Override\n    protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principalCollection) {\n        final SysUser sysUser = (SysUser)super.getAvailablePrincipal(principalCollection);\n        final String role = sysUser.getUserRole().getRole();\n        final SimpleAuthorizationInfo authorizationInfo = new SimpleAuthorizationInfo(Sets.newHashSet(role));\n        authorizationInfo.setStringPermissions(rolePermissions.get(role));\n        return authorizationInfo;\n    }\n\n    @Override\n    protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken authenticationToken) throws AuthenticationException {\n        final UsernamePasswordToken usernamePasswordToken = (UsernamePasswordToken) authenticationToken;\n        final String mobile = usernamePasswordToken.getUsername();\n        final String validateCode = authorizingService.getCodeByMobile(mobile);\n        if (StringUtils.isBlank(validateCode)) {\n            throw new ExpiredCredentialsException(\"验证码已失效#[\" + mobile + \"]\");\n        }\n        final List<SysUser> sysUserList = authorizingService.getUserByMobile(mobile);\n        if (CollectionUtils.isEmpty(sysUserList)) {\n            throw new UnknownAccountException(\"用户账户不存在#[\" + mobile + \"]\");\n        }\n        if (sysUserList.size() > 1) {\n            throw new ConcurrentAccessException(\"用户存在多个账户#[\" + mobile + \"]\");\n        }\n        final SysUser sysUser = sysUserList.iterator().next();\n        if (!sysUser.getStatus().isAllowLogin()) {\n            throw new DisabledAccountException(\"用户账户不可用#[\" + mobile + \"]\");\n        }\n        // 注意：SimpleAuthenticationInfo中principal表示验证主体，供后续获取权限标识符和当前登录用户信息使用， credentials表示正确的凭证串，shiro会自动与用户登录时填入的值进行密钥匹配后进行对比。\n        // credentials也可以通过setCredentialsSalt设置加密的salt\n        return new SimpleAuthenticationInfo(sysUser, validateCode.toCharArray(), super.getName());\n    }\n\n    @Override\n    public void afterPropertiesSet() throws Exception {\n        if (StringUtils.isBlank(rolePermissionsString)) {\n            throw new NullPointerException(\"未初始化权限配置\");\n        }\n        rolePermissions = Maps.newHashMap();\n        final JSONObject jsonObject = JSON.parseObject(rolePermissionsString);\n        final Iterator<Map.Entry<String, Object>> entryIterator = jsonObject.entrySet().iterator();\n        while (entryIterator.hasNext()) {\n            final Map.Entry<String, Object> objectEntry = entryIterator.next();\n            rolePermissions.put(objectEntry.getKey(), Sets.newHashSet(objectEntry.getValue().toString().split(\",\")));\n        }\n    }\n}\n```\n\n`UserApiController.java`\n```java\n@RestController\n@RequestMapping(value = \"/api/user\", produces = MediaType.APPLICATION_JSON_UTF8_VALUE)\npublic class UserApiController extends BasicApiController {\n\n    @Resource\n    private SysUserService userService;\n\n    /**\n    * 用户登录\n    */\n    @RequestMapping(value = \"/login/{mobileNo}/{code}\", method = RequestMethod.GET)\n    public Output login(@PathVariable String mobileNo, @PathVariable String code) throws ServiceException {\n        Subject subject = SecurityUtils.getSubject();\n        UsernamePasswordToken token = new UsernamePasswordToken(mobileNo, code);\n        subject.login(token);\n        token.clear();\n        return MapOutput.createSuccess();\n    }\n\n    /**\n    * 用户登出\n    */\n    @RequestMapping(value = \"/logout/{mobileNo}\", method = RequestMethod.GET)\n    public Output logout(@PathVariable String mobileNo) throws ServiceException {\n        SecurityUtils.getSubject().logout();\n        return MapOutput.createSuccess();\n    }\n}\n```\n## Shiro凭证匹配器配置\n加密方式都为`org.apache.shiro.authc.credential.CredentialsMatcher`的实现类\n通过`org.apache.shiro.realm.AuthenticatingRealm`的`private CredentialsMatcher credentialsMatcher`设置凭据的匹配实现类\n如：\n```xml\n<bean id=\"securityManager\" class=\"org.apache.shiro.web.mgt.DefaultWebSecurityManager\">\n    <property name=\"realm\">\n<!--BEGIN: 设置凭证器------------------>\n       <bean class=\"com.smzc.apps.order.web.auth.OrderAuthorizingRealm\">\n         <property name=\"credentialsMatcher\">\n           <bean class=\"org.apache.shiro.authc.credential.PasswordMatcher\" />\n         </property>\n       </bean>\n<!--END: 设置凭证器------------------>\n    </property>\n    <property name=\"cacheManager\">\n       <bean class=\"org.apache.shiro.cache.ehcache.EhCacheManager\" />\n    </property>\n    <property name=\"sessionManager\">\n       <bean class=\"org.apache.shiro.web.session.mgt.DefaultWebSessionManager\">\n           <property name=\"sessionIdCookie\">\n               <bean class=\"org.apache.shiro.web.servlet.SimpleCookie\">\n                   <constructor-arg value=\"SESSIONID\"/>\n                   <property name=\"httpOnly\" value=\"true\"/>\n                   <property name=\"maxAge\" value=\"-1\"/>\n               </bean>\n           </property>\n       </bean>\n    </property>\n</bean>\n```\n\n## Shiro内置的FilterChain\n1. Shiro验证URL时,URL匹配成功便不再继续匹配查找(所以要注意配置文件中的URL顺序,尤其在使用通配符时)\n 故filterChainDefinitions的配置顺序为自上而下,以最上面的为准\n2. 当运行一个Web应用程序时,Shiro将会创建一些有用的默认Filter实例,并自动地在[main]项中将它们置为可用\n 自动地可用的默认的Filter实例是被DefaultFilter枚举类定义的,枚举的名称字段就是可供配置的名称\n anon---------------org.apache.shiro.web.filter.authc.AnonymousFilter\n authc--------------org.apache.shiro.web.filter.authc.FormAuthenticationFilter\n authcBasic---------org.apache.shiro.web.filter.authc.BasicHttpAuthenticationFilter\n logout-------------org.apache.shiro.web.filter.authc.LogoutFilter\n noSessionCreation--org.apache.shiro.web.filter.session.NoSessionCreationFilter\n perms--------------org.apache.shiro.web.filter.authz.PermissionAuthorizationFilter\n port---------------org.apache.shiro.web.filter.authz.PortFilter\n rest---------------org.apache.shiro.web.filter.authz.HttpMethodPermissionFilter\n roles--------------org.apache.shiro.web.filter.authz.RolesAuthorizationFilter\n ssl----------------org.apache.shiro.web.filter.authz.SslFilter\n user---------------org.apache.shiro.web.filter.authz.UserFilter\n\n3. 通常可将这些过滤器分为两组\n anon,authc,authcBasic,user是第一组认证过滤器\n perms,port,rest,roles,ssl是第二组授权过滤器\n 注意user和authc不同：当应用开启了rememberMe时,用户下次访问时可以是一个user,但绝不会是authc,因为authc是需要重新认证的\n user表示用户不一定已通过认证,只要曾被Shiro记住过登录状态的用户就可以正常发起请求,比如rememberMe\n 说白了,以前的一个用户登录时开启了rememberMe,然后他关闭浏览器,下次再访问时他就是一个user,而不会authc\n\n4. 举几个例子\n /admin=authc,roles[admin]      表示用户必需已通过认证,并拥有admin角色才可以正常发起'/admin'请求\n /edit=authc,perms[admin:edit]  表示用户必需已通过认证,并拥有admin:edit权限才可以正常发起'/edit'请求\n /home=user                     表示用户不一定需要已经通过认证,只需要曾经被Shiro记住过登录状态就可以正常发起'/home'请求\n\n5. 各默认过滤器常用如下(注意URL Pattern里用到的是两颗星,这样才能实现任意层次的全匹配)\n /admins/**=anon             无参,表示可匿名使用,可以理解为匿名用户或游客\n /admins/user/**=authc       无参,表示需认证才能使用\n /admins/user/**=authcBasic  无参,表示httpBasic认证\n /admins/user/**=user        无参,表示必须存在用户,当登入操作时不做检查\n /admins/user/**=ssl         无参,表示安全的URL请求,协议为https\n /admins/user/**=perms[user:add:*]\n 参数可写多个,多参时必须加上引号,且参数之间用逗号分割,如/admins/user/**=perms[\"user:add:*,user:modify:*\"]\n 当有多个参数时必须每个参数都通过才算通过,相当于isPermitedAll()方法\n /admins/user/**=port[8081]\n 当请求的URL端口不是8081时,跳转到schemal://serverName:8081?queryString\n 其中schmal是协议http或https等,serverName是你访问的Host,8081是Port端口,queryString是你访问的URL里的?后面的参数\n /admins/user/**=rest[user]\n 根据请求的方法,相当于/admins/user/**=perms[user:method],其中method为post,get,delete等\n /admins/user/**=roles[admin]\n 参数可写多个,多个时必须加上引号,且参数之间用逗号分割,如/admins/user/**=roles[\"admin,guest\"]\n 当有多个参数时必须每个参数都通过才算通过,相当于hasAllRoles()方法\n\n-----\n\n*观点仅代表自己，期待你的留言。*\n","source":"_posts/shiro-smscode-auth.md","raw":"---\ntitle: Shiro完成短信验证码登录的实例\ntags:\n  - 原创\n  - shiro\nkeywords:\n  - 短信验证码登录\n  - shiro\n  - RestfulApi\n  - 身份校验\ndate: 2018-08-30 17:44:47\n---\n\n## 分析\nShiro通过`org.apache.shiro.realm.Realm`进行身份与权限的校验，通过`org.apache.shiro.realm.jdbc.JdbcRealm`来查看，\n我决定继承自`org.apache.shiro.realm.AuthorizingRealm`来实现身份校验逻辑和权限标识符获取的逻辑。\n\n`org.apache.shiro.realm.AuthorizingRealm`\n两个抽象方法：\n1、 `protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principalCollection)`:\n  主要用于通过当前身份来获取Permissions。\n\n2、 `protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken authenticationToken) throws AuthenticationException`\n  主要是用户在登录时调用此方法完成用户身份初步校验，注意：校验凭证(密码、验证码等)由Shiro进行校验不需要手动在此进行校验。\n\n## 源码\n`spring-shiro.xml`\n\n```xml\n<bean id=\"securityManager\" class=\"org.apache.shiro.web.mgt.DefaultWebSecurityManager\">\n    <property name=\"realm\">\n       <bean class=\"com.smzc.apps.order.web.auth.OrderAuthorizingRealm\" />\n    </property>\n    <property name=\"cacheManager\">\n       <bean class=\"org.apache.shiro.cache.ehcache.EhCacheManager\" />\n    </property>\n    <property name=\"sessionManager\">\n       <bean class=\"org.apache.shiro.web.session.mgt.DefaultWebSessionManager\">\n           <property name=\"sessionIdCookie\">\n               <bean class=\"org.apache.shiro.web.servlet.SimpleCookie\">\n                   <constructor-arg value=\"SESSIONID\"/>\n                   <property name=\"httpOnly\" value=\"true\"/>\n                   <property name=\"maxAge\" value=\"-1\"/>\n               </bean>\n           </property>\n       </bean>\n    </property>\n</bean>\n\n<bean class=\"org.springframework.beans.factory.config.MethodInvokingFactoryBean\">\n    <property name=\"staticMethod\" value=\"org.apache.shiro.SecurityUtils.setSecurityManager\" />\n    <property name=\"arguments\">\n        <list>\n            <ref bean=\"securityManager\"/>\n        </list>\n    </property>\n</bean>\n\n<!-- shiroFilter -->\n<bean id=\"shiroFilterFactoryBean\" class=\"org.apache.shiro.spring.web.ShiroFilterFactoryBean\">\n    <!-- Shiro的核心安全接口,这个属性是必须的 -->\n    <property name=\"securityManager\" ref=\"securityManager\" />\n    <!-- 要求登录时的链接,非必须的属性,默认会自动寻找Web工程根目录下的\"/login.jsp\"页面 -->\n    <property name=\"loginUrl\" value=\"/views/login\" />\n    <!-- 登录成功后要跳转的连接 -->\n    <property name=\"successUrl\" value=\"/views/index\" />\n    <!-- 用户访问未对其授权的资源时,所显示的连接 -->\n    <property name=\"unauthorizedUrl\" value=\"/views/common/unauthorized\" />\n    <property name=\"filters\">\n        <map>\n            <entry key=\"logout\">\n                <bean class=\"org.apache.shiro.web.filter.authc.LogoutFilter\">\n                    <property name=\"redirectUrl\" value=\"/views/login\"/>\n                </bean>\n            </entry>\n        </map>\n    </property>\n    <!-- 配置Shiro过滤链 -->\n    <property name=\"filterChainDefinitions\">\n        <value>\n            /api/user/login/** = anon\n            /api/** = authc\n            /logout = logout\n            /** = anon\n        </value>\n    </property>\n</bean>\n```\n\n`OrderAuthorizingRealm.java`\n```java\npublic class OrderAuthorizingRealm extends AuthorizingRealm implements InitializingBean {\n    @Resource\n    private AuthorizingService authorizingService;\n    @Value(\"${app.role.permissions:}\")\n    private String rolePermissionsString;\n    private Map<String, Set<String>> rolePermissions;\n\n    @Override\n    protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principalCollection) {\n        final SysUser sysUser = (SysUser)super.getAvailablePrincipal(principalCollection);\n        final String role = sysUser.getUserRole().getRole();\n        final SimpleAuthorizationInfo authorizationInfo = new SimpleAuthorizationInfo(Sets.newHashSet(role));\n        authorizationInfo.setStringPermissions(rolePermissions.get(role));\n        return authorizationInfo;\n    }\n\n    @Override\n    protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken authenticationToken) throws AuthenticationException {\n        final UsernamePasswordToken usernamePasswordToken = (UsernamePasswordToken) authenticationToken;\n        final String mobile = usernamePasswordToken.getUsername();\n        final String validateCode = authorizingService.getCodeByMobile(mobile);\n        if (StringUtils.isBlank(validateCode)) {\n            throw new ExpiredCredentialsException(\"验证码已失效#[\" + mobile + \"]\");\n        }\n        final List<SysUser> sysUserList = authorizingService.getUserByMobile(mobile);\n        if (CollectionUtils.isEmpty(sysUserList)) {\n            throw new UnknownAccountException(\"用户账户不存在#[\" + mobile + \"]\");\n        }\n        if (sysUserList.size() > 1) {\n            throw new ConcurrentAccessException(\"用户存在多个账户#[\" + mobile + \"]\");\n        }\n        final SysUser sysUser = sysUserList.iterator().next();\n        if (!sysUser.getStatus().isAllowLogin()) {\n            throw new DisabledAccountException(\"用户账户不可用#[\" + mobile + \"]\");\n        }\n        // 注意：SimpleAuthenticationInfo中principal表示验证主体，供后续获取权限标识符和当前登录用户信息使用， credentials表示正确的凭证串，shiro会自动与用户登录时填入的值进行密钥匹配后进行对比。\n        // credentials也可以通过setCredentialsSalt设置加密的salt\n        return new SimpleAuthenticationInfo(sysUser, validateCode.toCharArray(), super.getName());\n    }\n\n    @Override\n    public void afterPropertiesSet() throws Exception {\n        if (StringUtils.isBlank(rolePermissionsString)) {\n            throw new NullPointerException(\"未初始化权限配置\");\n        }\n        rolePermissions = Maps.newHashMap();\n        final JSONObject jsonObject = JSON.parseObject(rolePermissionsString);\n        final Iterator<Map.Entry<String, Object>> entryIterator = jsonObject.entrySet().iterator();\n        while (entryIterator.hasNext()) {\n            final Map.Entry<String, Object> objectEntry = entryIterator.next();\n            rolePermissions.put(objectEntry.getKey(), Sets.newHashSet(objectEntry.getValue().toString().split(\",\")));\n        }\n    }\n}\n```\n\n`UserApiController.java`\n```java\n@RestController\n@RequestMapping(value = \"/api/user\", produces = MediaType.APPLICATION_JSON_UTF8_VALUE)\npublic class UserApiController extends BasicApiController {\n\n    @Resource\n    private SysUserService userService;\n\n    /**\n    * 用户登录\n    */\n    @RequestMapping(value = \"/login/{mobileNo}/{code}\", method = RequestMethod.GET)\n    public Output login(@PathVariable String mobileNo, @PathVariable String code) throws ServiceException {\n        Subject subject = SecurityUtils.getSubject();\n        UsernamePasswordToken token = new UsernamePasswordToken(mobileNo, code);\n        subject.login(token);\n        token.clear();\n        return MapOutput.createSuccess();\n    }\n\n    /**\n    * 用户登出\n    */\n    @RequestMapping(value = \"/logout/{mobileNo}\", method = RequestMethod.GET)\n    public Output logout(@PathVariable String mobileNo) throws ServiceException {\n        SecurityUtils.getSubject().logout();\n        return MapOutput.createSuccess();\n    }\n}\n```\n## Shiro凭证匹配器配置\n加密方式都为`org.apache.shiro.authc.credential.CredentialsMatcher`的实现类\n通过`org.apache.shiro.realm.AuthenticatingRealm`的`private CredentialsMatcher credentialsMatcher`设置凭据的匹配实现类\n如：\n```xml\n<bean id=\"securityManager\" class=\"org.apache.shiro.web.mgt.DefaultWebSecurityManager\">\n    <property name=\"realm\">\n<!--BEGIN: 设置凭证器------------------>\n       <bean class=\"com.smzc.apps.order.web.auth.OrderAuthorizingRealm\">\n         <property name=\"credentialsMatcher\">\n           <bean class=\"org.apache.shiro.authc.credential.PasswordMatcher\" />\n         </property>\n       </bean>\n<!--END: 设置凭证器------------------>\n    </property>\n    <property name=\"cacheManager\">\n       <bean class=\"org.apache.shiro.cache.ehcache.EhCacheManager\" />\n    </property>\n    <property name=\"sessionManager\">\n       <bean class=\"org.apache.shiro.web.session.mgt.DefaultWebSessionManager\">\n           <property name=\"sessionIdCookie\">\n               <bean class=\"org.apache.shiro.web.servlet.SimpleCookie\">\n                   <constructor-arg value=\"SESSIONID\"/>\n                   <property name=\"httpOnly\" value=\"true\"/>\n                   <property name=\"maxAge\" value=\"-1\"/>\n               </bean>\n           </property>\n       </bean>\n    </property>\n</bean>\n```\n\n## Shiro内置的FilterChain\n1. Shiro验证URL时,URL匹配成功便不再继续匹配查找(所以要注意配置文件中的URL顺序,尤其在使用通配符时)\n 故filterChainDefinitions的配置顺序为自上而下,以最上面的为准\n2. 当运行一个Web应用程序时,Shiro将会创建一些有用的默认Filter实例,并自动地在[main]项中将它们置为可用\n 自动地可用的默认的Filter实例是被DefaultFilter枚举类定义的,枚举的名称字段就是可供配置的名称\n anon---------------org.apache.shiro.web.filter.authc.AnonymousFilter\n authc--------------org.apache.shiro.web.filter.authc.FormAuthenticationFilter\n authcBasic---------org.apache.shiro.web.filter.authc.BasicHttpAuthenticationFilter\n logout-------------org.apache.shiro.web.filter.authc.LogoutFilter\n noSessionCreation--org.apache.shiro.web.filter.session.NoSessionCreationFilter\n perms--------------org.apache.shiro.web.filter.authz.PermissionAuthorizationFilter\n port---------------org.apache.shiro.web.filter.authz.PortFilter\n rest---------------org.apache.shiro.web.filter.authz.HttpMethodPermissionFilter\n roles--------------org.apache.shiro.web.filter.authz.RolesAuthorizationFilter\n ssl----------------org.apache.shiro.web.filter.authz.SslFilter\n user---------------org.apache.shiro.web.filter.authz.UserFilter\n\n3. 通常可将这些过滤器分为两组\n anon,authc,authcBasic,user是第一组认证过滤器\n perms,port,rest,roles,ssl是第二组授权过滤器\n 注意user和authc不同：当应用开启了rememberMe时,用户下次访问时可以是一个user,但绝不会是authc,因为authc是需要重新认证的\n user表示用户不一定已通过认证,只要曾被Shiro记住过登录状态的用户就可以正常发起请求,比如rememberMe\n 说白了,以前的一个用户登录时开启了rememberMe,然后他关闭浏览器,下次再访问时他就是一个user,而不会authc\n\n4. 举几个例子\n /admin=authc,roles[admin]      表示用户必需已通过认证,并拥有admin角色才可以正常发起'/admin'请求\n /edit=authc,perms[admin:edit]  表示用户必需已通过认证,并拥有admin:edit权限才可以正常发起'/edit'请求\n /home=user                     表示用户不一定需要已经通过认证,只需要曾经被Shiro记住过登录状态就可以正常发起'/home'请求\n\n5. 各默认过滤器常用如下(注意URL Pattern里用到的是两颗星,这样才能实现任意层次的全匹配)\n /admins/**=anon             无参,表示可匿名使用,可以理解为匿名用户或游客\n /admins/user/**=authc       无参,表示需认证才能使用\n /admins/user/**=authcBasic  无参,表示httpBasic认证\n /admins/user/**=user        无参,表示必须存在用户,当登入操作时不做检查\n /admins/user/**=ssl         无参,表示安全的URL请求,协议为https\n /admins/user/**=perms[user:add:*]\n 参数可写多个,多参时必须加上引号,且参数之间用逗号分割,如/admins/user/**=perms[\"user:add:*,user:modify:*\"]\n 当有多个参数时必须每个参数都通过才算通过,相当于isPermitedAll()方法\n /admins/user/**=port[8081]\n 当请求的URL端口不是8081时,跳转到schemal://serverName:8081?queryString\n 其中schmal是协议http或https等,serverName是你访问的Host,8081是Port端口,queryString是你访问的URL里的?后面的参数\n /admins/user/**=rest[user]\n 根据请求的方法,相当于/admins/user/**=perms[user:method],其中method为post,get,delete等\n /admins/user/**=roles[admin]\n 参数可写多个,多个时必须加上引号,且参数之间用逗号分割,如/admins/user/**=roles[\"admin,guest\"]\n 当有多个参数时必须每个参数都通过才算通过,相当于hasAllRoles()方法\n\n-----\n\n*观点仅代表自己，期待你的留言。*\n","slug":"shiro-smscode-auth","published":1,"updated":"2021-08-31T14:23:11.549Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cku52dyoe004hbbin0f3t46pp","content":"<h2 id=\"分析\"><a href=\"#分析\" class=\"headerlink\" title=\"分析\"></a>分析</h2><p>Shiro通过<code>org.apache.shiro.realm.Realm</code>进行身份与权限的校验，通过<code>org.apache.shiro.realm.jdbc.JdbcRealm</code>来查看，<br>我决定继承自<code>org.apache.shiro.realm.AuthorizingRealm</code>来实现身份校验逻辑和权限标识符获取的逻辑。</p>\n<p><code>org.apache.shiro.realm.AuthorizingRealm</code><br>两个抽象方法：<br>1、 <code>protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principalCollection)</code>:<br>  主要用于通过当前身份来获取Permissions。</p>\n<p>2、 <code>protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken authenticationToken) throws AuthenticationException</code><br>  主要是用户在登录时调用此方法完成用户身份初步校验，注意：校验凭证(密码、验证码等)由Shiro进行校验不需要手动在此进行校验。</p>\n<h2 id=\"源码\"><a href=\"#源码\" class=\"headerlink\" title=\"源码\"></a>源码</h2><p><code>spring-shiro.xml</code></p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;securityManager&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;org.apache.shiro.web.mgt.DefaultWebSecurityManager&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;realm&quot;</span>&gt;</span></span><br><span class=\"line\">       <span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;com.smzc.apps.order.web.auth.OrderAuthorizingRealm&quot;</span> /&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;cacheManager&quot;</span>&gt;</span></span><br><span class=\"line\">       <span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;org.apache.shiro.cache.ehcache.EhCacheManager&quot;</span> /&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;sessionManager&quot;</span>&gt;</span></span><br><span class=\"line\">       <span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;org.apache.shiro.web.session.mgt.DefaultWebSessionManager&quot;</span>&gt;</span></span><br><span class=\"line\">           <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;sessionIdCookie&quot;</span>&gt;</span></span><br><span class=\"line\">               <span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;org.apache.shiro.web.servlet.SimpleCookie&quot;</span>&gt;</span></span><br><span class=\"line\">                   <span class=\"tag\">&lt;<span class=\"name\">constructor-arg</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;SESSIONID&quot;</span>/&gt;</span></span><br><span class=\"line\">                   <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;httpOnly&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;true&quot;</span>/&gt;</span></span><br><span class=\"line\">                   <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;maxAge&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;-1&quot;</span>/&gt;</span></span><br><span class=\"line\">               <span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br><span class=\"line\">           <span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">       <span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;org.springframework.beans.factory.config.MethodInvokingFactoryBean&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;staticMethod&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;org.apache.shiro.SecurityUtils.setSecurityManager&quot;</span> /&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;arguments&quot;</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">list</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">ref</span> <span class=\"attr\">bean</span>=<span class=\"string\">&quot;securityManager&quot;</span>/&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">list</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- shiroFilter --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;shiroFilterFactoryBean&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;org.apache.shiro.spring.web.ShiroFilterFactoryBean&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- Shiro的核心安全接口,这个属性是必须的 --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;securityManager&quot;</span> <span class=\"attr\">ref</span>=<span class=\"string\">&quot;securityManager&quot;</span> /&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 要求登录时的链接,非必须的属性,默认会自动寻找Web工程根目录下的&quot;/login.jsp&quot;页面 --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;loginUrl&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;/views/login&quot;</span> /&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 登录成功后要跳转的连接 --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;successUrl&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;/views/index&quot;</span> /&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 用户访问未对其授权的资源时,所显示的连接 --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;unauthorizedUrl&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;/views/common/unauthorized&quot;</span> /&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;filters&quot;</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">map</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">entry</span> <span class=\"attr\">key</span>=<span class=\"string\">&quot;logout&quot;</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;org.apache.shiro.web.filter.authc.LogoutFilter&quot;</span>&gt;</span></span><br><span class=\"line\">                    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;redirectUrl&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;/views/login&quot;</span>/&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;/<span class=\"name\">entry</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">map</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 配置Shiro过滤链 --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;filterChainDefinitions&quot;</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span></span><br><span class=\"line\">            /api/user/login/** = anon</span><br><span class=\"line\">            /api/** = authc</span><br><span class=\"line\">            /logout = logout</span><br><span class=\"line\">            /** = anon</span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p><code>OrderAuthorizingRealm.java</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">OrderAuthorizingRealm</span> <span class=\"keyword\">extends</span> <span class=\"title\">AuthorizingRealm</span> <span class=\"keyword\">implements</span> <span class=\"title\">InitializingBean</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Resource</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> AuthorizingService authorizingService;</span><br><span class=\"line\">    <span class=\"meta\">@Value(&quot;$&#123;app.role.permissions:&#125;&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String rolePermissionsString;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Map&lt;String, Set&lt;String&gt;&gt; rolePermissions;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> AuthorizationInfo <span class=\"title\">doGetAuthorizationInfo</span><span class=\"params\">(PrincipalCollection principalCollection)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> SysUser sysUser = (SysUser)<span class=\"keyword\">super</span>.getAvailablePrincipal(principalCollection);</span><br><span class=\"line\">        <span class=\"keyword\">final</span> String role = sysUser.getUserRole().getRole();</span><br><span class=\"line\">        <span class=\"keyword\">final</span> SimpleAuthorizationInfo authorizationInfo = <span class=\"keyword\">new</span> SimpleAuthorizationInfo(Sets.newHashSet(role));</span><br><span class=\"line\">        authorizationInfo.setStringPermissions(rolePermissions.get(role));</span><br><span class=\"line\">        <span class=\"keyword\">return</span> authorizationInfo;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> AuthenticationInfo <span class=\"title\">doGetAuthenticationInfo</span><span class=\"params\">(AuthenticationToken authenticationToken)</span> <span class=\"keyword\">throws</span> AuthenticationException </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> UsernamePasswordToken usernamePasswordToken = (UsernamePasswordToken) authenticationToken;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> String mobile = usernamePasswordToken.getUsername();</span><br><span class=\"line\">        <span class=\"keyword\">final</span> String validateCode = authorizingService.getCodeByMobile(mobile);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (StringUtils.isBlank(validateCode)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> ExpiredCredentialsException(<span class=\"string\">&quot;验证码已失效#[&quot;</span> + mobile + <span class=\"string\">&quot;]&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> List&lt;SysUser&gt; sysUserList = authorizingService.getUserByMobile(mobile);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (CollectionUtils.isEmpty(sysUserList)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> UnknownAccountException(<span class=\"string\">&quot;用户账户不存在#[&quot;</span> + mobile + <span class=\"string\">&quot;]&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (sysUserList.size() &gt; <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> ConcurrentAccessException(<span class=\"string\">&quot;用户存在多个账户#[&quot;</span> + mobile + <span class=\"string\">&quot;]&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> SysUser sysUser = sysUserList.iterator().next();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!sysUser.getStatus().isAllowLogin()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> DisabledAccountException(<span class=\"string\">&quot;用户账户不可用#[&quot;</span> + mobile + <span class=\"string\">&quot;]&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 注意：SimpleAuthenticationInfo中principal表示验证主体，供后续获取权限标识符和当前登录用户信息使用， credentials表示正确的凭证串，shiro会自动与用户登录时填入的值进行密钥匹配后进行对比。</span></span><br><span class=\"line\">        <span class=\"comment\">// credentials也可以通过setCredentialsSalt设置加密的salt</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> SimpleAuthenticationInfo(sysUser, validateCode.toCharArray(), <span class=\"keyword\">super</span>.getName());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">afterPropertiesSet</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (StringUtils.isBlank(rolePermissionsString)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NullPointerException(<span class=\"string\">&quot;未初始化权限配置&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        rolePermissions = Maps.newHashMap();</span><br><span class=\"line\">        <span class=\"keyword\">final</span> JSONObject jsonObject = JSON.parseObject(rolePermissionsString);</span><br><span class=\"line\">        <span class=\"keyword\">final</span> Iterator&lt;Map.Entry&lt;String, Object&gt;&gt; entryIterator = jsonObject.entrySet().iterator();</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (entryIterator.hasNext()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">final</span> Map.Entry&lt;String, Object&gt; objectEntry = entryIterator.next();</span><br><span class=\"line\">            rolePermissions.put(objectEntry.getKey(), Sets.newHashSet(objectEntry.getValue().toString().split(<span class=\"string\">&quot;,&quot;</span>)));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>UserApiController.java</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@RestController</span></span><br><span class=\"line\"><span class=\"meta\">@RequestMapping(value = &quot;/api/user&quot;, produces = MediaType.APPLICATION_JSON_UTF8_VALUE)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UserApiController</span> <span class=\"keyword\">extends</span> <span class=\"title\">BasicApiController</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Resource</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> SysUserService userService;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">    * 用户登录</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">    <span class=\"meta\">@RequestMapping(value = &quot;/login/&#123;mobileNo&#125;/&#123;code&#125;&quot;, method = RequestMethod.GET)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Output <span class=\"title\">login</span><span class=\"params\">(<span class=\"meta\">@PathVariable</span> String mobileNo, <span class=\"meta\">@PathVariable</span> String code)</span> <span class=\"keyword\">throws</span> ServiceException </span>&#123;</span><br><span class=\"line\">        Subject subject = SecurityUtils.getSubject();</span><br><span class=\"line\">        UsernamePasswordToken token = <span class=\"keyword\">new</span> UsernamePasswordToken(mobileNo, code);</span><br><span class=\"line\">        subject.login(token);</span><br><span class=\"line\">        token.clear();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> MapOutput.createSuccess();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">    * 用户登出</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">    <span class=\"meta\">@RequestMapping(value = &quot;/logout/&#123;mobileNo&#125;&quot;, method = RequestMethod.GET)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Output <span class=\"title\">logout</span><span class=\"params\">(<span class=\"meta\">@PathVariable</span> String mobileNo)</span> <span class=\"keyword\">throws</span> ServiceException </span>&#123;</span><br><span class=\"line\">        SecurityUtils.getSubject().logout();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> MapOutput.createSuccess();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"Shiro凭证匹配器配置\"><a href=\"#Shiro凭证匹配器配置\" class=\"headerlink\" title=\"Shiro凭证匹配器配置\"></a>Shiro凭证匹配器配置</h2><p>加密方式都为<code>org.apache.shiro.authc.credential.CredentialsMatcher</code>的实现类<br>通过<code>org.apache.shiro.realm.AuthenticatingRealm</code>的<code>private CredentialsMatcher credentialsMatcher</code>设置凭据的匹配实现类<br>如：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;securityManager&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;org.apache.shiro.web.mgt.DefaultWebSecurityManager&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;realm&quot;</span>&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!--BEGIN: 设置凭证器------------------&gt;</span></span><br><span class=\"line\">       <span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;com.smzc.apps.order.web.auth.OrderAuthorizingRealm&quot;</span>&gt;</span></span><br><span class=\"line\">         <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;credentialsMatcher&quot;</span>&gt;</span></span><br><span class=\"line\">           <span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;org.apache.shiro.authc.credential.PasswordMatcher&quot;</span> /&gt;</span></span><br><span class=\"line\">         <span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">       <span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!--END: 设置凭证器------------------&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;cacheManager&quot;</span>&gt;</span></span><br><span class=\"line\">       <span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;org.apache.shiro.cache.ehcache.EhCacheManager&quot;</span> /&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;sessionManager&quot;</span>&gt;</span></span><br><span class=\"line\">       <span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;org.apache.shiro.web.session.mgt.DefaultWebSessionManager&quot;</span>&gt;</span></span><br><span class=\"line\">           <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;sessionIdCookie&quot;</span>&gt;</span></span><br><span class=\"line\">               <span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;org.apache.shiro.web.servlet.SimpleCookie&quot;</span>&gt;</span></span><br><span class=\"line\">                   <span class=\"tag\">&lt;<span class=\"name\">constructor-arg</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;SESSIONID&quot;</span>/&gt;</span></span><br><span class=\"line\">                   <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;httpOnly&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;true&quot;</span>/&gt;</span></span><br><span class=\"line\">                   <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;maxAge&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;-1&quot;</span>/&gt;</span></span><br><span class=\"line\">               <span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br><span class=\"line\">           <span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">       <span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Shiro内置的FilterChain\"><a href=\"#Shiro内置的FilterChain\" class=\"headerlink\" title=\"Shiro内置的FilterChain\"></a>Shiro内置的FilterChain</h2><ol>\n<li><p>Shiro验证URL时,URL匹配成功便不再继续匹配查找(所以要注意配置文件中的URL顺序,尤其在使用通配符时)<br>故filterChainDefinitions的配置顺序为自上而下,以最上面的为准</p>\n</li>\n<li><p>当运行一个Web应用程序时,Shiro将会创建一些有用的默认Filter实例,并自动地在[main]项中将它们置为可用<br>自动地可用的默认的Filter实例是被DefaultFilter枚举类定义的,枚举的名称字段就是可供配置的名称<br>anon—————org.apache.shiro.web.filter.authc.AnonymousFilter<br>authc————–org.apache.shiro.web.filter.authc.FormAuthenticationFilter<br>authcBasic———org.apache.shiro.web.filter.authc.BasicHttpAuthenticationFilter<br>logout————-org.apache.shiro.web.filter.authc.LogoutFilter<br>noSessionCreation–org.apache.shiro.web.filter.session.NoSessionCreationFilter<br>perms————–org.apache.shiro.web.filter.authz.PermissionAuthorizationFilter<br>port—————org.apache.shiro.web.filter.authz.PortFilter<br>rest—————org.apache.shiro.web.filter.authz.HttpMethodPermissionFilter<br>roles————–org.apache.shiro.web.filter.authz.RolesAuthorizationFilter<br>ssl—————-org.apache.shiro.web.filter.authz.SslFilter<br>user—————org.apache.shiro.web.filter.authz.UserFilter</p>\n</li>\n<li><p>通常可将这些过滤器分为两组<br>anon,authc,authcBasic,user是第一组认证过滤器<br>perms,port,rest,roles,ssl是第二组授权过滤器<br>注意user和authc不同：当应用开启了rememberMe时,用户下次访问时可以是一个user,但绝不会是authc,因为authc是需要重新认证的<br>user表示用户不一定已通过认证,只要曾被Shiro记住过登录状态的用户就可以正常发起请求,比如rememberMe<br>说白了,以前的一个用户登录时开启了rememberMe,然后他关闭浏览器,下次再访问时他就是一个user,而不会authc</p>\n</li>\n<li><p>举几个例子<br>/admin=authc,roles[admin]      表示用户必需已通过认证,并拥有admin角色才可以正常发起’/admin’请求<br>/edit=authc,perms[admin:edit]  表示用户必需已通过认证,并拥有admin:edit权限才可以正常发起’/edit’请求<br>/home=user                     表示用户不一定需要已经通过认证,只需要曾经被Shiro记住过登录状态就可以正常发起’/home’请求</p>\n</li>\n<li><p>各默认过滤器常用如下(注意URL Pattern里用到的是两颗星,这样才能实现任意层次的全匹配)<br>/admins/<strong>=anon             无参,表示可匿名使用,可以理解为匿名用户或游客<br>/admins/user/</strong>=authc       无参,表示需认证才能使用<br>/admins/user/<strong>=authcBasic  无参,表示httpBasic认证<br>/admins/user/</strong>=user        无参,表示必须存在用户,当登入操作时不做检查<br>/admins/user/<strong>=ssl         无参,表示安全的URL请求,协议为https<br>/admins/user/</strong>=perms[user:add:<em>]<br>参数可写多个,多参时必须加上引号,且参数之间用逗号分割,如/admins/user/**=perms[“user:add:</em>,user:modify:*”]<br>当有多个参数时必须每个参数都通过才算通过,相当于isPermitedAll()方法<br>/admins/user/<strong>=port[8081]<br>当请求的URL端口不是8081时,跳转到schemal://serverName:8081?queryString<br>其中schmal是协议http或https等,serverName是你访问的Host,8081是Port端口,queryString是你访问的URL里的?后面的参数<br>/admins/user/</strong>=rest[user]<br>根据请求的方法,相当于/admins/user/<strong>=perms[user:method],其中method为post,get,delete等<br>/admins/user/</strong>=roles[admin]<br>参数可写多个,多个时必须加上引号,且参数之间用逗号分割,如/admins/user/**=roles[“admin,guest”]<br>当有多个参数时必须每个参数都通过才算通过,相当于hasAllRoles()方法</p>\n</li>\n</ol>\n<hr>\n<p><em>观点仅代表自己，期待你的留言。</em></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"分析\"><a href=\"#分析\" class=\"headerlink\" title=\"分析\"></a>分析</h2><p>Shiro通过<code>org.apache.shiro.realm.Realm</code>进行身份与权限的校验，通过<code>org.apache.shiro.realm.jdbc.JdbcRealm</code>来查看，<br>我决定继承自<code>org.apache.shiro.realm.AuthorizingRealm</code>来实现身份校验逻辑和权限标识符获取的逻辑。</p>\n<p><code>org.apache.shiro.realm.AuthorizingRealm</code><br>两个抽象方法：<br>1、 <code>protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principalCollection)</code>:<br>  主要用于通过当前身份来获取Permissions。</p>\n<p>2、 <code>protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken authenticationToken) throws AuthenticationException</code><br>  主要是用户在登录时调用此方法完成用户身份初步校验，注意：校验凭证(密码、验证码等)由Shiro进行校验不需要手动在此进行校验。</p>\n<h2 id=\"源码\"><a href=\"#源码\" class=\"headerlink\" title=\"源码\"></a>源码</h2><p><code>spring-shiro.xml</code></p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;securityManager&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;org.apache.shiro.web.mgt.DefaultWebSecurityManager&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;realm&quot;</span>&gt;</span></span><br><span class=\"line\">       <span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;com.smzc.apps.order.web.auth.OrderAuthorizingRealm&quot;</span> /&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;cacheManager&quot;</span>&gt;</span></span><br><span class=\"line\">       <span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;org.apache.shiro.cache.ehcache.EhCacheManager&quot;</span> /&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;sessionManager&quot;</span>&gt;</span></span><br><span class=\"line\">       <span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;org.apache.shiro.web.session.mgt.DefaultWebSessionManager&quot;</span>&gt;</span></span><br><span class=\"line\">           <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;sessionIdCookie&quot;</span>&gt;</span></span><br><span class=\"line\">               <span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;org.apache.shiro.web.servlet.SimpleCookie&quot;</span>&gt;</span></span><br><span class=\"line\">                   <span class=\"tag\">&lt;<span class=\"name\">constructor-arg</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;SESSIONID&quot;</span>/&gt;</span></span><br><span class=\"line\">                   <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;httpOnly&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;true&quot;</span>/&gt;</span></span><br><span class=\"line\">                   <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;maxAge&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;-1&quot;</span>/&gt;</span></span><br><span class=\"line\">               <span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br><span class=\"line\">           <span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">       <span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;org.springframework.beans.factory.config.MethodInvokingFactoryBean&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;staticMethod&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;org.apache.shiro.SecurityUtils.setSecurityManager&quot;</span> /&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;arguments&quot;</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">list</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">ref</span> <span class=\"attr\">bean</span>=<span class=\"string\">&quot;securityManager&quot;</span>/&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">list</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- shiroFilter --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;shiroFilterFactoryBean&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;org.apache.shiro.spring.web.ShiroFilterFactoryBean&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- Shiro的核心安全接口,这个属性是必须的 --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;securityManager&quot;</span> <span class=\"attr\">ref</span>=<span class=\"string\">&quot;securityManager&quot;</span> /&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 要求登录时的链接,非必须的属性,默认会自动寻找Web工程根目录下的&quot;/login.jsp&quot;页面 --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;loginUrl&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;/views/login&quot;</span> /&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 登录成功后要跳转的连接 --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;successUrl&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;/views/index&quot;</span> /&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 用户访问未对其授权的资源时,所显示的连接 --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;unauthorizedUrl&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;/views/common/unauthorized&quot;</span> /&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;filters&quot;</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">map</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">entry</span> <span class=\"attr\">key</span>=<span class=\"string\">&quot;logout&quot;</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;org.apache.shiro.web.filter.authc.LogoutFilter&quot;</span>&gt;</span></span><br><span class=\"line\">                    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;redirectUrl&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;/views/login&quot;</span>/&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;/<span class=\"name\">entry</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">map</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 配置Shiro过滤链 --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;filterChainDefinitions&quot;</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span></span><br><span class=\"line\">            /api/user/login/** = anon</span><br><span class=\"line\">            /api/** = authc</span><br><span class=\"line\">            /logout = logout</span><br><span class=\"line\">            /** = anon</span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p><code>OrderAuthorizingRealm.java</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">OrderAuthorizingRealm</span> <span class=\"keyword\">extends</span> <span class=\"title\">AuthorizingRealm</span> <span class=\"keyword\">implements</span> <span class=\"title\">InitializingBean</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Resource</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> AuthorizingService authorizingService;</span><br><span class=\"line\">    <span class=\"meta\">@Value(&quot;$&#123;app.role.permissions:&#125;&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String rolePermissionsString;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Map&lt;String, Set&lt;String&gt;&gt; rolePermissions;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> AuthorizationInfo <span class=\"title\">doGetAuthorizationInfo</span><span class=\"params\">(PrincipalCollection principalCollection)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> SysUser sysUser = (SysUser)<span class=\"keyword\">super</span>.getAvailablePrincipal(principalCollection);</span><br><span class=\"line\">        <span class=\"keyword\">final</span> String role = sysUser.getUserRole().getRole();</span><br><span class=\"line\">        <span class=\"keyword\">final</span> SimpleAuthorizationInfo authorizationInfo = <span class=\"keyword\">new</span> SimpleAuthorizationInfo(Sets.newHashSet(role));</span><br><span class=\"line\">        authorizationInfo.setStringPermissions(rolePermissions.get(role));</span><br><span class=\"line\">        <span class=\"keyword\">return</span> authorizationInfo;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> AuthenticationInfo <span class=\"title\">doGetAuthenticationInfo</span><span class=\"params\">(AuthenticationToken authenticationToken)</span> <span class=\"keyword\">throws</span> AuthenticationException </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> UsernamePasswordToken usernamePasswordToken = (UsernamePasswordToken) authenticationToken;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> String mobile = usernamePasswordToken.getUsername();</span><br><span class=\"line\">        <span class=\"keyword\">final</span> String validateCode = authorizingService.getCodeByMobile(mobile);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (StringUtils.isBlank(validateCode)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> ExpiredCredentialsException(<span class=\"string\">&quot;验证码已失效#[&quot;</span> + mobile + <span class=\"string\">&quot;]&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> List&lt;SysUser&gt; sysUserList = authorizingService.getUserByMobile(mobile);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (CollectionUtils.isEmpty(sysUserList)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> UnknownAccountException(<span class=\"string\">&quot;用户账户不存在#[&quot;</span> + mobile + <span class=\"string\">&quot;]&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (sysUserList.size() &gt; <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> ConcurrentAccessException(<span class=\"string\">&quot;用户存在多个账户#[&quot;</span> + mobile + <span class=\"string\">&quot;]&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> SysUser sysUser = sysUserList.iterator().next();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!sysUser.getStatus().isAllowLogin()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> DisabledAccountException(<span class=\"string\">&quot;用户账户不可用#[&quot;</span> + mobile + <span class=\"string\">&quot;]&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 注意：SimpleAuthenticationInfo中principal表示验证主体，供后续获取权限标识符和当前登录用户信息使用， credentials表示正确的凭证串，shiro会自动与用户登录时填入的值进行密钥匹配后进行对比。</span></span><br><span class=\"line\">        <span class=\"comment\">// credentials也可以通过setCredentialsSalt设置加密的salt</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> SimpleAuthenticationInfo(sysUser, validateCode.toCharArray(), <span class=\"keyword\">super</span>.getName());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">afterPropertiesSet</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (StringUtils.isBlank(rolePermissionsString)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NullPointerException(<span class=\"string\">&quot;未初始化权限配置&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        rolePermissions = Maps.newHashMap();</span><br><span class=\"line\">        <span class=\"keyword\">final</span> JSONObject jsonObject = JSON.parseObject(rolePermissionsString);</span><br><span class=\"line\">        <span class=\"keyword\">final</span> Iterator&lt;Map.Entry&lt;String, Object&gt;&gt; entryIterator = jsonObject.entrySet().iterator();</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (entryIterator.hasNext()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">final</span> Map.Entry&lt;String, Object&gt; objectEntry = entryIterator.next();</span><br><span class=\"line\">            rolePermissions.put(objectEntry.getKey(), Sets.newHashSet(objectEntry.getValue().toString().split(<span class=\"string\">&quot;,&quot;</span>)));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>UserApiController.java</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@RestController</span></span><br><span class=\"line\"><span class=\"meta\">@RequestMapping(value = &quot;/api/user&quot;, produces = MediaType.APPLICATION_JSON_UTF8_VALUE)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UserApiController</span> <span class=\"keyword\">extends</span> <span class=\"title\">BasicApiController</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Resource</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> SysUserService userService;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">    * 用户登录</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">    <span class=\"meta\">@RequestMapping(value = &quot;/login/&#123;mobileNo&#125;/&#123;code&#125;&quot;, method = RequestMethod.GET)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Output <span class=\"title\">login</span><span class=\"params\">(<span class=\"meta\">@PathVariable</span> String mobileNo, <span class=\"meta\">@PathVariable</span> String code)</span> <span class=\"keyword\">throws</span> ServiceException </span>&#123;</span><br><span class=\"line\">        Subject subject = SecurityUtils.getSubject();</span><br><span class=\"line\">        UsernamePasswordToken token = <span class=\"keyword\">new</span> UsernamePasswordToken(mobileNo, code);</span><br><span class=\"line\">        subject.login(token);</span><br><span class=\"line\">        token.clear();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> MapOutput.createSuccess();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">    * 用户登出</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">    <span class=\"meta\">@RequestMapping(value = &quot;/logout/&#123;mobileNo&#125;&quot;, method = RequestMethod.GET)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Output <span class=\"title\">logout</span><span class=\"params\">(<span class=\"meta\">@PathVariable</span> String mobileNo)</span> <span class=\"keyword\">throws</span> ServiceException </span>&#123;</span><br><span class=\"line\">        SecurityUtils.getSubject().logout();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> MapOutput.createSuccess();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"Shiro凭证匹配器配置\"><a href=\"#Shiro凭证匹配器配置\" class=\"headerlink\" title=\"Shiro凭证匹配器配置\"></a>Shiro凭证匹配器配置</h2><p>加密方式都为<code>org.apache.shiro.authc.credential.CredentialsMatcher</code>的实现类<br>通过<code>org.apache.shiro.realm.AuthenticatingRealm</code>的<code>private CredentialsMatcher credentialsMatcher</code>设置凭据的匹配实现类<br>如：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;securityManager&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;org.apache.shiro.web.mgt.DefaultWebSecurityManager&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;realm&quot;</span>&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!--BEGIN: 设置凭证器------------------&gt;</span></span><br><span class=\"line\">       <span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;com.smzc.apps.order.web.auth.OrderAuthorizingRealm&quot;</span>&gt;</span></span><br><span class=\"line\">         <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;credentialsMatcher&quot;</span>&gt;</span></span><br><span class=\"line\">           <span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;org.apache.shiro.authc.credential.PasswordMatcher&quot;</span> /&gt;</span></span><br><span class=\"line\">         <span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">       <span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!--END: 设置凭证器------------------&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;cacheManager&quot;</span>&gt;</span></span><br><span class=\"line\">       <span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;org.apache.shiro.cache.ehcache.EhCacheManager&quot;</span> /&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;sessionManager&quot;</span>&gt;</span></span><br><span class=\"line\">       <span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;org.apache.shiro.web.session.mgt.DefaultWebSessionManager&quot;</span>&gt;</span></span><br><span class=\"line\">           <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;sessionIdCookie&quot;</span>&gt;</span></span><br><span class=\"line\">               <span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;org.apache.shiro.web.servlet.SimpleCookie&quot;</span>&gt;</span></span><br><span class=\"line\">                   <span class=\"tag\">&lt;<span class=\"name\">constructor-arg</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;SESSIONID&quot;</span>/&gt;</span></span><br><span class=\"line\">                   <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;httpOnly&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;true&quot;</span>/&gt;</span></span><br><span class=\"line\">                   <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;maxAge&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;-1&quot;</span>/&gt;</span></span><br><span class=\"line\">               <span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br><span class=\"line\">           <span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">       <span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Shiro内置的FilterChain\"><a href=\"#Shiro内置的FilterChain\" class=\"headerlink\" title=\"Shiro内置的FilterChain\"></a>Shiro内置的FilterChain</h2><ol>\n<li><p>Shiro验证URL时,URL匹配成功便不再继续匹配查找(所以要注意配置文件中的URL顺序,尤其在使用通配符时)<br>故filterChainDefinitions的配置顺序为自上而下,以最上面的为准</p>\n</li>\n<li><p>当运行一个Web应用程序时,Shiro将会创建一些有用的默认Filter实例,并自动地在[main]项中将它们置为可用<br>自动地可用的默认的Filter实例是被DefaultFilter枚举类定义的,枚举的名称字段就是可供配置的名称<br>anon—————org.apache.shiro.web.filter.authc.AnonymousFilter<br>authc————–org.apache.shiro.web.filter.authc.FormAuthenticationFilter<br>authcBasic———org.apache.shiro.web.filter.authc.BasicHttpAuthenticationFilter<br>logout————-org.apache.shiro.web.filter.authc.LogoutFilter<br>noSessionCreation–org.apache.shiro.web.filter.session.NoSessionCreationFilter<br>perms————–org.apache.shiro.web.filter.authz.PermissionAuthorizationFilter<br>port—————org.apache.shiro.web.filter.authz.PortFilter<br>rest—————org.apache.shiro.web.filter.authz.HttpMethodPermissionFilter<br>roles————–org.apache.shiro.web.filter.authz.RolesAuthorizationFilter<br>ssl—————-org.apache.shiro.web.filter.authz.SslFilter<br>user—————org.apache.shiro.web.filter.authz.UserFilter</p>\n</li>\n<li><p>通常可将这些过滤器分为两组<br>anon,authc,authcBasic,user是第一组认证过滤器<br>perms,port,rest,roles,ssl是第二组授权过滤器<br>注意user和authc不同：当应用开启了rememberMe时,用户下次访问时可以是一个user,但绝不会是authc,因为authc是需要重新认证的<br>user表示用户不一定已通过认证,只要曾被Shiro记住过登录状态的用户就可以正常发起请求,比如rememberMe<br>说白了,以前的一个用户登录时开启了rememberMe,然后他关闭浏览器,下次再访问时他就是一个user,而不会authc</p>\n</li>\n<li><p>举几个例子<br>/admin=authc,roles[admin]      表示用户必需已通过认证,并拥有admin角色才可以正常发起’/admin’请求<br>/edit=authc,perms[admin:edit]  表示用户必需已通过认证,并拥有admin:edit权限才可以正常发起’/edit’请求<br>/home=user                     表示用户不一定需要已经通过认证,只需要曾经被Shiro记住过登录状态就可以正常发起’/home’请求</p>\n</li>\n<li><p>各默认过滤器常用如下(注意URL Pattern里用到的是两颗星,这样才能实现任意层次的全匹配)<br>/admins/<strong>=anon             无参,表示可匿名使用,可以理解为匿名用户或游客<br>/admins/user/</strong>=authc       无参,表示需认证才能使用<br>/admins/user/<strong>=authcBasic  无参,表示httpBasic认证<br>/admins/user/</strong>=user        无参,表示必须存在用户,当登入操作时不做检查<br>/admins/user/<strong>=ssl         无参,表示安全的URL请求,协议为https<br>/admins/user/</strong>=perms[user:add:<em>]<br>参数可写多个,多参时必须加上引号,且参数之间用逗号分割,如/admins/user/**=perms[“user:add:</em>,user:modify:*”]<br>当有多个参数时必须每个参数都通过才算通过,相当于isPermitedAll()方法<br>/admins/user/<strong>=port[8081]<br>当请求的URL端口不是8081时,跳转到schemal://serverName:8081?queryString<br>其中schmal是协议http或https等,serverName是你访问的Host,8081是Port端口,queryString是你访问的URL里的?后面的参数<br>/admins/user/</strong>=rest[user]<br>根据请求的方法,相当于/admins/user/<strong>=perms[user:method],其中method为post,get,delete等<br>/admins/user/</strong>=roles[admin]<br>参数可写多个,多个时必须加上引号,且参数之间用逗号分割,如/admins/user/**=roles[“admin,guest”]<br>当有多个参数时必须每个参数都通过才算通过,相当于hasAllRoles()方法</p>\n</li>\n</ol>\n<hr>\n<p><em>观点仅代表自己，期待你的留言。</em></p>\n"},{"title":"软件测试点汇总","keywords":["软件测试","测试点汇总","测试工具"],"date":"2019-01-08T09:06:36.000Z","_content":"\n## 功能性测试\n1. 需求功能完成度测试（业务逻辑、功能点等）\n2. 值类型测试\n3. 值乱码测试（特殊字符、表情符等）\n4. 值边界测试\n5. 关联功能测试\n6. 请求重复提交/请求中断测试（快速重复提交请求、发起请求后dismiss功能界面等）\n7. 运行速度测试（app启动、页面切换等）\n8. 程序异常测试\n9. 场景回滚测试\n\n## 兼容性测试\n1. 不同设备兼容性（分辨率、设备品牌、设备ROM版本、不同ROM厂家、不同尺寸等）\n2. 不同app版本兼容性\n3. 网络兼容性（移动网络、不同运营商网络、WIFI、弱网、断网等）\n4. 第三方软件兼容性（输入法软件、蓝牙软件等）\n\n## 升级测试\n1. 全新安装/卸载测试（apk安装/卸载、应用市场软件内安装/卸载等）\n2. 增量/全量升级测试（数字签名测试、跨版本升级等）\n3. 系统资源不足时测试（低电量、断电、硬盘空间不足、内存不足等）\n\n## 接口测试\n1. 数据正确性测试（按接口文档和数据库存储的数据进行计算后验证）\n2. 网络连通性（DNS异常、client断网、server端超时、server端异常、client签名证书异常等）\n3. 数据流量测试（是否有超大数据包传递等）\n4. 数据安全性（数据传输是否加密或混淆等）\n5. 调用方安全性（接口调用方是否鉴权、是否被模拟回调等）\n6. 系统时间篡改对功能的影响\n\n## UI测试\n1. 界面测试（UI布局、界面颜色、风格统一性、字体大小、提示文案位置、界面返回路径等）\n2. 内容测试（文案内容、错别字、版权、专利、隐私内容、敏感词、敏感图片等）\n3. 横竖屏切换、前后台切换等\n\n## 交互测试\n1. app中断测试（来电话、来短信、低电量、待机、插拔数据线、插拔耳机、断网、闹钟，日历提醒，蓝牙提醒等）\n2. 多个app争夺系统资源时对app的影响（声道播放、相机等）\n3. 用户打扰测试（push通知是否在免打扰时段内通知、push通知关闭状态下是否依然通知等）\n4. 长时间使用、长时间后台等\n5. 手势测试（单指滑动，单指单击，单指双击，单指长按，单指缩放，多指点击等）\n\n## 缓存量测试\n1. 第一次使用时存入缓存大量数据对app的影响\n2. 日常使用时更新缓存大量数据对app的影响\n3. 重新安装保存原缓存的大量缓存数据更新对app的影响\n\n## 安全性测试\n1. 数据安全（是否加密传输、关键数据是否容易被篡改等）\n2. 证书安全（SSL证书、SSL密钥等）\n3. 临时目录数据、缓存数据是否安全存储不被恶意读取\n4. 软件权限安全性（扣费风险、隐私泄露风险、非法授权访问等）\n\n## 性能测试（测试工具：LR、NeoLoad、ApacheBench、jmeter、http_load等）\n1. 极限测试（在各种边界压力情况下，如电池、存储、网速等，验证App是否能正确响应）\n2. 响应能力测试（测试各功能的响应时间要求）\n3. 压力测试（反复/长期操作下、系统资源是否占用正常）\n\n## 自动化测试（工具：Selenium、Appium、Watir、Katalon Studio、Monkey Test等）\n1. 通过编写语言脚本对功能或接口进行自动化调用，减少人力测试成本。\n\n\n-----\n\n*观点仅代表自己，期待你的留言。*\n","source":"_posts/software-test-point.md","raw":"---\ntitle: 软件测试点汇总\ntags:\n  - 原创\nkeywords:\n  - 软件测试\n  - 测试点汇总\n  - 测试工具\n\ndate: 2019-01-08 17:06:36\n---\n\n## 功能性测试\n1. 需求功能完成度测试（业务逻辑、功能点等）\n2. 值类型测试\n3. 值乱码测试（特殊字符、表情符等）\n4. 值边界测试\n5. 关联功能测试\n6. 请求重复提交/请求中断测试（快速重复提交请求、发起请求后dismiss功能界面等）\n7. 运行速度测试（app启动、页面切换等）\n8. 程序异常测试\n9. 场景回滚测试\n\n## 兼容性测试\n1. 不同设备兼容性（分辨率、设备品牌、设备ROM版本、不同ROM厂家、不同尺寸等）\n2. 不同app版本兼容性\n3. 网络兼容性（移动网络、不同运营商网络、WIFI、弱网、断网等）\n4. 第三方软件兼容性（输入法软件、蓝牙软件等）\n\n## 升级测试\n1. 全新安装/卸载测试（apk安装/卸载、应用市场软件内安装/卸载等）\n2. 增量/全量升级测试（数字签名测试、跨版本升级等）\n3. 系统资源不足时测试（低电量、断电、硬盘空间不足、内存不足等）\n\n## 接口测试\n1. 数据正确性测试（按接口文档和数据库存储的数据进行计算后验证）\n2. 网络连通性（DNS异常、client断网、server端超时、server端异常、client签名证书异常等）\n3. 数据流量测试（是否有超大数据包传递等）\n4. 数据安全性（数据传输是否加密或混淆等）\n5. 调用方安全性（接口调用方是否鉴权、是否被模拟回调等）\n6. 系统时间篡改对功能的影响\n\n## UI测试\n1. 界面测试（UI布局、界面颜色、风格统一性、字体大小、提示文案位置、界面返回路径等）\n2. 内容测试（文案内容、错别字、版权、专利、隐私内容、敏感词、敏感图片等）\n3. 横竖屏切换、前后台切换等\n\n## 交互测试\n1. app中断测试（来电话、来短信、低电量、待机、插拔数据线、插拔耳机、断网、闹钟，日历提醒，蓝牙提醒等）\n2. 多个app争夺系统资源时对app的影响（声道播放、相机等）\n3. 用户打扰测试（push通知是否在免打扰时段内通知、push通知关闭状态下是否依然通知等）\n4. 长时间使用、长时间后台等\n5. 手势测试（单指滑动，单指单击，单指双击，单指长按，单指缩放，多指点击等）\n\n## 缓存量测试\n1. 第一次使用时存入缓存大量数据对app的影响\n2. 日常使用时更新缓存大量数据对app的影响\n3. 重新安装保存原缓存的大量缓存数据更新对app的影响\n\n## 安全性测试\n1. 数据安全（是否加密传输、关键数据是否容易被篡改等）\n2. 证书安全（SSL证书、SSL密钥等）\n3. 临时目录数据、缓存数据是否安全存储不被恶意读取\n4. 软件权限安全性（扣费风险、隐私泄露风险、非法授权访问等）\n\n## 性能测试（测试工具：LR、NeoLoad、ApacheBench、jmeter、http_load等）\n1. 极限测试（在各种边界压力情况下，如电池、存储、网速等，验证App是否能正确响应）\n2. 响应能力测试（测试各功能的响应时间要求）\n3. 压力测试（反复/长期操作下、系统资源是否占用正常）\n\n## 自动化测试（工具：Selenium、Appium、Watir、Katalon Studio、Monkey Test等）\n1. 通过编写语言脚本对功能或接口进行自动化调用，减少人力测试成本。\n\n\n-----\n\n*观点仅代表自己，期待你的留言。*\n","slug":"software-test-point","published":1,"updated":"2021-08-31T14:23:11.549Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cku52dyog004kbbin3pambq7m","content":"<h2 id=\"功能性测试\"><a href=\"#功能性测试\" class=\"headerlink\" title=\"功能性测试\"></a>功能性测试</h2><ol>\n<li>需求功能完成度测试（业务逻辑、功能点等）</li>\n<li>值类型测试</li>\n<li>值乱码测试（特殊字符、表情符等）</li>\n<li>值边界测试</li>\n<li>关联功能测试</li>\n<li>请求重复提交/请求中断测试（快速重复提交请求、发起请求后dismiss功能界面等）</li>\n<li>运行速度测试（app启动、页面切换等）</li>\n<li>程序异常测试</li>\n<li>场景回滚测试</li>\n</ol>\n<h2 id=\"兼容性测试\"><a href=\"#兼容性测试\" class=\"headerlink\" title=\"兼容性测试\"></a>兼容性测试</h2><ol>\n<li>不同设备兼容性（分辨率、设备品牌、设备ROM版本、不同ROM厂家、不同尺寸等）</li>\n<li>不同app版本兼容性</li>\n<li>网络兼容性（移动网络、不同运营商网络、WIFI、弱网、断网等）</li>\n<li>第三方软件兼容性（输入法软件、蓝牙软件等）</li>\n</ol>\n<h2 id=\"升级测试\"><a href=\"#升级测试\" class=\"headerlink\" title=\"升级测试\"></a>升级测试</h2><ol>\n<li>全新安装/卸载测试（apk安装/卸载、应用市场软件内安装/卸载等）</li>\n<li>增量/全量升级测试（数字签名测试、跨版本升级等）</li>\n<li>系统资源不足时测试（低电量、断电、硬盘空间不足、内存不足等）</li>\n</ol>\n<h2 id=\"接口测试\"><a href=\"#接口测试\" class=\"headerlink\" title=\"接口测试\"></a>接口测试</h2><ol>\n<li>数据正确性测试（按接口文档和数据库存储的数据进行计算后验证）</li>\n<li>网络连通性（DNS异常、client断网、server端超时、server端异常、client签名证书异常等）</li>\n<li>数据流量测试（是否有超大数据包传递等）</li>\n<li>数据安全性（数据传输是否加密或混淆等）</li>\n<li>调用方安全性（接口调用方是否鉴权、是否被模拟回调等）</li>\n<li>系统时间篡改对功能的影响</li>\n</ol>\n<h2 id=\"UI测试\"><a href=\"#UI测试\" class=\"headerlink\" title=\"UI测试\"></a>UI测试</h2><ol>\n<li>界面测试（UI布局、界面颜色、风格统一性、字体大小、提示文案位置、界面返回路径等）</li>\n<li>内容测试（文案内容、错别字、版权、专利、隐私内容、敏感词、敏感图片等）</li>\n<li>横竖屏切换、前后台切换等</li>\n</ol>\n<h2 id=\"交互测试\"><a href=\"#交互测试\" class=\"headerlink\" title=\"交互测试\"></a>交互测试</h2><ol>\n<li>app中断测试（来电话、来短信、低电量、待机、插拔数据线、插拔耳机、断网、闹钟，日历提醒，蓝牙提醒等）</li>\n<li>多个app争夺系统资源时对app的影响（声道播放、相机等）</li>\n<li>用户打扰测试（push通知是否在免打扰时段内通知、push通知关闭状态下是否依然通知等）</li>\n<li>长时间使用、长时间后台等</li>\n<li>手势测试（单指滑动，单指单击，单指双击，单指长按，单指缩放，多指点击等）</li>\n</ol>\n<h2 id=\"缓存量测试\"><a href=\"#缓存量测试\" class=\"headerlink\" title=\"缓存量测试\"></a>缓存量测试</h2><ol>\n<li>第一次使用时存入缓存大量数据对app的影响</li>\n<li>日常使用时更新缓存大量数据对app的影响</li>\n<li>重新安装保存原缓存的大量缓存数据更新对app的影响</li>\n</ol>\n<h2 id=\"安全性测试\"><a href=\"#安全性测试\" class=\"headerlink\" title=\"安全性测试\"></a>安全性测试</h2><ol>\n<li>数据安全（是否加密传输、关键数据是否容易被篡改等）</li>\n<li>证书安全（SSL证书、SSL密钥等）</li>\n<li>临时目录数据、缓存数据是否安全存储不被恶意读取</li>\n<li>软件权限安全性（扣费风险、隐私泄露风险、非法授权访问等）</li>\n</ol>\n<h2 id=\"性能测试（测试工具：LR、NeoLoad、ApacheBench、jmeter、http-load等）\"><a href=\"#性能测试（测试工具：LR、NeoLoad、ApacheBench、jmeter、http-load等）\" class=\"headerlink\" title=\"性能测试（测试工具：LR、NeoLoad、ApacheBench、jmeter、http_load等）\"></a>性能测试（测试工具：LR、NeoLoad、ApacheBench、jmeter、http_load等）</h2><ol>\n<li>极限测试（在各种边界压力情况下，如电池、存储、网速等，验证App是否能正确响应）</li>\n<li>响应能力测试（测试各功能的响应时间要求）</li>\n<li>压力测试（反复/长期操作下、系统资源是否占用正常）</li>\n</ol>\n<h2 id=\"自动化测试（工具：Selenium、Appium、Watir、Katalon-Studio、Monkey-Test等）\"><a href=\"#自动化测试（工具：Selenium、Appium、Watir、Katalon-Studio、Monkey-Test等）\" class=\"headerlink\" title=\"自动化测试（工具：Selenium、Appium、Watir、Katalon Studio、Monkey Test等）\"></a>自动化测试（工具：Selenium、Appium、Watir、Katalon Studio、Monkey Test等）</h2><ol>\n<li>通过编写语言脚本对功能或接口进行自动化调用，减少人力测试成本。</li>\n</ol>\n<hr>\n<p><em>观点仅代表自己，期待你的留言。</em></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"功能性测试\"><a href=\"#功能性测试\" class=\"headerlink\" title=\"功能性测试\"></a>功能性测试</h2><ol>\n<li>需求功能完成度测试（业务逻辑、功能点等）</li>\n<li>值类型测试</li>\n<li>值乱码测试（特殊字符、表情符等）</li>\n<li>值边界测试</li>\n<li>关联功能测试</li>\n<li>请求重复提交/请求中断测试（快速重复提交请求、发起请求后dismiss功能界面等）</li>\n<li>运行速度测试（app启动、页面切换等）</li>\n<li>程序异常测试</li>\n<li>场景回滚测试</li>\n</ol>\n<h2 id=\"兼容性测试\"><a href=\"#兼容性测试\" class=\"headerlink\" title=\"兼容性测试\"></a>兼容性测试</h2><ol>\n<li>不同设备兼容性（分辨率、设备品牌、设备ROM版本、不同ROM厂家、不同尺寸等）</li>\n<li>不同app版本兼容性</li>\n<li>网络兼容性（移动网络、不同运营商网络、WIFI、弱网、断网等）</li>\n<li>第三方软件兼容性（输入法软件、蓝牙软件等）</li>\n</ol>\n<h2 id=\"升级测试\"><a href=\"#升级测试\" class=\"headerlink\" title=\"升级测试\"></a>升级测试</h2><ol>\n<li>全新安装/卸载测试（apk安装/卸载、应用市场软件内安装/卸载等）</li>\n<li>增量/全量升级测试（数字签名测试、跨版本升级等）</li>\n<li>系统资源不足时测试（低电量、断电、硬盘空间不足、内存不足等）</li>\n</ol>\n<h2 id=\"接口测试\"><a href=\"#接口测试\" class=\"headerlink\" title=\"接口测试\"></a>接口测试</h2><ol>\n<li>数据正确性测试（按接口文档和数据库存储的数据进行计算后验证）</li>\n<li>网络连通性（DNS异常、client断网、server端超时、server端异常、client签名证书异常等）</li>\n<li>数据流量测试（是否有超大数据包传递等）</li>\n<li>数据安全性（数据传输是否加密或混淆等）</li>\n<li>调用方安全性（接口调用方是否鉴权、是否被模拟回调等）</li>\n<li>系统时间篡改对功能的影响</li>\n</ol>\n<h2 id=\"UI测试\"><a href=\"#UI测试\" class=\"headerlink\" title=\"UI测试\"></a>UI测试</h2><ol>\n<li>界面测试（UI布局、界面颜色、风格统一性、字体大小、提示文案位置、界面返回路径等）</li>\n<li>内容测试（文案内容、错别字、版权、专利、隐私内容、敏感词、敏感图片等）</li>\n<li>横竖屏切换、前后台切换等</li>\n</ol>\n<h2 id=\"交互测试\"><a href=\"#交互测试\" class=\"headerlink\" title=\"交互测试\"></a>交互测试</h2><ol>\n<li>app中断测试（来电话、来短信、低电量、待机、插拔数据线、插拔耳机、断网、闹钟，日历提醒，蓝牙提醒等）</li>\n<li>多个app争夺系统资源时对app的影响（声道播放、相机等）</li>\n<li>用户打扰测试（push通知是否在免打扰时段内通知、push通知关闭状态下是否依然通知等）</li>\n<li>长时间使用、长时间后台等</li>\n<li>手势测试（单指滑动，单指单击，单指双击，单指长按，单指缩放，多指点击等）</li>\n</ol>\n<h2 id=\"缓存量测试\"><a href=\"#缓存量测试\" class=\"headerlink\" title=\"缓存量测试\"></a>缓存量测试</h2><ol>\n<li>第一次使用时存入缓存大量数据对app的影响</li>\n<li>日常使用时更新缓存大量数据对app的影响</li>\n<li>重新安装保存原缓存的大量缓存数据更新对app的影响</li>\n</ol>\n<h2 id=\"安全性测试\"><a href=\"#安全性测试\" class=\"headerlink\" title=\"安全性测试\"></a>安全性测试</h2><ol>\n<li>数据安全（是否加密传输、关键数据是否容易被篡改等）</li>\n<li>证书安全（SSL证书、SSL密钥等）</li>\n<li>临时目录数据、缓存数据是否安全存储不被恶意读取</li>\n<li>软件权限安全性（扣费风险、隐私泄露风险、非法授权访问等）</li>\n</ol>\n<h2 id=\"性能测试（测试工具：LR、NeoLoad、ApacheBench、jmeter、http-load等）\"><a href=\"#性能测试（测试工具：LR、NeoLoad、ApacheBench、jmeter、http-load等）\" class=\"headerlink\" title=\"性能测试（测试工具：LR、NeoLoad、ApacheBench、jmeter、http_load等）\"></a>性能测试（测试工具：LR、NeoLoad、ApacheBench、jmeter、http_load等）</h2><ol>\n<li>极限测试（在各种边界压力情况下，如电池、存储、网速等，验证App是否能正确响应）</li>\n<li>响应能力测试（测试各功能的响应时间要求）</li>\n<li>压力测试（反复/长期操作下、系统资源是否占用正常）</li>\n</ol>\n<h2 id=\"自动化测试（工具：Selenium、Appium、Watir、Katalon-Studio、Monkey-Test等）\"><a href=\"#自动化测试（工具：Selenium、Appium、Watir、Katalon-Studio、Monkey-Test等）\" class=\"headerlink\" title=\"自动化测试（工具：Selenium、Appium、Watir、Katalon Studio、Monkey Test等）\"></a>自动化测试（工具：Selenium、Appium、Watir、Katalon Studio、Monkey Test等）</h2><ol>\n<li>通过编写语言脚本对功能或接口进行自动化调用，减少人力测试成本。</li>\n</ol>\n<hr>\n<p><em>观点仅代表自己，期待你的留言。</em></p>\n"},{"title":"妙用Spring中的CompositeCacheManager","keywords":["Spring","CompositeCacheManager"],"date":"2016-07-19T08:47:23.000Z","_content":"\n## 简介\nSpring提供了@Cacheable，@CacheEvict,@CachePut等注解很方便有实现数据的缓存，而CompositeCacheManager主要用于集合多个CacheManager实例，在使用多种缓存容器时特别有用。\n\n## fallbackToNoOpCache属性的真实意义\n经过查看Spring 4.1.9.RELEASE的源码,当CompositeCacheManager的fallbackToNoOpCache属性设置为true时，CompositeCacheManager会在已配置的cacheManagers末尾添加一个NoOpCacheManager。\n当通过代码中指定的缓存容器（@Cacheable等注解设置的value）没有在cacheManagers中都找到时，则会进入到NoOpCacheManager中，此时就相当于禁用掉了缓存，而不抛出相应的异常。\n\n网络上有朋友在说，当设置fallbackToNoOpCache属性设置为true时，则可以解决缓存容器没有准备好时自动禁用缓存的效果，经过查看Spring源码，并未实现。\n不过，经测试以下方法可以实现通过配置禁用缓存。\n\n## 通过配置禁用缓存\n\n利用CompositeCacheManager + NoOpCacheManager还能解决当缓存容器没有准备好（缓存容器崩溃，网络不可用等）或者需要暂时去掉缓存的需求。\n\n只需要将cacheManagers的list值的第一个元素设置为NoOpCacheManager就OK了。\n\n__spring.xml__\n```\n<bean id=\"cacheManager\" class=\"org.springframework.cache.support.CompositeCacheManager\">\n    <property name=\"cacheManagers\">\n        <list>\n        \t<bean class=\"org.springframework.cache.support.NoOpCacheManager\" />\n            <ref bean=\"simpleCacheManager\" />\n        </list>\n    </property>\n    <property name=\"fallbackToNoOpCache\" value=\"true\" />\n</bean>\n```\n\n-----\n\n*观点仅代表自己，期待你的留言。*","source":"_posts/spring-compositeCacheManager.md","raw":"---\ntitle: 妙用Spring中的CompositeCacheManager\nkeywords:\n  - Spring\n  - CompositeCacheManager\ntags:\n  - 原创\ndate: 2016-07-19 16:47:23\n---\n\n## 简介\nSpring提供了@Cacheable，@CacheEvict,@CachePut等注解很方便有实现数据的缓存，而CompositeCacheManager主要用于集合多个CacheManager实例，在使用多种缓存容器时特别有用。\n\n## fallbackToNoOpCache属性的真实意义\n经过查看Spring 4.1.9.RELEASE的源码,当CompositeCacheManager的fallbackToNoOpCache属性设置为true时，CompositeCacheManager会在已配置的cacheManagers末尾添加一个NoOpCacheManager。\n当通过代码中指定的缓存容器（@Cacheable等注解设置的value）没有在cacheManagers中都找到时，则会进入到NoOpCacheManager中，此时就相当于禁用掉了缓存，而不抛出相应的异常。\n\n网络上有朋友在说，当设置fallbackToNoOpCache属性设置为true时，则可以解决缓存容器没有准备好时自动禁用缓存的效果，经过查看Spring源码，并未实现。\n不过，经测试以下方法可以实现通过配置禁用缓存。\n\n## 通过配置禁用缓存\n\n利用CompositeCacheManager + NoOpCacheManager还能解决当缓存容器没有准备好（缓存容器崩溃，网络不可用等）或者需要暂时去掉缓存的需求。\n\n只需要将cacheManagers的list值的第一个元素设置为NoOpCacheManager就OK了。\n\n__spring.xml__\n```\n<bean id=\"cacheManager\" class=\"org.springframework.cache.support.CompositeCacheManager\">\n    <property name=\"cacheManagers\">\n        <list>\n        \t<bean class=\"org.springframework.cache.support.NoOpCacheManager\" />\n            <ref bean=\"simpleCacheManager\" />\n        </list>\n    </property>\n    <property name=\"fallbackToNoOpCache\" value=\"true\" />\n</bean>\n```\n\n-----\n\n*观点仅代表自己，期待你的留言。*","slug":"spring-compositeCacheManager","published":1,"updated":"2021-08-31T14:23:11.550Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cku52dyom004mbbin1o848hjm","content":"<h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><p>Spring提供了@Cacheable，@CacheEvict,@CachePut等注解很方便有实现数据的缓存，而CompositeCacheManager主要用于集合多个CacheManager实例，在使用多种缓存容器时特别有用。</p>\n<h2 id=\"fallbackToNoOpCache属性的真实意义\"><a href=\"#fallbackToNoOpCache属性的真实意义\" class=\"headerlink\" title=\"fallbackToNoOpCache属性的真实意义\"></a>fallbackToNoOpCache属性的真实意义</h2><p>经过查看Spring 4.1.9.RELEASE的源码,当CompositeCacheManager的fallbackToNoOpCache属性设置为true时，CompositeCacheManager会在已配置的cacheManagers末尾添加一个NoOpCacheManager。<br>当通过代码中指定的缓存容器（@Cacheable等注解设置的value）没有在cacheManagers中都找到时，则会进入到NoOpCacheManager中，此时就相当于禁用掉了缓存，而不抛出相应的异常。</p>\n<p>网络上有朋友在说，当设置fallbackToNoOpCache属性设置为true时，则可以解决缓存容器没有准备好时自动禁用缓存的效果，经过查看Spring源码，并未实现。<br>不过，经测试以下方法可以实现通过配置禁用缓存。</p>\n<h2 id=\"通过配置禁用缓存\"><a href=\"#通过配置禁用缓存\" class=\"headerlink\" title=\"通过配置禁用缓存\"></a>通过配置禁用缓存</h2><p>利用CompositeCacheManager + NoOpCacheManager还能解决当缓存容器没有准备好（缓存容器崩溃，网络不可用等）或者需要暂时去掉缓存的需求。</p>\n<p>只需要将cacheManagers的list值的第一个元素设置为NoOpCacheManager就OK了。</p>\n<p><strong>spring.xml</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;bean id=&quot;cacheManager&quot; class=&quot;org.springframework.cache.support.CompositeCacheManager&quot;&gt;</span><br><span class=\"line\">    &lt;property name=&quot;cacheManagers&quot;&gt;</span><br><span class=\"line\">        &lt;list&gt;</span><br><span class=\"line\">        \t&lt;bean class=&quot;org.springframework.cache.support.NoOpCacheManager&quot; /&gt;</span><br><span class=\"line\">            &lt;ref bean=&quot;simpleCacheManager&quot; /&gt;</span><br><span class=\"line\">        &lt;/list&gt;</span><br><span class=\"line\">    &lt;/property&gt;</span><br><span class=\"line\">    &lt;property name=&quot;fallbackToNoOpCache&quot; value=&quot;true&quot; /&gt;</span><br><span class=\"line\">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<p><em>观点仅代表自己，期待你的留言。</em></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><p>Spring提供了@Cacheable，@CacheEvict,@CachePut等注解很方便有实现数据的缓存，而CompositeCacheManager主要用于集合多个CacheManager实例，在使用多种缓存容器时特别有用。</p>\n<h2 id=\"fallbackToNoOpCache属性的真实意义\"><a href=\"#fallbackToNoOpCache属性的真实意义\" class=\"headerlink\" title=\"fallbackToNoOpCache属性的真实意义\"></a>fallbackToNoOpCache属性的真实意义</h2><p>经过查看Spring 4.1.9.RELEASE的源码,当CompositeCacheManager的fallbackToNoOpCache属性设置为true时，CompositeCacheManager会在已配置的cacheManagers末尾添加一个NoOpCacheManager。<br>当通过代码中指定的缓存容器（@Cacheable等注解设置的value）没有在cacheManagers中都找到时，则会进入到NoOpCacheManager中，此时就相当于禁用掉了缓存，而不抛出相应的异常。</p>\n<p>网络上有朋友在说，当设置fallbackToNoOpCache属性设置为true时，则可以解决缓存容器没有准备好时自动禁用缓存的效果，经过查看Spring源码，并未实现。<br>不过，经测试以下方法可以实现通过配置禁用缓存。</p>\n<h2 id=\"通过配置禁用缓存\"><a href=\"#通过配置禁用缓存\" class=\"headerlink\" title=\"通过配置禁用缓存\"></a>通过配置禁用缓存</h2><p>利用CompositeCacheManager + NoOpCacheManager还能解决当缓存容器没有准备好（缓存容器崩溃，网络不可用等）或者需要暂时去掉缓存的需求。</p>\n<p>只需要将cacheManagers的list值的第一个元素设置为NoOpCacheManager就OK了。</p>\n<p><strong>spring.xml</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;bean id=&quot;cacheManager&quot; class=&quot;org.springframework.cache.support.CompositeCacheManager&quot;&gt;</span><br><span class=\"line\">    &lt;property name=&quot;cacheManagers&quot;&gt;</span><br><span class=\"line\">        &lt;list&gt;</span><br><span class=\"line\">        \t&lt;bean class=&quot;org.springframework.cache.support.NoOpCacheManager&quot; /&gt;</span><br><span class=\"line\">            &lt;ref bean=&quot;simpleCacheManager&quot; /&gt;</span><br><span class=\"line\">        &lt;/list&gt;</span><br><span class=\"line\">    &lt;/property&gt;</span><br><span class=\"line\">    &lt;property name=&quot;fallbackToNoOpCache&quot; value=&quot;true&quot; /&gt;</span><br><span class=\"line\">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<p><em>观点仅代表自己，期待你的留言。</em></p>\n"},{"title":"Spring-AOP实现之注解","keywords":["Spring aop实现","注解aop实现","面向切面编程"],"date":"2016-06-30T07:29:18.000Z","_content":"\n## AOP概念\n\nAOP术语:\n* 切面（Aspect）：一个关注点的模块化，这个关注点可能会横切多个对象。事务管理是J2EE应用中一个关于横切关注点的很好的例子。在Spring AOP中，切面可以使用基于模式或者基于@Aspect注解的方式来实现。\n* 连接点（Joinpoint）：在程序执行过程中某个特定的点，比如某方法调用的时候或者处理异常的时候。在Spring AOP中，一个连接点总是表示一个方法的执行。\n* 通知（Advice）：在切面的某个特定的连接点上执行的动作。其中包括了“around”、“before”和“after”等不同类型的通知（通知的类型将在后面部分进行讨论）。许多AOP框架（包括Spring）都是以拦截器做通知模型，并维护一个以连接点为中心的拦截器链。\n* 切入点（Pointcut）：匹配连接点的断言。通知和一个切入点表达式关联，并在满足这个切入点的连接点上运行（例如，当执行某个特定名称的方法时）。切入点表达式如何和连接点匹配是AOP的核心：Spring缺省使用AspectJ切入点语法。\n* 引入（Introduction）：用来给一个类型声明额外的方法或属性（也被称为连接类型声明（inter-type declaration））。Spring允许引入新的接口（以及一个对应的实现）到任何被代理的对象。例如，你可以使用引入来使一个bean实现IsModified接口，以便简化缓存机制。\n* 目标对象（Target Object）： 被一个或者多个切面所通知的对象。也被称做被通知（advised）对象。 既然Spring AOP是通过运行时代理实现的，这个对象永远是一个被代理（proxied）对象。\n* AOP代理（AOP Proxy）：AOP框架创建的对象，用来实现切面契约（例如通知方法执行等等）。在Spring中，AOP代理可以是JDK动态代理或者CGLIB代理。\n* 织入（Weaving）：把切面连接到其它的应用程序类型或者对象上，并创建一个被通知的对象。这些可以在编译时（例如使用AspectJ编译器），类加载时和运行时完成。Spring和其他纯Java AOP框架一样，在运行时完成织入。\n\n通知类型：\n* 前置通知（Before advice）：在某连接点之前执行的通知，但这个通知不能阻止连接点之前的执行流程（除非它抛出一个异常）。\n* 后置通知（After returning advice）：在某连接点正常完成后执行的通知：例如，一个方法没有抛出任何异常，正常返回。\n* 异常通知（After throwing advice）：在方法抛出异常退出时执行的通知。\n* 最终通知（After (finally) advice）：当某连接点退出的时候执行的通知（不论是正常返回还是异常退出）。\n* 环绕通知（Around Advice）：包围一个连接点的通知，如方法调用。这是最强大的一种通知类型。环绕通知可以在方法调用前后完成自定义的行为。它也会选择是否继续执行连接点或直接返回它自己的返回值或抛出异常来结束执行。\n\n## 配置实现\n实例需求: 监控各Api接口执行时间，找出耗时的业务操作。\n1、启用@AspectJ支持\n_spring.xml_\n```\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:mvc=\"http://www.springframework.org/schema/mvc\"\n       xmlns:util=\"http://www.springframework.org/schema/util\" xmlns:context=\"http://www.springframework.org/schema/context\"\n       xmlns:tx=\"http://www.springframework.org/schema/tx\" xmlns:aop=\"http://www.springframework.org/schema/aop\"\n       xmlns:cache=\"http://www.springframework.org/schema/cache\" xmlns:p=\"http://www.springframework.org/schema/p\"\n\t\txsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\n        http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd\n        http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd\n        http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd\n        http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\n        http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util.xsd\n        http://www.springframework.org/schema/cache http://www.springframework.org/schema/cache/spring-cache-3.2.xsd\"\n       default-lazy-init=\"true\">\n\n\t<aop:aspectj-autoproxy />\n\n</beans>\n```\n2、增加aspectj依赖库\n_pom.xml_\n```\n<dependency>\n    <groupId>org.aspectj</groupId>\n    <artifactId>aspectjrt</artifactId>\n    <version>1.7.4</version>\n</dependency>\n<dependency>\n    <groupId>org.aspectj</groupId>\n    <artifactId>aspectjweaver</artifactId>\n    <version>1.7.4</version>\n</dependency>\n```\n3、编写切面类\n```\n@Aspect\n@Repository\npublic class AspectPoint {\n\n    @Around(\"within(org.wujianjun.apps.service..*)\")\n    public Object doBasicProfiling(ProceedingJoinPoint pjp) throws Throwable {\n        final long beginTime = System.currentTimeMillis();\n        Object res = pjp.proceed(pjp.getArgs());\n        final long endTime = System.currentTimeMillis();\n        System.out.println(pjp.getTarget().getClass().getSimpleName()+\".\"+pjp.getSignature().getName()+\"-->\"+(endTime-beginTime)+\"ms\");\n        return res;\n    }\n}\n```\n\n对比一下xml配置\n```\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:mvc=\"http://www.springframework.org/schema/mvc\"\n       xmlns:util=\"http://www.springframework.org/schema/util\" xmlns:context=\"http://www.springframework.org/schema/context\"\n       xmlns:tx=\"http://www.springframework.org/schema/tx\" xmlns:aop=\"http://www.springframework.org/schema/aop\"\n       xmlns:cache=\"http://www.springframework.org/schema/cache\" xmlns:p=\"http://www.springframework.org/schema/p\"\n    xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\n        http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd\n        http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd\n        http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd\n        http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\n        http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util.xsd\n        http://www.springframework.org/schema/cache http://www.springframework.org/schema/cache/spring-cache-3.2.xsd\"\n       default-lazy-init=\"true\">\n\n  <bean id=\"aspectPoint\" class=\"AspectPoint\" />\n  <aop:aspectj-autoproxy/> \n  <aop:config>\n    <aop:aspect ref=\"aspectPoint\">\n      <aop:around method=\"doBasicProfiling\" pointcut=\"within(org.wujianjun.apps.service..*)\" />\n    </aop:aspect>\n  </aop:config>\n\n</beans>\n```\n\n附上测试业务实现类\n```\npackage org.wujianjun.apps.service.impl;\n\n@Service\npublic class ExampleServiceImpl implements ExampleService {\n    private final static Logger LOG = LoggerFactory\n            .getLogger(ExampleServiceImpl.class);\n\n    @Resource\n    private ExampleManager exampleManager;\n\n    @Override\n    public void test() {\n        System.out.println(\"test--\");\n        try {\n            Thread.sleep(100);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n\n4、测试结果\n```\n六月 30, 2016 4:11:07 下午 org.apache.coyote.AbstractProtocol start\n信息: Starting ProtocolHandler [\"http-bio-8080\"]\ntest--\nExampleServiceImpl.test-->103ms\ntest--\nExampleServiceImpl.test-->105ms\ntest--\nExampleServiceImpl.test-->103ms\ntest--\nExampleServiceImpl.test-->103ms\ntest--\nExampleServiceImpl.test-->100ms\ntest--\nExampleServiceImpl.test-->104ms\n```\n\n## 配置说明\n### AspectJ切入点指示符：\n* execution - 匹配方法执行的连接点，这是你将会用到的Spring的最主要的切入点指示符。\n\t具体格式：`execution(modifiers-pattern? ret-type-pattern declaring-type-pattern? name-pattern(param-pattern)throws-pattern?)`\n\t示例: execution(* com.xyz.service..*.*(..) - 在service包或其子包中定义的任意方法的执行\n* within - 限定匹配特定类型的连接点(在使用Spring AOP的时候，在匹配的类型中定义的方法的执行)。\n\t示例: within(com.xyz.service..*) - 在service包或其子包中的任意连接点(在Spring AOP中只是方法执行)，包含类和接口\n* this - 限定匹配特定的连接点(使用Spring AOP的时候方法的执行)，其中bean reference(Spring AOP 代理)是指定类型的实例。\n\t示例: this(com.xyz.service.AccountService) - 实现了AccountService接口的代理对象的任意连接点 (在Spring AOP中只是方法执行)\n* target - 限定匹配特定的连接点(使用Spring AOP的时候方法的执行)，其中目标对象(被代理的应用对象)是指定类型的实例。\n\t示例: target(com.xyz.service.AccountService) - 实现AccountService接口的目标对象的任意连接点 (在Spring AOP中只是方法执行)\n* args - 限定匹配特定的连接点(使用Spring AOP的时候方法的执行)，其中参数是指定类型的实例。\n\t示例: args(java.io.Serializable) - 任何一个只接受一个参数，并且运行时所传入的参数是Serializable 接口的连接点(在Spring AOP中只是方法执行)\n* bean - 标记可以是任何Spring bean的名字支持通配符'*'。\n\t示例: bean(*Service) - 任何一个在名字匹配通配符表达式'*Service'的Spring bean之上的连接点 (在Spring AOP中只是方法执行)\n* @target - 限定匹配特定的连接点(使用Spring AOP的时候方法的执行)，其中正执行对象的类持有指定类型的注解。\n\t示例: @target(org.springframework.transaction.annotation.Transactional) - 目标对象中有一个 @Transactional 注解的任意连接点 (在Spring AOP中只是方法执行)\n* @args - 限定匹配特定的连接点(使用Spring AOP的时候方法的执行)，其中实际传入参数的运行时类型持有指定类型的注解。\n\t示例: @args(com.xyz.security.Classified) - 任何一个只接受一个参数，并且运行时所传入的参数类型具有@Classified 注解的连接点(在Spring AOP中只是方法执行)\n* @within - 限定匹配特定的连接点，其中连接点所在类型已指定注解(在使用Spring AOP的时候，所执行的方法所在类型已指定注解)。\n\t示例: @within(org.springframework.transaction.annotation.Transactional) - 任何一个目标对象声明的类型有一个 @Transactional 注解的连接点 (在Spring AOP中只是方法执行)\n* @annotation - 限定匹配特定的连接点(使用Spring AOP的时候方法的执行)，其中连接点的主题持有指定的注解。\n\t示例: @annotation(org.springframework.transaction.annotation.Transactional) - 任何一个执行的方法有一个 @Transactional 注解的连接点 (在Spring AOP中只是方法执行)\n\n`注意：`__切入点表达式可以使用'&', '||' 和 '!'来组合__\n\n### 通知类型声明注解：\n* 前置通知 - 使用 @Before 注解声明\n* 后置通知 - 使用 @AfterReturning 注解来声明\n* 异常通知 - 使用@AfterThrowing注解\n* 最终通知 - 使用@After 注解来声明\n* 环绕通知 - 使用@Around注解来声明\n\n### 共享通用切入点定义\n\n通过@Pointcut先定义好切入点, 当通知类型可以通过被 @Pointcut 标识的方法名直接共享其切入点配置。\n\n示例：\n```\npackage com.xyz.someapp;\n\n@Aspect\npublic class SystemArchitecture {\n\t@Pointcut(\"within(com.xyz.someapp.web..*)\")\n  \tpublic void inWebLayer() {}\n\n  \t@Before(\"com.xyz.someapp.SystemArchitecture.inWebLayer()\")\n  \tpublic void doBefore() {\n\n  \t}\n\n  \t@After(\"com.xyz.someapp.SystemArchitecture.inWebLayer()\")\n  \tpublic void doAfter() {\n\n  \t}\n}\n```\n\n### 获取切入点更多的信息\n任何通知方法可以将第一个参数定义为org.aspectj.lang.JoinPoint类型 （环绕通知需要定义第一个参数为ProceedingJoinPoint类型， 它是 JoinPoint 的一个子类）。JoinPoint 接口提供了一系列有用的方法，比如 getArgs()（返回方法参数）、 getThis()（返回代理对象）、getTarget()（返回目标）、 getSignature()（返回正在被通知的方法相关信息）和 toString() （打印出正在被通知的方法的有用信息）。\n\n-----\nhttp://shouce.jb51.net/spring/aop.html\n\n*观点仅代表自己，期待你的留言。*","source":"_posts/spring-aop-annotation.md","raw":"---\ntitle: Spring-AOP实现之注解\nkeywords: \n  - \"Spring aop实现\"\n  - \"注解aop实现\"\n  - \"面向切面编程\"\ntags:\n  - 原创\ndate: 2016-06-30 15:29:18\n---\n\n## AOP概念\n\nAOP术语:\n* 切面（Aspect）：一个关注点的模块化，这个关注点可能会横切多个对象。事务管理是J2EE应用中一个关于横切关注点的很好的例子。在Spring AOP中，切面可以使用基于模式或者基于@Aspect注解的方式来实现。\n* 连接点（Joinpoint）：在程序执行过程中某个特定的点，比如某方法调用的时候或者处理异常的时候。在Spring AOP中，一个连接点总是表示一个方法的执行。\n* 通知（Advice）：在切面的某个特定的连接点上执行的动作。其中包括了“around”、“before”和“after”等不同类型的通知（通知的类型将在后面部分进行讨论）。许多AOP框架（包括Spring）都是以拦截器做通知模型，并维护一个以连接点为中心的拦截器链。\n* 切入点（Pointcut）：匹配连接点的断言。通知和一个切入点表达式关联，并在满足这个切入点的连接点上运行（例如，当执行某个特定名称的方法时）。切入点表达式如何和连接点匹配是AOP的核心：Spring缺省使用AspectJ切入点语法。\n* 引入（Introduction）：用来给一个类型声明额外的方法或属性（也被称为连接类型声明（inter-type declaration））。Spring允许引入新的接口（以及一个对应的实现）到任何被代理的对象。例如，你可以使用引入来使一个bean实现IsModified接口，以便简化缓存机制。\n* 目标对象（Target Object）： 被一个或者多个切面所通知的对象。也被称做被通知（advised）对象。 既然Spring AOP是通过运行时代理实现的，这个对象永远是一个被代理（proxied）对象。\n* AOP代理（AOP Proxy）：AOP框架创建的对象，用来实现切面契约（例如通知方法执行等等）。在Spring中，AOP代理可以是JDK动态代理或者CGLIB代理。\n* 织入（Weaving）：把切面连接到其它的应用程序类型或者对象上，并创建一个被通知的对象。这些可以在编译时（例如使用AspectJ编译器），类加载时和运行时完成。Spring和其他纯Java AOP框架一样，在运行时完成织入。\n\n通知类型：\n* 前置通知（Before advice）：在某连接点之前执行的通知，但这个通知不能阻止连接点之前的执行流程（除非它抛出一个异常）。\n* 后置通知（After returning advice）：在某连接点正常完成后执行的通知：例如，一个方法没有抛出任何异常，正常返回。\n* 异常通知（After throwing advice）：在方法抛出异常退出时执行的通知。\n* 最终通知（After (finally) advice）：当某连接点退出的时候执行的通知（不论是正常返回还是异常退出）。\n* 环绕通知（Around Advice）：包围一个连接点的通知，如方法调用。这是最强大的一种通知类型。环绕通知可以在方法调用前后完成自定义的行为。它也会选择是否继续执行连接点或直接返回它自己的返回值或抛出异常来结束执行。\n\n## 配置实现\n实例需求: 监控各Api接口执行时间，找出耗时的业务操作。\n1、启用@AspectJ支持\n_spring.xml_\n```\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:mvc=\"http://www.springframework.org/schema/mvc\"\n       xmlns:util=\"http://www.springframework.org/schema/util\" xmlns:context=\"http://www.springframework.org/schema/context\"\n       xmlns:tx=\"http://www.springframework.org/schema/tx\" xmlns:aop=\"http://www.springframework.org/schema/aop\"\n       xmlns:cache=\"http://www.springframework.org/schema/cache\" xmlns:p=\"http://www.springframework.org/schema/p\"\n\t\txsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\n        http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd\n        http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd\n        http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd\n        http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\n        http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util.xsd\n        http://www.springframework.org/schema/cache http://www.springframework.org/schema/cache/spring-cache-3.2.xsd\"\n       default-lazy-init=\"true\">\n\n\t<aop:aspectj-autoproxy />\n\n</beans>\n```\n2、增加aspectj依赖库\n_pom.xml_\n```\n<dependency>\n    <groupId>org.aspectj</groupId>\n    <artifactId>aspectjrt</artifactId>\n    <version>1.7.4</version>\n</dependency>\n<dependency>\n    <groupId>org.aspectj</groupId>\n    <artifactId>aspectjweaver</artifactId>\n    <version>1.7.4</version>\n</dependency>\n```\n3、编写切面类\n```\n@Aspect\n@Repository\npublic class AspectPoint {\n\n    @Around(\"within(org.wujianjun.apps.service..*)\")\n    public Object doBasicProfiling(ProceedingJoinPoint pjp) throws Throwable {\n        final long beginTime = System.currentTimeMillis();\n        Object res = pjp.proceed(pjp.getArgs());\n        final long endTime = System.currentTimeMillis();\n        System.out.println(pjp.getTarget().getClass().getSimpleName()+\".\"+pjp.getSignature().getName()+\"-->\"+(endTime-beginTime)+\"ms\");\n        return res;\n    }\n}\n```\n\n对比一下xml配置\n```\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:mvc=\"http://www.springframework.org/schema/mvc\"\n       xmlns:util=\"http://www.springframework.org/schema/util\" xmlns:context=\"http://www.springframework.org/schema/context\"\n       xmlns:tx=\"http://www.springframework.org/schema/tx\" xmlns:aop=\"http://www.springframework.org/schema/aop\"\n       xmlns:cache=\"http://www.springframework.org/schema/cache\" xmlns:p=\"http://www.springframework.org/schema/p\"\n    xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\n        http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd\n        http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd\n        http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd\n        http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\n        http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util.xsd\n        http://www.springframework.org/schema/cache http://www.springframework.org/schema/cache/spring-cache-3.2.xsd\"\n       default-lazy-init=\"true\">\n\n  <bean id=\"aspectPoint\" class=\"AspectPoint\" />\n  <aop:aspectj-autoproxy/> \n  <aop:config>\n    <aop:aspect ref=\"aspectPoint\">\n      <aop:around method=\"doBasicProfiling\" pointcut=\"within(org.wujianjun.apps.service..*)\" />\n    </aop:aspect>\n  </aop:config>\n\n</beans>\n```\n\n附上测试业务实现类\n```\npackage org.wujianjun.apps.service.impl;\n\n@Service\npublic class ExampleServiceImpl implements ExampleService {\n    private final static Logger LOG = LoggerFactory\n            .getLogger(ExampleServiceImpl.class);\n\n    @Resource\n    private ExampleManager exampleManager;\n\n    @Override\n    public void test() {\n        System.out.println(\"test--\");\n        try {\n            Thread.sleep(100);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n\n4、测试结果\n```\n六月 30, 2016 4:11:07 下午 org.apache.coyote.AbstractProtocol start\n信息: Starting ProtocolHandler [\"http-bio-8080\"]\ntest--\nExampleServiceImpl.test-->103ms\ntest--\nExampleServiceImpl.test-->105ms\ntest--\nExampleServiceImpl.test-->103ms\ntest--\nExampleServiceImpl.test-->103ms\ntest--\nExampleServiceImpl.test-->100ms\ntest--\nExampleServiceImpl.test-->104ms\n```\n\n## 配置说明\n### AspectJ切入点指示符：\n* execution - 匹配方法执行的连接点，这是你将会用到的Spring的最主要的切入点指示符。\n\t具体格式：`execution(modifiers-pattern? ret-type-pattern declaring-type-pattern? name-pattern(param-pattern)throws-pattern?)`\n\t示例: execution(* com.xyz.service..*.*(..) - 在service包或其子包中定义的任意方法的执行\n* within - 限定匹配特定类型的连接点(在使用Spring AOP的时候，在匹配的类型中定义的方法的执行)。\n\t示例: within(com.xyz.service..*) - 在service包或其子包中的任意连接点(在Spring AOP中只是方法执行)，包含类和接口\n* this - 限定匹配特定的连接点(使用Spring AOP的时候方法的执行)，其中bean reference(Spring AOP 代理)是指定类型的实例。\n\t示例: this(com.xyz.service.AccountService) - 实现了AccountService接口的代理对象的任意连接点 (在Spring AOP中只是方法执行)\n* target - 限定匹配特定的连接点(使用Spring AOP的时候方法的执行)，其中目标对象(被代理的应用对象)是指定类型的实例。\n\t示例: target(com.xyz.service.AccountService) - 实现AccountService接口的目标对象的任意连接点 (在Spring AOP中只是方法执行)\n* args - 限定匹配特定的连接点(使用Spring AOP的时候方法的执行)，其中参数是指定类型的实例。\n\t示例: args(java.io.Serializable) - 任何一个只接受一个参数，并且运行时所传入的参数是Serializable 接口的连接点(在Spring AOP中只是方法执行)\n* bean - 标记可以是任何Spring bean的名字支持通配符'*'。\n\t示例: bean(*Service) - 任何一个在名字匹配通配符表达式'*Service'的Spring bean之上的连接点 (在Spring AOP中只是方法执行)\n* @target - 限定匹配特定的连接点(使用Spring AOP的时候方法的执行)，其中正执行对象的类持有指定类型的注解。\n\t示例: @target(org.springframework.transaction.annotation.Transactional) - 目标对象中有一个 @Transactional 注解的任意连接点 (在Spring AOP中只是方法执行)\n* @args - 限定匹配特定的连接点(使用Spring AOP的时候方法的执行)，其中实际传入参数的运行时类型持有指定类型的注解。\n\t示例: @args(com.xyz.security.Classified) - 任何一个只接受一个参数，并且运行时所传入的参数类型具有@Classified 注解的连接点(在Spring AOP中只是方法执行)\n* @within - 限定匹配特定的连接点，其中连接点所在类型已指定注解(在使用Spring AOP的时候，所执行的方法所在类型已指定注解)。\n\t示例: @within(org.springframework.transaction.annotation.Transactional) - 任何一个目标对象声明的类型有一个 @Transactional 注解的连接点 (在Spring AOP中只是方法执行)\n* @annotation - 限定匹配特定的连接点(使用Spring AOP的时候方法的执行)，其中连接点的主题持有指定的注解。\n\t示例: @annotation(org.springframework.transaction.annotation.Transactional) - 任何一个执行的方法有一个 @Transactional 注解的连接点 (在Spring AOP中只是方法执行)\n\n`注意：`__切入点表达式可以使用'&', '||' 和 '!'来组合__\n\n### 通知类型声明注解：\n* 前置通知 - 使用 @Before 注解声明\n* 后置通知 - 使用 @AfterReturning 注解来声明\n* 异常通知 - 使用@AfterThrowing注解\n* 最终通知 - 使用@After 注解来声明\n* 环绕通知 - 使用@Around注解来声明\n\n### 共享通用切入点定义\n\n通过@Pointcut先定义好切入点, 当通知类型可以通过被 @Pointcut 标识的方法名直接共享其切入点配置。\n\n示例：\n```\npackage com.xyz.someapp;\n\n@Aspect\npublic class SystemArchitecture {\n\t@Pointcut(\"within(com.xyz.someapp.web..*)\")\n  \tpublic void inWebLayer() {}\n\n  \t@Before(\"com.xyz.someapp.SystemArchitecture.inWebLayer()\")\n  \tpublic void doBefore() {\n\n  \t}\n\n  \t@After(\"com.xyz.someapp.SystemArchitecture.inWebLayer()\")\n  \tpublic void doAfter() {\n\n  \t}\n}\n```\n\n### 获取切入点更多的信息\n任何通知方法可以将第一个参数定义为org.aspectj.lang.JoinPoint类型 （环绕通知需要定义第一个参数为ProceedingJoinPoint类型， 它是 JoinPoint 的一个子类）。JoinPoint 接口提供了一系列有用的方法，比如 getArgs()（返回方法参数）、 getThis()（返回代理对象）、getTarget()（返回目标）、 getSignature()（返回正在被通知的方法相关信息）和 toString() （打印出正在被通知的方法的有用信息）。\n\n-----\nhttp://shouce.jb51.net/spring/aop.html\n\n*观点仅代表自己，期待你的留言。*","slug":"spring-aop-annotation","published":1,"updated":"2021-08-31T14:23:11.550Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cku52dyos004pbbing5zz0sol","content":"<h2 id=\"AOP概念\"><a href=\"#AOP概念\" class=\"headerlink\" title=\"AOP概念\"></a>AOP概念</h2><p>AOP术语:</p>\n<ul>\n<li>切面（Aspect）：一个关注点的模块化，这个关注点可能会横切多个对象。事务管理是J2EE应用中一个关于横切关注点的很好的例子。在Spring AOP中，切面可以使用基于模式或者基于@Aspect注解的方式来实现。</li>\n<li>连接点（Joinpoint）：在程序执行过程中某个特定的点，比如某方法调用的时候或者处理异常的时候。在Spring AOP中，一个连接点总是表示一个方法的执行。</li>\n<li>通知（Advice）：在切面的某个特定的连接点上执行的动作。其中包括了“around”、“before”和“after”等不同类型的通知（通知的类型将在后面部分进行讨论）。许多AOP框架（包括Spring）都是以拦截器做通知模型，并维护一个以连接点为中心的拦截器链。</li>\n<li>切入点（Pointcut）：匹配连接点的断言。通知和一个切入点表达式关联，并在满足这个切入点的连接点上运行（例如，当执行某个特定名称的方法时）。切入点表达式如何和连接点匹配是AOP的核心：Spring缺省使用AspectJ切入点语法。</li>\n<li>引入（Introduction）：用来给一个类型声明额外的方法或属性（也被称为连接类型声明（inter-type declaration））。Spring允许引入新的接口（以及一个对应的实现）到任何被代理的对象。例如，你可以使用引入来使一个bean实现IsModified接口，以便简化缓存机制。</li>\n<li>目标对象（Target Object）： 被一个或者多个切面所通知的对象。也被称做被通知（advised）对象。 既然Spring AOP是通过运行时代理实现的，这个对象永远是一个被代理（proxied）对象。</li>\n<li>AOP代理（AOP Proxy）：AOP框架创建的对象，用来实现切面契约（例如通知方法执行等等）。在Spring中，AOP代理可以是JDK动态代理或者CGLIB代理。</li>\n<li>织入（Weaving）：把切面连接到其它的应用程序类型或者对象上，并创建一个被通知的对象。这些可以在编译时（例如使用AspectJ编译器），类加载时和运行时完成。Spring和其他纯Java AOP框架一样，在运行时完成织入。</li>\n</ul>\n<p>通知类型：</p>\n<ul>\n<li>前置通知（Before advice）：在某连接点之前执行的通知，但这个通知不能阻止连接点之前的执行流程（除非它抛出一个异常）。</li>\n<li>后置通知（After returning advice）：在某连接点正常完成后执行的通知：例如，一个方法没有抛出任何异常，正常返回。</li>\n<li>异常通知（After throwing advice）：在方法抛出异常退出时执行的通知。</li>\n<li>最终通知（After (finally) advice）：当某连接点退出的时候执行的通知（不论是正常返回还是异常退出）。</li>\n<li>环绕通知（Around Advice）：包围一个连接点的通知，如方法调用。这是最强大的一种通知类型。环绕通知可以在方法调用前后完成自定义的行为。它也会选择是否继续执行连接点或直接返回它自己的返回值或抛出异常来结束执行。</li>\n</ul>\n<h2 id=\"配置实现\"><a href=\"#配置实现\" class=\"headerlink\" title=\"配置实现\"></a>配置实现</h2><p>实例需求: 监控各Api接口执行时间，找出耗时的业务操作。<br>1、启用@AspectJ支持<br><em>spring.xml</em></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class=\"line\">       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;</span><br><span class=\"line\">       xmlns:util=&quot;http://www.springframework.org/schema/util&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot;</span><br><span class=\"line\">       xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;</span><br><span class=\"line\">       xmlns:cache=&quot;http://www.springframework.org/schema/cache&quot; xmlns:p=&quot;http://www.springframework.org/schema/p&quot;</span><br><span class=\"line\">\t\txsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd</span><br><span class=\"line\">        http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd</span><br><span class=\"line\">        http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd</span><br><span class=\"line\">        http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd</span><br><span class=\"line\">        http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd</span><br><span class=\"line\">        http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util.xsd</span><br><span class=\"line\">        http://www.springframework.org/schema/cache http://www.springframework.org/schema/cache/spring-cache-3.2.xsd&quot;</span><br><span class=\"line\">       default-lazy-init=&quot;true&quot;&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&lt;aop:aspectj-autoproxy /&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;/beans&gt;</span><br></pre></td></tr></table></figure>\n<p>2、增加aspectj依赖库<br><em>pom.xml</em></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;dependency&gt;</span><br><span class=\"line\">    &lt;groupId&gt;org.aspectj&lt;/groupId&gt;</span><br><span class=\"line\">    &lt;artifactId&gt;aspectjrt&lt;/artifactId&gt;</span><br><span class=\"line\">    &lt;version&gt;1.7.4&lt;/version&gt;</span><br><span class=\"line\">&lt;/dependency&gt;</span><br><span class=\"line\">&lt;dependency&gt;</span><br><span class=\"line\">    &lt;groupId&gt;org.aspectj&lt;/groupId&gt;</span><br><span class=\"line\">    &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt;</span><br><span class=\"line\">    &lt;version&gt;1.7.4&lt;/version&gt;</span><br><span class=\"line\">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>\n<p>3、编写切面类</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Aspect</span><br><span class=\"line\">@Repository</span><br><span class=\"line\">public class AspectPoint &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Around(&quot;within(org.wujianjun.apps.service..*)&quot;)</span><br><span class=\"line\">    public Object doBasicProfiling(ProceedingJoinPoint pjp) throws Throwable &#123;</span><br><span class=\"line\">        final long beginTime = System.currentTimeMillis();</span><br><span class=\"line\">        Object res = pjp.proceed(pjp.getArgs());</span><br><span class=\"line\">        final long endTime = System.currentTimeMillis();</span><br><span class=\"line\">        System.out.println(pjp.getTarget().getClass().getSimpleName()+&quot;.&quot;+pjp.getSignature().getName()+&quot;--&gt;&quot;+(endTime-beginTime)+&quot;ms&quot;);</span><br><span class=\"line\">        return res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>对比一下xml配置</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class=\"line\">       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;</span><br><span class=\"line\">       xmlns:util=&quot;http://www.springframework.org/schema/util&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot;</span><br><span class=\"line\">       xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;</span><br><span class=\"line\">       xmlns:cache=&quot;http://www.springframework.org/schema/cache&quot; xmlns:p=&quot;http://www.springframework.org/schema/p&quot;</span><br><span class=\"line\">    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd</span><br><span class=\"line\">        http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd</span><br><span class=\"line\">        http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd</span><br><span class=\"line\">        http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd</span><br><span class=\"line\">        http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd</span><br><span class=\"line\">        http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util.xsd</span><br><span class=\"line\">        http://www.springframework.org/schema/cache http://www.springframework.org/schema/cache/spring-cache-3.2.xsd&quot;</span><br><span class=\"line\">       default-lazy-init=&quot;true&quot;&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">  &lt;bean id=&quot;aspectPoint&quot; class=&quot;AspectPoint&quot; /&gt;</span><br><span class=\"line\">  &lt;aop:aspectj-autoproxy/&gt; </span><br><span class=\"line\">  &lt;aop:config&gt;</span><br><span class=\"line\">    &lt;aop:aspect ref=&quot;aspectPoint&quot;&gt;</span><br><span class=\"line\">      &lt;aop:around method=&quot;doBasicProfiling&quot; pointcut=&quot;within(org.wujianjun.apps.service..*)&quot; /&gt;</span><br><span class=\"line\">    &lt;/aop:aspect&gt;</span><br><span class=\"line\">  &lt;/aop:config&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;/beans&gt;</span><br></pre></td></tr></table></figure>\n\n<p>附上测试业务实现类</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package org.wujianjun.apps.service.impl;</span><br><span class=\"line\"></span><br><span class=\"line\">@Service</span><br><span class=\"line\">public class ExampleServiceImpl implements ExampleService &#123;</span><br><span class=\"line\">    private final static Logger LOG = LoggerFactory</span><br><span class=\"line\">            .getLogger(ExampleServiceImpl.class);</span><br><span class=\"line\"></span><br><span class=\"line\">    @Resource</span><br><span class=\"line\">    private ExampleManager exampleManager;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public void test() &#123;</span><br><span class=\"line\">        System.out.println(&quot;test--&quot;);</span><br><span class=\"line\">        try &#123;</span><br><span class=\"line\">            Thread.sleep(100);</span><br><span class=\"line\">        &#125; catch (InterruptedException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>4、测试结果</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">六月 30, 2016 4:11:07 下午 org.apache.coyote.AbstractProtocol start</span><br><span class=\"line\">信息: Starting ProtocolHandler [&quot;http-bio-8080&quot;]</span><br><span class=\"line\">test--</span><br><span class=\"line\">ExampleServiceImpl.test--&gt;103ms</span><br><span class=\"line\">test--</span><br><span class=\"line\">ExampleServiceImpl.test--&gt;105ms</span><br><span class=\"line\">test--</span><br><span class=\"line\">ExampleServiceImpl.test--&gt;103ms</span><br><span class=\"line\">test--</span><br><span class=\"line\">ExampleServiceImpl.test--&gt;103ms</span><br><span class=\"line\">test--</span><br><span class=\"line\">ExampleServiceImpl.test--&gt;100ms</span><br><span class=\"line\">test--</span><br><span class=\"line\">ExampleServiceImpl.test--&gt;104ms</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"配置说明\"><a href=\"#配置说明\" class=\"headerlink\" title=\"配置说明\"></a>配置说明</h2><h3 id=\"AspectJ切入点指示符：\"><a href=\"#AspectJ切入点指示符：\" class=\"headerlink\" title=\"AspectJ切入点指示符：\"></a>AspectJ切入点指示符：</h3><ul>\n<li>execution - 匹配方法执行的连接点，这是你将会用到的Spring的最主要的切入点指示符。<br>  具体格式：<code>execution(modifiers-pattern? ret-type-pattern declaring-type-pattern? name-pattern(param-pattern)throws-pattern?)</code><br>  示例: execution(* com.xyz.service..<em>.</em>(..) - 在service包或其子包中定义的任意方法的执行</li>\n<li>within - 限定匹配特定类型的连接点(在使用Spring AOP的时候，在匹配的类型中定义的方法的执行)。<br>  示例: within(com.xyz.service..*) - 在service包或其子包中的任意连接点(在Spring AOP中只是方法执行)，包含类和接口</li>\n<li>this - 限定匹配特定的连接点(使用Spring AOP的时候方法的执行)，其中bean reference(Spring AOP 代理)是指定类型的实例。<br>  示例: this(com.xyz.service.AccountService) - 实现了AccountService接口的代理对象的任意连接点 (在Spring AOP中只是方法执行)</li>\n<li>target - 限定匹配特定的连接点(使用Spring AOP的时候方法的执行)，其中目标对象(被代理的应用对象)是指定类型的实例。<br>  示例: target(com.xyz.service.AccountService) - 实现AccountService接口的目标对象的任意连接点 (在Spring AOP中只是方法执行)</li>\n<li>args - 限定匹配特定的连接点(使用Spring AOP的时候方法的执行)，其中参数是指定类型的实例。<br>  示例: args(java.io.Serializable) - 任何一个只接受一个参数，并且运行时所传入的参数是Serializable 接口的连接点(在Spring AOP中只是方法执行)</li>\n<li>bean - 标记可以是任何Spring bean的名字支持通配符’*’。<br>  示例: bean(*Service) - 任何一个在名字匹配通配符表达式’*Service’的Spring bean之上的连接点 (在Spring AOP中只是方法执行)</li>\n<li>@target - 限定匹配特定的连接点(使用Spring AOP的时候方法的执行)，其中正执行对象的类持有指定类型的注解。<br>  示例: @target(org.springframework.transaction.annotation.Transactional) - 目标对象中有一个 @Transactional 注解的任意连接点 (在Spring AOP中只是方法执行)</li>\n<li>@args - 限定匹配特定的连接点(使用Spring AOP的时候方法的执行)，其中实际传入参数的运行时类型持有指定类型的注解。<br>  示例: @args(com.xyz.security.Classified) - 任何一个只接受一个参数，并且运行时所传入的参数类型具有@Classified 注解的连接点(在Spring AOP中只是方法执行)</li>\n<li>@within - 限定匹配特定的连接点，其中连接点所在类型已指定注解(在使用Spring AOP的时候，所执行的方法所在类型已指定注解)。<br>  示例: @within(org.springframework.transaction.annotation.Transactional) - 任何一个目标对象声明的类型有一个 @Transactional 注解的连接点 (在Spring AOP中只是方法执行)</li>\n<li>@annotation - 限定匹配特定的连接点(使用Spring AOP的时候方法的执行)，其中连接点的主题持有指定的注解。<br>  示例: @annotation(org.springframework.transaction.annotation.Transactional) - 任何一个执行的方法有一个 @Transactional 注解的连接点 (在Spring AOP中只是方法执行)</li>\n</ul>\n<p><code>注意：</code><strong>切入点表达式可以使用’&amp;’, ‘||’ 和 ‘!’来组合</strong></p>\n<h3 id=\"通知类型声明注解：\"><a href=\"#通知类型声明注解：\" class=\"headerlink\" title=\"通知类型声明注解：\"></a>通知类型声明注解：</h3><ul>\n<li>前置通知 - 使用 @Before 注解声明</li>\n<li>后置通知 - 使用 @AfterReturning 注解来声明</li>\n<li>异常通知 - 使用@AfterThrowing注解</li>\n<li>最终通知 - 使用@After 注解来声明</li>\n<li>环绕通知 - 使用@Around注解来声明</li>\n</ul>\n<h3 id=\"共享通用切入点定义\"><a href=\"#共享通用切入点定义\" class=\"headerlink\" title=\"共享通用切入点定义\"></a>共享通用切入点定义</h3><p>通过@Pointcut先定义好切入点, 当通知类型可以通过被 @Pointcut 标识的方法名直接共享其切入点配置。</p>\n<p>示例：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package com.xyz.someapp;</span><br><span class=\"line\"></span><br><span class=\"line\">@Aspect</span><br><span class=\"line\">public class SystemArchitecture &#123;</span><br><span class=\"line\">\t@Pointcut(&quot;within(com.xyz.someapp.web..*)&quot;)</span><br><span class=\"line\">  \tpublic void inWebLayer() &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  \t@Before(&quot;com.xyz.someapp.SystemArchitecture.inWebLayer()&quot;)</span><br><span class=\"line\">  \tpublic void doBefore() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  \t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  \t@After(&quot;com.xyz.someapp.SystemArchitecture.inWebLayer()&quot;)</span><br><span class=\"line\">  \tpublic void doAfter() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  \t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"获取切入点更多的信息\"><a href=\"#获取切入点更多的信息\" class=\"headerlink\" title=\"获取切入点更多的信息\"></a>获取切入点更多的信息</h3><p>任何通知方法可以将第一个参数定义为org.aspectj.lang.JoinPoint类型 （环绕通知需要定义第一个参数为ProceedingJoinPoint类型， 它是 JoinPoint 的一个子类）。JoinPoint 接口提供了一系列有用的方法，比如 getArgs()（返回方法参数）、 getThis()（返回代理对象）、getTarget()（返回目标）、 getSignature()（返回正在被通知的方法相关信息）和 toString() （打印出正在被通知的方法的有用信息）。</p>\n<hr>\n<p><a href=\"http://shouce.jb51.net/spring/aop.html\">http://shouce.jb51.net/spring/aop.html</a></p>\n<p><em>观点仅代表自己，期待你的留言。</em></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"AOP概念\"><a href=\"#AOP概念\" class=\"headerlink\" title=\"AOP概念\"></a>AOP概念</h2><p>AOP术语:</p>\n<ul>\n<li>切面（Aspect）：一个关注点的模块化，这个关注点可能会横切多个对象。事务管理是J2EE应用中一个关于横切关注点的很好的例子。在Spring AOP中，切面可以使用基于模式或者基于@Aspect注解的方式来实现。</li>\n<li>连接点（Joinpoint）：在程序执行过程中某个特定的点，比如某方法调用的时候或者处理异常的时候。在Spring AOP中，一个连接点总是表示一个方法的执行。</li>\n<li>通知（Advice）：在切面的某个特定的连接点上执行的动作。其中包括了“around”、“before”和“after”等不同类型的通知（通知的类型将在后面部分进行讨论）。许多AOP框架（包括Spring）都是以拦截器做通知模型，并维护一个以连接点为中心的拦截器链。</li>\n<li>切入点（Pointcut）：匹配连接点的断言。通知和一个切入点表达式关联，并在满足这个切入点的连接点上运行（例如，当执行某个特定名称的方法时）。切入点表达式如何和连接点匹配是AOP的核心：Spring缺省使用AspectJ切入点语法。</li>\n<li>引入（Introduction）：用来给一个类型声明额外的方法或属性（也被称为连接类型声明（inter-type declaration））。Spring允许引入新的接口（以及一个对应的实现）到任何被代理的对象。例如，你可以使用引入来使一个bean实现IsModified接口，以便简化缓存机制。</li>\n<li>目标对象（Target Object）： 被一个或者多个切面所通知的对象。也被称做被通知（advised）对象。 既然Spring AOP是通过运行时代理实现的，这个对象永远是一个被代理（proxied）对象。</li>\n<li>AOP代理（AOP Proxy）：AOP框架创建的对象，用来实现切面契约（例如通知方法执行等等）。在Spring中，AOP代理可以是JDK动态代理或者CGLIB代理。</li>\n<li>织入（Weaving）：把切面连接到其它的应用程序类型或者对象上，并创建一个被通知的对象。这些可以在编译时（例如使用AspectJ编译器），类加载时和运行时完成。Spring和其他纯Java AOP框架一样，在运行时完成织入。</li>\n</ul>\n<p>通知类型：</p>\n<ul>\n<li>前置通知（Before advice）：在某连接点之前执行的通知，但这个通知不能阻止连接点之前的执行流程（除非它抛出一个异常）。</li>\n<li>后置通知（After returning advice）：在某连接点正常完成后执行的通知：例如，一个方法没有抛出任何异常，正常返回。</li>\n<li>异常通知（After throwing advice）：在方法抛出异常退出时执行的通知。</li>\n<li>最终通知（After (finally) advice）：当某连接点退出的时候执行的通知（不论是正常返回还是异常退出）。</li>\n<li>环绕通知（Around Advice）：包围一个连接点的通知，如方法调用。这是最强大的一种通知类型。环绕通知可以在方法调用前后完成自定义的行为。它也会选择是否继续执行连接点或直接返回它自己的返回值或抛出异常来结束执行。</li>\n</ul>\n<h2 id=\"配置实现\"><a href=\"#配置实现\" class=\"headerlink\" title=\"配置实现\"></a>配置实现</h2><p>实例需求: 监控各Api接口执行时间，找出耗时的业务操作。<br>1、启用@AspectJ支持<br><em>spring.xml</em></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class=\"line\">       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;</span><br><span class=\"line\">       xmlns:util=&quot;http://www.springframework.org/schema/util&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot;</span><br><span class=\"line\">       xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;</span><br><span class=\"line\">       xmlns:cache=&quot;http://www.springframework.org/schema/cache&quot; xmlns:p=&quot;http://www.springframework.org/schema/p&quot;</span><br><span class=\"line\">\t\txsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd</span><br><span class=\"line\">        http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd</span><br><span class=\"line\">        http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd</span><br><span class=\"line\">        http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd</span><br><span class=\"line\">        http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd</span><br><span class=\"line\">        http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util.xsd</span><br><span class=\"line\">        http://www.springframework.org/schema/cache http://www.springframework.org/schema/cache/spring-cache-3.2.xsd&quot;</span><br><span class=\"line\">       default-lazy-init=&quot;true&quot;&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&lt;aop:aspectj-autoproxy /&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;/beans&gt;</span><br></pre></td></tr></table></figure>\n<p>2、增加aspectj依赖库<br><em>pom.xml</em></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;dependency&gt;</span><br><span class=\"line\">    &lt;groupId&gt;org.aspectj&lt;/groupId&gt;</span><br><span class=\"line\">    &lt;artifactId&gt;aspectjrt&lt;/artifactId&gt;</span><br><span class=\"line\">    &lt;version&gt;1.7.4&lt;/version&gt;</span><br><span class=\"line\">&lt;/dependency&gt;</span><br><span class=\"line\">&lt;dependency&gt;</span><br><span class=\"line\">    &lt;groupId&gt;org.aspectj&lt;/groupId&gt;</span><br><span class=\"line\">    &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt;</span><br><span class=\"line\">    &lt;version&gt;1.7.4&lt;/version&gt;</span><br><span class=\"line\">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>\n<p>3、编写切面类</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Aspect</span><br><span class=\"line\">@Repository</span><br><span class=\"line\">public class AspectPoint &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Around(&quot;within(org.wujianjun.apps.service..*)&quot;)</span><br><span class=\"line\">    public Object doBasicProfiling(ProceedingJoinPoint pjp) throws Throwable &#123;</span><br><span class=\"line\">        final long beginTime = System.currentTimeMillis();</span><br><span class=\"line\">        Object res = pjp.proceed(pjp.getArgs());</span><br><span class=\"line\">        final long endTime = System.currentTimeMillis();</span><br><span class=\"line\">        System.out.println(pjp.getTarget().getClass().getSimpleName()+&quot;.&quot;+pjp.getSignature().getName()+&quot;--&gt;&quot;+(endTime-beginTime)+&quot;ms&quot;);</span><br><span class=\"line\">        return res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>对比一下xml配置</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class=\"line\">       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;</span><br><span class=\"line\">       xmlns:util=&quot;http://www.springframework.org/schema/util&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot;</span><br><span class=\"line\">       xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;</span><br><span class=\"line\">       xmlns:cache=&quot;http://www.springframework.org/schema/cache&quot; xmlns:p=&quot;http://www.springframework.org/schema/p&quot;</span><br><span class=\"line\">    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd</span><br><span class=\"line\">        http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd</span><br><span class=\"line\">        http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd</span><br><span class=\"line\">        http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd</span><br><span class=\"line\">        http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd</span><br><span class=\"line\">        http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util.xsd</span><br><span class=\"line\">        http://www.springframework.org/schema/cache http://www.springframework.org/schema/cache/spring-cache-3.2.xsd&quot;</span><br><span class=\"line\">       default-lazy-init=&quot;true&quot;&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">  &lt;bean id=&quot;aspectPoint&quot; class=&quot;AspectPoint&quot; /&gt;</span><br><span class=\"line\">  &lt;aop:aspectj-autoproxy/&gt; </span><br><span class=\"line\">  &lt;aop:config&gt;</span><br><span class=\"line\">    &lt;aop:aspect ref=&quot;aspectPoint&quot;&gt;</span><br><span class=\"line\">      &lt;aop:around method=&quot;doBasicProfiling&quot; pointcut=&quot;within(org.wujianjun.apps.service..*)&quot; /&gt;</span><br><span class=\"line\">    &lt;/aop:aspect&gt;</span><br><span class=\"line\">  &lt;/aop:config&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;/beans&gt;</span><br></pre></td></tr></table></figure>\n\n<p>附上测试业务实现类</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package org.wujianjun.apps.service.impl;</span><br><span class=\"line\"></span><br><span class=\"line\">@Service</span><br><span class=\"line\">public class ExampleServiceImpl implements ExampleService &#123;</span><br><span class=\"line\">    private final static Logger LOG = LoggerFactory</span><br><span class=\"line\">            .getLogger(ExampleServiceImpl.class);</span><br><span class=\"line\"></span><br><span class=\"line\">    @Resource</span><br><span class=\"line\">    private ExampleManager exampleManager;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public void test() &#123;</span><br><span class=\"line\">        System.out.println(&quot;test--&quot;);</span><br><span class=\"line\">        try &#123;</span><br><span class=\"line\">            Thread.sleep(100);</span><br><span class=\"line\">        &#125; catch (InterruptedException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>4、测试结果</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">六月 30, 2016 4:11:07 下午 org.apache.coyote.AbstractProtocol start</span><br><span class=\"line\">信息: Starting ProtocolHandler [&quot;http-bio-8080&quot;]</span><br><span class=\"line\">test--</span><br><span class=\"line\">ExampleServiceImpl.test--&gt;103ms</span><br><span class=\"line\">test--</span><br><span class=\"line\">ExampleServiceImpl.test--&gt;105ms</span><br><span class=\"line\">test--</span><br><span class=\"line\">ExampleServiceImpl.test--&gt;103ms</span><br><span class=\"line\">test--</span><br><span class=\"line\">ExampleServiceImpl.test--&gt;103ms</span><br><span class=\"line\">test--</span><br><span class=\"line\">ExampleServiceImpl.test--&gt;100ms</span><br><span class=\"line\">test--</span><br><span class=\"line\">ExampleServiceImpl.test--&gt;104ms</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"配置说明\"><a href=\"#配置说明\" class=\"headerlink\" title=\"配置说明\"></a>配置说明</h2><h3 id=\"AspectJ切入点指示符：\"><a href=\"#AspectJ切入点指示符：\" class=\"headerlink\" title=\"AspectJ切入点指示符：\"></a>AspectJ切入点指示符：</h3><ul>\n<li>execution - 匹配方法执行的连接点，这是你将会用到的Spring的最主要的切入点指示符。<br>  具体格式：<code>execution(modifiers-pattern? ret-type-pattern declaring-type-pattern? name-pattern(param-pattern)throws-pattern?)</code><br>  示例: execution(* com.xyz.service..<em>.</em>(..) - 在service包或其子包中定义的任意方法的执行</li>\n<li>within - 限定匹配特定类型的连接点(在使用Spring AOP的时候，在匹配的类型中定义的方法的执行)。<br>  示例: within(com.xyz.service..*) - 在service包或其子包中的任意连接点(在Spring AOP中只是方法执行)，包含类和接口</li>\n<li>this - 限定匹配特定的连接点(使用Spring AOP的时候方法的执行)，其中bean reference(Spring AOP 代理)是指定类型的实例。<br>  示例: this(com.xyz.service.AccountService) - 实现了AccountService接口的代理对象的任意连接点 (在Spring AOP中只是方法执行)</li>\n<li>target - 限定匹配特定的连接点(使用Spring AOP的时候方法的执行)，其中目标对象(被代理的应用对象)是指定类型的实例。<br>  示例: target(com.xyz.service.AccountService) - 实现AccountService接口的目标对象的任意连接点 (在Spring AOP中只是方法执行)</li>\n<li>args - 限定匹配特定的连接点(使用Spring AOP的时候方法的执行)，其中参数是指定类型的实例。<br>  示例: args(java.io.Serializable) - 任何一个只接受一个参数，并且运行时所传入的参数是Serializable 接口的连接点(在Spring AOP中只是方法执行)</li>\n<li>bean - 标记可以是任何Spring bean的名字支持通配符’*’。<br>  示例: bean(*Service) - 任何一个在名字匹配通配符表达式’*Service’的Spring bean之上的连接点 (在Spring AOP中只是方法执行)</li>\n<li>@target - 限定匹配特定的连接点(使用Spring AOP的时候方法的执行)，其中正执行对象的类持有指定类型的注解。<br>  示例: @target(org.springframework.transaction.annotation.Transactional) - 目标对象中有一个 @Transactional 注解的任意连接点 (在Spring AOP中只是方法执行)</li>\n<li>@args - 限定匹配特定的连接点(使用Spring AOP的时候方法的执行)，其中实际传入参数的运行时类型持有指定类型的注解。<br>  示例: @args(com.xyz.security.Classified) - 任何一个只接受一个参数，并且运行时所传入的参数类型具有@Classified 注解的连接点(在Spring AOP中只是方法执行)</li>\n<li>@within - 限定匹配特定的连接点，其中连接点所在类型已指定注解(在使用Spring AOP的时候，所执行的方法所在类型已指定注解)。<br>  示例: @within(org.springframework.transaction.annotation.Transactional) - 任何一个目标对象声明的类型有一个 @Transactional 注解的连接点 (在Spring AOP中只是方法执行)</li>\n<li>@annotation - 限定匹配特定的连接点(使用Spring AOP的时候方法的执行)，其中连接点的主题持有指定的注解。<br>  示例: @annotation(org.springframework.transaction.annotation.Transactional) - 任何一个执行的方法有一个 @Transactional 注解的连接点 (在Spring AOP中只是方法执行)</li>\n</ul>\n<p><code>注意：</code><strong>切入点表达式可以使用’&amp;’, ‘||’ 和 ‘!’来组合</strong></p>\n<h3 id=\"通知类型声明注解：\"><a href=\"#通知类型声明注解：\" class=\"headerlink\" title=\"通知类型声明注解：\"></a>通知类型声明注解：</h3><ul>\n<li>前置通知 - 使用 @Before 注解声明</li>\n<li>后置通知 - 使用 @AfterReturning 注解来声明</li>\n<li>异常通知 - 使用@AfterThrowing注解</li>\n<li>最终通知 - 使用@After 注解来声明</li>\n<li>环绕通知 - 使用@Around注解来声明</li>\n</ul>\n<h3 id=\"共享通用切入点定义\"><a href=\"#共享通用切入点定义\" class=\"headerlink\" title=\"共享通用切入点定义\"></a>共享通用切入点定义</h3><p>通过@Pointcut先定义好切入点, 当通知类型可以通过被 @Pointcut 标识的方法名直接共享其切入点配置。</p>\n<p>示例：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package com.xyz.someapp;</span><br><span class=\"line\"></span><br><span class=\"line\">@Aspect</span><br><span class=\"line\">public class SystemArchitecture &#123;</span><br><span class=\"line\">\t@Pointcut(&quot;within(com.xyz.someapp.web..*)&quot;)</span><br><span class=\"line\">  \tpublic void inWebLayer() &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  \t@Before(&quot;com.xyz.someapp.SystemArchitecture.inWebLayer()&quot;)</span><br><span class=\"line\">  \tpublic void doBefore() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  \t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  \t@After(&quot;com.xyz.someapp.SystemArchitecture.inWebLayer()&quot;)</span><br><span class=\"line\">  \tpublic void doAfter() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  \t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"获取切入点更多的信息\"><a href=\"#获取切入点更多的信息\" class=\"headerlink\" title=\"获取切入点更多的信息\"></a>获取切入点更多的信息</h3><p>任何通知方法可以将第一个参数定义为org.aspectj.lang.JoinPoint类型 （环绕通知需要定义第一个参数为ProceedingJoinPoint类型， 它是 JoinPoint 的一个子类）。JoinPoint 接口提供了一系列有用的方法，比如 getArgs()（返回方法参数）、 getThis()（返回代理对象）、getTarget()（返回目标）、 getSignature()（返回正在被通知的方法相关信息）和 toString() （打印出正在被通知的方法的有用信息）。</p>\n<hr>\n<p><a href=\"http://shouce.jb51.net/spring/aop.html\">http://shouce.jb51.net/spring/aop.html</a></p>\n<p><em>观点仅代表自己，期待你的留言。</em></p>\n"},{"title":"Spring InitializingBean趟坑笔记","date":"2017-07-18T09:59:12.000Z","list_number":false,"_content":"\n## 问题现象\n在Spring完成上下文初始化完成后, InitializingBean的实现类中重写的`afterPropertiesSet`方法并未执行.\n## 一、类对象延迟初始\n``` java\npublic interface InitializingBean {\n    /**\n      * Invoked by a BeanFactory after it has set all bean properties supplied\n      * (and satisfied BeanFactoryAware and ApplicationContextAware).\n      * <p>This method allows the bean instance to perform initialization only\n      * possible when all bean properties have been set and to throw an\n      * exception in the event of misconfiguration.\n      * @throws Exception in the event of misconfiguration (such\n      * as failure to set an essential property) or if initialization fails.\n      */\n     void afterPropertiesSet() throws Exception;\n }\n```\n由于此接口的方法afterPropertiesSet是在对象的所有属性被初始化后才会调用。当Spring的配置文件中设置类初始默认为\"延迟初始\"（`default-lazy-init=\"true\"`，此值默认为false）时，\n类对象如果不被使用，则不会实例化该类对象。所以 InitializingBean子类不能用于在容器启动时进行初始化的工作，则应使用Spring提供的`ApplicationListener`接口来进行程序的初始化工作。\n\n另外，如果需要InitializingBean子类对象在Spring容器启动时就初始化并则容器调用afterPropertiesSet方法则需要在类上增加`org.springframework.context.annotation.Lazy`注解并设置为false即可（也可通过spring配置bean时添加`lazy-init=\"false\"`)。\n\n-----\n\n*观点仅代表自己，期待你的留言。*\n","source":"_posts/spring-initializingbean.md","raw":"---\ntitle: Spring InitializingBean趟坑笔记\ntags:\n  - 原创\ndate: 2017-07-18 17:59:12\nlist_number: false\n---\n\n## 问题现象\n在Spring完成上下文初始化完成后, InitializingBean的实现类中重写的`afterPropertiesSet`方法并未执行.\n## 一、类对象延迟初始\n``` java\npublic interface InitializingBean {\n    /**\n      * Invoked by a BeanFactory after it has set all bean properties supplied\n      * (and satisfied BeanFactoryAware and ApplicationContextAware).\n      * <p>This method allows the bean instance to perform initialization only\n      * possible when all bean properties have been set and to throw an\n      * exception in the event of misconfiguration.\n      * @throws Exception in the event of misconfiguration (such\n      * as failure to set an essential property) or if initialization fails.\n      */\n     void afterPropertiesSet() throws Exception;\n }\n```\n由于此接口的方法afterPropertiesSet是在对象的所有属性被初始化后才会调用。当Spring的配置文件中设置类初始默认为\"延迟初始\"（`default-lazy-init=\"true\"`，此值默认为false）时，\n类对象如果不被使用，则不会实例化该类对象。所以 InitializingBean子类不能用于在容器启动时进行初始化的工作，则应使用Spring提供的`ApplicationListener`接口来进行程序的初始化工作。\n\n另外，如果需要InitializingBean子类对象在Spring容器启动时就初始化并则容器调用afterPropertiesSet方法则需要在类上增加`org.springframework.context.annotation.Lazy`注解并设置为false即可（也可通过spring配置bean时添加`lazy-init=\"false\"`)。\n\n-----\n\n*观点仅代表自己，期待你的留言。*\n","slug":"spring-initializingbean","published":1,"updated":"2021-08-31T14:23:11.550Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cku52dyov004rbbinh9gp2nn7","content":"<h2 id=\"问题现象\"><a href=\"#问题现象\" class=\"headerlink\" title=\"问题现象\"></a>问题现象</h2><p>在Spring完成上下文初始化完成后, InitializingBean的实现类中重写的<code>afterPropertiesSet</code>方法并未执行.</p>\n<h2 id=\"一、类对象延迟初始\"><a href=\"#一、类对象延迟初始\" class=\"headerlink\" title=\"一、类对象延迟初始\"></a>一、类对象延迟初始</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">InitializingBean</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">      * Invoked by a BeanFactory after it has set all bean properties supplied</span></span><br><span class=\"line\"><span class=\"comment\">      * (and satisfied BeanFactoryAware and ApplicationContextAware).</span></span><br><span class=\"line\"><span class=\"comment\">      * &lt;p&gt;This method allows the bean instance to perform initialization only</span></span><br><span class=\"line\"><span class=\"comment\">      * possible when all bean properties have been set and to throw an</span></span><br><span class=\"line\"><span class=\"comment\">      * exception in the event of misconfiguration.</span></span><br><span class=\"line\"><span class=\"comment\">      * <span class=\"doctag\">@throws</span> Exception in the event of misconfiguration (such</span></span><br><span class=\"line\"><span class=\"comment\">      * as failure to set an essential property) or if initialization fails.</span></span><br><span class=\"line\"><span class=\"comment\">      */</span></span><br><span class=\"line\">     <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">afterPropertiesSet</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception</span>;</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n<p>由于此接口的方法afterPropertiesSet是在对象的所有属性被初始化后才会调用。当Spring的配置文件中设置类初始默认为”延迟初始”（<code>default-lazy-init=&quot;true&quot;</code>，此值默认为false）时，<br>类对象如果不被使用，则不会实例化该类对象。所以 InitializingBean子类不能用于在容器启动时进行初始化的工作，则应使用Spring提供的<code>ApplicationListener</code>接口来进行程序的初始化工作。</p>\n<p>另外，如果需要InitializingBean子类对象在Spring容器启动时就初始化并则容器调用afterPropertiesSet方法则需要在类上增加<code>org.springframework.context.annotation.Lazy</code>注解并设置为false即可（也可通过spring配置bean时添加<code>lazy-init=&quot;false&quot;</code>)。</p>\n<hr>\n<p><em>观点仅代表自己，期待你的留言。</em></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"问题现象\"><a href=\"#问题现象\" class=\"headerlink\" title=\"问题现象\"></a>问题现象</h2><p>在Spring完成上下文初始化完成后, InitializingBean的实现类中重写的<code>afterPropertiesSet</code>方法并未执行.</p>\n<h2 id=\"一、类对象延迟初始\"><a href=\"#一、类对象延迟初始\" class=\"headerlink\" title=\"一、类对象延迟初始\"></a>一、类对象延迟初始</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">InitializingBean</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">      * Invoked by a BeanFactory after it has set all bean properties supplied</span></span><br><span class=\"line\"><span class=\"comment\">      * (and satisfied BeanFactoryAware and ApplicationContextAware).</span></span><br><span class=\"line\"><span class=\"comment\">      * &lt;p&gt;This method allows the bean instance to perform initialization only</span></span><br><span class=\"line\"><span class=\"comment\">      * possible when all bean properties have been set and to throw an</span></span><br><span class=\"line\"><span class=\"comment\">      * exception in the event of misconfiguration.</span></span><br><span class=\"line\"><span class=\"comment\">      * <span class=\"doctag\">@throws</span> Exception in the event of misconfiguration (such</span></span><br><span class=\"line\"><span class=\"comment\">      * as failure to set an essential property) or if initialization fails.</span></span><br><span class=\"line\"><span class=\"comment\">      */</span></span><br><span class=\"line\">     <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">afterPropertiesSet</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception</span>;</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n<p>由于此接口的方法afterPropertiesSet是在对象的所有属性被初始化后才会调用。当Spring的配置文件中设置类初始默认为”延迟初始”（<code>default-lazy-init=&quot;true&quot;</code>，此值默认为false）时，<br>类对象如果不被使用，则不会实例化该类对象。所以 InitializingBean子类不能用于在容器启动时进行初始化的工作，则应使用Spring提供的<code>ApplicationListener</code>接口来进行程序的初始化工作。</p>\n<p>另外，如果需要InitializingBean子类对象在Spring容器启动时就初始化并则容器调用afterPropertiesSet方法则需要在类上增加<code>org.springframework.context.annotation.Lazy</code>注解并设置为false即可（也可通过spring配置bean时添加<code>lazy-init=&quot;false&quot;</code>)。</p>\n<hr>\n<p><em>观点仅代表自己，期待你的留言。</em></p>\n"},{"title":"Spring ApplicationContext与常用接口笔记","keywords":["spring applicationContext","spring InitializingBean","spring FactoryBean","spring ApplicationListener","spring DisposableBean"],"toc":true,"list_number":false,"date":"2016-08-29T03:17:18.000Z","_content":"\n## 一、在Web项目中的ApplicationContext\n在web 项目中（spring mvc），系统会存在两个容器，一个是ApplicationContext,另一个就是我们自己的WebApplicationContext（作为ApplicationContext的子容器）。\n\n* ApplicationContext: 默认配置文件名applicationContext.xml，通过org.springframework.web.context.ContextLoaderListener进行加载并初始化。\n* WebApplicationContext: 默认配置文件名xxx-servlet.xml，xxx为DispatcherServlet配置的servlet-name, 通过org.springframework.web.servlet.DispatcherServlet进行加载并初始化。\n\nWebApplicationContext通过getParent()获取到ApplicationContext，而ApplicationContext的getParent()将获取到null（ApplicationContext没有父容器）。\n\n## 二、Spring常用接口\n### org.springframework.beans.factory.InitializingBean\nInitializingBean表示为spring管理的初始类，当Bean初始时进行属性注入完成后调用afterPropertiesSet进行初始处理。( [趟坑笔记 add by 2017-07-18](/2017/07/18/spring-initializingbean/))\n\n### org.springframework.beans.factory.FactoryBean<T>\nFactoryBean 是创建 复杂的bean，一般的bean 直接用xml配置即可，如果一个bean的创建过程中涉及到很多其他的bean 和复杂的逻辑，用xml配置比较困难，这时可以考虑用FactoryBean。\n\nspring配置时会自动调用getObject来获取注入对象。\n\n@see org.springframework.web.accept.ContentNegotiationManagerFactoryBean\n\n### org.springframework.context.ApplicationListener<E extends ApplicationEvent>\nApplicationListener用于监听应用程序的事件。\n所包含的事件详见ApplicationEvent子类。\n当Application事件发生时会自动调用监听器的onApplicationEvent方法。\n\n### org.springframework.context.ApplicationContextAware\n\nApplicationContextAware用于用户保存ApplicationContext的引用，供客户端程序获取ApplicationContext时使用。\n\n### org.springframework.beans.factory.DisposableBean\nDisposableBean用于标识可销毁的类，当类进行回收时调用destroy()\n\n\n-----\n\n*观点仅代表自己，期待你的留言。*\n","source":"_posts/spring-core-interface.md","raw":"---\ntitle: Spring ApplicationContext与常用接口笔记\nkeywords:\n  - spring applicationContext\n  - spring InitializingBean\n  - spring FactoryBean\n  - spring ApplicationListener\n  - spring DisposableBean\ntags:\n  - 原创\ntoc: true\nlist_number: false\ndate: 2016-08-29 11:17:18\n---\n\n## 一、在Web项目中的ApplicationContext\n在web 项目中（spring mvc），系统会存在两个容器，一个是ApplicationContext,另一个就是我们自己的WebApplicationContext（作为ApplicationContext的子容器）。\n\n* ApplicationContext: 默认配置文件名applicationContext.xml，通过org.springframework.web.context.ContextLoaderListener进行加载并初始化。\n* WebApplicationContext: 默认配置文件名xxx-servlet.xml，xxx为DispatcherServlet配置的servlet-name, 通过org.springframework.web.servlet.DispatcherServlet进行加载并初始化。\n\nWebApplicationContext通过getParent()获取到ApplicationContext，而ApplicationContext的getParent()将获取到null（ApplicationContext没有父容器）。\n\n## 二、Spring常用接口\n### org.springframework.beans.factory.InitializingBean\nInitializingBean表示为spring管理的初始类，当Bean初始时进行属性注入完成后调用afterPropertiesSet进行初始处理。( [趟坑笔记 add by 2017-07-18](/2017/07/18/spring-initializingbean/))\n\n### org.springframework.beans.factory.FactoryBean<T>\nFactoryBean 是创建 复杂的bean，一般的bean 直接用xml配置即可，如果一个bean的创建过程中涉及到很多其他的bean 和复杂的逻辑，用xml配置比较困难，这时可以考虑用FactoryBean。\n\nspring配置时会自动调用getObject来获取注入对象。\n\n@see org.springframework.web.accept.ContentNegotiationManagerFactoryBean\n\n### org.springframework.context.ApplicationListener<E extends ApplicationEvent>\nApplicationListener用于监听应用程序的事件。\n所包含的事件详见ApplicationEvent子类。\n当Application事件发生时会自动调用监听器的onApplicationEvent方法。\n\n### org.springframework.context.ApplicationContextAware\n\nApplicationContextAware用于用户保存ApplicationContext的引用，供客户端程序获取ApplicationContext时使用。\n\n### org.springframework.beans.factory.DisposableBean\nDisposableBean用于标识可销毁的类，当类进行回收时调用destroy()\n\n\n-----\n\n*观点仅代表自己，期待你的留言。*\n","slug":"spring-core-interface","published":1,"updated":"2021-08-31T14:23:11.550Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cku52dyp9004ubbin6hpm7vkc","content":"<h2 id=\"一、在Web项目中的ApplicationContext\"><a href=\"#一、在Web项目中的ApplicationContext\" class=\"headerlink\" title=\"一、在Web项目中的ApplicationContext\"></a>一、在Web项目中的ApplicationContext</h2><p>在web 项目中（spring mvc），系统会存在两个容器，一个是ApplicationContext,另一个就是我们自己的WebApplicationContext（作为ApplicationContext的子容器）。</p>\n<ul>\n<li>ApplicationContext: 默认配置文件名applicationContext.xml，通过org.springframework.web.context.ContextLoaderListener进行加载并初始化。</li>\n<li>WebApplicationContext: 默认配置文件名xxx-servlet.xml，xxx为DispatcherServlet配置的servlet-name, 通过org.springframework.web.servlet.DispatcherServlet进行加载并初始化。</li>\n</ul>\n<p>WebApplicationContext通过getParent()获取到ApplicationContext，而ApplicationContext的getParent()将获取到null（ApplicationContext没有父容器）。</p>\n<h2 id=\"二、Spring常用接口\"><a href=\"#二、Spring常用接口\" class=\"headerlink\" title=\"二、Spring常用接口\"></a>二、Spring常用接口</h2><h3 id=\"org-springframework-beans-factory-InitializingBean\"><a href=\"#org-springframework-beans-factory-InitializingBean\" class=\"headerlink\" title=\"org.springframework.beans.factory.InitializingBean\"></a>org.springframework.beans.factory.InitializingBean</h3><p>InitializingBean表示为spring管理的初始类，当Bean初始时进行属性注入完成后调用afterPropertiesSet进行初始处理。( <a href=\"/2017/07/18/spring-initializingbean/\">趟坑笔记 add by 2017-07-18</a>)</p>\n<h3 id=\"org-springframework-beans-factory-FactoryBean\"><a href=\"#org-springframework-beans-factory-FactoryBean\" class=\"headerlink\" title=\"org.springframework.beans.factory.FactoryBean\"></a>org.springframework.beans.factory.FactoryBean<T></h3><p>FactoryBean 是创建 复杂的bean，一般的bean 直接用xml配置即可，如果一个bean的创建过程中涉及到很多其他的bean 和复杂的逻辑，用xml配置比较困难，这时可以考虑用FactoryBean。</p>\n<p>spring配置时会自动调用getObject来获取注入对象。</p>\n<p>@see org.springframework.web.accept.ContentNegotiationManagerFactoryBean</p>\n<h3 id=\"org-springframework-context-ApplicationListener\"><a href=\"#org-springframework-context-ApplicationListener\" class=\"headerlink\" title=\"org.springframework.context.ApplicationListener\"></a>org.springframework.context.ApplicationListener<E extends ApplicationEvent></h3><p>ApplicationListener用于监听应用程序的事件。<br>所包含的事件详见ApplicationEvent子类。<br>当Application事件发生时会自动调用监听器的onApplicationEvent方法。</p>\n<h3 id=\"org-springframework-context-ApplicationContextAware\"><a href=\"#org-springframework-context-ApplicationContextAware\" class=\"headerlink\" title=\"org.springframework.context.ApplicationContextAware\"></a>org.springframework.context.ApplicationContextAware</h3><p>ApplicationContextAware用于用户保存ApplicationContext的引用，供客户端程序获取ApplicationContext时使用。</p>\n<h3 id=\"org-springframework-beans-factory-DisposableBean\"><a href=\"#org-springframework-beans-factory-DisposableBean\" class=\"headerlink\" title=\"org.springframework.beans.factory.DisposableBean\"></a>org.springframework.beans.factory.DisposableBean</h3><p>DisposableBean用于标识可销毁的类，当类进行回收时调用destroy()</p>\n<hr>\n<p><em>观点仅代表自己，期待你的留言。</em></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"一、在Web项目中的ApplicationContext\"><a href=\"#一、在Web项目中的ApplicationContext\" class=\"headerlink\" title=\"一、在Web项目中的ApplicationContext\"></a>一、在Web项目中的ApplicationContext</h2><p>在web 项目中（spring mvc），系统会存在两个容器，一个是ApplicationContext,另一个就是我们自己的WebApplicationContext（作为ApplicationContext的子容器）。</p>\n<ul>\n<li>ApplicationContext: 默认配置文件名applicationContext.xml，通过org.springframework.web.context.ContextLoaderListener进行加载并初始化。</li>\n<li>WebApplicationContext: 默认配置文件名xxx-servlet.xml，xxx为DispatcherServlet配置的servlet-name, 通过org.springframework.web.servlet.DispatcherServlet进行加载并初始化。</li>\n</ul>\n<p>WebApplicationContext通过getParent()获取到ApplicationContext，而ApplicationContext的getParent()将获取到null（ApplicationContext没有父容器）。</p>\n<h2 id=\"二、Spring常用接口\"><a href=\"#二、Spring常用接口\" class=\"headerlink\" title=\"二、Spring常用接口\"></a>二、Spring常用接口</h2><h3 id=\"org-springframework-beans-factory-InitializingBean\"><a href=\"#org-springframework-beans-factory-InitializingBean\" class=\"headerlink\" title=\"org.springframework.beans.factory.InitializingBean\"></a>org.springframework.beans.factory.InitializingBean</h3><p>InitializingBean表示为spring管理的初始类，当Bean初始时进行属性注入完成后调用afterPropertiesSet进行初始处理。( <a href=\"/2017/07/18/spring-initializingbean/\">趟坑笔记 add by 2017-07-18</a>)</p>\n<h3 id=\"org-springframework-beans-factory-FactoryBean\"><a href=\"#org-springframework-beans-factory-FactoryBean\" class=\"headerlink\" title=\"org.springframework.beans.factory.FactoryBean\"></a>org.springframework.beans.factory.FactoryBean<T></h3><p>FactoryBean 是创建 复杂的bean，一般的bean 直接用xml配置即可，如果一个bean的创建过程中涉及到很多其他的bean 和复杂的逻辑，用xml配置比较困难，这时可以考虑用FactoryBean。</p>\n<p>spring配置时会自动调用getObject来获取注入对象。</p>\n<p>@see org.springframework.web.accept.ContentNegotiationManagerFactoryBean</p>\n<h3 id=\"org-springframework-context-ApplicationListener\"><a href=\"#org-springframework-context-ApplicationListener\" class=\"headerlink\" title=\"org.springframework.context.ApplicationListener\"></a>org.springframework.context.ApplicationListener<E extends ApplicationEvent></h3><p>ApplicationListener用于监听应用程序的事件。<br>所包含的事件详见ApplicationEvent子类。<br>当Application事件发生时会自动调用监听器的onApplicationEvent方法。</p>\n<h3 id=\"org-springframework-context-ApplicationContextAware\"><a href=\"#org-springframework-context-ApplicationContextAware\" class=\"headerlink\" title=\"org.springframework.context.ApplicationContextAware\"></a>org.springframework.context.ApplicationContextAware</h3><p>ApplicationContextAware用于用户保存ApplicationContext的引用，供客户端程序获取ApplicationContext时使用。</p>\n<h3 id=\"org-springframework-beans-factory-DisposableBean\"><a href=\"#org-springframework-beans-factory-DisposableBean\" class=\"headerlink\" title=\"org.springframework.beans.factory.DisposableBean\"></a>org.springframework.beans.factory.DisposableBean</h3><p>DisposableBean用于标识可销毁的类，当类进行回收时调用destroy()</p>\n<hr>\n<p><em>观点仅代表自己，期待你的留言。</em></p>\n"},{"title":"Spring多视图配置及源码剖析","keywords":["ContentNegotiatingViewResolver","Spring多视图配置","Spring源码剖析"],"date":"2016-06-29T07:56:16.000Z","_content":"\n## 简介\n在MVC架构中，Controller被用于连接Model与View，同时控制View的显示与跳转。在以往的开发实践中常常是直接将View与Controller放置在同一个Project中，如果此时想要真正实现Controller与View的分离，View与Controller的交互就只能通过HTTP+数据格式或者ajax实现。那么Controller所需要做的就是将数据通过api的方式提供给View。此时针对Controller就需要将数据进行api和view的两种完全不同的视图呈现。好在Spring已经给我们提供了`org.springframework.web.servlet.view.ContentNegotiatingViewResolver`来实现。\n\n## Spring多视图配置\n_spring-web.xml_\n```\n<!--配置消息转换器-->\n<mvc:annotation-driven>\n    <mvc:message-converters register-defaults=\"true\">\n        <bean class=\"org.springframework.http.converter.StringHttpMessageConverter\">\n            <constructor-arg value=\"UTF-8\"/>\n            <property name=\"supportedMediaTypes\">\n               <list>\n                   <value>application/xml;charset=UTF-8</value>\n                   <value>text/html;charset=UTF-8</value>\n                   <value>text/plain;charset=UTF-8</value>\n                   <value>application/json;charset=UTF-8</value>\n               </list>\n           </property>\n        </bean>\n        <bean class=\"org.springframework.http.converter.json.MappingJackson2HttpMessageConverter\">\n            <property name=\"prettyPrint\" value=\"true\"/>\n        </bean>\n    </mvc:message-converters>\n</mvc:annotation-driven>\n<!--多视图解析配置-->\n<bean class=\"org.springframework.web.servlet.view.ContentNegotiatingViewResolver\">\n\t<property name=\"defaultContentType\" value=\"text/html;charset=UTF-8\" />\n\t<!-- not by accept header -->\n\t<property name=\"ignoreAcceptHeader\" value=\"true\"/>\n\t<property name=\"favorPathExtension\" value=\"true\"/>\n\t<property name=\"favorParameter\" value=\"true\"/>\n    <property name=\"useNotAcceptableStatusCode\" value=\"true\" />\n\t<!-- by extension -->\n\t<property name=\"mediaTypes\">\n\t\t<map>\n\t\t    <entry key=\"xml\" value=\"application/xml\" />\n\t\t\t<entry key=\"json\" value=\"application/json\" />\n            <entry key=\"httl\" value=\"text/html\" />\n\t\t</map>\n\t</property>\n\t<property name=\"viewResolvers\">\n\t\t<list>\n            <ref bean=\"httlViewResolver\"/>\n\t\t</list>\n\t</property>\n\t\t<property name=\"defaultViews\">\n\t\t<list>\n            <bean class=\"org.springframework.web.servlet.view.json.MappingJackson2JsonView\" />\n           \t<bean class=\"org.springframework.web.servlet.view.xml.MappingJackson2XmlView\" />\n\t\t</list>\n\t</property>\n</bean>\n\n<!-- 视图解析器配置 -->\n<bean id=\"httlViewResolver\" class=\"httl.web.springmvc.HttlViewResolver\">\n    <property name=\"suffix\" value=\".view\"/>\n    <property name=\"contentType\" value=\"text/html;charset=UTF-8\"/>\n    <property name=\"attributesMap\" ref=\"viewTools\" />\n</bean>\n```\n_Controller.java_\n```\n@Controller\n@RequestMapping(\"/\")\npublic class CommonController {\n\t@RequestMapping(\"index\")\n    public ModelAndView indexPage() {\n        Map<String, Object> param = new HashMap<>();\n        param.put(\"_model_\", new Example());\n        return getView(\"index\", param);\n    }\n}\n```\n以上为多视图配置的全部内容，配置中我们提供了三种视图。\n1. httl的页面视图。 通过访问/index或/index.httl就可以得到。\n![](/images/spring-mutiview-0.png)\n2. json的数据视图。 通过访问/index.json就可以得到。\n![](/images/spring-mutiview-1.png)\n3. xml的数据视图。 通过访问/index.xml就可以各到。\n![](/images/spring-mutiview-2.png)\n这里需要注意的是，由于xml只有一个根节点，所以返回的param的Map中只能包含一个元素。如果配置多个map元素，则会抛出异常java.lang.IllegalStateException: Model contains more than one object to render, only one is supported\n![](/images/spring-mutiview-4.png)\n\n`useNotAcceptableStatusCode`：这个配置表示，当配置为true且不能找到你需要的配置时返回HttpStatus 406. 默认值为false\n![](/images/spring-mutiview-3.png)\n\n## Spring源码剖析\n首先当然是org.springframework.web.servlet.view.ContentNegotiatingViewResolver类，经过断点跟踪后，发现是通过resolveViewName()来定位的显示View。\n![](/images/spring-mutiview-5.png)\n从图上可以看出，先通过request获取到requestedMediaTypes。\n### 获取请求的视图格式\n![](/images/spring-mutiview-6.png)\n再深入一层查看，发现这里是针对requestedMediaTypes的过滤，而获取请求格式有三个途径，\nServletPathExtensionContentNegotiationStrategy（继承自PathExtensionContentNegotiationStrategy），\nParameterContentNegotiationStrategy\nFixedContentNegotiationStrategy\n而这恰好对应了Spring中针对识别多视图标识的配置\n```\n<property name=\"ignoreAcceptHeader\" value=\"true\"/>\n<property name=\"favorPathExtension\" value=\"true\"/>\n<property name=\"favorParameter\" value=\"true\"/>\n```\n所以可以得出结论：\n1、HeaderContentNegotiationStrategy对应ignoreAcceptHeader的配置，此处配置为false,那么ContentNegotiatingViewResolver.contentNegotiationManager属性里则会多出一个元素。通过其源码可以得到它是通过在request header中增加Accept消息头获取视图格式。\n2、ServletPathExtensionContentNegotiationStrategy（或者PathExtensionContentNegotiationStrategy）对应favorPathExtension的配置。通过请求后缀获取视图格式。\n3、ParameterContentNegotiationStrategy对应favorParameter的配置，通过在request uri中增加format=?获取视图格式。\n\n### 按requestdMediaTypes获取到支持的ViewResolver\n```\nList candidateViews = this.getCandidateViews(viewName, locale, requestedMediaTypes);\n```\n![](/images/spring-mutiview-7.png)\n这里所做的事，就是将controller处理完成的view名称拿到配置的ViewResolver里去查找（视图名称和加了后缀的视图名称两步搜索），最后再将配置的defaultViews直接加入到返回结果的List中。此处忽略掉了视图格式标识。 \n\n### 获取匹配度最高的View\n```\nView bestView = this.getBestView(candidateViews, requestedMediaTypes, attrs);\n```\n此方法所做的事：将包含视图名称的ViewResolver按requestedMediaTypes找到匹配度最高的View。\n如果没有找到，则按useNotAcceptableStatusCode返回HttpCode 406.或者通过candidateViews的第一个进行视图渲染。__这里的顺序可以通过配置viewResolvers的order属性确定__。\n\n## Velocity与Httl视图工具类实例处理方案\n\n由于在页面视图中我们需要用到很多的工具类来对Controller返回的数据进行判断以及转换等操作，所以一般来讲我们会在Map存入工具类的实例对象以便能在Page中直接使用。\n但是当返回的为xml视图时，由于元素数据限制为1个，所以这些工具类将会导致多视图不能返回xml的数据格式。\n\n在Velocity中可以配置toolbox等工具组件来实现，但是Httl并未支持。所以我找到另一个实现方式。\n\n经过源码的查看，UrlBasedViewResolver类中包含一个staticAttributes的Map类型属性，这里完全可以拿来存放工具类对象实例，staticAttributes属性的get和set方法名称为：setAttributesMap()和getAttributesMap(). 所以配置的时候要注意配置名为__attributesMap__。\n而HttlViewResolver与VelocityLayoutViewResolver都间接继承自UrlBasedViewResolver，所以可以通过配置attributesMap属性来实现工具类实例的配置。\n\n-----\n\n*观点仅代表自己，期待你的留言。*","source":"_posts/spring-mutiview.md","raw":"---\ntitle: Spring多视图配置及源码剖析\nkeywords:\n  - \"ContentNegotiatingViewResolver\"\n  - \"Spring多视图配置\"\n  - \"Spring源码剖析\"\ntags:\n  - 原创\ndate: 2016-06-29 15:56:16\n---\n\n## 简介\n在MVC架构中，Controller被用于连接Model与View，同时控制View的显示与跳转。在以往的开发实践中常常是直接将View与Controller放置在同一个Project中，如果此时想要真正实现Controller与View的分离，View与Controller的交互就只能通过HTTP+数据格式或者ajax实现。那么Controller所需要做的就是将数据通过api的方式提供给View。此时针对Controller就需要将数据进行api和view的两种完全不同的视图呈现。好在Spring已经给我们提供了`org.springframework.web.servlet.view.ContentNegotiatingViewResolver`来实现。\n\n## Spring多视图配置\n_spring-web.xml_\n```\n<!--配置消息转换器-->\n<mvc:annotation-driven>\n    <mvc:message-converters register-defaults=\"true\">\n        <bean class=\"org.springframework.http.converter.StringHttpMessageConverter\">\n            <constructor-arg value=\"UTF-8\"/>\n            <property name=\"supportedMediaTypes\">\n               <list>\n                   <value>application/xml;charset=UTF-8</value>\n                   <value>text/html;charset=UTF-8</value>\n                   <value>text/plain;charset=UTF-8</value>\n                   <value>application/json;charset=UTF-8</value>\n               </list>\n           </property>\n        </bean>\n        <bean class=\"org.springframework.http.converter.json.MappingJackson2HttpMessageConverter\">\n            <property name=\"prettyPrint\" value=\"true\"/>\n        </bean>\n    </mvc:message-converters>\n</mvc:annotation-driven>\n<!--多视图解析配置-->\n<bean class=\"org.springframework.web.servlet.view.ContentNegotiatingViewResolver\">\n\t<property name=\"defaultContentType\" value=\"text/html;charset=UTF-8\" />\n\t<!-- not by accept header -->\n\t<property name=\"ignoreAcceptHeader\" value=\"true\"/>\n\t<property name=\"favorPathExtension\" value=\"true\"/>\n\t<property name=\"favorParameter\" value=\"true\"/>\n    <property name=\"useNotAcceptableStatusCode\" value=\"true\" />\n\t<!-- by extension -->\n\t<property name=\"mediaTypes\">\n\t\t<map>\n\t\t    <entry key=\"xml\" value=\"application/xml\" />\n\t\t\t<entry key=\"json\" value=\"application/json\" />\n            <entry key=\"httl\" value=\"text/html\" />\n\t\t</map>\n\t</property>\n\t<property name=\"viewResolvers\">\n\t\t<list>\n            <ref bean=\"httlViewResolver\"/>\n\t\t</list>\n\t</property>\n\t\t<property name=\"defaultViews\">\n\t\t<list>\n            <bean class=\"org.springframework.web.servlet.view.json.MappingJackson2JsonView\" />\n           \t<bean class=\"org.springframework.web.servlet.view.xml.MappingJackson2XmlView\" />\n\t\t</list>\n\t</property>\n</bean>\n\n<!-- 视图解析器配置 -->\n<bean id=\"httlViewResolver\" class=\"httl.web.springmvc.HttlViewResolver\">\n    <property name=\"suffix\" value=\".view\"/>\n    <property name=\"contentType\" value=\"text/html;charset=UTF-8\"/>\n    <property name=\"attributesMap\" ref=\"viewTools\" />\n</bean>\n```\n_Controller.java_\n```\n@Controller\n@RequestMapping(\"/\")\npublic class CommonController {\n\t@RequestMapping(\"index\")\n    public ModelAndView indexPage() {\n        Map<String, Object> param = new HashMap<>();\n        param.put(\"_model_\", new Example());\n        return getView(\"index\", param);\n    }\n}\n```\n以上为多视图配置的全部内容，配置中我们提供了三种视图。\n1. httl的页面视图。 通过访问/index或/index.httl就可以得到。\n![](/images/spring-mutiview-0.png)\n2. json的数据视图。 通过访问/index.json就可以得到。\n![](/images/spring-mutiview-1.png)\n3. xml的数据视图。 通过访问/index.xml就可以各到。\n![](/images/spring-mutiview-2.png)\n这里需要注意的是，由于xml只有一个根节点，所以返回的param的Map中只能包含一个元素。如果配置多个map元素，则会抛出异常java.lang.IllegalStateException: Model contains more than one object to render, only one is supported\n![](/images/spring-mutiview-4.png)\n\n`useNotAcceptableStatusCode`：这个配置表示，当配置为true且不能找到你需要的配置时返回HttpStatus 406. 默认值为false\n![](/images/spring-mutiview-3.png)\n\n## Spring源码剖析\n首先当然是org.springframework.web.servlet.view.ContentNegotiatingViewResolver类，经过断点跟踪后，发现是通过resolveViewName()来定位的显示View。\n![](/images/spring-mutiview-5.png)\n从图上可以看出，先通过request获取到requestedMediaTypes。\n### 获取请求的视图格式\n![](/images/spring-mutiview-6.png)\n再深入一层查看，发现这里是针对requestedMediaTypes的过滤，而获取请求格式有三个途径，\nServletPathExtensionContentNegotiationStrategy（继承自PathExtensionContentNegotiationStrategy），\nParameterContentNegotiationStrategy\nFixedContentNegotiationStrategy\n而这恰好对应了Spring中针对识别多视图标识的配置\n```\n<property name=\"ignoreAcceptHeader\" value=\"true\"/>\n<property name=\"favorPathExtension\" value=\"true\"/>\n<property name=\"favorParameter\" value=\"true\"/>\n```\n所以可以得出结论：\n1、HeaderContentNegotiationStrategy对应ignoreAcceptHeader的配置，此处配置为false,那么ContentNegotiatingViewResolver.contentNegotiationManager属性里则会多出一个元素。通过其源码可以得到它是通过在request header中增加Accept消息头获取视图格式。\n2、ServletPathExtensionContentNegotiationStrategy（或者PathExtensionContentNegotiationStrategy）对应favorPathExtension的配置。通过请求后缀获取视图格式。\n3、ParameterContentNegotiationStrategy对应favorParameter的配置，通过在request uri中增加format=?获取视图格式。\n\n### 按requestdMediaTypes获取到支持的ViewResolver\n```\nList candidateViews = this.getCandidateViews(viewName, locale, requestedMediaTypes);\n```\n![](/images/spring-mutiview-7.png)\n这里所做的事，就是将controller处理完成的view名称拿到配置的ViewResolver里去查找（视图名称和加了后缀的视图名称两步搜索），最后再将配置的defaultViews直接加入到返回结果的List中。此处忽略掉了视图格式标识。 \n\n### 获取匹配度最高的View\n```\nView bestView = this.getBestView(candidateViews, requestedMediaTypes, attrs);\n```\n此方法所做的事：将包含视图名称的ViewResolver按requestedMediaTypes找到匹配度最高的View。\n如果没有找到，则按useNotAcceptableStatusCode返回HttpCode 406.或者通过candidateViews的第一个进行视图渲染。__这里的顺序可以通过配置viewResolvers的order属性确定__。\n\n## Velocity与Httl视图工具类实例处理方案\n\n由于在页面视图中我们需要用到很多的工具类来对Controller返回的数据进行判断以及转换等操作，所以一般来讲我们会在Map存入工具类的实例对象以便能在Page中直接使用。\n但是当返回的为xml视图时，由于元素数据限制为1个，所以这些工具类将会导致多视图不能返回xml的数据格式。\n\n在Velocity中可以配置toolbox等工具组件来实现，但是Httl并未支持。所以我找到另一个实现方式。\n\n经过源码的查看，UrlBasedViewResolver类中包含一个staticAttributes的Map类型属性，这里完全可以拿来存放工具类对象实例，staticAttributes属性的get和set方法名称为：setAttributesMap()和getAttributesMap(). 所以配置的时候要注意配置名为__attributesMap__。\n而HttlViewResolver与VelocityLayoutViewResolver都间接继承自UrlBasedViewResolver，所以可以通过配置attributesMap属性来实现工具类实例的配置。\n\n-----\n\n*观点仅代表自己，期待你的留言。*","slug":"spring-mutiview","published":1,"updated":"2021-08-31T14:23:11.550Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cku52dypa004wbbin2q4r14y4","content":"<h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><p>在MVC架构中，Controller被用于连接Model与View，同时控制View的显示与跳转。在以往的开发实践中常常是直接将View与Controller放置在同一个Project中，如果此时想要真正实现Controller与View的分离，View与Controller的交互就只能通过HTTP+数据格式或者ajax实现。那么Controller所需要做的就是将数据通过api的方式提供给View。此时针对Controller就需要将数据进行api和view的两种完全不同的视图呈现。好在Spring已经给我们提供了<code>org.springframework.web.servlet.view.ContentNegotiatingViewResolver</code>来实现。</p>\n<h2 id=\"Spring多视图配置\"><a href=\"#Spring多视图配置\" class=\"headerlink\" title=\"Spring多视图配置\"></a>Spring多视图配置</h2><p><em>spring-web.xml</em></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!--配置消息转换器--&gt;</span><br><span class=\"line\">&lt;mvc:annotation-driven&gt;</span><br><span class=\"line\">    &lt;mvc:message-converters register-defaults=&quot;true&quot;&gt;</span><br><span class=\"line\">        &lt;bean class=&quot;org.springframework.http.converter.StringHttpMessageConverter&quot;&gt;</span><br><span class=\"line\">            &lt;constructor-arg value=&quot;UTF-8&quot;/&gt;</span><br><span class=\"line\">            &lt;property name=&quot;supportedMediaTypes&quot;&gt;</span><br><span class=\"line\">               &lt;list&gt;</span><br><span class=\"line\">                   &lt;value&gt;application/xml;charset=UTF-8&lt;/value&gt;</span><br><span class=\"line\">                   &lt;value&gt;text/html;charset=UTF-8&lt;/value&gt;</span><br><span class=\"line\">                   &lt;value&gt;text/plain;charset=UTF-8&lt;/value&gt;</span><br><span class=\"line\">                   &lt;value&gt;application/json;charset=UTF-8&lt;/value&gt;</span><br><span class=\"line\">               &lt;/list&gt;</span><br><span class=\"line\">           &lt;/property&gt;</span><br><span class=\"line\">        &lt;/bean&gt;</span><br><span class=\"line\">        &lt;bean class=&quot;org.springframework.http.converter.json.MappingJackson2HttpMessageConverter&quot;&gt;</span><br><span class=\"line\">            &lt;property name=&quot;prettyPrint&quot; value=&quot;true&quot;/&gt;</span><br><span class=\"line\">        &lt;/bean&gt;</span><br><span class=\"line\">    &lt;/mvc:message-converters&gt;</span><br><span class=\"line\">&lt;/mvc:annotation-driven&gt;</span><br><span class=\"line\">&lt;!--多视图解析配置--&gt;</span><br><span class=\"line\">&lt;bean class=&quot;org.springframework.web.servlet.view.ContentNegotiatingViewResolver&quot;&gt;</span><br><span class=\"line\">\t&lt;property name=&quot;defaultContentType&quot; value=&quot;text/html;charset=UTF-8&quot; /&gt;</span><br><span class=\"line\">\t&lt;!-- not by accept header --&gt;</span><br><span class=\"line\">\t&lt;property name=&quot;ignoreAcceptHeader&quot; value=&quot;true&quot;/&gt;</span><br><span class=\"line\">\t&lt;property name=&quot;favorPathExtension&quot; value=&quot;true&quot;/&gt;</span><br><span class=\"line\">\t&lt;property name=&quot;favorParameter&quot; value=&quot;true&quot;/&gt;</span><br><span class=\"line\">    &lt;property name=&quot;useNotAcceptableStatusCode&quot; value=&quot;true&quot; /&gt;</span><br><span class=\"line\">\t&lt;!-- by extension --&gt;</span><br><span class=\"line\">\t&lt;property name=&quot;mediaTypes&quot;&gt;</span><br><span class=\"line\">\t\t&lt;map&gt;</span><br><span class=\"line\">\t\t    &lt;entry key=&quot;xml&quot; value=&quot;application/xml&quot; /&gt;</span><br><span class=\"line\">\t\t\t&lt;entry key=&quot;json&quot; value=&quot;application/json&quot; /&gt;</span><br><span class=\"line\">            &lt;entry key=&quot;httl&quot; value=&quot;text/html&quot; /&gt;</span><br><span class=\"line\">\t\t&lt;/map&gt;</span><br><span class=\"line\">\t&lt;/property&gt;</span><br><span class=\"line\">\t&lt;property name=&quot;viewResolvers&quot;&gt;</span><br><span class=\"line\">\t\t&lt;list&gt;</span><br><span class=\"line\">            &lt;ref bean=&quot;httlViewResolver&quot;/&gt;</span><br><span class=\"line\">\t\t&lt;/list&gt;</span><br><span class=\"line\">\t&lt;/property&gt;</span><br><span class=\"line\">\t\t&lt;property name=&quot;defaultViews&quot;&gt;</span><br><span class=\"line\">\t\t&lt;list&gt;</span><br><span class=\"line\">            &lt;bean class=&quot;org.springframework.web.servlet.view.json.MappingJackson2JsonView&quot; /&gt;</span><br><span class=\"line\">           \t&lt;bean class=&quot;org.springframework.web.servlet.view.xml.MappingJackson2XmlView&quot; /&gt;</span><br><span class=\"line\">\t\t&lt;/list&gt;</span><br><span class=\"line\">\t&lt;/property&gt;</span><br><span class=\"line\">&lt;/bean&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;!-- 视图解析器配置 --&gt;</span><br><span class=\"line\">&lt;bean id=&quot;httlViewResolver&quot; class=&quot;httl.web.springmvc.HttlViewResolver&quot;&gt;</span><br><span class=\"line\">    &lt;property name=&quot;suffix&quot; value=&quot;.view&quot;/&gt;</span><br><span class=\"line\">    &lt;property name=&quot;contentType&quot; value=&quot;text/html;charset=UTF-8&quot;/&gt;</span><br><span class=\"line\">    &lt;property name=&quot;attributesMap&quot; ref=&quot;viewTools&quot; /&gt;</span><br><span class=\"line\">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>\n<p><em>Controller.java</em></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Controller</span><br><span class=\"line\">@RequestMapping(&quot;/&quot;)</span><br><span class=\"line\">public class CommonController &#123;</span><br><span class=\"line\">\t@RequestMapping(&quot;index&quot;)</span><br><span class=\"line\">    public ModelAndView indexPage() &#123;</span><br><span class=\"line\">        Map&lt;String, Object&gt; param = new HashMap&lt;&gt;();</span><br><span class=\"line\">        param.put(&quot;_model_&quot;, new Example());</span><br><span class=\"line\">        return getView(&quot;index&quot;, param);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>以上为多视图配置的全部内容，配置中我们提供了三种视图。</p>\n<ol>\n<li>httl的页面视图。 通过访问/index或/index.httl就可以得到。<br><img src=\"/images/spring-mutiview-0.png\"></li>\n<li>json的数据视图。 通过访问/index.json就可以得到。<br><img src=\"/images/spring-mutiview-1.png\"></li>\n<li>xml的数据视图。 通过访问/index.xml就可以各到。<br><img src=\"/images/spring-mutiview-2.png\"><br>这里需要注意的是，由于xml只有一个根节点，所以返回的param的Map中只能包含一个元素。如果配置多个map元素，则会抛出异常java.lang.IllegalStateException: Model contains more than one object to render, only one is supported<br><img src=\"/images/spring-mutiview-4.png\"></li>\n</ol>\n<p><code>useNotAcceptableStatusCode</code>：这个配置表示，当配置为true且不能找到你需要的配置时返回HttpStatus 406. 默认值为false<br><img src=\"/images/spring-mutiview-3.png\"></p>\n<h2 id=\"Spring源码剖析\"><a href=\"#Spring源码剖析\" class=\"headerlink\" title=\"Spring源码剖析\"></a>Spring源码剖析</h2><p>首先当然是org.springframework.web.servlet.view.ContentNegotiatingViewResolver类，经过断点跟踪后，发现是通过resolveViewName()来定位的显示View。<br><img src=\"/images/spring-mutiview-5.png\"><br>从图上可以看出，先通过request获取到requestedMediaTypes。</p>\n<h3 id=\"获取请求的视图格式\"><a href=\"#获取请求的视图格式\" class=\"headerlink\" title=\"获取请求的视图格式\"></a>获取请求的视图格式</h3><p><img src=\"/images/spring-mutiview-6.png\"><br>再深入一层查看，发现这里是针对requestedMediaTypes的过滤，而获取请求格式有三个途径，<br>ServletPathExtensionContentNegotiationStrategy（继承自PathExtensionContentNegotiationStrategy），<br>ParameterContentNegotiationStrategy<br>FixedContentNegotiationStrategy<br>而这恰好对应了Spring中针对识别多视图标识的配置</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;property name=&quot;ignoreAcceptHeader&quot; value=&quot;true&quot;/&gt;</span><br><span class=\"line\">&lt;property name=&quot;favorPathExtension&quot; value=&quot;true&quot;/&gt;</span><br><span class=\"line\">&lt;property name=&quot;favorParameter&quot; value=&quot;true&quot;/&gt;</span><br></pre></td></tr></table></figure>\n<p>所以可以得出结论：<br>1、HeaderContentNegotiationStrategy对应ignoreAcceptHeader的配置，此处配置为false,那么ContentNegotiatingViewResolver.contentNegotiationManager属性里则会多出一个元素。通过其源码可以得到它是通过在request header中增加Accept消息头获取视图格式。<br>2、ServletPathExtensionContentNegotiationStrategy（或者PathExtensionContentNegotiationStrategy）对应favorPathExtension的配置。通过请求后缀获取视图格式。<br>3、ParameterContentNegotiationStrategy对应favorParameter的配置，通过在request uri中增加format=?获取视图格式。</p>\n<h3 id=\"按requestdMediaTypes获取到支持的ViewResolver\"><a href=\"#按requestdMediaTypes获取到支持的ViewResolver\" class=\"headerlink\" title=\"按requestdMediaTypes获取到支持的ViewResolver\"></a>按requestdMediaTypes获取到支持的ViewResolver</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List candidateViews = this.getCandidateViews(viewName, locale, requestedMediaTypes);</span><br></pre></td></tr></table></figure>\n<p><img src=\"/images/spring-mutiview-7.png\"><br>这里所做的事，就是将controller处理完成的view名称拿到配置的ViewResolver里去查找（视图名称和加了后缀的视图名称两步搜索），最后再将配置的defaultViews直接加入到返回结果的List中。此处忽略掉了视图格式标识。 </p>\n<h3 id=\"获取匹配度最高的View\"><a href=\"#获取匹配度最高的View\" class=\"headerlink\" title=\"获取匹配度最高的View\"></a>获取匹配度最高的View</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">View bestView = this.getBestView(candidateViews, requestedMediaTypes, attrs);</span><br></pre></td></tr></table></figure>\n<p>此方法所做的事：将包含视图名称的ViewResolver按requestedMediaTypes找到匹配度最高的View。<br>如果没有找到，则按useNotAcceptableStatusCode返回HttpCode 406.或者通过candidateViews的第一个进行视图渲染。__这里的顺序可以通过配置viewResolvers的order属性确定__。</p>\n<h2 id=\"Velocity与Httl视图工具类实例处理方案\"><a href=\"#Velocity与Httl视图工具类实例处理方案\" class=\"headerlink\" title=\"Velocity与Httl视图工具类实例处理方案\"></a>Velocity与Httl视图工具类实例处理方案</h2><p>由于在页面视图中我们需要用到很多的工具类来对Controller返回的数据进行判断以及转换等操作，所以一般来讲我们会在Map存入工具类的实例对象以便能在Page中直接使用。<br>但是当返回的为xml视图时，由于元素数据限制为1个，所以这些工具类将会导致多视图不能返回xml的数据格式。</p>\n<p>在Velocity中可以配置toolbox等工具组件来实现，但是Httl并未支持。所以我找到另一个实现方式。</p>\n<p>经过源码的查看，UrlBasedViewResolver类中包含一个staticAttributes的Map类型属性，这里完全可以拿来存放工具类对象实例，staticAttributes属性的get和set方法名称为：setAttributesMap()和getAttributesMap(). 所以配置的时候要注意配置名为__attributesMap__。<br>而HttlViewResolver与VelocityLayoutViewResolver都间接继承自UrlBasedViewResolver，所以可以通过配置attributesMap属性来实现工具类实例的配置。</p>\n<hr>\n<p><em>观点仅代表自己，期待你的留言。</em></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><p>在MVC架构中，Controller被用于连接Model与View，同时控制View的显示与跳转。在以往的开发实践中常常是直接将View与Controller放置在同一个Project中，如果此时想要真正实现Controller与View的分离，View与Controller的交互就只能通过HTTP+数据格式或者ajax实现。那么Controller所需要做的就是将数据通过api的方式提供给View。此时针对Controller就需要将数据进行api和view的两种完全不同的视图呈现。好在Spring已经给我们提供了<code>org.springframework.web.servlet.view.ContentNegotiatingViewResolver</code>来实现。</p>\n<h2 id=\"Spring多视图配置\"><a href=\"#Spring多视图配置\" class=\"headerlink\" title=\"Spring多视图配置\"></a>Spring多视图配置</h2><p><em>spring-web.xml</em></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!--配置消息转换器--&gt;</span><br><span class=\"line\">&lt;mvc:annotation-driven&gt;</span><br><span class=\"line\">    &lt;mvc:message-converters register-defaults=&quot;true&quot;&gt;</span><br><span class=\"line\">        &lt;bean class=&quot;org.springframework.http.converter.StringHttpMessageConverter&quot;&gt;</span><br><span class=\"line\">            &lt;constructor-arg value=&quot;UTF-8&quot;/&gt;</span><br><span class=\"line\">            &lt;property name=&quot;supportedMediaTypes&quot;&gt;</span><br><span class=\"line\">               &lt;list&gt;</span><br><span class=\"line\">                   &lt;value&gt;application/xml;charset=UTF-8&lt;/value&gt;</span><br><span class=\"line\">                   &lt;value&gt;text/html;charset=UTF-8&lt;/value&gt;</span><br><span class=\"line\">                   &lt;value&gt;text/plain;charset=UTF-8&lt;/value&gt;</span><br><span class=\"line\">                   &lt;value&gt;application/json;charset=UTF-8&lt;/value&gt;</span><br><span class=\"line\">               &lt;/list&gt;</span><br><span class=\"line\">           &lt;/property&gt;</span><br><span class=\"line\">        &lt;/bean&gt;</span><br><span class=\"line\">        &lt;bean class=&quot;org.springframework.http.converter.json.MappingJackson2HttpMessageConverter&quot;&gt;</span><br><span class=\"line\">            &lt;property name=&quot;prettyPrint&quot; value=&quot;true&quot;/&gt;</span><br><span class=\"line\">        &lt;/bean&gt;</span><br><span class=\"line\">    &lt;/mvc:message-converters&gt;</span><br><span class=\"line\">&lt;/mvc:annotation-driven&gt;</span><br><span class=\"line\">&lt;!--多视图解析配置--&gt;</span><br><span class=\"line\">&lt;bean class=&quot;org.springframework.web.servlet.view.ContentNegotiatingViewResolver&quot;&gt;</span><br><span class=\"line\">\t&lt;property name=&quot;defaultContentType&quot; value=&quot;text/html;charset=UTF-8&quot; /&gt;</span><br><span class=\"line\">\t&lt;!-- not by accept header --&gt;</span><br><span class=\"line\">\t&lt;property name=&quot;ignoreAcceptHeader&quot; value=&quot;true&quot;/&gt;</span><br><span class=\"line\">\t&lt;property name=&quot;favorPathExtension&quot; value=&quot;true&quot;/&gt;</span><br><span class=\"line\">\t&lt;property name=&quot;favorParameter&quot; value=&quot;true&quot;/&gt;</span><br><span class=\"line\">    &lt;property name=&quot;useNotAcceptableStatusCode&quot; value=&quot;true&quot; /&gt;</span><br><span class=\"line\">\t&lt;!-- by extension --&gt;</span><br><span class=\"line\">\t&lt;property name=&quot;mediaTypes&quot;&gt;</span><br><span class=\"line\">\t\t&lt;map&gt;</span><br><span class=\"line\">\t\t    &lt;entry key=&quot;xml&quot; value=&quot;application/xml&quot; /&gt;</span><br><span class=\"line\">\t\t\t&lt;entry key=&quot;json&quot; value=&quot;application/json&quot; /&gt;</span><br><span class=\"line\">            &lt;entry key=&quot;httl&quot; value=&quot;text/html&quot; /&gt;</span><br><span class=\"line\">\t\t&lt;/map&gt;</span><br><span class=\"line\">\t&lt;/property&gt;</span><br><span class=\"line\">\t&lt;property name=&quot;viewResolvers&quot;&gt;</span><br><span class=\"line\">\t\t&lt;list&gt;</span><br><span class=\"line\">            &lt;ref bean=&quot;httlViewResolver&quot;/&gt;</span><br><span class=\"line\">\t\t&lt;/list&gt;</span><br><span class=\"line\">\t&lt;/property&gt;</span><br><span class=\"line\">\t\t&lt;property name=&quot;defaultViews&quot;&gt;</span><br><span class=\"line\">\t\t&lt;list&gt;</span><br><span class=\"line\">            &lt;bean class=&quot;org.springframework.web.servlet.view.json.MappingJackson2JsonView&quot; /&gt;</span><br><span class=\"line\">           \t&lt;bean class=&quot;org.springframework.web.servlet.view.xml.MappingJackson2XmlView&quot; /&gt;</span><br><span class=\"line\">\t\t&lt;/list&gt;</span><br><span class=\"line\">\t&lt;/property&gt;</span><br><span class=\"line\">&lt;/bean&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;!-- 视图解析器配置 --&gt;</span><br><span class=\"line\">&lt;bean id=&quot;httlViewResolver&quot; class=&quot;httl.web.springmvc.HttlViewResolver&quot;&gt;</span><br><span class=\"line\">    &lt;property name=&quot;suffix&quot; value=&quot;.view&quot;/&gt;</span><br><span class=\"line\">    &lt;property name=&quot;contentType&quot; value=&quot;text/html;charset=UTF-8&quot;/&gt;</span><br><span class=\"line\">    &lt;property name=&quot;attributesMap&quot; ref=&quot;viewTools&quot; /&gt;</span><br><span class=\"line\">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>\n<p><em>Controller.java</em></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Controller</span><br><span class=\"line\">@RequestMapping(&quot;/&quot;)</span><br><span class=\"line\">public class CommonController &#123;</span><br><span class=\"line\">\t@RequestMapping(&quot;index&quot;)</span><br><span class=\"line\">    public ModelAndView indexPage() &#123;</span><br><span class=\"line\">        Map&lt;String, Object&gt; param = new HashMap&lt;&gt;();</span><br><span class=\"line\">        param.put(&quot;_model_&quot;, new Example());</span><br><span class=\"line\">        return getView(&quot;index&quot;, param);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>以上为多视图配置的全部内容，配置中我们提供了三种视图。</p>\n<ol>\n<li>httl的页面视图。 通过访问/index或/index.httl就可以得到。<br><img src=\"/images/spring-mutiview-0.png\"></li>\n<li>json的数据视图。 通过访问/index.json就可以得到。<br><img src=\"/images/spring-mutiview-1.png\"></li>\n<li>xml的数据视图。 通过访问/index.xml就可以各到。<br><img src=\"/images/spring-mutiview-2.png\"><br>这里需要注意的是，由于xml只有一个根节点，所以返回的param的Map中只能包含一个元素。如果配置多个map元素，则会抛出异常java.lang.IllegalStateException: Model contains more than one object to render, only one is supported<br><img src=\"/images/spring-mutiview-4.png\"></li>\n</ol>\n<p><code>useNotAcceptableStatusCode</code>：这个配置表示，当配置为true且不能找到你需要的配置时返回HttpStatus 406. 默认值为false<br><img src=\"/images/spring-mutiview-3.png\"></p>\n<h2 id=\"Spring源码剖析\"><a href=\"#Spring源码剖析\" class=\"headerlink\" title=\"Spring源码剖析\"></a>Spring源码剖析</h2><p>首先当然是org.springframework.web.servlet.view.ContentNegotiatingViewResolver类，经过断点跟踪后，发现是通过resolveViewName()来定位的显示View。<br><img src=\"/images/spring-mutiview-5.png\"><br>从图上可以看出，先通过request获取到requestedMediaTypes。</p>\n<h3 id=\"获取请求的视图格式\"><a href=\"#获取请求的视图格式\" class=\"headerlink\" title=\"获取请求的视图格式\"></a>获取请求的视图格式</h3><p><img src=\"/images/spring-mutiview-6.png\"><br>再深入一层查看，发现这里是针对requestedMediaTypes的过滤，而获取请求格式有三个途径，<br>ServletPathExtensionContentNegotiationStrategy（继承自PathExtensionContentNegotiationStrategy），<br>ParameterContentNegotiationStrategy<br>FixedContentNegotiationStrategy<br>而这恰好对应了Spring中针对识别多视图标识的配置</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;property name=&quot;ignoreAcceptHeader&quot; value=&quot;true&quot;/&gt;</span><br><span class=\"line\">&lt;property name=&quot;favorPathExtension&quot; value=&quot;true&quot;/&gt;</span><br><span class=\"line\">&lt;property name=&quot;favorParameter&quot; value=&quot;true&quot;/&gt;</span><br></pre></td></tr></table></figure>\n<p>所以可以得出结论：<br>1、HeaderContentNegotiationStrategy对应ignoreAcceptHeader的配置，此处配置为false,那么ContentNegotiatingViewResolver.contentNegotiationManager属性里则会多出一个元素。通过其源码可以得到它是通过在request header中增加Accept消息头获取视图格式。<br>2、ServletPathExtensionContentNegotiationStrategy（或者PathExtensionContentNegotiationStrategy）对应favorPathExtension的配置。通过请求后缀获取视图格式。<br>3、ParameterContentNegotiationStrategy对应favorParameter的配置，通过在request uri中增加format=?获取视图格式。</p>\n<h3 id=\"按requestdMediaTypes获取到支持的ViewResolver\"><a href=\"#按requestdMediaTypes获取到支持的ViewResolver\" class=\"headerlink\" title=\"按requestdMediaTypes获取到支持的ViewResolver\"></a>按requestdMediaTypes获取到支持的ViewResolver</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List candidateViews = this.getCandidateViews(viewName, locale, requestedMediaTypes);</span><br></pre></td></tr></table></figure>\n<p><img src=\"/images/spring-mutiview-7.png\"><br>这里所做的事，就是将controller处理完成的view名称拿到配置的ViewResolver里去查找（视图名称和加了后缀的视图名称两步搜索），最后再将配置的defaultViews直接加入到返回结果的List中。此处忽略掉了视图格式标识。 </p>\n<h3 id=\"获取匹配度最高的View\"><a href=\"#获取匹配度最高的View\" class=\"headerlink\" title=\"获取匹配度最高的View\"></a>获取匹配度最高的View</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">View bestView = this.getBestView(candidateViews, requestedMediaTypes, attrs);</span><br></pre></td></tr></table></figure>\n<p>此方法所做的事：将包含视图名称的ViewResolver按requestedMediaTypes找到匹配度最高的View。<br>如果没有找到，则按useNotAcceptableStatusCode返回HttpCode 406.或者通过candidateViews的第一个进行视图渲染。__这里的顺序可以通过配置viewResolvers的order属性确定__。</p>\n<h2 id=\"Velocity与Httl视图工具类实例处理方案\"><a href=\"#Velocity与Httl视图工具类实例处理方案\" class=\"headerlink\" title=\"Velocity与Httl视图工具类实例处理方案\"></a>Velocity与Httl视图工具类实例处理方案</h2><p>由于在页面视图中我们需要用到很多的工具类来对Controller返回的数据进行判断以及转换等操作，所以一般来讲我们会在Map存入工具类的实例对象以便能在Page中直接使用。<br>但是当返回的为xml视图时，由于元素数据限制为1个，所以这些工具类将会导致多视图不能返回xml的数据格式。</p>\n<p>在Velocity中可以配置toolbox等工具组件来实现，但是Httl并未支持。所以我找到另一个实现方式。</p>\n<p>经过源码的查看，UrlBasedViewResolver类中包含一个staticAttributes的Map类型属性，这里完全可以拿来存放工具类对象实例，staticAttributes属性的get和set方法名称为：setAttributesMap()和getAttributesMap(). 所以配置的时候要注意配置名为__attributesMap__。<br>而HttlViewResolver与VelocityLayoutViewResolver都间接继承自UrlBasedViewResolver，所以可以通过配置attributesMap属性来实现工具类实例的配置。</p>\n<hr>\n<p><em>观点仅代表自己，期待你的留言。</em></p>\n"},{"title":"SpringBoot（一）","keywords":["springboot"],"date":"2019-01-07T08:44:15.000Z","_content":"\n## 配置演进\n1. spring1.x时代xml配置，优点：取代new实例、ioc、实例对象池化管理\n2. spring2.x时代注解配置，优点：减少配置量\n3. spring3.x时代Java配置，优点：类型安全，可重构\n\n## POM简化\n增加parent module依赖，自动引入默认的jar配置\n```xml\n<parent>\n<groupId>org.springframework.boot</groupId>\n<artifactId>spring-boot-starter-parent</artifactId>\n<version>1.4.4.RELEASE</version>\n</parent>\n```\n\n## 知识点\n一. WEB应用添加spring-boot-starter-web启动器\n```xml\n<dependency>\n<groupId>org.springframework.boot</groupId>\n<artifactId>spring-boot-starter-web</artifactId>\n</dependency>\n```\n二. 更改jdk依赖版本，在properties下增加`java.version`配置jdk版本，如：\n```xml\n<properties>\n  <java.version>1.7</java.version>\n</properties>\n```\n三. spring-boot-devtools实现热部署调试\n```xml\n<dependency>\n<groupId>org.springframework.boot</groupId>\n<artifactId>spring-boot-devtools</artifactId>\n</dependency>\n```\n四. spring-boot-test实现单元测试\n```xml\n<dependency>\n<groupId>org.springframework.boot</groupId>\n<artifactId>spring-boot-test</artifactId>\n<scope>test</scope>\n</dependency>\n```\n```java\n@RunWith(SpringJUnit4ClassRunner.class)\n@SpringBootTest(classes = Application.class)\npublic class TestCls {\n  @Test\n  public void hello() {\n    //....\n  }\n}\n```\n五. 程序读取配置文件\nsrc/main/resources/application.properties\n```properties\ncfg.name=abc\n```\n1) 环境对象实例中获取\n```java\npublic class A {\n  @Resource\n  private org.springframework.core.env.Environment env;\n\n  public void hello() {\n    System.out.println(env.getProperty(\"cfg.name\"));// 输出abc\n  }\n}\n```\n2) Value获取\n```java\npublic class A {\n  @Value(\"${cfg.name}\")\n  private String cfgName;\n\n  public void hello() {\n    System.out.println(cfgName);// 输出abc\n  }\n}\n```\n3) ConfigurationProperties获取\n```java\n@Component\n@ConfigurationProperties(\"cfg\")\n@Setter\npublic class A {\n  private String name;\n}\n```\n六. spring-boot-starter-actuator实现应用运行状态监控\n* 设置`management.endpoint.<id>.enabled=true/false`(id是endpoint的id)来完成一个endpoint的开启和关闭\n* 自定义检测指标：实现HealthIndicator接口或继承AbstractHealthIndicator类\n* 可通过Spring Security或Shiro来保障Actuator Endpoints的安全\n* 设置`management.endpoint.health.show-details=always`则可查看详细的应用健康信息\n\n七、框架接口\n* CommandLineRunner、ApplicationRunner接口在容器启动成功后的Spring框架加载前回调（类似开机自启动），适合初始读取资源或加载通讯证书等\n\n## 打包\n一. 编译生成jar包程序（默认包类型）\n```xml\n<packaging>jar</packaging>\n<build>\n  <plugins>\n    <plugin>\n      <groupId>org.springframework.boot</groupId>\n      <artifactId>spring-boot-maven-plugin</artifactId>\n    </plugin>\n  </plugins>\n</build>\n```\n`输出:` 生成带tomcat-plugin的package.jar，通过java -jar package.jar运行。\n\n二. 编译生成war包程序\n```xml\n<!--1. 更改package类型-->\n<packaging>war</packaging>\n<!--2. 修改tomcat的依赖为provided-->\n<dependencies>\n  <dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-tomcat</artifactId>\n    <scope>provided</scope>\n  </dependency>\n</dependencies>\n<build>\n  <!--3. 设置输出package的名称-->\n  <finalName>package</finalName>\n</build>\n```\n调整启动类:\n```java\n@SpringBootApplication\npublic class ClientApplication extends SpringBootServletInitializer  {\n\tpublic static void main(String[] args) {\n\t\tSpringApplication.run(ClientApplication.class, args);\n\t}\n\t@Override\n\tprotected SpringApplicationBuilder configure(SpringApplicationBuilder builder) {\n\t\treturn builder.sources(getClass());\n\t}\n}\n```\n`输出:` 生成package.war，将war放入到tomcat或其它的支持java运行的服务器中运行。\n\n三. appassembler-maven-plugin生成跨平台启动脚本\n```xml\n<plugin>\n\t<groupId>org.codehaus.mojo</groupId>\n\t<artifactId>appassembler-maven-plugin</artifactId>\n</plugin>\n```\n执行 `mvn package appassembler:assemble`完成脚本的生成\n优点:\n* jar包分散容易管理\n* 编译发布代码速度快\n* 可配置jvm相关启动参数\n* 日志管理\n* shell启动，停止、重启方便\n\n四、docker-maven-plugin生成docker使用包\n__优点:__\n* 减少Dockerfile编写\n* 增强代码一致性\n* 编译部署方便\n* 快速运维。\n__缺点：__\n* 编译后包比较大\n* 无法替换局部jar文件\n\n-----\n\n*观点仅代表自己，期待你的留言。*\n","source":"_posts/springboot-step1.md","raw":"---\ntitle: SpringBoot（一）\ntags:\n  - 原创\nkeywords:\n  - springboot\ndate: 2019-01-07 16:44:15\n---\n\n## 配置演进\n1. spring1.x时代xml配置，优点：取代new实例、ioc、实例对象池化管理\n2. spring2.x时代注解配置，优点：减少配置量\n3. spring3.x时代Java配置，优点：类型安全，可重构\n\n## POM简化\n增加parent module依赖，自动引入默认的jar配置\n```xml\n<parent>\n<groupId>org.springframework.boot</groupId>\n<artifactId>spring-boot-starter-parent</artifactId>\n<version>1.4.4.RELEASE</version>\n</parent>\n```\n\n## 知识点\n一. WEB应用添加spring-boot-starter-web启动器\n```xml\n<dependency>\n<groupId>org.springframework.boot</groupId>\n<artifactId>spring-boot-starter-web</artifactId>\n</dependency>\n```\n二. 更改jdk依赖版本，在properties下增加`java.version`配置jdk版本，如：\n```xml\n<properties>\n  <java.version>1.7</java.version>\n</properties>\n```\n三. spring-boot-devtools实现热部署调试\n```xml\n<dependency>\n<groupId>org.springframework.boot</groupId>\n<artifactId>spring-boot-devtools</artifactId>\n</dependency>\n```\n四. spring-boot-test实现单元测试\n```xml\n<dependency>\n<groupId>org.springframework.boot</groupId>\n<artifactId>spring-boot-test</artifactId>\n<scope>test</scope>\n</dependency>\n```\n```java\n@RunWith(SpringJUnit4ClassRunner.class)\n@SpringBootTest(classes = Application.class)\npublic class TestCls {\n  @Test\n  public void hello() {\n    //....\n  }\n}\n```\n五. 程序读取配置文件\nsrc/main/resources/application.properties\n```properties\ncfg.name=abc\n```\n1) 环境对象实例中获取\n```java\npublic class A {\n  @Resource\n  private org.springframework.core.env.Environment env;\n\n  public void hello() {\n    System.out.println(env.getProperty(\"cfg.name\"));// 输出abc\n  }\n}\n```\n2) Value获取\n```java\npublic class A {\n  @Value(\"${cfg.name}\")\n  private String cfgName;\n\n  public void hello() {\n    System.out.println(cfgName);// 输出abc\n  }\n}\n```\n3) ConfigurationProperties获取\n```java\n@Component\n@ConfigurationProperties(\"cfg\")\n@Setter\npublic class A {\n  private String name;\n}\n```\n六. spring-boot-starter-actuator实现应用运行状态监控\n* 设置`management.endpoint.<id>.enabled=true/false`(id是endpoint的id)来完成一个endpoint的开启和关闭\n* 自定义检测指标：实现HealthIndicator接口或继承AbstractHealthIndicator类\n* 可通过Spring Security或Shiro来保障Actuator Endpoints的安全\n* 设置`management.endpoint.health.show-details=always`则可查看详细的应用健康信息\n\n七、框架接口\n* CommandLineRunner、ApplicationRunner接口在容器启动成功后的Spring框架加载前回调（类似开机自启动），适合初始读取资源或加载通讯证书等\n\n## 打包\n一. 编译生成jar包程序（默认包类型）\n```xml\n<packaging>jar</packaging>\n<build>\n  <plugins>\n    <plugin>\n      <groupId>org.springframework.boot</groupId>\n      <artifactId>spring-boot-maven-plugin</artifactId>\n    </plugin>\n  </plugins>\n</build>\n```\n`输出:` 生成带tomcat-plugin的package.jar，通过java -jar package.jar运行。\n\n二. 编译生成war包程序\n```xml\n<!--1. 更改package类型-->\n<packaging>war</packaging>\n<!--2. 修改tomcat的依赖为provided-->\n<dependencies>\n  <dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-tomcat</artifactId>\n    <scope>provided</scope>\n  </dependency>\n</dependencies>\n<build>\n  <!--3. 设置输出package的名称-->\n  <finalName>package</finalName>\n</build>\n```\n调整启动类:\n```java\n@SpringBootApplication\npublic class ClientApplication extends SpringBootServletInitializer  {\n\tpublic static void main(String[] args) {\n\t\tSpringApplication.run(ClientApplication.class, args);\n\t}\n\t@Override\n\tprotected SpringApplicationBuilder configure(SpringApplicationBuilder builder) {\n\t\treturn builder.sources(getClass());\n\t}\n}\n```\n`输出:` 生成package.war，将war放入到tomcat或其它的支持java运行的服务器中运行。\n\n三. appassembler-maven-plugin生成跨平台启动脚本\n```xml\n<plugin>\n\t<groupId>org.codehaus.mojo</groupId>\n\t<artifactId>appassembler-maven-plugin</artifactId>\n</plugin>\n```\n执行 `mvn package appassembler:assemble`完成脚本的生成\n优点:\n* jar包分散容易管理\n* 编译发布代码速度快\n* 可配置jvm相关启动参数\n* 日志管理\n* shell启动，停止、重启方便\n\n四、docker-maven-plugin生成docker使用包\n__优点:__\n* 减少Dockerfile编写\n* 增强代码一致性\n* 编译部署方便\n* 快速运维。\n__缺点：__\n* 编译后包比较大\n* 无法替换局部jar文件\n\n-----\n\n*观点仅代表自己，期待你的留言。*\n","slug":"springboot-step1","published":1,"updated":"2021-08-31T14:23:11.551Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cku52dype004zbbin57mpesr9","content":"<h2 id=\"配置演进\"><a href=\"#配置演进\" class=\"headerlink\" title=\"配置演进\"></a>配置演进</h2><ol>\n<li>spring1.x时代xml配置，优点：取代new实例、ioc、实例对象池化管理</li>\n<li>spring2.x时代注解配置，优点：减少配置量</li>\n<li>spring3.x时代Java配置，优点：类型安全，可重构</li>\n</ol>\n<h2 id=\"POM简化\"><a href=\"#POM简化\" class=\"headerlink\" title=\"POM简化\"></a>POM简化</h2><p>增加parent module依赖，自动引入默认的jar配置</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">parent</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-boot-starter-parent<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>1.4.4.RELEASE<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">parent</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"知识点\"><a href=\"#知识点\" class=\"headerlink\" title=\"知识点\"></a>知识点</h2><p>一. WEB应用添加spring-boot-starter-web启动器</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-boot-starter-web<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>二. 更改jdk依赖版本，在properties下增加<code>java.version</code>配置jdk版本，如：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">properties</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">java.version</span>&gt;</span>1.7<span class=\"tag\">&lt;/<span class=\"name\">java.version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">properties</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>三. spring-boot-devtools实现热部署调试</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-boot-devtools<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>四. spring-boot-test实现单元测试</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-boot-test<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">scope</span>&gt;</span>test<span class=\"tag\">&lt;/<span class=\"name\">scope</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@RunWith(SpringJUnit4ClassRunner.class)</span></span><br><span class=\"line\"><span class=\"meta\">@SpringBootTest(classes = Application.class)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TestCls</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"meta\">@Test</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">hello</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//....</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>五. 程序读取配置文件<br>src/main/resources/application.properties</p>\n<figure class=\"highlight properties\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">cfg.name</span>=<span class=\"string\">abc</span></span><br></pre></td></tr></table></figure>\n<ol>\n<li>环境对象实例中获取<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"meta\">@Resource</span></span><br><span class=\"line\">  <span class=\"keyword\">private</span> org.springframework.core.env.Environment env;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">hello</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    System.out.println(env.getProperty(<span class=\"string\">&quot;cfg.name&quot;</span>));<span class=\"comment\">// 输出abc</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li>Value获取<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"meta\">@Value(&quot;$&#123;cfg.name&#125;&quot;)</span></span><br><span class=\"line\">  <span class=\"keyword\">private</span> String cfgName;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">hello</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    System.out.println(cfgName);<span class=\"comment\">// 输出abc</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li>ConfigurationProperties获取<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"meta\">@ConfigurationProperties(&quot;cfg&quot;)</span></span><br><span class=\"line\"><span class=\"meta\">@Setter</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> String name;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n六. spring-boot-starter-actuator实现应用运行状态监控</li>\n</ol>\n<ul>\n<li>设置<code>management.endpoint.&lt;id&gt;.enabled=true/false</code>(id是endpoint的id)来完成一个endpoint的开启和关闭</li>\n<li>自定义检测指标：实现HealthIndicator接口或继承AbstractHealthIndicator类</li>\n<li>可通过Spring Security或Shiro来保障Actuator Endpoints的安全</li>\n<li>设置<code>management.endpoint.health.show-details=always</code>则可查看详细的应用健康信息</li>\n</ul>\n<p>七、框架接口</p>\n<ul>\n<li>CommandLineRunner、ApplicationRunner接口在容器启动成功后的Spring框架加载前回调（类似开机自启动），适合初始读取资源或加载通讯证书等</li>\n</ul>\n<h2 id=\"打包\"><a href=\"#打包\" class=\"headerlink\" title=\"打包\"></a>打包</h2><p>一. 编译生成jar包程序（默认包类型）</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">packaging</span>&gt;</span>jar<span class=\"tag\">&lt;/<span class=\"name\">packaging</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">build</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">plugins</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">plugin</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">plugin</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">plugins</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">build</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p><code>输出:</code> 生成带tomcat-plugin的package.jar，通过java -jar package.jar运行。</p>\n<p>二. 编译生成war包程序</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!--1. 更改package类型--&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">packaging</span>&gt;</span>war<span class=\"tag\">&lt;/<span class=\"name\">packaging</span>&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!--2. 修改tomcat的依赖为provided--&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependencies</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-boot-starter-tomcat<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">scope</span>&gt;</span>provided<span class=\"tag\">&lt;/<span class=\"name\">scope</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependencies</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">build</span>&gt;</span></span><br><span class=\"line\">  <span class=\"comment\">&lt;!--3. 设置输出package的名称--&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">finalName</span>&gt;</span>package<span class=\"tag\">&lt;/<span class=\"name\">finalName</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">build</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>调整启动类:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@SpringBootApplication</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ClientApplication</span> <span class=\"keyword\">extends</span> <span class=\"title\">SpringBootServletInitializer</span>  </span>&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">\t\tSpringApplication.run(ClientApplication.class, args);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">protected</span> SpringApplicationBuilder <span class=\"title\">configure</span><span class=\"params\">(SpringApplicationBuilder builder)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> builder.sources(getClass());</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>输出:</code> 生成package.war，将war放入到tomcat或其它的支持java运行的服务器中运行。</p>\n<p>三. appassembler-maven-plugin生成跨平台启动脚本</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">plugin</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.codehaus.mojo<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>appassembler-maven-plugin<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>执行 <code>mvn package appassembler:assemble</code>完成脚本的生成<br>优点:</p>\n<ul>\n<li>jar包分散容易管理</li>\n<li>编译发布代码速度快</li>\n<li>可配置jvm相关启动参数</li>\n<li>日志管理</li>\n<li>shell启动，停止、重启方便</li>\n</ul>\n<p>四、docker-maven-plugin生成docker使用包<br><strong>优点:</strong></p>\n<ul>\n<li>减少Dockerfile编写</li>\n<li>增强代码一致性</li>\n<li>编译部署方便</li>\n<li>快速运维。<br><strong>缺点：</strong></li>\n<li>编译后包比较大</li>\n<li>无法替换局部jar文件</li>\n</ul>\n<hr>\n<p><em>观点仅代表自己，期待你的留言。</em></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"配置演进\"><a href=\"#配置演进\" class=\"headerlink\" title=\"配置演进\"></a>配置演进</h2><ol>\n<li>spring1.x时代xml配置，优点：取代new实例、ioc、实例对象池化管理</li>\n<li>spring2.x时代注解配置，优点：减少配置量</li>\n<li>spring3.x时代Java配置，优点：类型安全，可重构</li>\n</ol>\n<h2 id=\"POM简化\"><a href=\"#POM简化\" class=\"headerlink\" title=\"POM简化\"></a>POM简化</h2><p>增加parent module依赖，自动引入默认的jar配置</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">parent</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-boot-starter-parent<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>1.4.4.RELEASE<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">parent</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"知识点\"><a href=\"#知识点\" class=\"headerlink\" title=\"知识点\"></a>知识点</h2><p>一. WEB应用添加spring-boot-starter-web启动器</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-boot-starter-web<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>二. 更改jdk依赖版本，在properties下增加<code>java.version</code>配置jdk版本，如：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">properties</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">java.version</span>&gt;</span>1.7<span class=\"tag\">&lt;/<span class=\"name\">java.version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">properties</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>三. spring-boot-devtools实现热部署调试</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-boot-devtools<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>四. spring-boot-test实现单元测试</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-boot-test<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">scope</span>&gt;</span>test<span class=\"tag\">&lt;/<span class=\"name\">scope</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@RunWith(SpringJUnit4ClassRunner.class)</span></span><br><span class=\"line\"><span class=\"meta\">@SpringBootTest(classes = Application.class)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TestCls</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"meta\">@Test</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">hello</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//....</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>五. 程序读取配置文件<br>src/main/resources/application.properties</p>\n<figure class=\"highlight properties\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">cfg.name</span>=<span class=\"string\">abc</span></span><br></pre></td></tr></table></figure>\n<ol>\n<li>环境对象实例中获取<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"meta\">@Resource</span></span><br><span class=\"line\">  <span class=\"keyword\">private</span> org.springframework.core.env.Environment env;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">hello</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    System.out.println(env.getProperty(<span class=\"string\">&quot;cfg.name&quot;</span>));<span class=\"comment\">// 输出abc</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li>Value获取<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"meta\">@Value(&quot;$&#123;cfg.name&#125;&quot;)</span></span><br><span class=\"line\">  <span class=\"keyword\">private</span> String cfgName;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">hello</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    System.out.println(cfgName);<span class=\"comment\">// 输出abc</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li>ConfigurationProperties获取<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"meta\">@ConfigurationProperties(&quot;cfg&quot;)</span></span><br><span class=\"line\"><span class=\"meta\">@Setter</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> String name;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n六. spring-boot-starter-actuator实现应用运行状态监控</li>\n</ol>\n<ul>\n<li>设置<code>management.endpoint.&lt;id&gt;.enabled=true/false</code>(id是endpoint的id)来完成一个endpoint的开启和关闭</li>\n<li>自定义检测指标：实现HealthIndicator接口或继承AbstractHealthIndicator类</li>\n<li>可通过Spring Security或Shiro来保障Actuator Endpoints的安全</li>\n<li>设置<code>management.endpoint.health.show-details=always</code>则可查看详细的应用健康信息</li>\n</ul>\n<p>七、框架接口</p>\n<ul>\n<li>CommandLineRunner、ApplicationRunner接口在容器启动成功后的Spring框架加载前回调（类似开机自启动），适合初始读取资源或加载通讯证书等</li>\n</ul>\n<h2 id=\"打包\"><a href=\"#打包\" class=\"headerlink\" title=\"打包\"></a>打包</h2><p>一. 编译生成jar包程序（默认包类型）</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">packaging</span>&gt;</span>jar<span class=\"tag\">&lt;/<span class=\"name\">packaging</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">build</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">plugins</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">plugin</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">plugin</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">plugins</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">build</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p><code>输出:</code> 生成带tomcat-plugin的package.jar，通过java -jar package.jar运行。</p>\n<p>二. 编译生成war包程序</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!--1. 更改package类型--&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">packaging</span>&gt;</span>war<span class=\"tag\">&lt;/<span class=\"name\">packaging</span>&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!--2. 修改tomcat的依赖为provided--&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependencies</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-boot-starter-tomcat<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">scope</span>&gt;</span>provided<span class=\"tag\">&lt;/<span class=\"name\">scope</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependencies</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">build</span>&gt;</span></span><br><span class=\"line\">  <span class=\"comment\">&lt;!--3. 设置输出package的名称--&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">finalName</span>&gt;</span>package<span class=\"tag\">&lt;/<span class=\"name\">finalName</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">build</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>调整启动类:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@SpringBootApplication</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ClientApplication</span> <span class=\"keyword\">extends</span> <span class=\"title\">SpringBootServletInitializer</span>  </span>&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">\t\tSpringApplication.run(ClientApplication.class, args);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">protected</span> SpringApplicationBuilder <span class=\"title\">configure</span><span class=\"params\">(SpringApplicationBuilder builder)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> builder.sources(getClass());</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>输出:</code> 生成package.war，将war放入到tomcat或其它的支持java运行的服务器中运行。</p>\n<p>三. appassembler-maven-plugin生成跨平台启动脚本</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">plugin</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.codehaus.mojo<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>appassembler-maven-plugin<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>执行 <code>mvn package appassembler:assemble</code>完成脚本的生成<br>优点:</p>\n<ul>\n<li>jar包分散容易管理</li>\n<li>编译发布代码速度快</li>\n<li>可配置jvm相关启动参数</li>\n<li>日志管理</li>\n<li>shell启动，停止、重启方便</li>\n</ul>\n<p>四、docker-maven-plugin生成docker使用包<br><strong>优点:</strong></p>\n<ul>\n<li>减少Dockerfile编写</li>\n<li>增强代码一致性</li>\n<li>编译部署方便</li>\n<li>快速运维。<br><strong>缺点：</strong></li>\n<li>编译后包比较大</li>\n<li>无法替换局部jar文件</li>\n</ul>\n<hr>\n<p><em>观点仅代表自己，期待你的留言。</em></p>\n"},{"title":"springcloud各组件目标","keywords":["springcloud","架构"],"date":"2019-01-14T10:42:37.000Z","_content":"\n## 软件架构发展史\n1、单体架构\n部署形式：一个应用、一个DB、一个WebServer\n优点：快速、灵活、技术要求低\n缺点：升级迭代难、业务支撑能力弱、部署扩展性差\n\n2、SOA\n部署形式：多个分布式应用集群部署、统一DB/按业务拆分DB、多个WebServer\n优点：业务模块内部高内聚，业务模块之间低耦合、业务模块目标清晰、模块升级服务独立、针对业务洪峰可通过水平扩展来支撑\n缺点：ESB（企业服务总线）职责过多（职责：统一服务管理、协议转换、消息转换、消息路由服务监控等）\n\n3、微服务（比SOA组件化和服务化更彻底）\n部署形式：多个分布式应用集群部署、多个服务模块DB、多个WebServer\n优点：在SOA优点之上增加开发语言和数据库类型的多样化支持、服务治理职责更为单一\n缺点：事务问题成为必须要解决的问题、系统复杂度增高\n与SOA区别：去掉ESB的大一统职责组件，将大一统职责组件进行拆分，组件职责进一步细化。\n\n## springcloud组件\n\n* `Eureka` 负责服务的注册与发现，很好将各服务连接起来。通过`feign`简化接口调用方式。\n* `Hystrix` 负责监控服务之间的调用情况，连续多次失败进行熔断保护。\n* `Hystrix dashboard+Turbine` 负责监控 Hystrix的熔断情况，并给予图形化的展示\n* `Spring Cloud Config` 提供了统一的配置中心服务\n* 当配置文件发生变化的时候，`Spring Cloud Bus` 负责通知各服务去获取最新的配置信息\n* 所有对外的请求和服务，我们都通过`Spring Cloud Gateway`来进行转发，起到API网关的作用\n* 监控我们使用`Sleuth+Zipkin+springAdmin`将所有的请求数据及路径记录下来\n\n### Eureka（服务中心）\nEureka是Netflix开源的一款提供服务注册和发现的产品。完成服务注册、负载均衡和故障转移的功能。\n依赖spring-cloud-starter-eureka\n同质化产品：Consul、Feature、zookeeper、etcd等\n\n### Feign（HTTP客户端）\nFeign是一个声明式的伪Http客户端，它使得写Http客户端变得更简单。Feign默认集成了Ribbon，并和Eureka结合，默认实现了负载均衡的效果。\n依赖spring-cloud-starter-feign\n\n### Hystrix（服务熔断/故障隔离）\n避免一个服务故障导致调用该服务的其它N个服务等待引起级联故障而造成服务雪崩（服务雪崩效应是一种因“服务提供者”的不可用导致“服务消费者”的不可用,并将不可用逐渐放大的过程。）\n针对故障服务Hystrix会间隔时间进行检查，如果服务恢复将继续提供服务。\n\n### Hystrix-dashboard+Turbine (监控工具)\nHystrix-dashboard是针对Hystrix进行实时监控的管理工具，能展示Hystrix Command的请求响应时间, 请求成功率等数据。添加Turbine工具则能同时展示多个服务信息。\n\n### Spring Cloud Config (配置中心)\n将服务的配置信息服务化，通过Config Client连接到Config Server进行获取，通过手动Refresh可完成在服务的运行期间重新加载配置更新。\n\n### Spring Cloud Bus（广播指令）\nSpring Cloud Bus通过轻量消息代理连接各个分布的服务节点。可通过它广播消息指令到任一服务节点。比如与Spring Cloud Config配合使用自动识别配置变化，可通过该组件通知服务节点自动Refresh完成配置的更新。\n\n### Spring Cloud Gateway (服务网关)\n基于SpringFramework5和SpringBoot2实现了动态路由、HTTP请求的路由匹配、过滤器可以修改下游HTTP请求和HTTP响应等功能。\n同质化产品：Zuul、Linkerd等\n\n### Spring Cloud Sleuth+Zipkin+springAdmin （消息链路跟踪）\n随着服务的越来越多，对调用链的分析会越来越复杂。系统的架构改进需要监控服务和服务之间通讯的各项指标达成情况如（服务间调用关系、调用链、各服务消耗时间等）。Zipkin是Twitter的一个开源项目，允许开发者收集 Twitter 各个服务上的监控数据，并提供查询接口。\n\n-----\n\n*观点仅代表自己，期待你的留言。*\n","source":"_posts/springcloud-step1.md","raw":"---\ntitle: springcloud各组件目标\ntags:\n  - 原创\n  - springcloud\nkeywords:\n  - springcloud\n  - 架构\ndate: 2019-01-14 18:42:37\n---\n\n## 软件架构发展史\n1、单体架构\n部署形式：一个应用、一个DB、一个WebServer\n优点：快速、灵活、技术要求低\n缺点：升级迭代难、业务支撑能力弱、部署扩展性差\n\n2、SOA\n部署形式：多个分布式应用集群部署、统一DB/按业务拆分DB、多个WebServer\n优点：业务模块内部高内聚，业务模块之间低耦合、业务模块目标清晰、模块升级服务独立、针对业务洪峰可通过水平扩展来支撑\n缺点：ESB（企业服务总线）职责过多（职责：统一服务管理、协议转换、消息转换、消息路由服务监控等）\n\n3、微服务（比SOA组件化和服务化更彻底）\n部署形式：多个分布式应用集群部署、多个服务模块DB、多个WebServer\n优点：在SOA优点之上增加开发语言和数据库类型的多样化支持、服务治理职责更为单一\n缺点：事务问题成为必须要解决的问题、系统复杂度增高\n与SOA区别：去掉ESB的大一统职责组件，将大一统职责组件进行拆分，组件职责进一步细化。\n\n## springcloud组件\n\n* `Eureka` 负责服务的注册与发现，很好将各服务连接起来。通过`feign`简化接口调用方式。\n* `Hystrix` 负责监控服务之间的调用情况，连续多次失败进行熔断保护。\n* `Hystrix dashboard+Turbine` 负责监控 Hystrix的熔断情况，并给予图形化的展示\n* `Spring Cloud Config` 提供了统一的配置中心服务\n* 当配置文件发生变化的时候，`Spring Cloud Bus` 负责通知各服务去获取最新的配置信息\n* 所有对外的请求和服务，我们都通过`Spring Cloud Gateway`来进行转发，起到API网关的作用\n* 监控我们使用`Sleuth+Zipkin+springAdmin`将所有的请求数据及路径记录下来\n\n### Eureka（服务中心）\nEureka是Netflix开源的一款提供服务注册和发现的产品。完成服务注册、负载均衡和故障转移的功能。\n依赖spring-cloud-starter-eureka\n同质化产品：Consul、Feature、zookeeper、etcd等\n\n### Feign（HTTP客户端）\nFeign是一个声明式的伪Http客户端，它使得写Http客户端变得更简单。Feign默认集成了Ribbon，并和Eureka结合，默认实现了负载均衡的效果。\n依赖spring-cloud-starter-feign\n\n### Hystrix（服务熔断/故障隔离）\n避免一个服务故障导致调用该服务的其它N个服务等待引起级联故障而造成服务雪崩（服务雪崩效应是一种因“服务提供者”的不可用导致“服务消费者”的不可用,并将不可用逐渐放大的过程。）\n针对故障服务Hystrix会间隔时间进行检查，如果服务恢复将继续提供服务。\n\n### Hystrix-dashboard+Turbine (监控工具)\nHystrix-dashboard是针对Hystrix进行实时监控的管理工具，能展示Hystrix Command的请求响应时间, 请求成功率等数据。添加Turbine工具则能同时展示多个服务信息。\n\n### Spring Cloud Config (配置中心)\n将服务的配置信息服务化，通过Config Client连接到Config Server进行获取，通过手动Refresh可完成在服务的运行期间重新加载配置更新。\n\n### Spring Cloud Bus（广播指令）\nSpring Cloud Bus通过轻量消息代理连接各个分布的服务节点。可通过它广播消息指令到任一服务节点。比如与Spring Cloud Config配合使用自动识别配置变化，可通过该组件通知服务节点自动Refresh完成配置的更新。\n\n### Spring Cloud Gateway (服务网关)\n基于SpringFramework5和SpringBoot2实现了动态路由、HTTP请求的路由匹配、过滤器可以修改下游HTTP请求和HTTP响应等功能。\n同质化产品：Zuul、Linkerd等\n\n### Spring Cloud Sleuth+Zipkin+springAdmin （消息链路跟踪）\n随着服务的越来越多，对调用链的分析会越来越复杂。系统的架构改进需要监控服务和服务之间通讯的各项指标达成情况如（服务间调用关系、调用链、各服务消耗时间等）。Zipkin是Twitter的一个开源项目，允许开发者收集 Twitter 各个服务上的监控数据，并提供查询接口。\n\n-----\n\n*观点仅代表自己，期待你的留言。*\n","slug":"springcloud-step1","published":1,"updated":"2021-08-31T14:23:11.551Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cku52dypj0051bbin8j3a72t6","content":"<h2 id=\"软件架构发展史\"><a href=\"#软件架构发展史\" class=\"headerlink\" title=\"软件架构发展史\"></a>软件架构发展史</h2><p>1、单体架构<br>部署形式：一个应用、一个DB、一个WebServer<br>优点：快速、灵活、技术要求低<br>缺点：升级迭代难、业务支撑能力弱、部署扩展性差</p>\n<p>2、SOA<br>部署形式：多个分布式应用集群部署、统一DB/按业务拆分DB、多个WebServer<br>优点：业务模块内部高内聚，业务模块之间低耦合、业务模块目标清晰、模块升级服务独立、针对业务洪峰可通过水平扩展来支撑<br>缺点：ESB（企业服务总线）职责过多（职责：统一服务管理、协议转换、消息转换、消息路由服务监控等）</p>\n<p>3、微服务（比SOA组件化和服务化更彻底）<br>部署形式：多个分布式应用集群部署、多个服务模块DB、多个WebServer<br>优点：在SOA优点之上增加开发语言和数据库类型的多样化支持、服务治理职责更为单一<br>缺点：事务问题成为必须要解决的问题、系统复杂度增高<br>与SOA区别：去掉ESB的大一统职责组件，将大一统职责组件进行拆分，组件职责进一步细化。</p>\n<h2 id=\"springcloud组件\"><a href=\"#springcloud组件\" class=\"headerlink\" title=\"springcloud组件\"></a>springcloud组件</h2><ul>\n<li><code>Eureka</code> 负责服务的注册与发现，很好将各服务连接起来。通过<code>feign</code>简化接口调用方式。</li>\n<li><code>Hystrix</code> 负责监控服务之间的调用情况，连续多次失败进行熔断保护。</li>\n<li><code>Hystrix dashboard+Turbine</code> 负责监控 Hystrix的熔断情况，并给予图形化的展示</li>\n<li><code>Spring Cloud Config</code> 提供了统一的配置中心服务</li>\n<li>当配置文件发生变化的时候，<code>Spring Cloud Bus</code> 负责通知各服务去获取最新的配置信息</li>\n<li>所有对外的请求和服务，我们都通过<code>Spring Cloud Gateway</code>来进行转发，起到API网关的作用</li>\n<li>监控我们使用<code>Sleuth+Zipkin+springAdmin</code>将所有的请求数据及路径记录下来</li>\n</ul>\n<h3 id=\"Eureka（服务中心）\"><a href=\"#Eureka（服务中心）\" class=\"headerlink\" title=\"Eureka（服务中心）\"></a>Eureka（服务中心）</h3><p>Eureka是Netflix开源的一款提供服务注册和发现的产品。完成服务注册、负载均衡和故障转移的功能。<br>依赖spring-cloud-starter-eureka<br>同质化产品：Consul、Feature、zookeeper、etcd等</p>\n<h3 id=\"Feign（HTTP客户端）\"><a href=\"#Feign（HTTP客户端）\" class=\"headerlink\" title=\"Feign（HTTP客户端）\"></a>Feign（HTTP客户端）</h3><p>Feign是一个声明式的伪Http客户端，它使得写Http客户端变得更简单。Feign默认集成了Ribbon，并和Eureka结合，默认实现了负载均衡的效果。<br>依赖spring-cloud-starter-feign</p>\n<h3 id=\"Hystrix（服务熔断-故障隔离）\"><a href=\"#Hystrix（服务熔断-故障隔离）\" class=\"headerlink\" title=\"Hystrix（服务熔断/故障隔离）\"></a>Hystrix（服务熔断/故障隔离）</h3><p>避免一个服务故障导致调用该服务的其它N个服务等待引起级联故障而造成服务雪崩（服务雪崩效应是一种因“服务提供者”的不可用导致“服务消费者”的不可用,并将不可用逐渐放大的过程。）<br>针对故障服务Hystrix会间隔时间进行检查，如果服务恢复将继续提供服务。</p>\n<h3 id=\"Hystrix-dashboard-Turbine-监控工具\"><a href=\"#Hystrix-dashboard-Turbine-监控工具\" class=\"headerlink\" title=\"Hystrix-dashboard+Turbine (监控工具)\"></a>Hystrix-dashboard+Turbine (监控工具)</h3><p>Hystrix-dashboard是针对Hystrix进行实时监控的管理工具，能展示Hystrix Command的请求响应时间, 请求成功率等数据。添加Turbine工具则能同时展示多个服务信息。</p>\n<h3 id=\"Spring-Cloud-Config-配置中心\"><a href=\"#Spring-Cloud-Config-配置中心\" class=\"headerlink\" title=\"Spring Cloud Config (配置中心)\"></a>Spring Cloud Config (配置中心)</h3><p>将服务的配置信息服务化，通过Config Client连接到Config Server进行获取，通过手动Refresh可完成在服务的运行期间重新加载配置更新。</p>\n<h3 id=\"Spring-Cloud-Bus（广播指令）\"><a href=\"#Spring-Cloud-Bus（广播指令）\" class=\"headerlink\" title=\"Spring Cloud Bus（广播指令）\"></a>Spring Cloud Bus（广播指令）</h3><p>Spring Cloud Bus通过轻量消息代理连接各个分布的服务节点。可通过它广播消息指令到任一服务节点。比如与Spring Cloud Config配合使用自动识别配置变化，可通过该组件通知服务节点自动Refresh完成配置的更新。</p>\n<h3 id=\"Spring-Cloud-Gateway-服务网关\"><a href=\"#Spring-Cloud-Gateway-服务网关\" class=\"headerlink\" title=\"Spring Cloud Gateway (服务网关)\"></a>Spring Cloud Gateway (服务网关)</h3><p>基于SpringFramework5和SpringBoot2实现了动态路由、HTTP请求的路由匹配、过滤器可以修改下游HTTP请求和HTTP响应等功能。<br>同质化产品：Zuul、Linkerd等</p>\n<h3 id=\"Spring-Cloud-Sleuth-Zipkin-springAdmin-（消息链路跟踪）\"><a href=\"#Spring-Cloud-Sleuth-Zipkin-springAdmin-（消息链路跟踪）\" class=\"headerlink\" title=\"Spring Cloud Sleuth+Zipkin+springAdmin （消息链路跟踪）\"></a>Spring Cloud Sleuth+Zipkin+springAdmin （消息链路跟踪）</h3><p>随着服务的越来越多，对调用链的分析会越来越复杂。系统的架构改进需要监控服务和服务之间通讯的各项指标达成情况如（服务间调用关系、调用链、各服务消耗时间等）。Zipkin是Twitter的一个开源项目，允许开发者收集 Twitter 各个服务上的监控数据，并提供查询接口。</p>\n<hr>\n<p><em>观点仅代表自己，期待你的留言。</em></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"软件架构发展史\"><a href=\"#软件架构发展史\" class=\"headerlink\" title=\"软件架构发展史\"></a>软件架构发展史</h2><p>1、单体架构<br>部署形式：一个应用、一个DB、一个WebServer<br>优点：快速、灵活、技术要求低<br>缺点：升级迭代难、业务支撑能力弱、部署扩展性差</p>\n<p>2、SOA<br>部署形式：多个分布式应用集群部署、统一DB/按业务拆分DB、多个WebServer<br>优点：业务模块内部高内聚，业务模块之间低耦合、业务模块目标清晰、模块升级服务独立、针对业务洪峰可通过水平扩展来支撑<br>缺点：ESB（企业服务总线）职责过多（职责：统一服务管理、协议转换、消息转换、消息路由服务监控等）</p>\n<p>3、微服务（比SOA组件化和服务化更彻底）<br>部署形式：多个分布式应用集群部署、多个服务模块DB、多个WebServer<br>优点：在SOA优点之上增加开发语言和数据库类型的多样化支持、服务治理职责更为单一<br>缺点：事务问题成为必须要解决的问题、系统复杂度增高<br>与SOA区别：去掉ESB的大一统职责组件，将大一统职责组件进行拆分，组件职责进一步细化。</p>\n<h2 id=\"springcloud组件\"><a href=\"#springcloud组件\" class=\"headerlink\" title=\"springcloud组件\"></a>springcloud组件</h2><ul>\n<li><code>Eureka</code> 负责服务的注册与发现，很好将各服务连接起来。通过<code>feign</code>简化接口调用方式。</li>\n<li><code>Hystrix</code> 负责监控服务之间的调用情况，连续多次失败进行熔断保护。</li>\n<li><code>Hystrix dashboard+Turbine</code> 负责监控 Hystrix的熔断情况，并给予图形化的展示</li>\n<li><code>Spring Cloud Config</code> 提供了统一的配置中心服务</li>\n<li>当配置文件发生变化的时候，<code>Spring Cloud Bus</code> 负责通知各服务去获取最新的配置信息</li>\n<li>所有对外的请求和服务，我们都通过<code>Spring Cloud Gateway</code>来进行转发，起到API网关的作用</li>\n<li>监控我们使用<code>Sleuth+Zipkin+springAdmin</code>将所有的请求数据及路径记录下来</li>\n</ul>\n<h3 id=\"Eureka（服务中心）\"><a href=\"#Eureka（服务中心）\" class=\"headerlink\" title=\"Eureka（服务中心）\"></a>Eureka（服务中心）</h3><p>Eureka是Netflix开源的一款提供服务注册和发现的产品。完成服务注册、负载均衡和故障转移的功能。<br>依赖spring-cloud-starter-eureka<br>同质化产品：Consul、Feature、zookeeper、etcd等</p>\n<h3 id=\"Feign（HTTP客户端）\"><a href=\"#Feign（HTTP客户端）\" class=\"headerlink\" title=\"Feign（HTTP客户端）\"></a>Feign（HTTP客户端）</h3><p>Feign是一个声明式的伪Http客户端，它使得写Http客户端变得更简单。Feign默认集成了Ribbon，并和Eureka结合，默认实现了负载均衡的效果。<br>依赖spring-cloud-starter-feign</p>\n<h3 id=\"Hystrix（服务熔断-故障隔离）\"><a href=\"#Hystrix（服务熔断-故障隔离）\" class=\"headerlink\" title=\"Hystrix（服务熔断/故障隔离）\"></a>Hystrix（服务熔断/故障隔离）</h3><p>避免一个服务故障导致调用该服务的其它N个服务等待引起级联故障而造成服务雪崩（服务雪崩效应是一种因“服务提供者”的不可用导致“服务消费者”的不可用,并将不可用逐渐放大的过程。）<br>针对故障服务Hystrix会间隔时间进行检查，如果服务恢复将继续提供服务。</p>\n<h3 id=\"Hystrix-dashboard-Turbine-监控工具\"><a href=\"#Hystrix-dashboard-Turbine-监控工具\" class=\"headerlink\" title=\"Hystrix-dashboard+Turbine (监控工具)\"></a>Hystrix-dashboard+Turbine (监控工具)</h3><p>Hystrix-dashboard是针对Hystrix进行实时监控的管理工具，能展示Hystrix Command的请求响应时间, 请求成功率等数据。添加Turbine工具则能同时展示多个服务信息。</p>\n<h3 id=\"Spring-Cloud-Config-配置中心\"><a href=\"#Spring-Cloud-Config-配置中心\" class=\"headerlink\" title=\"Spring Cloud Config (配置中心)\"></a>Spring Cloud Config (配置中心)</h3><p>将服务的配置信息服务化，通过Config Client连接到Config Server进行获取，通过手动Refresh可完成在服务的运行期间重新加载配置更新。</p>\n<h3 id=\"Spring-Cloud-Bus（广播指令）\"><a href=\"#Spring-Cloud-Bus（广播指令）\" class=\"headerlink\" title=\"Spring Cloud Bus（广播指令）\"></a>Spring Cloud Bus（广播指令）</h3><p>Spring Cloud Bus通过轻量消息代理连接各个分布的服务节点。可通过它广播消息指令到任一服务节点。比如与Spring Cloud Config配合使用自动识别配置变化，可通过该组件通知服务节点自动Refresh完成配置的更新。</p>\n<h3 id=\"Spring-Cloud-Gateway-服务网关\"><a href=\"#Spring-Cloud-Gateway-服务网关\" class=\"headerlink\" title=\"Spring Cloud Gateway (服务网关)\"></a>Spring Cloud Gateway (服务网关)</h3><p>基于SpringFramework5和SpringBoot2实现了动态路由、HTTP请求的路由匹配、过滤器可以修改下游HTTP请求和HTTP响应等功能。<br>同质化产品：Zuul、Linkerd等</p>\n<h3 id=\"Spring-Cloud-Sleuth-Zipkin-springAdmin-（消息链路跟踪）\"><a href=\"#Spring-Cloud-Sleuth-Zipkin-springAdmin-（消息链路跟踪）\" class=\"headerlink\" title=\"Spring Cloud Sleuth+Zipkin+springAdmin （消息链路跟踪）\"></a>Spring Cloud Sleuth+Zipkin+springAdmin （消息链路跟踪）</h3><p>随着服务的越来越多，对调用链的分析会越来越复杂。系统的架构改进需要监控服务和服务之间通讯的各项指标达成情况如（服务间调用关系、调用链、各服务消耗时间等）。Zipkin是Twitter的一个开源项目，允许开发者收集 Twitter 各个服务上的监控数据，并提供查询接口。</p>\n<hr>\n<p><em>观点仅代表自己，期待你的留言。</em></p>\n"},{"title":"博客站开写啦","date":"2016-03-10T08:46:19.000Z","_content":"经过两天的努力总算搭建一个属于自己的博客站，不得不感叹自己真的是太懒了，原本很早以前就想做的事情偏偏等到现在才来完成，懒！懒！懒！\n\n为了让自己形成坚持记录的习惯，理清工作中千丝万缕的思路，让瞬间的“天马行空”留下痕迹。\n\n我决定以后坚持写博客，并开通评论功能接收各位朋友的褒贬建议。\n\n不积跬步，无以至千里；不积小流，无以成江海。坚持写作，观点仅代表自己，加油！！！\n","source":"_posts/started.md","raw":"---\ntitle: 博客站开写啦\ntags:\n  - 随笔\ndate: 2016-03-10 16:46:19\n---\n经过两天的努力总算搭建一个属于自己的博客站，不得不感叹自己真的是太懒了，原本很早以前就想做的事情偏偏等到现在才来完成，懒！懒！懒！\n\n为了让自己形成坚持记录的习惯，理清工作中千丝万缕的思路，让瞬间的“天马行空”留下痕迹。\n\n我决定以后坚持写博客，并开通评论功能接收各位朋友的褒贬建议。\n\n不积跬步，无以至千里；不积小流，无以成江海。坚持写作，观点仅代表自己，加油！！！\n","slug":"started","published":1,"updated":"2021-08-31T14:23:11.552Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cku52dypk0054bbinfzfja2te","content":"<p>经过两天的努力总算搭建一个属于自己的博客站，不得不感叹自己真的是太懒了，原本很早以前就想做的事情偏偏等到现在才来完成，懒！懒！懒！</p>\n<p>为了让自己形成坚持记录的习惯，理清工作中千丝万缕的思路，让瞬间的“天马行空”留下痕迹。</p>\n<p>我决定以后坚持写博客，并开通评论功能接收各位朋友的褒贬建议。</p>\n<p>不积跬步，无以至千里；不积小流，无以成江海。坚持写作，观点仅代表自己，加油！！！</p>\n","site":{"data":{}},"excerpt":"","more":"<p>经过两天的努力总算搭建一个属于自己的博客站，不得不感叹自己真的是太懒了，原本很早以前就想做的事情偏偏等到现在才来完成，懒！懒！懒！</p>\n<p>为了让自己形成坚持记录的习惯，理清工作中千丝万缕的思路，让瞬间的“天马行空”留下痕迹。</p>\n<p>我决定以后坚持写博客，并开通评论功能接收各位朋友的褒贬建议。</p>\n<p>不积跬步，无以至千里；不积小流，无以成江海。坚持写作，观点仅代表自己，加油！！！</p>\n"},{"title":"多标识位存储优化方案","date":"2017-08-24T11:08:28.000Z","_content":"\n## 背景\n在做程序开发的过程中常常会遇到数据的标识位（取值为\"是\"与\"否\"）需要进行存储，\n如神马专车系统消息中心中的一个场景：新建一个消息需要勾选发送对象，可选的对象有：司机，下单人，乘车人。\n最常见的Mysql存储方式为一个消息表中包含三个字段sendDriver,sendUser,sendPassenger\n按用户新建消息所勾选的情况，依次存储到数据表中并在后续的业务中直接获取值进行对比。\n\n## 优化方案\n利用\"与或非\"的运算可将这多个标识符存储到一个字段中。\n实例如下：\n按业务这里有三个标识符需要存储，因此可以定义一个长度为3的二进行序列：000，从左至右第一位表示司机，第二位表示下单人，第三位表示乘车人。\n那么，如果只需要发送给司机则可标识为100的二进行序列，如果下单人也需要通知，则可标识为110的二进行序列，依次，如果都需要通知则为111的二进制序列。\n存储的值则为二进行制序列对应的十进制即可，当需要判断时，则可采用\"与\"运算符进行判定。\n\n示例Java代码如下：\n```java\npublic static final byte NOTIFY_PASSENGER = 0B001; //二进制为001\npublic static final byte NOTIFY_SUBSCRIBER = 0B010; //二进制为010\npublic static final byte NOTIFY_DRIVER = 0B100; //二进制为100\n\n/**\n * 获取需要存储的值则为notifyFlag\n */\npublic byte getStoreValue() {\n  byte notifyFlag = 0B000; //二进制为000\n  if (request.isNotifyDriver()) {\n      notifyFlag |= NOTIFY_DRIVER;\n  }\n  if (request.isNotifyPassenger()) {\n      notifyFlag |= NOTIFY_PASSENGER;\n  }\n  if (request.isNotifySubscriber()) {\n    notifyFlag |= NOTIFY_SUBSCRIBER;\n  }\n  return notifyFlag;\n}\n\n/**\n * 判断是否需要通知\n * @param notifyTarget 预计需要通知的目标\n * @return true-需要通知，false-不需要通知\n */\npublic boolean isNotify(byte notifyTarget) {\n  byte notifyFlag = 0B111;//二进制为111 , 从数据库取出\n  return notifyFlag & notifyTarget == notifyTarget;\n}\n```\n\n在Java中byte的最大值为：127，二进行为0B1111111, 足够标识七个标识位!\n\n-----\n\n*观点仅代表自己，期待你的留言。*\n","source":"_posts/store-flag-bit.md","raw":"---\ntitle: 多标识位存储优化方案\ntags:\n  - 原创\ndate: 2017-08-24 19:08:28\n---\n\n## 背景\n在做程序开发的过程中常常会遇到数据的标识位（取值为\"是\"与\"否\"）需要进行存储，\n如神马专车系统消息中心中的一个场景：新建一个消息需要勾选发送对象，可选的对象有：司机，下单人，乘车人。\n最常见的Mysql存储方式为一个消息表中包含三个字段sendDriver,sendUser,sendPassenger\n按用户新建消息所勾选的情况，依次存储到数据表中并在后续的业务中直接获取值进行对比。\n\n## 优化方案\n利用\"与或非\"的运算可将这多个标识符存储到一个字段中。\n实例如下：\n按业务这里有三个标识符需要存储，因此可以定义一个长度为3的二进行序列：000，从左至右第一位表示司机，第二位表示下单人，第三位表示乘车人。\n那么，如果只需要发送给司机则可标识为100的二进行序列，如果下单人也需要通知，则可标识为110的二进行序列，依次，如果都需要通知则为111的二进制序列。\n存储的值则为二进行制序列对应的十进制即可，当需要判断时，则可采用\"与\"运算符进行判定。\n\n示例Java代码如下：\n```java\npublic static final byte NOTIFY_PASSENGER = 0B001; //二进制为001\npublic static final byte NOTIFY_SUBSCRIBER = 0B010; //二进制为010\npublic static final byte NOTIFY_DRIVER = 0B100; //二进制为100\n\n/**\n * 获取需要存储的值则为notifyFlag\n */\npublic byte getStoreValue() {\n  byte notifyFlag = 0B000; //二进制为000\n  if (request.isNotifyDriver()) {\n      notifyFlag |= NOTIFY_DRIVER;\n  }\n  if (request.isNotifyPassenger()) {\n      notifyFlag |= NOTIFY_PASSENGER;\n  }\n  if (request.isNotifySubscriber()) {\n    notifyFlag |= NOTIFY_SUBSCRIBER;\n  }\n  return notifyFlag;\n}\n\n/**\n * 判断是否需要通知\n * @param notifyTarget 预计需要通知的目标\n * @return true-需要通知，false-不需要通知\n */\npublic boolean isNotify(byte notifyTarget) {\n  byte notifyFlag = 0B111;//二进制为111 , 从数据库取出\n  return notifyFlag & notifyTarget == notifyTarget;\n}\n```\n\n在Java中byte的最大值为：127，二进行为0B1111111, 足够标识七个标识位!\n\n-----\n\n*观点仅代表自己，期待你的留言。*\n","slug":"store-flag-bit","published":1,"updated":"2021-08-31T14:23:11.552Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cku52dypl0056bbing4hg6av5","content":"<h2 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h2><p>在做程序开发的过程中常常会遇到数据的标识位（取值为”是”与”否”）需要进行存储，<br>如神马专车系统消息中心中的一个场景：新建一个消息需要勾选发送对象，可选的对象有：司机，下单人，乘车人。<br>最常见的Mysql存储方式为一个消息表中包含三个字段sendDriver,sendUser,sendPassenger<br>按用户新建消息所勾选的情况，依次存储到数据表中并在后续的业务中直接获取值进行对比。</p>\n<h2 id=\"优化方案\"><a href=\"#优化方案\" class=\"headerlink\" title=\"优化方案\"></a>优化方案</h2><p>利用”与或非”的运算可将这多个标识符存储到一个字段中。<br>实例如下：<br>按业务这里有三个标识符需要存储，因此可以定义一个长度为3的二进行序列：000，从左至右第一位表示司机，第二位表示下单人，第三位表示乘车人。<br>那么，如果只需要发送给司机则可标识为100的二进行序列，如果下单人也需要通知，则可标识为110的二进行序列，依次，如果都需要通知则为111的二进制序列。<br>存储的值则为二进行制序列对应的十进制即可，当需要判断时，则可采用”与”运算符进行判定。</p>\n<p>示例Java代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">byte</span> NOTIFY_PASSENGER = <span class=\"number\">0B001</span>; <span class=\"comment\">//二进制为001</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">byte</span> NOTIFY_SUBSCRIBER = <span class=\"number\">0B010</span>; <span class=\"comment\">//二进制为010</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">byte</span> NOTIFY_DRIVER = <span class=\"number\">0B100</span>; <span class=\"comment\">//二进制为100</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 获取需要存储的值则为notifyFlag</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">byte</span> <span class=\"title\">getStoreValue</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">byte</span> notifyFlag = <span class=\"number\">0B000</span>; <span class=\"comment\">//二进制为000</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (request.isNotifyDriver()) &#123;</span><br><span class=\"line\">      notifyFlag |= NOTIFY_DRIVER;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (request.isNotifyPassenger()) &#123;</span><br><span class=\"line\">      notifyFlag |= NOTIFY_PASSENGER;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (request.isNotifySubscriber()) &#123;</span><br><span class=\"line\">    notifyFlag |= NOTIFY_SUBSCRIBER;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> notifyFlag;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 判断是否需要通知</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> notifyTarget 预计需要通知的目标</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return</span> true-需要通知，false-不需要通知</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isNotify</span><span class=\"params\">(<span class=\"keyword\">byte</span> notifyTarget)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">byte</span> notifyFlag = <span class=\"number\">0B111</span>;<span class=\"comment\">//二进制为111 , 从数据库取出</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> notifyFlag &amp; notifyTarget == notifyTarget;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在Java中byte的最大值为：127，二进行为0B1111111, 足够标识七个标识位!</p>\n<hr>\n<p><em>观点仅代表自己，期待你的留言。</em></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h2><p>在做程序开发的过程中常常会遇到数据的标识位（取值为”是”与”否”）需要进行存储，<br>如神马专车系统消息中心中的一个场景：新建一个消息需要勾选发送对象，可选的对象有：司机，下单人，乘车人。<br>最常见的Mysql存储方式为一个消息表中包含三个字段sendDriver,sendUser,sendPassenger<br>按用户新建消息所勾选的情况，依次存储到数据表中并在后续的业务中直接获取值进行对比。</p>\n<h2 id=\"优化方案\"><a href=\"#优化方案\" class=\"headerlink\" title=\"优化方案\"></a>优化方案</h2><p>利用”与或非”的运算可将这多个标识符存储到一个字段中。<br>实例如下：<br>按业务这里有三个标识符需要存储，因此可以定义一个长度为3的二进行序列：000，从左至右第一位表示司机，第二位表示下单人，第三位表示乘车人。<br>那么，如果只需要发送给司机则可标识为100的二进行序列，如果下单人也需要通知，则可标识为110的二进行序列，依次，如果都需要通知则为111的二进制序列。<br>存储的值则为二进行制序列对应的十进制即可，当需要判断时，则可采用”与”运算符进行判定。</p>\n<p>示例Java代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">byte</span> NOTIFY_PASSENGER = <span class=\"number\">0B001</span>; <span class=\"comment\">//二进制为001</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">byte</span> NOTIFY_SUBSCRIBER = <span class=\"number\">0B010</span>; <span class=\"comment\">//二进制为010</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">byte</span> NOTIFY_DRIVER = <span class=\"number\">0B100</span>; <span class=\"comment\">//二进制为100</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 获取需要存储的值则为notifyFlag</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">byte</span> <span class=\"title\">getStoreValue</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">byte</span> notifyFlag = <span class=\"number\">0B000</span>; <span class=\"comment\">//二进制为000</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (request.isNotifyDriver()) &#123;</span><br><span class=\"line\">      notifyFlag |= NOTIFY_DRIVER;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (request.isNotifyPassenger()) &#123;</span><br><span class=\"line\">      notifyFlag |= NOTIFY_PASSENGER;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (request.isNotifySubscriber()) &#123;</span><br><span class=\"line\">    notifyFlag |= NOTIFY_SUBSCRIBER;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> notifyFlag;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 判断是否需要通知</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> notifyTarget 预计需要通知的目标</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return</span> true-需要通知，false-不需要通知</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isNotify</span><span class=\"params\">(<span class=\"keyword\">byte</span> notifyTarget)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">byte</span> notifyFlag = <span class=\"number\">0B111</span>;<span class=\"comment\">//二进制为111 , 从数据库取出</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> notifyFlag &amp; notifyTarget == notifyTarget;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在Java中byte的最大值为：127，二进行为0B1111111, 足够标识七个标识位!</p>\n<hr>\n<p><em>观点仅代表自己，期待你的留言。</em></p>\n"},{"title":"String.format详解","date":"2016-04-13T08:02:59.000Z","_content":"\nString类的format()方法用于创建格式化的字符串以及连接多个字符串对象。熟悉C语言的同学应该记得C语言的sprintf()方法，两者有类似之处。format()方法有两种重载形式。\nformat(String format, Object... args) 新字符串使用本地语言环境，制定字符串格式和参数生成格式化的新字符串。\n\nformat(Locale locale, String format, Object... args) 使用指定的语言环境，制定字符串格式和参数生成格式化的字符串。\n\n## 常规类型的格式化\n\n|转换符|说明|示例\n|:-|:- |:-\n|%s\t\t\t|字符串类型\t\t\t\t\t|\"mingrisoft\"\t\t\t\n|%c\t\t\t|字符类型\t\t\t\t\t\t|'m'\t\t\t\n|%b\t\t\t|布尔类型\t\t\t\t\t\t|true\t\t\t\n|%d\t\t\t|整数类型（十进制）\t\t\t|99\t\t\t\n|%x\t\t\t|整数类型（十六进制）\t\t\t|FF\t\t\t\n|%o\t\t\t|整数类型（八进制）\t\t\t|77\t\t\t\n|%f\t\t\t|浮点类型\t\t\t\t\t\t|99.99\t\t\t\n|%a\t\t\t|十六进制浮点类型\t\t\t\t|FF.35AE\t\t\t\n|%e\t\t\t|指数类型\t\t\t\t\t\t|9.38e+5\t\t\t\n|%g\t\t\t|通用浮点类型（f和e类型中较短的）\t\t\t \n|%h\t\t\t|散列码\t\t\t \n|%%\t\t\t|百分比类型\t\t\t\t\t|％\t\t\t\n|%n\t\t\t|换行符\t\t\t \n|%tx\t\t|日期与时间类型（x代表不同的日期与时间转换符）\n\n测试代码：\n```\npublic static void main(String[] args) {  \n    String str=null;  \n    str=String.format(\"Hi,%s\", \"王力\");  \n    System.out.println(str);  \n    str=String.format(\"Hi,%s:%s.%s\", \"王南\",\"王力\",\"王张\");            \n    System.out.println(str);                           \n    System.out.printf(\"字母a的大写是：%c %n\", 'A');  \n    System.out.printf(\"3>7的结果是：%b %n\", 3>7);  \n    System.out.printf(\"100的一半是：%d %n\", 100/2);  \n    System.out.printf(\"100的16进制数是：%x %n\", 100);  \n    System.out.printf(\"100的8进制数是：%o %n\", 100);  \n    System.out.printf(\"50元的书打8.5折扣是：%f 元%n\", 50*0.85);  \n    System.out.printf(\"上面价格的16进制数是：%a %n\", 50*0.85);  \n    System.out.printf(\"上面价格的指数表示：%e %n\", 50*0.85);  \n    System.out.printf(\"上面价格的指数和浮点数结果的长度较短的是：%g %n\", 50*0.85);  \n    System.out.printf(\"上面的折扣是%d%% %n\", 85);  \n    System.out.printf(\"字母A的散列码是：%h %n\", 'A');  \n}  \n```\n输出结果:\n```\nHi,王力  \nHi,王南:王力.王张  \n字母a的大写是：A   \n3>7的结果是：false   \n100的一半是：50   \n100的16进制数是：64   \n100的8进制数是：144   \n50元的书打8.5折扣是：42.500000 元  \n上面价格的16进制数是：0x1.54p5   \n上面价格的指数表示：4.250000e+01   \n上面价格的指数和浮点数结果的长度较短的是：42.5000   \n上面的折扣是85%   \n字母A的散列码是：41  \n```\n搭配转换符的标志，如图所示:\n\n|标志|说明|示例|结果\n|:-|:- |:- |:-\n|+|为正数或者负数添加符号|(\"%+d\",15)|+15\n|−|左对齐|(\"%-5d\",15)|15   |\n|0|数字前面补0|(\"%04d\", 99)|0099\n|空格|在整数之前添加指定数量的空格|(\"% 4d\", 99)|  99\n|,|以“,”对数字分组|(\"%,f\", 9999.99)|9,999.990000\n|(|使用括号包含负数|(\"%(f\", -99.99)|(99.990000)\n|#|如果是浮点数则包含小数点，如果是16进制或8进制则添加0x或0|(\"%#x\", 99)|0x63\n|||(\"%#o\", 99)|0143\n|< |格式化前一个转换符所描述的参数|(\"%f和%<3.2f\", 99.45)|99.450000和99.45\n|$|被格式化的参数索引|(\"%1$d,%2$s\", 99,\"abc\")|99,abc\n测试代码：\n```\npublic static void main(String[] args) {  \n    String str=null;  \n    //$使用  \n    str=String.format(\"格式参数$的使用：%1$d,%2$s\", 99,\"abc\");             \n    System.out.println(str);                       \n    //+使用  \n    System.out.printf(\"显示正负数的符号：%+d与%d%n\", 99,-99);  \n    //补O使用  \n    System.out.printf(\"最牛的编号是：%03d%n\", 7);  \n    //空格使用  \n    System.out.printf(\"Tab键的效果是：% 8d%n\", 7);  \n    //.使用  \n    System.out.printf(\"整数分组的效果是：%,d%n\", 9989997);  \n    //空格和小数点后面个数  \n    System.out.printf(\"一本书的价格是：% 50.5f元%n\", 49.8);  \n}  \n```\n输出结果:\n```\n格式参数$的使用：99,abc  \n显示正负数的符号：+99与-99  \n最牛的编号是：007  \nTab键的效果是：       7  \n整数分组的效果是：9,989,997  \n一本书的价格是：                                          49.80000元\n```\n\n## 日期和事件字符串格式化\n在程序界面中经常需要显示时间和日期，但是其显示的 格式经常不尽人意，需要编写大量的代码经过各种算法才得到理想的日期与时间格式。字符串格式中还有%tx转换符没有详细介绍，它是专门用来格式化日期和时 间的。%tx转换符中的x代表另外的处理日期和时间格式的转换符，它们的组合能够将日期和时间格式化成多种格式。\n\n常见日期和时间组合的格式，如表所示。\n\n|转换符|说明|示例\n|:- |:- |:-\n|c|包括全部日期和时间信息|星期六 十月 27 14:21:20 CST 2007\n|F|“年-月-日”格式|2007-10-27\n|D|“月/日/年”格式|10/27/07\n|r|“HH:MM:SS PM”格式（12时制）|02:25:51 下午\n|T|“HH:MM:SS”格式（24时制）|14:28:16\n|R|“HH:MM”格式（24时制）|14:28\n\n测试代码：\n```\npublic static void main(String[] args) {  \n    Date date=new Date();                                  \n    //c的使用  \n    System.out.printf(\"全部日期和时间信息：%tc%n\",date);          \n    //f的使用  \n    System.out.printf(\"年-月-日格式：%tF%n\",date);  \n    //d的使用  \n    System.out.printf(\"月/日/年格式：%tD%n\",date);  \n    //r的使用  \n    System.out.printf(\"HH:MM:SS PM格式（12时制）：%tr%n\",date);  \n    //t的使用  \n    System.out.printf(\"HH:MM:SS格式（24时制）：%tT%n\",date);  \n    //R的使用  \n    System.out.printf(\"HH:MM格式（24时制）：%tR\",date);  \n}\n```\n输出结果：\n```\n全部日期和时间信息：星期一 九月 10 10:43:36 CST 2012  \n年-月-日格式：2012-09-10  \n月/日/年格式：09/10/12  \nHH:MM:SS PM格式（12时制）：10:43:36 上午  \nHH:MM:SS格式（24时制）：10:43:36  \nHH:MM格式（24时制）：10:43  \n```\n定义日期格式的转换符可以使日期通过指定的转换符生成新字符串。这些日期转换符如图所示。\n```\npublic static void main(String[] args) {  \n    Date date=new Date();                                      \n    //b的使用，月份简称  \n    String str=String.format(Locale.US,\"英文月份简称：%tb\",date);       \n    System.out.println(str);                                                                              \n    System.out.printf(\"本地月份简称：%tb%n\",date);  \n    //B的使用，月份全称  \n    str=String.format(Locale.US,\"英文月份全称：%tB\",date);  \n    System.out.println(str);  \n    System.out.printf(\"本地月份全称：%tB%n\",date);  \n    //a的使用，星期简称  \n    str=String.format(Locale.US,\"英文星期的简称：%ta\",date);  \n    System.out.println(str);  \n    //A的使用，星期全称  \n    System.out.printf(\"本地星期的简称：%tA%n\",date);  \n    //C的使用，年前两位  \n    System.out.printf(\"年的前两位数字（不足两位前面补0）：%tC%n\",date);  \n    //y的使用，年后两位  \n    System.out.printf(\"年的后两位数字（不足两位前面补0）：%ty%n\",date);  \n    //j的使用，一年的天数  \n    System.out.printf(\"一年中的天数（即年的第几天）：%tj%n\",date);  \n    //m的使用，月份  \n    System.out.printf(\"两位数字的月份（不足两位前面补0）：%tm%n\",date);  \n    //d的使用，日（二位，不够补零）  \n    System.out.printf(\"两位数字的日（不足两位前面补0）：%td%n\",date);  \n    //e的使用，日（一位不补零）  \n    System.out.printf(\"月份的日（前面不补0）：%te\",date);  \n}  \n```\n输出结果：\n```\n英文月份简称：Sep  \n本地月份简称：九月  \n英文月份全称：September  \n本地月份全称：九月  \n英文星期的简称：Mon  \n本地星期的简称：星期一  \n年的前两位数字（不足两位前面补0）：20  \n年的后两位数字（不足两位前面补0）：12  \n一年中的天数（即年的第几天）：254  \n两位数字的月份（不足两位前面补0）：09  \n两位数字的日（不足两位前面补0）：10  \n月份的日（前面不补0）：10  \n```\n和日期格式转换符相比，时间格式的转换符要更多、更精确。它可以将时间格式化成时、分、秒甚至时毫秒等单位。格式化时间字符串的转换符如图所示。\n\n|转换符|说明|示例\n|:- |:- |:- \n|H|2位数字24时制的小时（不足2位前面补0）|15\n|I|2位数字12时制的小时（不足2位前面补0）|03\n|k|2位数字24时制的小时（前面不补0）|15\n|l|2位数字12时制的小时（前面不补0）|3\n|M|2位数字的分钟（不足2位前面补0）|03\n|S|2位数字的秒（不足2位前面补0）|09\n|L|3位数字的毫秒（不足3位前面补0）|015\n|N|9位数字的毫秒数（不足9位前面补0）|562000000\n|p|小写字母的上午或下午标记|中：下午\n|||英：pm\n|z|相对于GMT的RFC822时区的偏移量|+0800\n|Z|时区缩写字符串|CST\n|s|1970-1-1 00:00:00 到现在所经过的秒数|1193468128\n|Q|1970-1-1 00:00:00 到现在所经过的毫秒数|1193468128984\n示例：\n```\npublic static void main(String[] args) {  \n    Date date = new Date();  \n    //H的使用  \n    System.out.printf(\"2位数字24时制的小时（不足2位前面补0）:%tH%n\", date);  \n    //I的使用  \n    System.out.printf(\"2位数字12时制的小时（不足2位前面补0）:%tI%n\", date);  \n    //k的使用  \n    System.out.printf(\"2位数字24时制的小时（前面不补0）:%tk%n\", date);  \n    //l的使用  \n    System.out.printf(\"2位数字12时制的小时（前面不补0）:%tl%n\", date);  \n    //M的使用  \n    System.out.printf(\"2位数字的分钟（不足2位前面补0）:%tM%n\", date);  \n    //S的使用  \n    System.out.printf(\"2位数字的秒（不足2位前面补0）:%tS%n\", date);  \n    //L的使用  \n    System.out.printf(\"3位数字的毫秒（不足3位前面补0）:%tL%n\", date);  \n    //N的使用  \n    System.out.printf(\"9位数字的毫秒数（不足9位前面补0）:%tN%n\", date);  \n    //p的使用  \n    String str = String.format(Locale.US, \"小写字母的上午或下午标记(英)：%tp\", date);  \n    System.out.println(str);   \n    System.out.printf(\"小写字母的上午或下午标记（中）：%tp%n\", date);  \n    //z的使用  \n    System.out.printf(\"相对于GMT的RFC822时区的偏移量:%tz%n\", date);  \n    //Z的使用  \n    System.out.printf(\"时区缩写字符串:%tZ%n\", date);  \n    //s的使用  \n    System.out.printf(\"1970-1-1 00:00:00 到现在所经过的秒数：%ts%n\", date);  \n    //Q的使用  \n    System.out.printf(\"1970-1-1 00:00:00 到现在所经过的毫秒数：%tQ%n\", date);  \n}\n```\n输出结果：\n```\n2位数字24时制的小时（不足2位前面补0）:11  \n2位数字12时制的小时（不足2位前面补0）:11  \n2位数字24时制的小时（前面不补0）:11  \n2位数字12时制的小时（前面不补0）:11  \n2位数字的分钟（不足2位前面补0）:03  \n2位数字的秒（不足2位前面补0）:52  \n3位数字的毫秒（不足3位前面补0）:773  \n9位数字的毫秒数（不足9位前面补0）:773000000  \n小写字母的上午或下午标记(英)：am  \n小写字母的上午或下午标记（中）：上午  \n相对于GMT的RFC822时区的偏移量:+0800  \n时区缩写字符串:CST  \n1970-1-1 00:00:00 到现在所经过的秒数：1347246232  \n1970-1-1 00:00:00 到现在所经过的毫秒数：1347246232773  \n```\n\n-----\n\n*观点仅代表自己，期待你的留言。*\n","source":"_posts/string-format.md","raw":"---\ntitle: String.format详解\ntags:\n  - Java\n  - 原创\ndate: 2016-04-13 16:02:59\n---\n\nString类的format()方法用于创建格式化的字符串以及连接多个字符串对象。熟悉C语言的同学应该记得C语言的sprintf()方法，两者有类似之处。format()方法有两种重载形式。\nformat(String format, Object... args) 新字符串使用本地语言环境，制定字符串格式和参数生成格式化的新字符串。\n\nformat(Locale locale, String format, Object... args) 使用指定的语言环境，制定字符串格式和参数生成格式化的字符串。\n\n## 常规类型的格式化\n\n|转换符|说明|示例\n|:-|:- |:-\n|%s\t\t\t|字符串类型\t\t\t\t\t|\"mingrisoft\"\t\t\t\n|%c\t\t\t|字符类型\t\t\t\t\t\t|'m'\t\t\t\n|%b\t\t\t|布尔类型\t\t\t\t\t\t|true\t\t\t\n|%d\t\t\t|整数类型（十进制）\t\t\t|99\t\t\t\n|%x\t\t\t|整数类型（十六进制）\t\t\t|FF\t\t\t\n|%o\t\t\t|整数类型（八进制）\t\t\t|77\t\t\t\n|%f\t\t\t|浮点类型\t\t\t\t\t\t|99.99\t\t\t\n|%a\t\t\t|十六进制浮点类型\t\t\t\t|FF.35AE\t\t\t\n|%e\t\t\t|指数类型\t\t\t\t\t\t|9.38e+5\t\t\t\n|%g\t\t\t|通用浮点类型（f和e类型中较短的）\t\t\t \n|%h\t\t\t|散列码\t\t\t \n|%%\t\t\t|百分比类型\t\t\t\t\t|％\t\t\t\n|%n\t\t\t|换行符\t\t\t \n|%tx\t\t|日期与时间类型（x代表不同的日期与时间转换符）\n\n测试代码：\n```\npublic static void main(String[] args) {  \n    String str=null;  \n    str=String.format(\"Hi,%s\", \"王力\");  \n    System.out.println(str);  \n    str=String.format(\"Hi,%s:%s.%s\", \"王南\",\"王力\",\"王张\");            \n    System.out.println(str);                           \n    System.out.printf(\"字母a的大写是：%c %n\", 'A');  \n    System.out.printf(\"3>7的结果是：%b %n\", 3>7);  \n    System.out.printf(\"100的一半是：%d %n\", 100/2);  \n    System.out.printf(\"100的16进制数是：%x %n\", 100);  \n    System.out.printf(\"100的8进制数是：%o %n\", 100);  \n    System.out.printf(\"50元的书打8.5折扣是：%f 元%n\", 50*0.85);  \n    System.out.printf(\"上面价格的16进制数是：%a %n\", 50*0.85);  \n    System.out.printf(\"上面价格的指数表示：%e %n\", 50*0.85);  \n    System.out.printf(\"上面价格的指数和浮点数结果的长度较短的是：%g %n\", 50*0.85);  \n    System.out.printf(\"上面的折扣是%d%% %n\", 85);  \n    System.out.printf(\"字母A的散列码是：%h %n\", 'A');  \n}  \n```\n输出结果:\n```\nHi,王力  \nHi,王南:王力.王张  \n字母a的大写是：A   \n3>7的结果是：false   \n100的一半是：50   \n100的16进制数是：64   \n100的8进制数是：144   \n50元的书打8.5折扣是：42.500000 元  \n上面价格的16进制数是：0x1.54p5   \n上面价格的指数表示：4.250000e+01   \n上面价格的指数和浮点数结果的长度较短的是：42.5000   \n上面的折扣是85%   \n字母A的散列码是：41  \n```\n搭配转换符的标志，如图所示:\n\n|标志|说明|示例|结果\n|:-|:- |:- |:-\n|+|为正数或者负数添加符号|(\"%+d\",15)|+15\n|−|左对齐|(\"%-5d\",15)|15   |\n|0|数字前面补0|(\"%04d\", 99)|0099\n|空格|在整数之前添加指定数量的空格|(\"% 4d\", 99)|  99\n|,|以“,”对数字分组|(\"%,f\", 9999.99)|9,999.990000\n|(|使用括号包含负数|(\"%(f\", -99.99)|(99.990000)\n|#|如果是浮点数则包含小数点，如果是16进制或8进制则添加0x或0|(\"%#x\", 99)|0x63\n|||(\"%#o\", 99)|0143\n|< |格式化前一个转换符所描述的参数|(\"%f和%<3.2f\", 99.45)|99.450000和99.45\n|$|被格式化的参数索引|(\"%1$d,%2$s\", 99,\"abc\")|99,abc\n测试代码：\n```\npublic static void main(String[] args) {  \n    String str=null;  \n    //$使用  \n    str=String.format(\"格式参数$的使用：%1$d,%2$s\", 99,\"abc\");             \n    System.out.println(str);                       \n    //+使用  \n    System.out.printf(\"显示正负数的符号：%+d与%d%n\", 99,-99);  \n    //补O使用  \n    System.out.printf(\"最牛的编号是：%03d%n\", 7);  \n    //空格使用  \n    System.out.printf(\"Tab键的效果是：% 8d%n\", 7);  \n    //.使用  \n    System.out.printf(\"整数分组的效果是：%,d%n\", 9989997);  \n    //空格和小数点后面个数  \n    System.out.printf(\"一本书的价格是：% 50.5f元%n\", 49.8);  \n}  \n```\n输出结果:\n```\n格式参数$的使用：99,abc  \n显示正负数的符号：+99与-99  \n最牛的编号是：007  \nTab键的效果是：       7  \n整数分组的效果是：9,989,997  \n一本书的价格是：                                          49.80000元\n```\n\n## 日期和事件字符串格式化\n在程序界面中经常需要显示时间和日期，但是其显示的 格式经常不尽人意，需要编写大量的代码经过各种算法才得到理想的日期与时间格式。字符串格式中还有%tx转换符没有详细介绍，它是专门用来格式化日期和时 间的。%tx转换符中的x代表另外的处理日期和时间格式的转换符，它们的组合能够将日期和时间格式化成多种格式。\n\n常见日期和时间组合的格式，如表所示。\n\n|转换符|说明|示例\n|:- |:- |:-\n|c|包括全部日期和时间信息|星期六 十月 27 14:21:20 CST 2007\n|F|“年-月-日”格式|2007-10-27\n|D|“月/日/年”格式|10/27/07\n|r|“HH:MM:SS PM”格式（12时制）|02:25:51 下午\n|T|“HH:MM:SS”格式（24时制）|14:28:16\n|R|“HH:MM”格式（24时制）|14:28\n\n测试代码：\n```\npublic static void main(String[] args) {  \n    Date date=new Date();                                  \n    //c的使用  \n    System.out.printf(\"全部日期和时间信息：%tc%n\",date);          \n    //f的使用  \n    System.out.printf(\"年-月-日格式：%tF%n\",date);  \n    //d的使用  \n    System.out.printf(\"月/日/年格式：%tD%n\",date);  \n    //r的使用  \n    System.out.printf(\"HH:MM:SS PM格式（12时制）：%tr%n\",date);  \n    //t的使用  \n    System.out.printf(\"HH:MM:SS格式（24时制）：%tT%n\",date);  \n    //R的使用  \n    System.out.printf(\"HH:MM格式（24时制）：%tR\",date);  \n}\n```\n输出结果：\n```\n全部日期和时间信息：星期一 九月 10 10:43:36 CST 2012  \n年-月-日格式：2012-09-10  \n月/日/年格式：09/10/12  \nHH:MM:SS PM格式（12时制）：10:43:36 上午  \nHH:MM:SS格式（24时制）：10:43:36  \nHH:MM格式（24时制）：10:43  \n```\n定义日期格式的转换符可以使日期通过指定的转换符生成新字符串。这些日期转换符如图所示。\n```\npublic static void main(String[] args) {  \n    Date date=new Date();                                      \n    //b的使用，月份简称  \n    String str=String.format(Locale.US,\"英文月份简称：%tb\",date);       \n    System.out.println(str);                                                                              \n    System.out.printf(\"本地月份简称：%tb%n\",date);  \n    //B的使用，月份全称  \n    str=String.format(Locale.US,\"英文月份全称：%tB\",date);  \n    System.out.println(str);  \n    System.out.printf(\"本地月份全称：%tB%n\",date);  \n    //a的使用，星期简称  \n    str=String.format(Locale.US,\"英文星期的简称：%ta\",date);  \n    System.out.println(str);  \n    //A的使用，星期全称  \n    System.out.printf(\"本地星期的简称：%tA%n\",date);  \n    //C的使用，年前两位  \n    System.out.printf(\"年的前两位数字（不足两位前面补0）：%tC%n\",date);  \n    //y的使用，年后两位  \n    System.out.printf(\"年的后两位数字（不足两位前面补0）：%ty%n\",date);  \n    //j的使用，一年的天数  \n    System.out.printf(\"一年中的天数（即年的第几天）：%tj%n\",date);  \n    //m的使用，月份  \n    System.out.printf(\"两位数字的月份（不足两位前面补0）：%tm%n\",date);  \n    //d的使用，日（二位，不够补零）  \n    System.out.printf(\"两位数字的日（不足两位前面补0）：%td%n\",date);  \n    //e的使用，日（一位不补零）  \n    System.out.printf(\"月份的日（前面不补0）：%te\",date);  \n}  \n```\n输出结果：\n```\n英文月份简称：Sep  \n本地月份简称：九月  \n英文月份全称：September  \n本地月份全称：九月  \n英文星期的简称：Mon  \n本地星期的简称：星期一  \n年的前两位数字（不足两位前面补0）：20  \n年的后两位数字（不足两位前面补0）：12  \n一年中的天数（即年的第几天）：254  \n两位数字的月份（不足两位前面补0）：09  \n两位数字的日（不足两位前面补0）：10  \n月份的日（前面不补0）：10  \n```\n和日期格式转换符相比，时间格式的转换符要更多、更精确。它可以将时间格式化成时、分、秒甚至时毫秒等单位。格式化时间字符串的转换符如图所示。\n\n|转换符|说明|示例\n|:- |:- |:- \n|H|2位数字24时制的小时（不足2位前面补0）|15\n|I|2位数字12时制的小时（不足2位前面补0）|03\n|k|2位数字24时制的小时（前面不补0）|15\n|l|2位数字12时制的小时（前面不补0）|3\n|M|2位数字的分钟（不足2位前面补0）|03\n|S|2位数字的秒（不足2位前面补0）|09\n|L|3位数字的毫秒（不足3位前面补0）|015\n|N|9位数字的毫秒数（不足9位前面补0）|562000000\n|p|小写字母的上午或下午标记|中：下午\n|||英：pm\n|z|相对于GMT的RFC822时区的偏移量|+0800\n|Z|时区缩写字符串|CST\n|s|1970-1-1 00:00:00 到现在所经过的秒数|1193468128\n|Q|1970-1-1 00:00:00 到现在所经过的毫秒数|1193468128984\n示例：\n```\npublic static void main(String[] args) {  \n    Date date = new Date();  \n    //H的使用  \n    System.out.printf(\"2位数字24时制的小时（不足2位前面补0）:%tH%n\", date);  \n    //I的使用  \n    System.out.printf(\"2位数字12时制的小时（不足2位前面补0）:%tI%n\", date);  \n    //k的使用  \n    System.out.printf(\"2位数字24时制的小时（前面不补0）:%tk%n\", date);  \n    //l的使用  \n    System.out.printf(\"2位数字12时制的小时（前面不补0）:%tl%n\", date);  \n    //M的使用  \n    System.out.printf(\"2位数字的分钟（不足2位前面补0）:%tM%n\", date);  \n    //S的使用  \n    System.out.printf(\"2位数字的秒（不足2位前面补0）:%tS%n\", date);  \n    //L的使用  \n    System.out.printf(\"3位数字的毫秒（不足3位前面补0）:%tL%n\", date);  \n    //N的使用  \n    System.out.printf(\"9位数字的毫秒数（不足9位前面补0）:%tN%n\", date);  \n    //p的使用  \n    String str = String.format(Locale.US, \"小写字母的上午或下午标记(英)：%tp\", date);  \n    System.out.println(str);   \n    System.out.printf(\"小写字母的上午或下午标记（中）：%tp%n\", date);  \n    //z的使用  \n    System.out.printf(\"相对于GMT的RFC822时区的偏移量:%tz%n\", date);  \n    //Z的使用  \n    System.out.printf(\"时区缩写字符串:%tZ%n\", date);  \n    //s的使用  \n    System.out.printf(\"1970-1-1 00:00:00 到现在所经过的秒数：%ts%n\", date);  \n    //Q的使用  \n    System.out.printf(\"1970-1-1 00:00:00 到现在所经过的毫秒数：%tQ%n\", date);  \n}\n```\n输出结果：\n```\n2位数字24时制的小时（不足2位前面补0）:11  \n2位数字12时制的小时（不足2位前面补0）:11  \n2位数字24时制的小时（前面不补0）:11  \n2位数字12时制的小时（前面不补0）:11  \n2位数字的分钟（不足2位前面补0）:03  \n2位数字的秒（不足2位前面补0）:52  \n3位数字的毫秒（不足3位前面补0）:773  \n9位数字的毫秒数（不足9位前面补0）:773000000  \n小写字母的上午或下午标记(英)：am  \n小写字母的上午或下午标记（中）：上午  \n相对于GMT的RFC822时区的偏移量:+0800  \n时区缩写字符串:CST  \n1970-1-1 00:00:00 到现在所经过的秒数：1347246232  \n1970-1-1 00:00:00 到现在所经过的毫秒数：1347246232773  \n```\n\n-----\n\n*观点仅代表自己，期待你的留言。*\n","slug":"string-format","published":1,"updated":"2021-09-18T03:05:32.967Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cku52dypm0059bbinarolgi5e","content":"<p>String类的format()方法用于创建格式化的字符串以及连接多个字符串对象。熟悉C语言的同学应该记得C语言的sprintf()方法，两者有类似之处。format()方法有两种重载形式。<br>format(String format, Object… args) 新字符串使用本地语言环境，制定字符串格式和参数生成格式化的新字符串。</p>\n<p>format(Locale locale, String format, Object… args) 使用指定的语言环境，制定字符串格式和参数生成格式化的字符串。</p>\n<h2 id=\"常规类型的格式化\"><a href=\"#常规类型的格式化\" class=\"headerlink\" title=\"常规类型的格式化\"></a>常规类型的格式化</h2><table>\n<thead>\n<tr>\n<th align=\"left\">转换符</th>\n<th align=\"left\">说明</th>\n<th align=\"left\">示例</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">%s</td>\n<td align=\"left\">字符串类型</td>\n<td align=\"left\">“mingrisoft”</td>\n</tr>\n<tr>\n<td align=\"left\">%c</td>\n<td align=\"left\">字符类型</td>\n<td align=\"left\">‘m’</td>\n</tr>\n<tr>\n<td align=\"left\">%b</td>\n<td align=\"left\">布尔类型</td>\n<td align=\"left\">true</td>\n</tr>\n<tr>\n<td align=\"left\">%d</td>\n<td align=\"left\">整数类型（十进制）</td>\n<td align=\"left\">99</td>\n</tr>\n<tr>\n<td align=\"left\">%x</td>\n<td align=\"left\">整数类型（十六进制）</td>\n<td align=\"left\">FF</td>\n</tr>\n<tr>\n<td align=\"left\">%o</td>\n<td align=\"left\">整数类型（八进制）</td>\n<td align=\"left\">77</td>\n</tr>\n<tr>\n<td align=\"left\">%f</td>\n<td align=\"left\">浮点类型</td>\n<td align=\"left\">99.99</td>\n</tr>\n<tr>\n<td align=\"left\">%a</td>\n<td align=\"left\">十六进制浮点类型</td>\n<td align=\"left\">FF.35AE</td>\n</tr>\n<tr>\n<td align=\"left\">%e</td>\n<td align=\"left\">指数类型</td>\n<td align=\"left\">9.38e+5</td>\n</tr>\n<tr>\n<td align=\"left\">%g</td>\n<td align=\"left\">通用浮点类型（f和e类型中较短的）</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">%h</td>\n<td align=\"left\">散列码</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">%%</td>\n<td align=\"left\">百分比类型</td>\n<td align=\"left\">％</td>\n</tr>\n<tr>\n<td align=\"left\">%n</td>\n<td align=\"left\">换行符</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">%tx</td>\n<td align=\"left\">日期与时间类型（x代表不同的日期与时间转换符）</td>\n<td align=\"left\"></td>\n</tr>\n</tbody></table>\n<p>测试代码：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static void main(String[] args) &#123;  </span><br><span class=\"line\">    String str=null;  </span><br><span class=\"line\">    str=String.format(&quot;Hi,%s&quot;, &quot;王力&quot;);  </span><br><span class=\"line\">    System.out.println(str);  </span><br><span class=\"line\">    str=String.format(&quot;Hi,%s:%s.%s&quot;, &quot;王南&quot;,&quot;王力&quot;,&quot;王张&quot;);            </span><br><span class=\"line\">    System.out.println(str);                           </span><br><span class=\"line\">    System.out.printf(&quot;字母a的大写是：%c %n&quot;, &#x27;A&#x27;);  </span><br><span class=\"line\">    System.out.printf(&quot;3&gt;7的结果是：%b %n&quot;, 3&gt;7);  </span><br><span class=\"line\">    System.out.printf(&quot;100的一半是：%d %n&quot;, 100/2);  </span><br><span class=\"line\">    System.out.printf(&quot;100的16进制数是：%x %n&quot;, 100);  </span><br><span class=\"line\">    System.out.printf(&quot;100的8进制数是：%o %n&quot;, 100);  </span><br><span class=\"line\">    System.out.printf(&quot;50元的书打8.5折扣是：%f 元%n&quot;, 50*0.85);  </span><br><span class=\"line\">    System.out.printf(&quot;上面价格的16进制数是：%a %n&quot;, 50*0.85);  </span><br><span class=\"line\">    System.out.printf(&quot;上面价格的指数表示：%e %n&quot;, 50*0.85);  </span><br><span class=\"line\">    System.out.printf(&quot;上面价格的指数和浮点数结果的长度较短的是：%g %n&quot;, 50*0.85);  </span><br><span class=\"line\">    System.out.printf(&quot;上面的折扣是%d%% %n&quot;, 85);  </span><br><span class=\"line\">    System.out.printf(&quot;字母A的散列码是：%h %n&quot;, &#x27;A&#x27;);  </span><br><span class=\"line\">&#125;  </span><br></pre></td></tr></table></figure>\n<p>输出结果:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Hi,王力  </span><br><span class=\"line\">Hi,王南:王力.王张  </span><br><span class=\"line\">字母a的大写是：A   </span><br><span class=\"line\">3&gt;7的结果是：false   </span><br><span class=\"line\">100的一半是：50   </span><br><span class=\"line\">100的16进制数是：64   </span><br><span class=\"line\">100的8进制数是：144   </span><br><span class=\"line\">50元的书打8.5折扣是：42.500000 元  </span><br><span class=\"line\">上面价格的16进制数是：0x1.54p5   </span><br><span class=\"line\">上面价格的指数表示：4.250000e+01   </span><br><span class=\"line\">上面价格的指数和浮点数结果的长度较短的是：42.5000   </span><br><span class=\"line\">上面的折扣是85%   </span><br><span class=\"line\">字母A的散列码是：41  </span><br></pre></td></tr></table></figure>\n<p>搭配转换符的标志，如图所示:</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">标志</th>\n<th align=\"left\">说明</th>\n<th align=\"left\">示例</th>\n<th align=\"left\">结果</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">+</td>\n<td align=\"left\">为正数或者负数添加符号</td>\n<td align=\"left\">(“%+d”,15)</td>\n<td align=\"left\">+15</td>\n</tr>\n<tr>\n<td align=\"left\">−</td>\n<td align=\"left\">左对齐</td>\n<td align=\"left\">(“%-5d”,15)</td>\n<td align=\"left\">15</td>\n</tr>\n<tr>\n<td align=\"left\">0</td>\n<td align=\"left\">数字前面补0</td>\n<td align=\"left\">(“%04d”, 99)</td>\n<td align=\"left\">0099</td>\n</tr>\n<tr>\n<td align=\"left\">空格</td>\n<td align=\"left\">在整数之前添加指定数量的空格</td>\n<td align=\"left\">(“% 4d”, 99)</td>\n<td align=\"left\">99</td>\n</tr>\n<tr>\n<td align=\"left\">,</td>\n<td align=\"left\">以“,”对数字分组</td>\n<td align=\"left\">(“%,f”, 9999.99)</td>\n<td align=\"left\">9,999.990000</td>\n</tr>\n<tr>\n<td align=\"left\">(</td>\n<td align=\"left\">使用括号包含负数</td>\n<td align=\"left\">(“%(f”, -99.99)</td>\n<td align=\"left\">(99.990000)</td>\n</tr>\n<tr>\n<td align=\"left\">#</td>\n<td align=\"left\">如果是浮点数则包含小数点，如果是16进制或8进制则添加0x或0</td>\n<td align=\"left\">(“%#x”, 99)</td>\n<td align=\"left\">0x63</td>\n</tr>\n<tr>\n<td align=\"left\"></td>\n<td align=\"left\"></td>\n<td align=\"left\">(“%#o”, 99)</td>\n<td align=\"left\">0143</td>\n</tr>\n<tr>\n<td align=\"left\">&lt;</td>\n<td align=\"left\">格式化前一个转换符所描述的参数</td>\n<td align=\"left\">(“%f和%&lt;3.2f”, 99.45)</td>\n<td align=\"left\">99.450000和99.45</td>\n</tr>\n<tr>\n<td align=\"left\">$</td>\n<td align=\"left\">被格式化的参数索引</td>\n<td align=\"left\">(“%1$d,%2$s”, 99,”abc”)</td>\n<td align=\"left\">99,abc</td>\n</tr>\n<tr>\n<td align=\"left\">测试代码：</td>\n<td align=\"left\"></td>\n<td align=\"left\"></td>\n<td align=\"left\"></td>\n</tr>\n</tbody></table>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static void main(String[] args) &#123;  </span><br><span class=\"line\">    String str=null;  </span><br><span class=\"line\">    //$使用  </span><br><span class=\"line\">    str=String.format(&quot;格式参数$的使用：%1$d,%2$s&quot;, 99,&quot;abc&quot;);             </span><br><span class=\"line\">    System.out.println(str);                       </span><br><span class=\"line\">    //+使用  </span><br><span class=\"line\">    System.out.printf(&quot;显示正负数的符号：%+d与%d%n&quot;, 99,-99);  </span><br><span class=\"line\">    //补O使用  </span><br><span class=\"line\">    System.out.printf(&quot;最牛的编号是：%03d%n&quot;, 7);  </span><br><span class=\"line\">    //空格使用  </span><br><span class=\"line\">    System.out.printf(&quot;Tab键的效果是：% 8d%n&quot;, 7);  </span><br><span class=\"line\">    //.使用  </span><br><span class=\"line\">    System.out.printf(&quot;整数分组的效果是：%,d%n&quot;, 9989997);  </span><br><span class=\"line\">    //空格和小数点后面个数  </span><br><span class=\"line\">    System.out.printf(&quot;一本书的价格是：% 50.5f元%n&quot;, 49.8);  </span><br><span class=\"line\">&#125;  </span><br></pre></td></tr></table></figure>\n<p>输出结果:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">格式参数$的使用：99,abc  </span><br><span class=\"line\">显示正负数的符号：+99与-99  </span><br><span class=\"line\">最牛的编号是：007  </span><br><span class=\"line\">Tab键的效果是：       7  </span><br><span class=\"line\">整数分组的效果是：9,989,997  </span><br><span class=\"line\">一本书的价格是：                                          49.80000元</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"日期和事件字符串格式化\"><a href=\"#日期和事件字符串格式化\" class=\"headerlink\" title=\"日期和事件字符串格式化\"></a>日期和事件字符串格式化</h2><p>在程序界面中经常需要显示时间和日期，但是其显示的 格式经常不尽人意，需要编写大量的代码经过各种算法才得到理想的日期与时间格式。字符串格式中还有%tx转换符没有详细介绍，它是专门用来格式化日期和时 间的。%tx转换符中的x代表另外的处理日期和时间格式的转换符，它们的组合能够将日期和时间格式化成多种格式。</p>\n<p>常见日期和时间组合的格式，如表所示。</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">转换符</th>\n<th align=\"left\">说明</th>\n<th align=\"left\">示例</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">c</td>\n<td align=\"left\">包括全部日期和时间信息</td>\n<td align=\"left\">星期六 十月 27 14:21:20 CST 2007</td>\n</tr>\n<tr>\n<td align=\"left\">F</td>\n<td align=\"left\">“年-月-日”格式</td>\n<td align=\"left\">2007-10-27</td>\n</tr>\n<tr>\n<td align=\"left\">D</td>\n<td align=\"left\">“月/日/年”格式</td>\n<td align=\"left\">10/27/07</td>\n</tr>\n<tr>\n<td align=\"left\">r</td>\n<td align=\"left\">“HH:MM:SS PM”格式（12时制）</td>\n<td align=\"left\">02:25:51 下午</td>\n</tr>\n<tr>\n<td align=\"left\">T</td>\n<td align=\"left\">“HH:MM:SS”格式（24时制）</td>\n<td align=\"left\">14:28:16</td>\n</tr>\n<tr>\n<td align=\"left\">R</td>\n<td align=\"left\">“HH:MM”格式（24时制）</td>\n<td align=\"left\">14:28</td>\n</tr>\n</tbody></table>\n<p>测试代码：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static void main(String[] args) &#123;  </span><br><span class=\"line\">    Date date=new Date();                                  </span><br><span class=\"line\">    //c的使用  </span><br><span class=\"line\">    System.out.printf(&quot;全部日期和时间信息：%tc%n&quot;,date);          </span><br><span class=\"line\">    //f的使用  </span><br><span class=\"line\">    System.out.printf(&quot;年-月-日格式：%tF%n&quot;,date);  </span><br><span class=\"line\">    //d的使用  </span><br><span class=\"line\">    System.out.printf(&quot;月/日/年格式：%tD%n&quot;,date);  </span><br><span class=\"line\">    //r的使用  </span><br><span class=\"line\">    System.out.printf(&quot;HH:MM:SS PM格式（12时制）：%tr%n&quot;,date);  </span><br><span class=\"line\">    //t的使用  </span><br><span class=\"line\">    System.out.printf(&quot;HH:MM:SS格式（24时制）：%tT%n&quot;,date);  </span><br><span class=\"line\">    //R的使用  </span><br><span class=\"line\">    System.out.printf(&quot;HH:MM格式（24时制）：%tR&quot;,date);  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>输出结果：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">全部日期和时间信息：星期一 九月 10 10:43:36 CST 2012  </span><br><span class=\"line\">年-月-日格式：2012-09-10  </span><br><span class=\"line\">月/日/年格式：09/10/12  </span><br><span class=\"line\">HH:MM:SS PM格式（12时制）：10:43:36 上午  </span><br><span class=\"line\">HH:MM:SS格式（24时制）：10:43:36  </span><br><span class=\"line\">HH:MM格式（24时制）：10:43  </span><br></pre></td></tr></table></figure>\n<p>定义日期格式的转换符可以使日期通过指定的转换符生成新字符串。这些日期转换符如图所示。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static void main(String[] args) &#123;  </span><br><span class=\"line\">    Date date=new Date();                                      </span><br><span class=\"line\">    //b的使用，月份简称  </span><br><span class=\"line\">    String str=String.format(Locale.US,&quot;英文月份简称：%tb&quot;,date);       </span><br><span class=\"line\">    System.out.println(str);                                                                              </span><br><span class=\"line\">    System.out.printf(&quot;本地月份简称：%tb%n&quot;,date);  </span><br><span class=\"line\">    //B的使用，月份全称  </span><br><span class=\"line\">    str=String.format(Locale.US,&quot;英文月份全称：%tB&quot;,date);  </span><br><span class=\"line\">    System.out.println(str);  </span><br><span class=\"line\">    System.out.printf(&quot;本地月份全称：%tB%n&quot;,date);  </span><br><span class=\"line\">    //a的使用，星期简称  </span><br><span class=\"line\">    str=String.format(Locale.US,&quot;英文星期的简称：%ta&quot;,date);  </span><br><span class=\"line\">    System.out.println(str);  </span><br><span class=\"line\">    //A的使用，星期全称  </span><br><span class=\"line\">    System.out.printf(&quot;本地星期的简称：%tA%n&quot;,date);  </span><br><span class=\"line\">    //C的使用，年前两位  </span><br><span class=\"line\">    System.out.printf(&quot;年的前两位数字（不足两位前面补0）：%tC%n&quot;,date);  </span><br><span class=\"line\">    //y的使用，年后两位  </span><br><span class=\"line\">    System.out.printf(&quot;年的后两位数字（不足两位前面补0）：%ty%n&quot;,date);  </span><br><span class=\"line\">    //j的使用，一年的天数  </span><br><span class=\"line\">    System.out.printf(&quot;一年中的天数（即年的第几天）：%tj%n&quot;,date);  </span><br><span class=\"line\">    //m的使用，月份  </span><br><span class=\"line\">    System.out.printf(&quot;两位数字的月份（不足两位前面补0）：%tm%n&quot;,date);  </span><br><span class=\"line\">    //d的使用，日（二位，不够补零）  </span><br><span class=\"line\">    System.out.printf(&quot;两位数字的日（不足两位前面补0）：%td%n&quot;,date);  </span><br><span class=\"line\">    //e的使用，日（一位不补零）  </span><br><span class=\"line\">    System.out.printf(&quot;月份的日（前面不补0）：%te&quot;,date);  </span><br><span class=\"line\">&#125;  </span><br></pre></td></tr></table></figure>\n<p>输出结果：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">英文月份简称：Sep  </span><br><span class=\"line\">本地月份简称：九月  </span><br><span class=\"line\">英文月份全称：September  </span><br><span class=\"line\">本地月份全称：九月  </span><br><span class=\"line\">英文星期的简称：Mon  </span><br><span class=\"line\">本地星期的简称：星期一  </span><br><span class=\"line\">年的前两位数字（不足两位前面补0）：20  </span><br><span class=\"line\">年的后两位数字（不足两位前面补0）：12  </span><br><span class=\"line\">一年中的天数（即年的第几天）：254  </span><br><span class=\"line\">两位数字的月份（不足两位前面补0）：09  </span><br><span class=\"line\">两位数字的日（不足两位前面补0）：10  </span><br><span class=\"line\">月份的日（前面不补0）：10  </span><br></pre></td></tr></table></figure>\n<p>和日期格式转换符相比，时间格式的转换符要更多、更精确。它可以将时间格式化成时、分、秒甚至时毫秒等单位。格式化时间字符串的转换符如图所示。</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">转换符</th>\n<th align=\"left\">说明</th>\n<th align=\"left\">示例</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">H</td>\n<td align=\"left\">2位数字24时制的小时（不足2位前面补0）</td>\n<td align=\"left\">15</td>\n</tr>\n<tr>\n<td align=\"left\">I</td>\n<td align=\"left\">2位数字12时制的小时（不足2位前面补0）</td>\n<td align=\"left\">03</td>\n</tr>\n<tr>\n<td align=\"left\">k</td>\n<td align=\"left\">2位数字24时制的小时（前面不补0）</td>\n<td align=\"left\">15</td>\n</tr>\n<tr>\n<td align=\"left\">l</td>\n<td align=\"left\">2位数字12时制的小时（前面不补0）</td>\n<td align=\"left\">3</td>\n</tr>\n<tr>\n<td align=\"left\">M</td>\n<td align=\"left\">2位数字的分钟（不足2位前面补0）</td>\n<td align=\"left\">03</td>\n</tr>\n<tr>\n<td align=\"left\">S</td>\n<td align=\"left\">2位数字的秒（不足2位前面补0）</td>\n<td align=\"left\">09</td>\n</tr>\n<tr>\n<td align=\"left\">L</td>\n<td align=\"left\">3位数字的毫秒（不足3位前面补0）</td>\n<td align=\"left\">015</td>\n</tr>\n<tr>\n<td align=\"left\">N</td>\n<td align=\"left\">9位数字的毫秒数（不足9位前面补0）</td>\n<td align=\"left\">562000000</td>\n</tr>\n<tr>\n<td align=\"left\">p</td>\n<td align=\"left\">小写字母的上午或下午标记</td>\n<td align=\"left\">中：下午</td>\n</tr>\n<tr>\n<td align=\"left\"></td>\n<td align=\"left\"></td>\n<td align=\"left\">英：pm</td>\n</tr>\n<tr>\n<td align=\"left\">z</td>\n<td align=\"left\">相对于GMT的RFC822时区的偏移量</td>\n<td align=\"left\">+0800</td>\n</tr>\n<tr>\n<td align=\"left\">Z</td>\n<td align=\"left\">时区缩写字符串</td>\n<td align=\"left\">CST</td>\n</tr>\n<tr>\n<td align=\"left\">s</td>\n<td align=\"left\">1970-1-1 00:00:00 到现在所经过的秒数</td>\n<td align=\"left\">1193468128</td>\n</tr>\n<tr>\n<td align=\"left\">Q</td>\n<td align=\"left\">1970-1-1 00:00:00 到现在所经过的毫秒数</td>\n<td align=\"left\">1193468128984</td>\n</tr>\n<tr>\n<td align=\"left\">示例：</td>\n<td align=\"left\"></td>\n<td align=\"left\"></td>\n</tr>\n</tbody></table>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static void main(String[] args) &#123;  </span><br><span class=\"line\">    Date date = new Date();  </span><br><span class=\"line\">    //H的使用  </span><br><span class=\"line\">    System.out.printf(&quot;2位数字24时制的小时（不足2位前面补0）:%tH%n&quot;, date);  </span><br><span class=\"line\">    //I的使用  </span><br><span class=\"line\">    System.out.printf(&quot;2位数字12时制的小时（不足2位前面补0）:%tI%n&quot;, date);  </span><br><span class=\"line\">    //k的使用  </span><br><span class=\"line\">    System.out.printf(&quot;2位数字24时制的小时（前面不补0）:%tk%n&quot;, date);  </span><br><span class=\"line\">    //l的使用  </span><br><span class=\"line\">    System.out.printf(&quot;2位数字12时制的小时（前面不补0）:%tl%n&quot;, date);  </span><br><span class=\"line\">    //M的使用  </span><br><span class=\"line\">    System.out.printf(&quot;2位数字的分钟（不足2位前面补0）:%tM%n&quot;, date);  </span><br><span class=\"line\">    //S的使用  </span><br><span class=\"line\">    System.out.printf(&quot;2位数字的秒（不足2位前面补0）:%tS%n&quot;, date);  </span><br><span class=\"line\">    //L的使用  </span><br><span class=\"line\">    System.out.printf(&quot;3位数字的毫秒（不足3位前面补0）:%tL%n&quot;, date);  </span><br><span class=\"line\">    //N的使用  </span><br><span class=\"line\">    System.out.printf(&quot;9位数字的毫秒数（不足9位前面补0）:%tN%n&quot;, date);  </span><br><span class=\"line\">    //p的使用  </span><br><span class=\"line\">    String str = String.format(Locale.US, &quot;小写字母的上午或下午标记(英)：%tp&quot;, date);  </span><br><span class=\"line\">    System.out.println(str);   </span><br><span class=\"line\">    System.out.printf(&quot;小写字母的上午或下午标记（中）：%tp%n&quot;, date);  </span><br><span class=\"line\">    //z的使用  </span><br><span class=\"line\">    System.out.printf(&quot;相对于GMT的RFC822时区的偏移量:%tz%n&quot;, date);  </span><br><span class=\"line\">    //Z的使用  </span><br><span class=\"line\">    System.out.printf(&quot;时区缩写字符串:%tZ%n&quot;, date);  </span><br><span class=\"line\">    //s的使用  </span><br><span class=\"line\">    System.out.printf(&quot;1970-1-1 00:00:00 到现在所经过的秒数：%ts%n&quot;, date);  </span><br><span class=\"line\">    //Q的使用  </span><br><span class=\"line\">    System.out.printf(&quot;1970-1-1 00:00:00 到现在所经过的毫秒数：%tQ%n&quot;, date);  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>输出结果：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2位数字24时制的小时（不足2位前面补0）:11  </span><br><span class=\"line\">2位数字12时制的小时（不足2位前面补0）:11  </span><br><span class=\"line\">2位数字24时制的小时（前面不补0）:11  </span><br><span class=\"line\">2位数字12时制的小时（前面不补0）:11  </span><br><span class=\"line\">2位数字的分钟（不足2位前面补0）:03  </span><br><span class=\"line\">2位数字的秒（不足2位前面补0）:52  </span><br><span class=\"line\">3位数字的毫秒（不足3位前面补0）:773  </span><br><span class=\"line\">9位数字的毫秒数（不足9位前面补0）:773000000  </span><br><span class=\"line\">小写字母的上午或下午标记(英)：am  </span><br><span class=\"line\">小写字母的上午或下午标记（中）：上午  </span><br><span class=\"line\">相对于GMT的RFC822时区的偏移量:+0800  </span><br><span class=\"line\">时区缩写字符串:CST  </span><br><span class=\"line\">1970-1-1 00:00:00 到现在所经过的秒数：1347246232  </span><br><span class=\"line\">1970-1-1 00:00:00 到现在所经过的毫秒数：1347246232773  </span><br></pre></td></tr></table></figure>\n\n<hr>\n<p><em>观点仅代表自己，期待你的留言。</em></p>\n","site":{"data":{}},"excerpt":"","more":"<p>String类的format()方法用于创建格式化的字符串以及连接多个字符串对象。熟悉C语言的同学应该记得C语言的sprintf()方法，两者有类似之处。format()方法有两种重载形式。<br>format(String format, Object… args) 新字符串使用本地语言环境，制定字符串格式和参数生成格式化的新字符串。</p>\n<p>format(Locale locale, String format, Object… args) 使用指定的语言环境，制定字符串格式和参数生成格式化的字符串。</p>\n<h2 id=\"常规类型的格式化\"><a href=\"#常规类型的格式化\" class=\"headerlink\" title=\"常规类型的格式化\"></a>常规类型的格式化</h2><table>\n<thead>\n<tr>\n<th align=\"left\">转换符</th>\n<th align=\"left\">说明</th>\n<th align=\"left\">示例</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">%s</td>\n<td align=\"left\">字符串类型</td>\n<td align=\"left\">“mingrisoft”</td>\n</tr>\n<tr>\n<td align=\"left\">%c</td>\n<td align=\"left\">字符类型</td>\n<td align=\"left\">‘m’</td>\n</tr>\n<tr>\n<td align=\"left\">%b</td>\n<td align=\"left\">布尔类型</td>\n<td align=\"left\">true</td>\n</tr>\n<tr>\n<td align=\"left\">%d</td>\n<td align=\"left\">整数类型（十进制）</td>\n<td align=\"left\">99</td>\n</tr>\n<tr>\n<td align=\"left\">%x</td>\n<td align=\"left\">整数类型（十六进制）</td>\n<td align=\"left\">FF</td>\n</tr>\n<tr>\n<td align=\"left\">%o</td>\n<td align=\"left\">整数类型（八进制）</td>\n<td align=\"left\">77</td>\n</tr>\n<tr>\n<td align=\"left\">%f</td>\n<td align=\"left\">浮点类型</td>\n<td align=\"left\">99.99</td>\n</tr>\n<tr>\n<td align=\"left\">%a</td>\n<td align=\"left\">十六进制浮点类型</td>\n<td align=\"left\">FF.35AE</td>\n</tr>\n<tr>\n<td align=\"left\">%e</td>\n<td align=\"left\">指数类型</td>\n<td align=\"left\">9.38e+5</td>\n</tr>\n<tr>\n<td align=\"left\">%g</td>\n<td align=\"left\">通用浮点类型（f和e类型中较短的）</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">%h</td>\n<td align=\"left\">散列码</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">%%</td>\n<td align=\"left\">百分比类型</td>\n<td align=\"left\">％</td>\n</tr>\n<tr>\n<td align=\"left\">%n</td>\n<td align=\"left\">换行符</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">%tx</td>\n<td align=\"left\">日期与时间类型（x代表不同的日期与时间转换符）</td>\n<td align=\"left\"></td>\n</tr>\n</tbody></table>\n<p>测试代码：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static void main(String[] args) &#123;  </span><br><span class=\"line\">    String str=null;  </span><br><span class=\"line\">    str=String.format(&quot;Hi,%s&quot;, &quot;王力&quot;);  </span><br><span class=\"line\">    System.out.println(str);  </span><br><span class=\"line\">    str=String.format(&quot;Hi,%s:%s.%s&quot;, &quot;王南&quot;,&quot;王力&quot;,&quot;王张&quot;);            </span><br><span class=\"line\">    System.out.println(str);                           </span><br><span class=\"line\">    System.out.printf(&quot;字母a的大写是：%c %n&quot;, &#x27;A&#x27;);  </span><br><span class=\"line\">    System.out.printf(&quot;3&gt;7的结果是：%b %n&quot;, 3&gt;7);  </span><br><span class=\"line\">    System.out.printf(&quot;100的一半是：%d %n&quot;, 100/2);  </span><br><span class=\"line\">    System.out.printf(&quot;100的16进制数是：%x %n&quot;, 100);  </span><br><span class=\"line\">    System.out.printf(&quot;100的8进制数是：%o %n&quot;, 100);  </span><br><span class=\"line\">    System.out.printf(&quot;50元的书打8.5折扣是：%f 元%n&quot;, 50*0.85);  </span><br><span class=\"line\">    System.out.printf(&quot;上面价格的16进制数是：%a %n&quot;, 50*0.85);  </span><br><span class=\"line\">    System.out.printf(&quot;上面价格的指数表示：%e %n&quot;, 50*0.85);  </span><br><span class=\"line\">    System.out.printf(&quot;上面价格的指数和浮点数结果的长度较短的是：%g %n&quot;, 50*0.85);  </span><br><span class=\"line\">    System.out.printf(&quot;上面的折扣是%d%% %n&quot;, 85);  </span><br><span class=\"line\">    System.out.printf(&quot;字母A的散列码是：%h %n&quot;, &#x27;A&#x27;);  </span><br><span class=\"line\">&#125;  </span><br></pre></td></tr></table></figure>\n<p>输出结果:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Hi,王力  </span><br><span class=\"line\">Hi,王南:王力.王张  </span><br><span class=\"line\">字母a的大写是：A   </span><br><span class=\"line\">3&gt;7的结果是：false   </span><br><span class=\"line\">100的一半是：50   </span><br><span class=\"line\">100的16进制数是：64   </span><br><span class=\"line\">100的8进制数是：144   </span><br><span class=\"line\">50元的书打8.5折扣是：42.500000 元  </span><br><span class=\"line\">上面价格的16进制数是：0x1.54p5   </span><br><span class=\"line\">上面价格的指数表示：4.250000e+01   </span><br><span class=\"line\">上面价格的指数和浮点数结果的长度较短的是：42.5000   </span><br><span class=\"line\">上面的折扣是85%   </span><br><span class=\"line\">字母A的散列码是：41  </span><br></pre></td></tr></table></figure>\n<p>搭配转换符的标志，如图所示:</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">标志</th>\n<th align=\"left\">说明</th>\n<th align=\"left\">示例</th>\n<th align=\"left\">结果</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">+</td>\n<td align=\"left\">为正数或者负数添加符号</td>\n<td align=\"left\">(“%+d”,15)</td>\n<td align=\"left\">+15</td>\n</tr>\n<tr>\n<td align=\"left\">−</td>\n<td align=\"left\">左对齐</td>\n<td align=\"left\">(“%-5d”,15)</td>\n<td align=\"left\">15</td>\n</tr>\n<tr>\n<td align=\"left\">0</td>\n<td align=\"left\">数字前面补0</td>\n<td align=\"left\">(“%04d”, 99)</td>\n<td align=\"left\">0099</td>\n</tr>\n<tr>\n<td align=\"left\">空格</td>\n<td align=\"left\">在整数之前添加指定数量的空格</td>\n<td align=\"left\">(“% 4d”, 99)</td>\n<td align=\"left\">99</td>\n</tr>\n<tr>\n<td align=\"left\">,</td>\n<td align=\"left\">以“,”对数字分组</td>\n<td align=\"left\">(“%,f”, 9999.99)</td>\n<td align=\"left\">9,999.990000</td>\n</tr>\n<tr>\n<td align=\"left\">(</td>\n<td align=\"left\">使用括号包含负数</td>\n<td align=\"left\">(“%(f”, -99.99)</td>\n<td align=\"left\">(99.990000)</td>\n</tr>\n<tr>\n<td align=\"left\">#</td>\n<td align=\"left\">如果是浮点数则包含小数点，如果是16进制或8进制则添加0x或0</td>\n<td align=\"left\">(“%#x”, 99)</td>\n<td align=\"left\">0x63</td>\n</tr>\n<tr>\n<td align=\"left\"></td>\n<td align=\"left\"></td>\n<td align=\"left\">(“%#o”, 99)</td>\n<td align=\"left\">0143</td>\n</tr>\n<tr>\n<td align=\"left\">&lt;</td>\n<td align=\"left\">格式化前一个转换符所描述的参数</td>\n<td align=\"left\">(“%f和%&lt;3.2f”, 99.45)</td>\n<td align=\"left\">99.450000和99.45</td>\n</tr>\n<tr>\n<td align=\"left\">$</td>\n<td align=\"left\">被格式化的参数索引</td>\n<td align=\"left\">(“%1$d,%2$s”, 99,”abc”)</td>\n<td align=\"left\">99,abc</td>\n</tr>\n<tr>\n<td align=\"left\">测试代码：</td>\n<td align=\"left\"></td>\n<td align=\"left\"></td>\n<td align=\"left\"></td>\n</tr>\n</tbody></table>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static void main(String[] args) &#123;  </span><br><span class=\"line\">    String str=null;  </span><br><span class=\"line\">    //$使用  </span><br><span class=\"line\">    str=String.format(&quot;格式参数$的使用：%1$d,%2$s&quot;, 99,&quot;abc&quot;);             </span><br><span class=\"line\">    System.out.println(str);                       </span><br><span class=\"line\">    //+使用  </span><br><span class=\"line\">    System.out.printf(&quot;显示正负数的符号：%+d与%d%n&quot;, 99,-99);  </span><br><span class=\"line\">    //补O使用  </span><br><span class=\"line\">    System.out.printf(&quot;最牛的编号是：%03d%n&quot;, 7);  </span><br><span class=\"line\">    //空格使用  </span><br><span class=\"line\">    System.out.printf(&quot;Tab键的效果是：% 8d%n&quot;, 7);  </span><br><span class=\"line\">    //.使用  </span><br><span class=\"line\">    System.out.printf(&quot;整数分组的效果是：%,d%n&quot;, 9989997);  </span><br><span class=\"line\">    //空格和小数点后面个数  </span><br><span class=\"line\">    System.out.printf(&quot;一本书的价格是：% 50.5f元%n&quot;, 49.8);  </span><br><span class=\"line\">&#125;  </span><br></pre></td></tr></table></figure>\n<p>输出结果:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">格式参数$的使用：99,abc  </span><br><span class=\"line\">显示正负数的符号：+99与-99  </span><br><span class=\"line\">最牛的编号是：007  </span><br><span class=\"line\">Tab键的效果是：       7  </span><br><span class=\"line\">整数分组的效果是：9,989,997  </span><br><span class=\"line\">一本书的价格是：                                          49.80000元</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"日期和事件字符串格式化\"><a href=\"#日期和事件字符串格式化\" class=\"headerlink\" title=\"日期和事件字符串格式化\"></a>日期和事件字符串格式化</h2><p>在程序界面中经常需要显示时间和日期，但是其显示的 格式经常不尽人意，需要编写大量的代码经过各种算法才得到理想的日期与时间格式。字符串格式中还有%tx转换符没有详细介绍，它是专门用来格式化日期和时 间的。%tx转换符中的x代表另外的处理日期和时间格式的转换符，它们的组合能够将日期和时间格式化成多种格式。</p>\n<p>常见日期和时间组合的格式，如表所示。</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">转换符</th>\n<th align=\"left\">说明</th>\n<th align=\"left\">示例</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">c</td>\n<td align=\"left\">包括全部日期和时间信息</td>\n<td align=\"left\">星期六 十月 27 14:21:20 CST 2007</td>\n</tr>\n<tr>\n<td align=\"left\">F</td>\n<td align=\"left\">“年-月-日”格式</td>\n<td align=\"left\">2007-10-27</td>\n</tr>\n<tr>\n<td align=\"left\">D</td>\n<td align=\"left\">“月/日/年”格式</td>\n<td align=\"left\">10/27/07</td>\n</tr>\n<tr>\n<td align=\"left\">r</td>\n<td align=\"left\">“HH:MM:SS PM”格式（12时制）</td>\n<td align=\"left\">02:25:51 下午</td>\n</tr>\n<tr>\n<td align=\"left\">T</td>\n<td align=\"left\">“HH:MM:SS”格式（24时制）</td>\n<td align=\"left\">14:28:16</td>\n</tr>\n<tr>\n<td align=\"left\">R</td>\n<td align=\"left\">“HH:MM”格式（24时制）</td>\n<td align=\"left\">14:28</td>\n</tr>\n</tbody></table>\n<p>测试代码：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static void main(String[] args) &#123;  </span><br><span class=\"line\">    Date date=new Date();                                  </span><br><span class=\"line\">    //c的使用  </span><br><span class=\"line\">    System.out.printf(&quot;全部日期和时间信息：%tc%n&quot;,date);          </span><br><span class=\"line\">    //f的使用  </span><br><span class=\"line\">    System.out.printf(&quot;年-月-日格式：%tF%n&quot;,date);  </span><br><span class=\"line\">    //d的使用  </span><br><span class=\"line\">    System.out.printf(&quot;月/日/年格式：%tD%n&quot;,date);  </span><br><span class=\"line\">    //r的使用  </span><br><span class=\"line\">    System.out.printf(&quot;HH:MM:SS PM格式（12时制）：%tr%n&quot;,date);  </span><br><span class=\"line\">    //t的使用  </span><br><span class=\"line\">    System.out.printf(&quot;HH:MM:SS格式（24时制）：%tT%n&quot;,date);  </span><br><span class=\"line\">    //R的使用  </span><br><span class=\"line\">    System.out.printf(&quot;HH:MM格式（24时制）：%tR&quot;,date);  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>输出结果：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">全部日期和时间信息：星期一 九月 10 10:43:36 CST 2012  </span><br><span class=\"line\">年-月-日格式：2012-09-10  </span><br><span class=\"line\">月/日/年格式：09/10/12  </span><br><span class=\"line\">HH:MM:SS PM格式（12时制）：10:43:36 上午  </span><br><span class=\"line\">HH:MM:SS格式（24时制）：10:43:36  </span><br><span class=\"line\">HH:MM格式（24时制）：10:43  </span><br></pre></td></tr></table></figure>\n<p>定义日期格式的转换符可以使日期通过指定的转换符生成新字符串。这些日期转换符如图所示。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static void main(String[] args) &#123;  </span><br><span class=\"line\">    Date date=new Date();                                      </span><br><span class=\"line\">    //b的使用，月份简称  </span><br><span class=\"line\">    String str=String.format(Locale.US,&quot;英文月份简称：%tb&quot;,date);       </span><br><span class=\"line\">    System.out.println(str);                                                                              </span><br><span class=\"line\">    System.out.printf(&quot;本地月份简称：%tb%n&quot;,date);  </span><br><span class=\"line\">    //B的使用，月份全称  </span><br><span class=\"line\">    str=String.format(Locale.US,&quot;英文月份全称：%tB&quot;,date);  </span><br><span class=\"line\">    System.out.println(str);  </span><br><span class=\"line\">    System.out.printf(&quot;本地月份全称：%tB%n&quot;,date);  </span><br><span class=\"line\">    //a的使用，星期简称  </span><br><span class=\"line\">    str=String.format(Locale.US,&quot;英文星期的简称：%ta&quot;,date);  </span><br><span class=\"line\">    System.out.println(str);  </span><br><span class=\"line\">    //A的使用，星期全称  </span><br><span class=\"line\">    System.out.printf(&quot;本地星期的简称：%tA%n&quot;,date);  </span><br><span class=\"line\">    //C的使用，年前两位  </span><br><span class=\"line\">    System.out.printf(&quot;年的前两位数字（不足两位前面补0）：%tC%n&quot;,date);  </span><br><span class=\"line\">    //y的使用，年后两位  </span><br><span class=\"line\">    System.out.printf(&quot;年的后两位数字（不足两位前面补0）：%ty%n&quot;,date);  </span><br><span class=\"line\">    //j的使用，一年的天数  </span><br><span class=\"line\">    System.out.printf(&quot;一年中的天数（即年的第几天）：%tj%n&quot;,date);  </span><br><span class=\"line\">    //m的使用，月份  </span><br><span class=\"line\">    System.out.printf(&quot;两位数字的月份（不足两位前面补0）：%tm%n&quot;,date);  </span><br><span class=\"line\">    //d的使用，日（二位，不够补零）  </span><br><span class=\"line\">    System.out.printf(&quot;两位数字的日（不足两位前面补0）：%td%n&quot;,date);  </span><br><span class=\"line\">    //e的使用，日（一位不补零）  </span><br><span class=\"line\">    System.out.printf(&quot;月份的日（前面不补0）：%te&quot;,date);  </span><br><span class=\"line\">&#125;  </span><br></pre></td></tr></table></figure>\n<p>输出结果：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">英文月份简称：Sep  </span><br><span class=\"line\">本地月份简称：九月  </span><br><span class=\"line\">英文月份全称：September  </span><br><span class=\"line\">本地月份全称：九月  </span><br><span class=\"line\">英文星期的简称：Mon  </span><br><span class=\"line\">本地星期的简称：星期一  </span><br><span class=\"line\">年的前两位数字（不足两位前面补0）：20  </span><br><span class=\"line\">年的后两位数字（不足两位前面补0）：12  </span><br><span class=\"line\">一年中的天数（即年的第几天）：254  </span><br><span class=\"line\">两位数字的月份（不足两位前面补0）：09  </span><br><span class=\"line\">两位数字的日（不足两位前面补0）：10  </span><br><span class=\"line\">月份的日（前面不补0）：10  </span><br></pre></td></tr></table></figure>\n<p>和日期格式转换符相比，时间格式的转换符要更多、更精确。它可以将时间格式化成时、分、秒甚至时毫秒等单位。格式化时间字符串的转换符如图所示。</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">转换符</th>\n<th align=\"left\">说明</th>\n<th align=\"left\">示例</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">H</td>\n<td align=\"left\">2位数字24时制的小时（不足2位前面补0）</td>\n<td align=\"left\">15</td>\n</tr>\n<tr>\n<td align=\"left\">I</td>\n<td align=\"left\">2位数字12时制的小时（不足2位前面补0）</td>\n<td align=\"left\">03</td>\n</tr>\n<tr>\n<td align=\"left\">k</td>\n<td align=\"left\">2位数字24时制的小时（前面不补0）</td>\n<td align=\"left\">15</td>\n</tr>\n<tr>\n<td align=\"left\">l</td>\n<td align=\"left\">2位数字12时制的小时（前面不补0）</td>\n<td align=\"left\">3</td>\n</tr>\n<tr>\n<td align=\"left\">M</td>\n<td align=\"left\">2位数字的分钟（不足2位前面补0）</td>\n<td align=\"left\">03</td>\n</tr>\n<tr>\n<td align=\"left\">S</td>\n<td align=\"left\">2位数字的秒（不足2位前面补0）</td>\n<td align=\"left\">09</td>\n</tr>\n<tr>\n<td align=\"left\">L</td>\n<td align=\"left\">3位数字的毫秒（不足3位前面补0）</td>\n<td align=\"left\">015</td>\n</tr>\n<tr>\n<td align=\"left\">N</td>\n<td align=\"left\">9位数字的毫秒数（不足9位前面补0）</td>\n<td align=\"left\">562000000</td>\n</tr>\n<tr>\n<td align=\"left\">p</td>\n<td align=\"left\">小写字母的上午或下午标记</td>\n<td align=\"left\">中：下午</td>\n</tr>\n<tr>\n<td align=\"left\"></td>\n<td align=\"left\"></td>\n<td align=\"left\">英：pm</td>\n</tr>\n<tr>\n<td align=\"left\">z</td>\n<td align=\"left\">相对于GMT的RFC822时区的偏移量</td>\n<td align=\"left\">+0800</td>\n</tr>\n<tr>\n<td align=\"left\">Z</td>\n<td align=\"left\">时区缩写字符串</td>\n<td align=\"left\">CST</td>\n</tr>\n<tr>\n<td align=\"left\">s</td>\n<td align=\"left\">1970-1-1 00:00:00 到现在所经过的秒数</td>\n<td align=\"left\">1193468128</td>\n</tr>\n<tr>\n<td align=\"left\">Q</td>\n<td align=\"left\">1970-1-1 00:00:00 到现在所经过的毫秒数</td>\n<td align=\"left\">1193468128984</td>\n</tr>\n<tr>\n<td align=\"left\">示例：</td>\n<td align=\"left\"></td>\n<td align=\"left\"></td>\n</tr>\n</tbody></table>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static void main(String[] args) &#123;  </span><br><span class=\"line\">    Date date = new Date();  </span><br><span class=\"line\">    //H的使用  </span><br><span class=\"line\">    System.out.printf(&quot;2位数字24时制的小时（不足2位前面补0）:%tH%n&quot;, date);  </span><br><span class=\"line\">    //I的使用  </span><br><span class=\"line\">    System.out.printf(&quot;2位数字12时制的小时（不足2位前面补0）:%tI%n&quot;, date);  </span><br><span class=\"line\">    //k的使用  </span><br><span class=\"line\">    System.out.printf(&quot;2位数字24时制的小时（前面不补0）:%tk%n&quot;, date);  </span><br><span class=\"line\">    //l的使用  </span><br><span class=\"line\">    System.out.printf(&quot;2位数字12时制的小时（前面不补0）:%tl%n&quot;, date);  </span><br><span class=\"line\">    //M的使用  </span><br><span class=\"line\">    System.out.printf(&quot;2位数字的分钟（不足2位前面补0）:%tM%n&quot;, date);  </span><br><span class=\"line\">    //S的使用  </span><br><span class=\"line\">    System.out.printf(&quot;2位数字的秒（不足2位前面补0）:%tS%n&quot;, date);  </span><br><span class=\"line\">    //L的使用  </span><br><span class=\"line\">    System.out.printf(&quot;3位数字的毫秒（不足3位前面补0）:%tL%n&quot;, date);  </span><br><span class=\"line\">    //N的使用  </span><br><span class=\"line\">    System.out.printf(&quot;9位数字的毫秒数（不足9位前面补0）:%tN%n&quot;, date);  </span><br><span class=\"line\">    //p的使用  </span><br><span class=\"line\">    String str = String.format(Locale.US, &quot;小写字母的上午或下午标记(英)：%tp&quot;, date);  </span><br><span class=\"line\">    System.out.println(str);   </span><br><span class=\"line\">    System.out.printf(&quot;小写字母的上午或下午标记（中）：%tp%n&quot;, date);  </span><br><span class=\"line\">    //z的使用  </span><br><span class=\"line\">    System.out.printf(&quot;相对于GMT的RFC822时区的偏移量:%tz%n&quot;, date);  </span><br><span class=\"line\">    //Z的使用  </span><br><span class=\"line\">    System.out.printf(&quot;时区缩写字符串:%tZ%n&quot;, date);  </span><br><span class=\"line\">    //s的使用  </span><br><span class=\"line\">    System.out.printf(&quot;1970-1-1 00:00:00 到现在所经过的秒数：%ts%n&quot;, date);  </span><br><span class=\"line\">    //Q的使用  </span><br><span class=\"line\">    System.out.printf(&quot;1970-1-1 00:00:00 到现在所经过的毫秒数：%tQ%n&quot;, date);  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>输出结果：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2位数字24时制的小时（不足2位前面补0）:11  </span><br><span class=\"line\">2位数字12时制的小时（不足2位前面补0）:11  </span><br><span class=\"line\">2位数字24时制的小时（前面不补0）:11  </span><br><span class=\"line\">2位数字12时制的小时（前面不补0）:11  </span><br><span class=\"line\">2位数字的分钟（不足2位前面补0）:03  </span><br><span class=\"line\">2位数字的秒（不足2位前面补0）:52  </span><br><span class=\"line\">3位数字的毫秒（不足3位前面补0）:773  </span><br><span class=\"line\">9位数字的毫秒数（不足9位前面补0）:773000000  </span><br><span class=\"line\">小写字母的上午或下午标记(英)：am  </span><br><span class=\"line\">小写字母的上午或下午标记（中）：上午  </span><br><span class=\"line\">相对于GMT的RFC822时区的偏移量:+0800  </span><br><span class=\"line\">时区缩写字符串:CST  </span><br><span class=\"line\">1970-1-1 00:00:00 到现在所经过的秒数：1347246232  </span><br><span class=\"line\">1970-1-1 00:00:00 到现在所经过的毫秒数：1347246232773  </span><br></pre></td></tr></table></figure>\n\n<hr>\n<p><em>观点仅代表自己，期待你的留言。</em></p>\n"},{"title":"系统组成部分","date":"2021-08-26T02:10:29.000Z","_content":"\n## 核心主线功能\n- 会员端功能、管理端、运营端的业务功能\n- 远程化、便捷化、数据化\n## 会员体系\n- 会员星级\n- 会员权益\n## 金融体系\n- 钱包、充值、消费、即时支付\n- 对帐、报表、发票、退款\n## 物流体系\n- 取货：快捷高效、不掉包、不破损、透明\n- 处理\n- 送货：快捷、准确、透明\n## 库存体系\n- 进出库、盘点、预警\n- 对帐\n## 营销体系\n- 日常活动\n- 基于业务事件活动\n- 基于热点事件营销\n## 积分体系\n- 增长方式、消耗方式、衰减方式\n## 业态联合\n- 商城\n- 广告\n- 权益互换\n## 智能化\n- 无接触交易\n- 上门取送\n## 数字化\n- 会员画像、员工画像、物体画像\n- 库存预测、价格波动预测\n- 数字孪生\n\n\n-----\n\n*观点仅代表自己，期待你的留言。*\n","source":"_posts/system-main-fn.md","raw":"---\ntitle: 系统组成部分\ntags:\n  - 原创\ndate: 2021-08-26 10:10:29\n---\n\n## 核心主线功能\n- 会员端功能、管理端、运营端的业务功能\n- 远程化、便捷化、数据化\n## 会员体系\n- 会员星级\n- 会员权益\n## 金融体系\n- 钱包、充值、消费、即时支付\n- 对帐、报表、发票、退款\n## 物流体系\n- 取货：快捷高效、不掉包、不破损、透明\n- 处理\n- 送货：快捷、准确、透明\n## 库存体系\n- 进出库、盘点、预警\n- 对帐\n## 营销体系\n- 日常活动\n- 基于业务事件活动\n- 基于热点事件营销\n## 积分体系\n- 增长方式、消耗方式、衰减方式\n## 业态联合\n- 商城\n- 广告\n- 权益互换\n## 智能化\n- 无接触交易\n- 上门取送\n## 数字化\n- 会员画像、员工画像、物体画像\n- 库存预测、价格波动预测\n- 数字孪生\n\n\n-----\n\n*观点仅代表自己，期待你的留言。*\n","slug":"system-main-fn","published":1,"updated":"2021-09-01T02:11:45.297Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cku52dypn005bbbinfc25b2sh","content":"<h2 id=\"核心主线功能\"><a href=\"#核心主线功能\" class=\"headerlink\" title=\"核心主线功能\"></a>核心主线功能</h2><ul>\n<li>会员端功能、管理端、运营端的业务功能</li>\n<li>远程化、便捷化、数据化<h2 id=\"会员体系\"><a href=\"#会员体系\" class=\"headerlink\" title=\"会员体系\"></a>会员体系</h2></li>\n<li>会员星级</li>\n<li>会员权益<h2 id=\"金融体系\"><a href=\"#金融体系\" class=\"headerlink\" title=\"金融体系\"></a>金融体系</h2></li>\n<li>钱包、充值、消费、即时支付</li>\n<li>对帐、报表、发票、退款<h2 id=\"物流体系\"><a href=\"#物流体系\" class=\"headerlink\" title=\"物流体系\"></a>物流体系</h2></li>\n<li>取货：快捷高效、不掉包、不破损、透明</li>\n<li>处理</li>\n<li>送货：快捷、准确、透明<h2 id=\"库存体系\"><a href=\"#库存体系\" class=\"headerlink\" title=\"库存体系\"></a>库存体系</h2></li>\n<li>进出库、盘点、预警</li>\n<li>对帐<h2 id=\"营销体系\"><a href=\"#营销体系\" class=\"headerlink\" title=\"营销体系\"></a>营销体系</h2></li>\n<li>日常活动</li>\n<li>基于业务事件活动</li>\n<li>基于热点事件营销<h2 id=\"积分体系\"><a href=\"#积分体系\" class=\"headerlink\" title=\"积分体系\"></a>积分体系</h2></li>\n<li>增长方式、消耗方式、衰减方式<h2 id=\"业态联合\"><a href=\"#业态联合\" class=\"headerlink\" title=\"业态联合\"></a>业态联合</h2></li>\n<li>商城</li>\n<li>广告</li>\n<li>权益互换<h2 id=\"智能化\"><a href=\"#智能化\" class=\"headerlink\" title=\"智能化\"></a>智能化</h2></li>\n<li>无接触交易</li>\n<li>上门取送<h2 id=\"数字化\"><a href=\"#数字化\" class=\"headerlink\" title=\"数字化\"></a>数字化</h2></li>\n<li>会员画像、员工画像、物体画像</li>\n<li>库存预测、价格波动预测</li>\n<li>数字孪生</li>\n</ul>\n<hr>\n<p><em>观点仅代表自己，期待你的留言。</em></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"核心主线功能\"><a href=\"#核心主线功能\" class=\"headerlink\" title=\"核心主线功能\"></a>核心主线功能</h2><ul>\n<li>会员端功能、管理端、运营端的业务功能</li>\n<li>远程化、便捷化、数据化<h2 id=\"会员体系\"><a href=\"#会员体系\" class=\"headerlink\" title=\"会员体系\"></a>会员体系</h2></li>\n<li>会员星级</li>\n<li>会员权益<h2 id=\"金融体系\"><a href=\"#金融体系\" class=\"headerlink\" title=\"金融体系\"></a>金融体系</h2></li>\n<li>钱包、充值、消费、即时支付</li>\n<li>对帐、报表、发票、退款<h2 id=\"物流体系\"><a href=\"#物流体系\" class=\"headerlink\" title=\"物流体系\"></a>物流体系</h2></li>\n<li>取货：快捷高效、不掉包、不破损、透明</li>\n<li>处理</li>\n<li>送货：快捷、准确、透明<h2 id=\"库存体系\"><a href=\"#库存体系\" class=\"headerlink\" title=\"库存体系\"></a>库存体系</h2></li>\n<li>进出库、盘点、预警</li>\n<li>对帐<h2 id=\"营销体系\"><a href=\"#营销体系\" class=\"headerlink\" title=\"营销体系\"></a>营销体系</h2></li>\n<li>日常活动</li>\n<li>基于业务事件活动</li>\n<li>基于热点事件营销<h2 id=\"积分体系\"><a href=\"#积分体系\" class=\"headerlink\" title=\"积分体系\"></a>积分体系</h2></li>\n<li>增长方式、消耗方式、衰减方式<h2 id=\"业态联合\"><a href=\"#业态联合\" class=\"headerlink\" title=\"业态联合\"></a>业态联合</h2></li>\n<li>商城</li>\n<li>广告</li>\n<li>权益互换<h2 id=\"智能化\"><a href=\"#智能化\" class=\"headerlink\" title=\"智能化\"></a>智能化</h2></li>\n<li>无接触交易</li>\n<li>上门取送<h2 id=\"数字化\"><a href=\"#数字化\" class=\"headerlink\" title=\"数字化\"></a>数字化</h2></li>\n<li>会员画像、员工画像、物体画像</li>\n<li>库存预测、价格波动预测</li>\n<li>数字孪生</li>\n</ul>\n<hr>\n<p><em>观点仅代表自己，期待你的留言。</em></p>\n"},{"title":"科技公司","date":"2020-11-02T06:55:47.000Z","_content":"\n## 文章内容\n「科技公司」这个概念在今天已经变得有些泛滥，但回归到本质，它的底色应该是技术。而一家公司是否能被称为「科技公司」，最简单的判断应该是：它是否以技术解决了实际的问题、推动了商业或社会的进步。-- from洪偌馨\n\n「科技公司」定义标准：\n- 软件能够创造一个生态系统\n- 软件的边际成本为零\n- 软件随着时间的推移而不断改进\n- 软件能无限扩展（offers infinite leverage）\n- 软件能实现交易成本为零\n\n推进策略：\n拥抱变化，小步快跑，快速响应，快速迭代，谦虚心态，不断总结\n\n-----\n\n*观点仅代表自己，期待你的留言。*\n","source":"_posts/tech-company.md","raw":"---\ntitle: 科技公司\ntags:\n  - 原创\ndate: 2020-11-02 14:55:47\n---\n\n## 文章内容\n「科技公司」这个概念在今天已经变得有些泛滥，但回归到本质，它的底色应该是技术。而一家公司是否能被称为「科技公司」，最简单的判断应该是：它是否以技术解决了实际的问题、推动了商业或社会的进步。-- from洪偌馨\n\n「科技公司」定义标准：\n- 软件能够创造一个生态系统\n- 软件的边际成本为零\n- 软件随着时间的推移而不断改进\n- 软件能无限扩展（offers infinite leverage）\n- 软件能实现交易成本为零\n\n推进策略：\n拥抱变化，小步快跑，快速响应，快速迭代，谦虚心态，不断总结\n\n-----\n\n*观点仅代表自己，期待你的留言。*\n","slug":"tech-company","published":1,"updated":"2021-09-01T01:57:06.619Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cku52dypo005ebbinahirbpp9","content":"<h2 id=\"文章内容\"><a href=\"#文章内容\" class=\"headerlink\" title=\"文章内容\"></a>文章内容</h2><p>「科技公司」这个概念在今天已经变得有些泛滥，但回归到本质，它的底色应该是技术。而一家公司是否能被称为「科技公司」，最简单的判断应该是：它是否以技术解决了实际的问题、推动了商业或社会的进步。– from洪偌馨</p>\n<p>「科技公司」定义标准：</p>\n<ul>\n<li>软件能够创造一个生态系统</li>\n<li>软件的边际成本为零</li>\n<li>软件随着时间的推移而不断改进</li>\n<li>软件能无限扩展（offers infinite leverage）</li>\n<li>软件能实现交易成本为零</li>\n</ul>\n<p>推进策略：<br>拥抱变化，小步快跑，快速响应，快速迭代，谦虚心态，不断总结</p>\n<hr>\n<p><em>观点仅代表自己，期待你的留言。</em></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"文章内容\"><a href=\"#文章内容\" class=\"headerlink\" title=\"文章内容\"></a>文章内容</h2><p>「科技公司」这个概念在今天已经变得有些泛滥，但回归到本质，它的底色应该是技术。而一家公司是否能被称为「科技公司」，最简单的判断应该是：它是否以技术解决了实际的问题、推动了商业或社会的进步。– from洪偌馨</p>\n<p>「科技公司」定义标准：</p>\n<ul>\n<li>软件能够创造一个生态系统</li>\n<li>软件的边际成本为零</li>\n<li>软件随着时间的推移而不断改进</li>\n<li>软件能无限扩展（offers infinite leverage）</li>\n<li>软件能实现交易成本为零</li>\n</ul>\n<p>推进策略：<br>拥抱变化，小步快跑，快速响应，快速迭代，谦虚心态，不断总结</p>\n<hr>\n<p><em>观点仅代表自己，期待你的留言。</em></p>\n"},{"title":"ubuntu下thinkpad电池阀设置（待验证）","date":"2017-10-18T08:04:47.000Z","_content":"\n## 设置电池阀\nsudo add-apt-repository ppa:linrunner/tlp\nsudo apt-get update\n\nsudo apt-get install tlp tlp-rdw\nsudo apt-get install tp-smapi-dkms acpi-call-tools\n\nsudo gedit /etc/default/tlp\n\n# Main battery (values in %)\nSTART_CHARGE_THRESH_BAT0=10\nSTOP_CHARGE_THRESH_BAT0=96\n\n之后执行\n\nsudo tlp setcharge\n\n重启 OK 电池阀设置完成了\n\n## 查看电池阀设置\ntone@ubuntu:~$ sudo tlp-stat --battery\n--- TLP 0.4 --------------------------------------------\n\n\n+++ ThinkPad Extended Battery Functions\ntp-smapi = active\ntpacpi-bat = active\n\n\n+++ ThinkPad Battery Status (Main)\n/sys/devices/platform/smapi/BAT0/manufacturer = LGC\n/sys/devices/platform/smapi/BAT0/model = 42T4865\n/sys/devices/platform/smapi/BAT0/manufacture_date = 2011-11-24\n/sys/devices/platform/smapi/BAT0/first_use_date = 2012-04-13\n/sys/devices/platform/smapi/BAT0/cycle_count = 63\n/sys/devices/platform/smapi/BAT0/design_capacity = 62160 [mWh]\n/sys/devices/platform/smapi/BAT0/last_full_capacity = 59470 [mWh]\n/sys/devices/platform/smapi/BAT0/remaining_capacity = 42410 [mWh]\n/sys/devices/platform/smapi/BAT0/remaining_percent = 71 [%]\n/sys/devices/platform/smapi/BAT0/remaining_running_time_now = 189 [min]\n/sys/devices/platform/smapi/BAT0/remaining_charging_time = not_charging [min]\n/sys/devices/platform/smapi/BAT0/power_now = -13432 [mW]\n/sys/devices/platform/smapi/BAT0/power_avg = -12742 [mW]\n\n\ntpacpi-bat.BAT0.startThreshold = 10 [%]\ntpacpi-bat.BAT0.stopThreshold = 96 [%]\ntpacpi-bat.BAT0.forceDischarge = 0\n\n\n-----\n\n*观点仅代表自己，期待你的留言。*\n","source":"_posts/thinkpad-battery-limit.md","raw":"---\ntitle: ubuntu下thinkpad电池阀设置（待验证）\ntags:\n  - 笔记\ndate: 2017-10-18 16:04:47\n---\n\n## 设置电池阀\nsudo add-apt-repository ppa:linrunner/tlp\nsudo apt-get update\n\nsudo apt-get install tlp tlp-rdw\nsudo apt-get install tp-smapi-dkms acpi-call-tools\n\nsudo gedit /etc/default/tlp\n\n# Main battery (values in %)\nSTART_CHARGE_THRESH_BAT0=10\nSTOP_CHARGE_THRESH_BAT0=96\n\n之后执行\n\nsudo tlp setcharge\n\n重启 OK 电池阀设置完成了\n\n## 查看电池阀设置\ntone@ubuntu:~$ sudo tlp-stat --battery\n--- TLP 0.4 --------------------------------------------\n\n\n+++ ThinkPad Extended Battery Functions\ntp-smapi = active\ntpacpi-bat = active\n\n\n+++ ThinkPad Battery Status (Main)\n/sys/devices/platform/smapi/BAT0/manufacturer = LGC\n/sys/devices/platform/smapi/BAT0/model = 42T4865\n/sys/devices/platform/smapi/BAT0/manufacture_date = 2011-11-24\n/sys/devices/platform/smapi/BAT0/first_use_date = 2012-04-13\n/sys/devices/platform/smapi/BAT0/cycle_count = 63\n/sys/devices/platform/smapi/BAT0/design_capacity = 62160 [mWh]\n/sys/devices/platform/smapi/BAT0/last_full_capacity = 59470 [mWh]\n/sys/devices/platform/smapi/BAT0/remaining_capacity = 42410 [mWh]\n/sys/devices/platform/smapi/BAT0/remaining_percent = 71 [%]\n/sys/devices/platform/smapi/BAT0/remaining_running_time_now = 189 [min]\n/sys/devices/platform/smapi/BAT0/remaining_charging_time = not_charging [min]\n/sys/devices/platform/smapi/BAT0/power_now = -13432 [mW]\n/sys/devices/platform/smapi/BAT0/power_avg = -12742 [mW]\n\n\ntpacpi-bat.BAT0.startThreshold = 10 [%]\ntpacpi-bat.BAT0.stopThreshold = 96 [%]\ntpacpi-bat.BAT0.forceDischarge = 0\n\n\n-----\n\n*观点仅代表自己，期待你的留言。*\n","slug":"thinkpad-battery-limit","published":1,"updated":"2021-08-31T14:23:11.552Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cku52dypo005gbbingtx80prm","content":"<h2 id=\"设置电池阀\"><a href=\"#设置电池阀\" class=\"headerlink\" title=\"设置电池阀\"></a>设置电池阀</h2><p>sudo add-apt-repository ppa:linrunner/tlp<br>sudo apt-get update</p>\n<p>sudo apt-get install tlp tlp-rdw<br>sudo apt-get install tp-smapi-dkms acpi-call-tools</p>\n<p>sudo gedit /etc/default/tlp</p>\n<h1 id=\"Main-battery-values-in\"><a href=\"#Main-battery-values-in\" class=\"headerlink\" title=\"Main battery (values in %)\"></a>Main battery (values in %)</h1><p>START_CHARGE_THRESH_BAT0=10<br>STOP_CHARGE_THRESH_BAT0=96</p>\n<p>之后执行</p>\n<p>sudo tlp setcharge</p>\n<p>重启 OK 电池阀设置完成了</p>\n<h2 id=\"查看电池阀设置\"><a href=\"#查看电池阀设置\" class=\"headerlink\" title=\"查看电池阀设置\"></a>查看电池阀设置</h2><p>tone@ubuntu:~$ sudo tlp-stat –battery<br>— TLP 0.4 ——————————————–</p>\n<p>+++ ThinkPad Extended Battery Functions<br>tp-smapi = active<br>tpacpi-bat = active</p>\n<p>+++ ThinkPad Battery Status (Main)<br>/sys/devices/platform/smapi/BAT0/manufacturer = LGC<br>/sys/devices/platform/smapi/BAT0/model = 42T4865<br>/sys/devices/platform/smapi/BAT0/manufacture_date = 2011-11-24<br>/sys/devices/platform/smapi/BAT0/first_use_date = 2012-04-13<br>/sys/devices/platform/smapi/BAT0/cycle_count = 63<br>/sys/devices/platform/smapi/BAT0/design_capacity = 62160 [mWh]<br>/sys/devices/platform/smapi/BAT0/last_full_capacity = 59470 [mWh]<br>/sys/devices/platform/smapi/BAT0/remaining_capacity = 42410 [mWh]<br>/sys/devices/platform/smapi/BAT0/remaining_percent = 71 [%]<br>/sys/devices/platform/smapi/BAT0/remaining_running_time_now = 189 [min]<br>/sys/devices/platform/smapi/BAT0/remaining_charging_time = not_charging [min]<br>/sys/devices/platform/smapi/BAT0/power_now = -13432 [mW]<br>/sys/devices/platform/smapi/BAT0/power_avg = -12742 [mW]</p>\n<p>tpacpi-bat.BAT0.startThreshold = 10 [%]<br>tpacpi-bat.BAT0.stopThreshold = 96 [%]<br>tpacpi-bat.BAT0.forceDischarge = 0</p>\n<hr>\n<p><em>观点仅代表自己，期待你的留言。</em></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"设置电池阀\"><a href=\"#设置电池阀\" class=\"headerlink\" title=\"设置电池阀\"></a>设置电池阀</h2><p>sudo add-apt-repository ppa:linrunner/tlp<br>sudo apt-get update</p>\n<p>sudo apt-get install tlp tlp-rdw<br>sudo apt-get install tp-smapi-dkms acpi-call-tools</p>\n<p>sudo gedit /etc/default/tlp</p>\n<h1 id=\"Main-battery-values-in\"><a href=\"#Main-battery-values-in\" class=\"headerlink\" title=\"Main battery (values in %)\"></a>Main battery (values in %)</h1><p>START_CHARGE_THRESH_BAT0=10<br>STOP_CHARGE_THRESH_BAT0=96</p>\n<p>之后执行</p>\n<p>sudo tlp setcharge</p>\n<p>重启 OK 电池阀设置完成了</p>\n<h2 id=\"查看电池阀设置\"><a href=\"#查看电池阀设置\" class=\"headerlink\" title=\"查看电池阀设置\"></a>查看电池阀设置</h2><p>tone@ubuntu:~$ sudo tlp-stat –battery<br>— TLP 0.4 ——————————————–</p>\n<p>+++ ThinkPad Extended Battery Functions<br>tp-smapi = active<br>tpacpi-bat = active</p>\n<p>+++ ThinkPad Battery Status (Main)<br>/sys/devices/platform/smapi/BAT0/manufacturer = LGC<br>/sys/devices/platform/smapi/BAT0/model = 42T4865<br>/sys/devices/platform/smapi/BAT0/manufacture_date = 2011-11-24<br>/sys/devices/platform/smapi/BAT0/first_use_date = 2012-04-13<br>/sys/devices/platform/smapi/BAT0/cycle_count = 63<br>/sys/devices/platform/smapi/BAT0/design_capacity = 62160 [mWh]<br>/sys/devices/platform/smapi/BAT0/last_full_capacity = 59470 [mWh]<br>/sys/devices/platform/smapi/BAT0/remaining_capacity = 42410 [mWh]<br>/sys/devices/platform/smapi/BAT0/remaining_percent = 71 [%]<br>/sys/devices/platform/smapi/BAT0/remaining_running_time_now = 189 [min]<br>/sys/devices/platform/smapi/BAT0/remaining_charging_time = not_charging [min]<br>/sys/devices/platform/smapi/BAT0/power_now = -13432 [mW]<br>/sys/devices/platform/smapi/BAT0/power_avg = -12742 [mW]</p>\n<p>tpacpi-bat.BAT0.startThreshold = 10 [%]<br>tpacpi-bat.BAT0.stopThreshold = 96 [%]<br>tpacpi-bat.BAT0.forceDischarge = 0</p>\n<hr>\n<p><em>观点仅代表自己，期待你的留言。</em></p>\n"},{"title":"Nginx+tomcat+redis集群之session共享","date":"2016-03-17T03:32:15.000Z","_content":"## 实验环境\nCentOS7, Tomcat7(tomcat-1, tomcat-2), Nginx1.8.1, redis3.0.7\n## 安装redis与tomcat\n```\n[root@localhost ~]# wget http://download.redis.io/releases/redis-3.0.7.tar.gz\n[root@localhost ~]# wget http://mirror.nus.edu.sg/apache/tomcat/tomcat-7/v7.0.68/bin/apache-tomcat-7.0.68.tar.gz\n[root@localhost ~]# tar -xvf redis-3.0.7.tar.gz; cd redis-3.0.7\n[root@localhost redis-3.0.7]# make && make install\n[root@localhost redis-3.0.7]# redis-server & //运行redis服务\n[root@localhost ~]# tar -xvf apache-tomcat-7.0.68.tar.gz\n[root@localhost ~]# mv apache-tomcat-7.0.68 tomcat-1; cp -r tomcat-1 tomcat-2\n```\n在tomcat-1和tomcat-2的webapps/ROOT目录下新增一个名叫session.jsp的文件，内容如下：\n```\n<%@ page  %>\nTomcat1（tomcat-2中为Tomcat2） SessionId = <%=session.getId() %>\n```\n### 修改tomcat与nginx配置\n架设场景如下图：\n\n![架设场景](/images/nginx-tomcat-redis.png)\n\n* 修改tomcat端口(conf/server.xml) \n\ntomcat1：Server port=\"8105\"，Connector port=\"8081\"，ajp Connector port=\"8109\"\n\ntomcat2：Server port=\"8205\"，Connector port=\"8082\"，ajp Connector port=\"8209\"\n* 修改nginx配置，以随机访问的方式将请求引入后端的tomcat集群中\n```\nhttp {\n    upstream tomcat {\n       server 127.0.0.1:8081;\n       server 127.0.0.1:8082;\n    }\n    server {\n        listen       80;\n        server_name  localhost;\n        #charset koi8-r;\n        #access_log  logs/host.access.log  main;\n        location ~ .*\\.(do|jsp|action)?$ {\n            proxy_redirect          off;\n            proxy_set_header        Host            $host;\n            proxy_set_header        X-Real-IP       $remote_addr;\n            proxy_set_header        X-Forwarded-For $proxy_add_x_forwarded_for;\n            root   html;\n            index  index.html index.htm;\n            proxy_pass http://tomcat;\n        }\n        #配置Nginx动静分离，定义的静态页面直接从Nginx发布目录读取。\n        location ~ .*\\.(html|htm|gif|jpg|jpeg|bmp|png|ico|txt|js|css)$ {\n            root /data/;\n            gzip_static on; #开启压缩静态资源\n        }\n        \n        location / {\n            root   html;\n            index  index.html index.htm;\n        }\n    }\n}\n```\n然后访问http://10.28.10.218/session.jsp   可以看到服务器随机返回给我们两个tomcat的session页面。同时我们也可以看到SessionId在不停的变化。\n\n![Tomcat1的session.jsp](/images/QQ20160316-1.png)\n\n![Tomcat2的session.jsp](/images/QQ20160316-0.png)\n\n通过Nginx的监控页也可以看出请求被随机的转发到了tomcat中\n\n![Nginx的监控页](/images/QQ20160316-2.png)\n## 将tomcat的session都存储到redis中\n\nTomcat存储到Redis库项目地址：https://github.com/jcoleman/tomcat-redis-session-manager  \n从gradle配置上看，此项目还有三个依赖库。通过gradle进行编译，最终会自动从网络下载commons-pool,commons-pool2,jedis库并编译生成tomcat-redis-session-manager。\n```\ndependencies {\n  compile group: 'org.apache.tomcat', name: 'tomcat-catalina', version: '7.0.27'\n  compile group: 'redis.clients', name: 'jedis', version: '2.5.2'\n  compile group: 'org.apache.commons', name: 'commons-pool2', version: '2.2'\n  //compile group: 'commons-codec', name: 'commons-codec', version: '1.9'\n\n  testCompile group: 'junit', name: 'junit', version: '4.+'\n  testCompile 'org.hamcrest:hamcrest-core:1.3'\n  testCompile 'org.hamcrest:hamcrest-library:1.3'\n  testCompile 'org.mockito:mockito-all:1.9.5'\n  testCompile group: 'org.apache.tomcat', name: 'tomcat-coyote', version: '7.0.27'\n}\n```\n觉得麻烦的同学可以直接下载以下库，放入到tomcat/lib下：\n[commons-pool-1.5.5.jar](/libs/commons-pool-1.5.5.jar)\n[commons-pool2-2.2.jar](/libs/commons-pool2-2.2.jar)\n[jedis-2.0.0.jar](/libs/jedis-2.0.0.jar)\n[tomcat-redis-session-manager-1.2-tomcat-7-1.2.jar](/libs/tomcat-redis-session-manager-1.2-tomcat-7-1.2.jar)\n\n按tomcat-redis-session-manager在github上地址里的说明修改两个tomcat的context.xml（tomcat/conf/context.xml）增加存储配置\n```\n<Valve className=\"com.radiadesign.catalina.session.RedisSessionHandlerValve\" />\n<Manager className=\"com.radiadesign.catalina.session.RedisSessionManager\"\n         host=\"localhost\" <!-- optional: defaults to \"localhost\" -->\n         port=\"6379\" <!-- optional: defaults to \"6379\" -->\n         database=\"0\" <!-- optional: defaults to \"0\" -->\n         maxInactiveInterval=\"60\" <!-- optional: defaults to \"60\" (in seconds) -->\n         sessionPersistPolicies=\"PERSIST_POLICY_1,PERSIST_POLICY_2,..\" <!-- optional -->\n         sentinelMaster=\"SentinelMasterName\" <!-- optional -->\n         sentinels=\"sentinel-host-1:port,sentinel-host-2:port,..\" />\n```\n修改好配置后，启动tomcat-1和tomcat-2。再访问session.jsp时你会发现无论是从哪一个tomcat返回的页面同一个客户端的sessionID都是相同的，这就达到了session在集群tomcat下共享的目的。\n\n![](/images/QQ20160317-0.png)![](/images/QQ20160317-1.png)\n\n通过redis-cli命令连接到redis服务器，可以看到对应sessionID的数据已存储到了redis中。\n\n![](/images/QQ20160317-2.png)\n\n__提醒：session的超时时间由context.xml中的maxInactiveInterval配置，默认60秒__\n\n-----\n*观点仅代表自己，期待你的留言。*\n","source":"_posts/tomcat-redis-session.md","raw":"---\ntitle: Nginx+tomcat+redis集群之session共享\ntags:\n  - 原创\n  - Nginx\n  - tomcat\n  - redis\ndate: 2016-03-17 11:32:15\n---\n## 实验环境\nCentOS7, Tomcat7(tomcat-1, tomcat-2), Nginx1.8.1, redis3.0.7\n## 安装redis与tomcat\n```\n[root@localhost ~]# wget http://download.redis.io/releases/redis-3.0.7.tar.gz\n[root@localhost ~]# wget http://mirror.nus.edu.sg/apache/tomcat/tomcat-7/v7.0.68/bin/apache-tomcat-7.0.68.tar.gz\n[root@localhost ~]# tar -xvf redis-3.0.7.tar.gz; cd redis-3.0.7\n[root@localhost redis-3.0.7]# make && make install\n[root@localhost redis-3.0.7]# redis-server & //运行redis服务\n[root@localhost ~]# tar -xvf apache-tomcat-7.0.68.tar.gz\n[root@localhost ~]# mv apache-tomcat-7.0.68 tomcat-1; cp -r tomcat-1 tomcat-2\n```\n在tomcat-1和tomcat-2的webapps/ROOT目录下新增一个名叫session.jsp的文件，内容如下：\n```\n<%@ page  %>\nTomcat1（tomcat-2中为Tomcat2） SessionId = <%=session.getId() %>\n```\n### 修改tomcat与nginx配置\n架设场景如下图：\n\n![架设场景](/images/nginx-tomcat-redis.png)\n\n* 修改tomcat端口(conf/server.xml) \n\ntomcat1：Server port=\"8105\"，Connector port=\"8081\"，ajp Connector port=\"8109\"\n\ntomcat2：Server port=\"8205\"，Connector port=\"8082\"，ajp Connector port=\"8209\"\n* 修改nginx配置，以随机访问的方式将请求引入后端的tomcat集群中\n```\nhttp {\n    upstream tomcat {\n       server 127.0.0.1:8081;\n       server 127.0.0.1:8082;\n    }\n    server {\n        listen       80;\n        server_name  localhost;\n        #charset koi8-r;\n        #access_log  logs/host.access.log  main;\n        location ~ .*\\.(do|jsp|action)?$ {\n            proxy_redirect          off;\n            proxy_set_header        Host            $host;\n            proxy_set_header        X-Real-IP       $remote_addr;\n            proxy_set_header        X-Forwarded-For $proxy_add_x_forwarded_for;\n            root   html;\n            index  index.html index.htm;\n            proxy_pass http://tomcat;\n        }\n        #配置Nginx动静分离，定义的静态页面直接从Nginx发布目录读取。\n        location ~ .*\\.(html|htm|gif|jpg|jpeg|bmp|png|ico|txt|js|css)$ {\n            root /data/;\n            gzip_static on; #开启压缩静态资源\n        }\n        \n        location / {\n            root   html;\n            index  index.html index.htm;\n        }\n    }\n}\n```\n然后访问http://10.28.10.218/session.jsp   可以看到服务器随机返回给我们两个tomcat的session页面。同时我们也可以看到SessionId在不停的变化。\n\n![Tomcat1的session.jsp](/images/QQ20160316-1.png)\n\n![Tomcat2的session.jsp](/images/QQ20160316-0.png)\n\n通过Nginx的监控页也可以看出请求被随机的转发到了tomcat中\n\n![Nginx的监控页](/images/QQ20160316-2.png)\n## 将tomcat的session都存储到redis中\n\nTomcat存储到Redis库项目地址：https://github.com/jcoleman/tomcat-redis-session-manager  \n从gradle配置上看，此项目还有三个依赖库。通过gradle进行编译，最终会自动从网络下载commons-pool,commons-pool2,jedis库并编译生成tomcat-redis-session-manager。\n```\ndependencies {\n  compile group: 'org.apache.tomcat', name: 'tomcat-catalina', version: '7.0.27'\n  compile group: 'redis.clients', name: 'jedis', version: '2.5.2'\n  compile group: 'org.apache.commons', name: 'commons-pool2', version: '2.2'\n  //compile group: 'commons-codec', name: 'commons-codec', version: '1.9'\n\n  testCompile group: 'junit', name: 'junit', version: '4.+'\n  testCompile 'org.hamcrest:hamcrest-core:1.3'\n  testCompile 'org.hamcrest:hamcrest-library:1.3'\n  testCompile 'org.mockito:mockito-all:1.9.5'\n  testCompile group: 'org.apache.tomcat', name: 'tomcat-coyote', version: '7.0.27'\n}\n```\n觉得麻烦的同学可以直接下载以下库，放入到tomcat/lib下：\n[commons-pool-1.5.5.jar](/libs/commons-pool-1.5.5.jar)\n[commons-pool2-2.2.jar](/libs/commons-pool2-2.2.jar)\n[jedis-2.0.0.jar](/libs/jedis-2.0.0.jar)\n[tomcat-redis-session-manager-1.2-tomcat-7-1.2.jar](/libs/tomcat-redis-session-manager-1.2-tomcat-7-1.2.jar)\n\n按tomcat-redis-session-manager在github上地址里的说明修改两个tomcat的context.xml（tomcat/conf/context.xml）增加存储配置\n```\n<Valve className=\"com.radiadesign.catalina.session.RedisSessionHandlerValve\" />\n<Manager className=\"com.radiadesign.catalina.session.RedisSessionManager\"\n         host=\"localhost\" <!-- optional: defaults to \"localhost\" -->\n         port=\"6379\" <!-- optional: defaults to \"6379\" -->\n         database=\"0\" <!-- optional: defaults to \"0\" -->\n         maxInactiveInterval=\"60\" <!-- optional: defaults to \"60\" (in seconds) -->\n         sessionPersistPolicies=\"PERSIST_POLICY_1,PERSIST_POLICY_2,..\" <!-- optional -->\n         sentinelMaster=\"SentinelMasterName\" <!-- optional -->\n         sentinels=\"sentinel-host-1:port,sentinel-host-2:port,..\" />\n```\n修改好配置后，启动tomcat-1和tomcat-2。再访问session.jsp时你会发现无论是从哪一个tomcat返回的页面同一个客户端的sessionID都是相同的，这就达到了session在集群tomcat下共享的目的。\n\n![](/images/QQ20160317-0.png)![](/images/QQ20160317-1.png)\n\n通过redis-cli命令连接到redis服务器，可以看到对应sessionID的数据已存储到了redis中。\n\n![](/images/QQ20160317-2.png)\n\n__提醒：session的超时时间由context.xml中的maxInactiveInterval配置，默认60秒__\n\n-----\n*观点仅代表自己，期待你的留言。*\n","slug":"tomcat-redis-session","published":1,"updated":"2021-08-31T14:23:11.552Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cku52dypp005ibbin89mwdoqj","content":"<h2 id=\"实验环境\"><a href=\"#实验环境\" class=\"headerlink\" title=\"实验环境\"></a>实验环境</h2><p>CentOS7, Tomcat7(tomcat-1, tomcat-2), Nginx1.8.1, redis3.0.7</p>\n<h2 id=\"安装redis与tomcat\"><a href=\"#安装redis与tomcat\" class=\"headerlink\" title=\"安装redis与tomcat\"></a>安装redis与tomcat</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@localhost ~]# wget http://download.redis.io/releases/redis-3.0.7.tar.gz</span><br><span class=\"line\">[root@localhost ~]# wget http://mirror.nus.edu.sg/apache/tomcat/tomcat-7/v7.0.68/bin/apache-tomcat-7.0.68.tar.gz</span><br><span class=\"line\">[root@localhost ~]# tar -xvf redis-3.0.7.tar.gz; cd redis-3.0.7</span><br><span class=\"line\">[root@localhost redis-3.0.7]# make &amp;&amp; make install</span><br><span class=\"line\">[root@localhost redis-3.0.7]# redis-server &amp; //运行redis服务</span><br><span class=\"line\">[root@localhost ~]# tar -xvf apache-tomcat-7.0.68.tar.gz</span><br><span class=\"line\">[root@localhost ~]# mv apache-tomcat-7.0.68 tomcat-1; cp -r tomcat-1 tomcat-2</span><br></pre></td></tr></table></figure>\n<p>在tomcat-1和tomcat-2的webapps/ROOT目录下新增一个名叫session.jsp的文件，内容如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;%@ page  %&gt;</span><br><span class=\"line\">Tomcat1（tomcat-2中为Tomcat2） SessionId = &lt;%=session.getId() %&gt;</span><br></pre></td></tr></table></figure>\n<h3 id=\"修改tomcat与nginx配置\"><a href=\"#修改tomcat与nginx配置\" class=\"headerlink\" title=\"修改tomcat与nginx配置\"></a>修改tomcat与nginx配置</h3><p>架设场景如下图：</p>\n<p><img src=\"/images/nginx-tomcat-redis.png\" alt=\"架设场景\"></p>\n<ul>\n<li>修改tomcat端口(conf/server.xml) </li>\n</ul>\n<p>tomcat1：Server port=”8105”，Connector port=”8081”，ajp Connector port=”8109”</p>\n<p>tomcat2：Server port=”8205”，Connector port=”8082”，ajp Connector port=”8209”</p>\n<ul>\n<li>修改nginx配置，以随机访问的方式将请求引入后端的tomcat集群中<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">http &#123;</span><br><span class=\"line\">    upstream tomcat &#123;</span><br><span class=\"line\">       server 127.0.0.1:8081;</span><br><span class=\"line\">       server 127.0.0.1:8082;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    server &#123;</span><br><span class=\"line\">        listen       80;</span><br><span class=\"line\">        server_name  localhost;</span><br><span class=\"line\">        #charset koi8-r;</span><br><span class=\"line\">        #access_log  logs/host.access.log  main;</span><br><span class=\"line\">        location ~ .*\\.(do|jsp|action)?$ &#123;</span><br><span class=\"line\">            proxy_redirect          off;</span><br><span class=\"line\">            proxy_set_header        Host            $host;</span><br><span class=\"line\">            proxy_set_header        X-Real-IP       $remote_addr;</span><br><span class=\"line\">            proxy_set_header        X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class=\"line\">            root   html;</span><br><span class=\"line\">            index  index.html index.htm;</span><br><span class=\"line\">            proxy_pass http://tomcat;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        #配置Nginx动静分离，定义的静态页面直接从Nginx发布目录读取。</span><br><span class=\"line\">        location ~ .*\\.(html|htm|gif|jpg|jpeg|bmp|png|ico|txt|js|css)$ &#123;</span><br><span class=\"line\">            root /data/;</span><br><span class=\"line\">            gzip_static on; #开启压缩静态资源</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        location / &#123;</span><br><span class=\"line\">            root   html;</span><br><span class=\"line\">            index  index.html index.htm;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n然后访问<a href=\"http://10.28.10.218/session.jsp\">http://10.28.10.218/session.jsp</a>   可以看到服务器随机返回给我们两个tomcat的session页面。同时我们也可以看到SessionId在不停的变化。</li>\n</ul>\n<p><img src=\"/images/QQ20160316-1.png\" alt=\"Tomcat1的session.jsp\"></p>\n<p><img src=\"/images/QQ20160316-0.png\" alt=\"Tomcat2的session.jsp\"></p>\n<p>通过Nginx的监控页也可以看出请求被随机的转发到了tomcat中</p>\n<p><img src=\"/images/QQ20160316-2.png\" alt=\"Nginx的监控页\"></p>\n<h2 id=\"将tomcat的session都存储到redis中\"><a href=\"#将tomcat的session都存储到redis中\" class=\"headerlink\" title=\"将tomcat的session都存储到redis中\"></a>将tomcat的session都存储到redis中</h2><p>Tomcat存储到Redis库项目地址：<a href=\"https://github.com/jcoleman/tomcat-redis-session-manager\">https://github.com/jcoleman/tomcat-redis-session-manager</a><br>从gradle配置上看，此项目还有三个依赖库。通过gradle进行编译，最终会自动从网络下载commons-pool,commons-pool2,jedis库并编译生成tomcat-redis-session-manager。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dependencies &#123;</span><br><span class=\"line\">  compile group: &#x27;org.apache.tomcat&#x27;, name: &#x27;tomcat-catalina&#x27;, version: &#x27;7.0.27&#x27;</span><br><span class=\"line\">  compile group: &#x27;redis.clients&#x27;, name: &#x27;jedis&#x27;, version: &#x27;2.5.2&#x27;</span><br><span class=\"line\">  compile group: &#x27;org.apache.commons&#x27;, name: &#x27;commons-pool2&#x27;, version: &#x27;2.2&#x27;</span><br><span class=\"line\">  //compile group: &#x27;commons-codec&#x27;, name: &#x27;commons-codec&#x27;, version: &#x27;1.9&#x27;</span><br><span class=\"line\"></span><br><span class=\"line\">  testCompile group: &#x27;junit&#x27;, name: &#x27;junit&#x27;, version: &#x27;4.+&#x27;</span><br><span class=\"line\">  testCompile &#x27;org.hamcrest:hamcrest-core:1.3&#x27;</span><br><span class=\"line\">  testCompile &#x27;org.hamcrest:hamcrest-library:1.3&#x27;</span><br><span class=\"line\">  testCompile &#x27;org.mockito:mockito-all:1.9.5&#x27;</span><br><span class=\"line\">  testCompile group: &#x27;org.apache.tomcat&#x27;, name: &#x27;tomcat-coyote&#x27;, version: &#x27;7.0.27&#x27;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>觉得麻烦的同学可以直接下载以下库，放入到tomcat/lib下：<br><a href=\"/libs/commons-pool-1.5.5.jar\">commons-pool-1.5.5.jar</a><br><a href=\"/libs/commons-pool2-2.2.jar\">commons-pool2-2.2.jar</a><br><a href=\"/libs/jedis-2.0.0.jar\">jedis-2.0.0.jar</a><br><a href=\"/libs/tomcat-redis-session-manager-1.2-tomcat-7-1.2.jar\">tomcat-redis-session-manager-1.2-tomcat-7-1.2.jar</a></p>\n<p>按tomcat-redis-session-manager在github上地址里的说明修改两个tomcat的context.xml（tomcat/conf/context.xml）增加存储配置</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;Valve className=&quot;com.radiadesign.catalina.session.RedisSessionHandlerValve&quot; /&gt;</span><br><span class=\"line\">&lt;Manager className=&quot;com.radiadesign.catalina.session.RedisSessionManager&quot;</span><br><span class=\"line\">         host=&quot;localhost&quot; &lt;!-- optional: defaults to &quot;localhost&quot; --&gt;</span><br><span class=\"line\">         port=&quot;6379&quot; &lt;!-- optional: defaults to &quot;6379&quot; --&gt;</span><br><span class=\"line\">         database=&quot;0&quot; &lt;!-- optional: defaults to &quot;0&quot; --&gt;</span><br><span class=\"line\">         maxInactiveInterval=&quot;60&quot; &lt;!-- optional: defaults to &quot;60&quot; (in seconds) --&gt;</span><br><span class=\"line\">         sessionPersistPolicies=&quot;PERSIST_POLICY_1,PERSIST_POLICY_2,..&quot; &lt;!-- optional --&gt;</span><br><span class=\"line\">         sentinelMaster=&quot;SentinelMasterName&quot; &lt;!-- optional --&gt;</span><br><span class=\"line\">         sentinels=&quot;sentinel-host-1:port,sentinel-host-2:port,..&quot; /&gt;</span><br></pre></td></tr></table></figure>\n<p>修改好配置后，启动tomcat-1和tomcat-2。再访问session.jsp时你会发现无论是从哪一个tomcat返回的页面同一个客户端的sessionID都是相同的，这就达到了session在集群tomcat下共享的目的。</p>\n<p><img src=\"/images/QQ20160317-0.png\"><img src=\"/images/QQ20160317-1.png\"></p>\n<p>通过redis-cli命令连接到redis服务器，可以看到对应sessionID的数据已存储到了redis中。</p>\n<p><img src=\"/images/QQ20160317-2.png\"></p>\n<p><strong>提醒：session的超时时间由context.xml中的maxInactiveInterval配置，默认60秒</strong></p>\n<hr>\n<p><em>观点仅代表自己，期待你的留言。</em></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"实验环境\"><a href=\"#实验环境\" class=\"headerlink\" title=\"实验环境\"></a>实验环境</h2><p>CentOS7, Tomcat7(tomcat-1, tomcat-2), Nginx1.8.1, redis3.0.7</p>\n<h2 id=\"安装redis与tomcat\"><a href=\"#安装redis与tomcat\" class=\"headerlink\" title=\"安装redis与tomcat\"></a>安装redis与tomcat</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@localhost ~]# wget http://download.redis.io/releases/redis-3.0.7.tar.gz</span><br><span class=\"line\">[root@localhost ~]# wget http://mirror.nus.edu.sg/apache/tomcat/tomcat-7/v7.0.68/bin/apache-tomcat-7.0.68.tar.gz</span><br><span class=\"line\">[root@localhost ~]# tar -xvf redis-3.0.7.tar.gz; cd redis-3.0.7</span><br><span class=\"line\">[root@localhost redis-3.0.7]# make &amp;&amp; make install</span><br><span class=\"line\">[root@localhost redis-3.0.7]# redis-server &amp; //运行redis服务</span><br><span class=\"line\">[root@localhost ~]# tar -xvf apache-tomcat-7.0.68.tar.gz</span><br><span class=\"line\">[root@localhost ~]# mv apache-tomcat-7.0.68 tomcat-1; cp -r tomcat-1 tomcat-2</span><br></pre></td></tr></table></figure>\n<p>在tomcat-1和tomcat-2的webapps/ROOT目录下新增一个名叫session.jsp的文件，内容如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;%@ page  %&gt;</span><br><span class=\"line\">Tomcat1（tomcat-2中为Tomcat2） SessionId = &lt;%=session.getId() %&gt;</span><br></pre></td></tr></table></figure>\n<h3 id=\"修改tomcat与nginx配置\"><a href=\"#修改tomcat与nginx配置\" class=\"headerlink\" title=\"修改tomcat与nginx配置\"></a>修改tomcat与nginx配置</h3><p>架设场景如下图：</p>\n<p><img src=\"/images/nginx-tomcat-redis.png\" alt=\"架设场景\"></p>\n<ul>\n<li>修改tomcat端口(conf/server.xml) </li>\n</ul>\n<p>tomcat1：Server port=”8105”，Connector port=”8081”，ajp Connector port=”8109”</p>\n<p>tomcat2：Server port=”8205”，Connector port=”8082”，ajp Connector port=”8209”</p>\n<ul>\n<li>修改nginx配置，以随机访问的方式将请求引入后端的tomcat集群中<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">http &#123;</span><br><span class=\"line\">    upstream tomcat &#123;</span><br><span class=\"line\">       server 127.0.0.1:8081;</span><br><span class=\"line\">       server 127.0.0.1:8082;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    server &#123;</span><br><span class=\"line\">        listen       80;</span><br><span class=\"line\">        server_name  localhost;</span><br><span class=\"line\">        #charset koi8-r;</span><br><span class=\"line\">        #access_log  logs/host.access.log  main;</span><br><span class=\"line\">        location ~ .*\\.(do|jsp|action)?$ &#123;</span><br><span class=\"line\">            proxy_redirect          off;</span><br><span class=\"line\">            proxy_set_header        Host            $host;</span><br><span class=\"line\">            proxy_set_header        X-Real-IP       $remote_addr;</span><br><span class=\"line\">            proxy_set_header        X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class=\"line\">            root   html;</span><br><span class=\"line\">            index  index.html index.htm;</span><br><span class=\"line\">            proxy_pass http://tomcat;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        #配置Nginx动静分离，定义的静态页面直接从Nginx发布目录读取。</span><br><span class=\"line\">        location ~ .*\\.(html|htm|gif|jpg|jpeg|bmp|png|ico|txt|js|css)$ &#123;</span><br><span class=\"line\">            root /data/;</span><br><span class=\"line\">            gzip_static on; #开启压缩静态资源</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        location / &#123;</span><br><span class=\"line\">            root   html;</span><br><span class=\"line\">            index  index.html index.htm;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n然后访问<a href=\"http://10.28.10.218/session.jsp\">http://10.28.10.218/session.jsp</a>   可以看到服务器随机返回给我们两个tomcat的session页面。同时我们也可以看到SessionId在不停的变化。</li>\n</ul>\n<p><img src=\"/images/QQ20160316-1.png\" alt=\"Tomcat1的session.jsp\"></p>\n<p><img src=\"/images/QQ20160316-0.png\" alt=\"Tomcat2的session.jsp\"></p>\n<p>通过Nginx的监控页也可以看出请求被随机的转发到了tomcat中</p>\n<p><img src=\"/images/QQ20160316-2.png\" alt=\"Nginx的监控页\"></p>\n<h2 id=\"将tomcat的session都存储到redis中\"><a href=\"#将tomcat的session都存储到redis中\" class=\"headerlink\" title=\"将tomcat的session都存储到redis中\"></a>将tomcat的session都存储到redis中</h2><p>Tomcat存储到Redis库项目地址：<a href=\"https://github.com/jcoleman/tomcat-redis-session-manager\">https://github.com/jcoleman/tomcat-redis-session-manager</a><br>从gradle配置上看，此项目还有三个依赖库。通过gradle进行编译，最终会自动从网络下载commons-pool,commons-pool2,jedis库并编译生成tomcat-redis-session-manager。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dependencies &#123;</span><br><span class=\"line\">  compile group: &#x27;org.apache.tomcat&#x27;, name: &#x27;tomcat-catalina&#x27;, version: &#x27;7.0.27&#x27;</span><br><span class=\"line\">  compile group: &#x27;redis.clients&#x27;, name: &#x27;jedis&#x27;, version: &#x27;2.5.2&#x27;</span><br><span class=\"line\">  compile group: &#x27;org.apache.commons&#x27;, name: &#x27;commons-pool2&#x27;, version: &#x27;2.2&#x27;</span><br><span class=\"line\">  //compile group: &#x27;commons-codec&#x27;, name: &#x27;commons-codec&#x27;, version: &#x27;1.9&#x27;</span><br><span class=\"line\"></span><br><span class=\"line\">  testCompile group: &#x27;junit&#x27;, name: &#x27;junit&#x27;, version: &#x27;4.+&#x27;</span><br><span class=\"line\">  testCompile &#x27;org.hamcrest:hamcrest-core:1.3&#x27;</span><br><span class=\"line\">  testCompile &#x27;org.hamcrest:hamcrest-library:1.3&#x27;</span><br><span class=\"line\">  testCompile &#x27;org.mockito:mockito-all:1.9.5&#x27;</span><br><span class=\"line\">  testCompile group: &#x27;org.apache.tomcat&#x27;, name: &#x27;tomcat-coyote&#x27;, version: &#x27;7.0.27&#x27;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>觉得麻烦的同学可以直接下载以下库，放入到tomcat/lib下：<br><a href=\"/libs/commons-pool-1.5.5.jar\">commons-pool-1.5.5.jar</a><br><a href=\"/libs/commons-pool2-2.2.jar\">commons-pool2-2.2.jar</a><br><a href=\"/libs/jedis-2.0.0.jar\">jedis-2.0.0.jar</a><br><a href=\"/libs/tomcat-redis-session-manager-1.2-tomcat-7-1.2.jar\">tomcat-redis-session-manager-1.2-tomcat-7-1.2.jar</a></p>\n<p>按tomcat-redis-session-manager在github上地址里的说明修改两个tomcat的context.xml（tomcat/conf/context.xml）增加存储配置</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;Valve className=&quot;com.radiadesign.catalina.session.RedisSessionHandlerValve&quot; /&gt;</span><br><span class=\"line\">&lt;Manager className=&quot;com.radiadesign.catalina.session.RedisSessionManager&quot;</span><br><span class=\"line\">         host=&quot;localhost&quot; &lt;!-- optional: defaults to &quot;localhost&quot; --&gt;</span><br><span class=\"line\">         port=&quot;6379&quot; &lt;!-- optional: defaults to &quot;6379&quot; --&gt;</span><br><span class=\"line\">         database=&quot;0&quot; &lt;!-- optional: defaults to &quot;0&quot; --&gt;</span><br><span class=\"line\">         maxInactiveInterval=&quot;60&quot; &lt;!-- optional: defaults to &quot;60&quot; (in seconds) --&gt;</span><br><span class=\"line\">         sessionPersistPolicies=&quot;PERSIST_POLICY_1,PERSIST_POLICY_2,..&quot; &lt;!-- optional --&gt;</span><br><span class=\"line\">         sentinelMaster=&quot;SentinelMasterName&quot; &lt;!-- optional --&gt;</span><br><span class=\"line\">         sentinels=&quot;sentinel-host-1:port,sentinel-host-2:port,..&quot; /&gt;</span><br></pre></td></tr></table></figure>\n<p>修改好配置后，启动tomcat-1和tomcat-2。再访问session.jsp时你会发现无论是从哪一个tomcat返回的页面同一个客户端的sessionID都是相同的，这就达到了session在集群tomcat下共享的目的。</p>\n<p><img src=\"/images/QQ20160317-0.png\"><img src=\"/images/QQ20160317-1.png\"></p>\n<p>通过redis-cli命令连接到redis服务器，可以看到对应sessionID的数据已存储到了redis中。</p>\n<p><img src=\"/images/QQ20160317-2.png\"></p>\n<p><strong>提醒：session的超时时间由context.xml中的maxInactiveInterval配置，默认60秒</strong></p>\n<hr>\n<p><em>观点仅代表自己，期待你的留言。</em></p>\n"},{"title":"分布式下数据事务","keywords":["数据库事务","CAP","ACID","BASE","最终一致性"],"list_number":false,"date":"2017-09-18T07:13:57.000Z","_content":"\n## 一、概念\n### 1、CAP定律\n__Consistency(一致性)：__ 数据一致更新，针对集群内所有节点数据变动都是同步完成。\n__Availability(可用性)：__ 在集群中一部分节点故障后，集群整体是否还能响应客户端的读写请求。\n__Partition tolerance(分区容错性)：__ 以实际效果而言，分区相当于对通信的时限要求。系统如果不能在时限内达成数据一致性，就意味着发生了分区的情况，必须就当前操作在C和A之间做出选择。\n\nIt states, that though its desirable to have Consistency, High-Availability and Partition-tolerance in every system, unfortunately no system can achieve all three at the same time.\n在分布式系统的设计中，没有一种设计可以同时满足一致性，可用性，分区容错性 3个特性\n\n![CAP定制](/images/cap-theorem.png)\n\n### 2、ACID模型\n__Atomicity(原子性)：__ 事务作为一个整体被执行，包含在其中的对数据库的操作要么全部被执行，要么都不执行。\n__Consistency(一致性)：__ 事务应确保数据库的状态从一个一致状态转变为另一个一致状态。一致状态的含义是数据库中的数据应满足完整性约束。\n__Isolation(隔离性)：__ 多个事务并发执行时，一个事务的执行不应影响其他事务的执行。\n__Durability(持久性)：__ 一个事务一旦提交，他对数据库的修改应该永久保存在数据库中。\n\n### 3、BASE模型（反ACID模型）\n__Basically Available（基本可用）：__ 基本可用是指分布式系统在出现不可预知故障的时候，允许损失部分可用性。\n__Soft state（软状态）：__ 软状态和硬状态相对，是指允许系统中的数据存在中间状态，并认为该中间状态的存在不会影响系统的整体可用性，数据更改时允许集群的不同节点有一段时间进行数据状态同步。\n__Eventually consistent（最终一致性）：__ 事务处理过程中，会有短暂不一致的情况，但通过恢复系统，可以让事务的数据达到最终一致的目标。\n\n## 二、强一致性解决方案\n### 1、2PC (二阶段提交)\n__算法思路：__ 参与者将操作成败通知协调者，再由协调者根据所有参与者的反馈情报决定各参与者是否要提交操作还是中止操作。\n__XA协议：__ XA是一个分布式事务协议，由Tuxedo提出。XA中大致分为两部分：事务管理器(Transaction Manager)和本地资源管理器(Local Resource Manager)。其中本地资源管理器往往由数据库实现，比如Oracle、DB2这些商业数据库都实现了XA接口，而事务管理器作为全局的调度者，负责各个本地资源的提交和回滚。\n\n![X/Open DTP模型](/images/xopen-dtp.gif)\n\n__二阶段：__\n1. 准备阶段： 事务协调者(事务管理器)给每个参与者(资源管理器)发送Prepare消息，每个参与者要么直接返回失败(如权限验证失败)，要么在本地执行事务，写本地的redo和undo日志，但不提交本地事务。\n2. 提交阶段： 如果协调者收到了参与者的失败消息或者超时，直接给每个参与者发送回滚(Rollback)消息；否则，发送提交(Commit)消息；参与者根据协调者的指令执行提交或者回滚操作，释放所有事务处理过程中使用的锁资源。(注意:必须在最后阶段释放锁资源)\n\n__缺点:__\n1. 同步阻塞问题。执行过程中，所有参与节点都是事务阻塞型的。当参与者占有公共资源时，其他第三方节点访问公共资源不得不处于阻塞状态。\n2. 单点故障。由于协调者的重要性，一旦协调者发生故障。参与者会一直阻塞下去。尤其在第二阶段，协调者发生故障，那么所有的参与者还都处于锁定事务资源的状态中，而无法继续完成事务操作。（如果是协调者挂掉，可以重新选举一个协调者，但是无法解决因为协调者宕机导致的参与者处于阻塞状态的问题）\n3. 数据不一致。在二阶段提交的阶段二中，当协调者向参与者发送commit请求之后，发生了局部网络异常或者在发送commit请求过程中协调者发生了故障，这回导致只有一部分参与者接受到了commit请求。而在这部分参与者接到commit请求之后就会执行commit操作。但是其他部分未接到commit请求的机器则无法执行事务提交。于是整个分布式系统便出现了数据部一致性的现象。\n4. 二阶段无法解决的问题：协调者再发出commit消息之后宕机，而唯一接收到这条消息的参与者同时也宕机了。那么即使协调者通过选举协议产生了新的协调者，这条事务的状态也是不确定的，没人知道事务是否被已经提交。\n\n### 2、3PC (三阶段提交)\n与两阶段提交不同的是，三阶段(CanCommit、PreCommit、DoCommit)提交有两个改动点:\n1. 引入超时机制。同时在协调者和参与者中都引入超时机制。\n2. 在第一阶段和第二阶段中插入一个准备阶段。保证了在最后提交阶段之前各参与节点的状态是一致的。\n\n__CanCommit阶段：__ 3PC的CanCommit阶段其实和2PC的准备阶段很像。协调者向参与者发送commit请求，参与者如果可以提交就返回Yes响应，否则返回No响应。\n__PreCommit阶段：__ 协调者根据参与者的反应情况来决定是否可以继续事务的PreCommit操作。如果参与者执行完本地事务操作则返回YES，假如有任何一个参与者向协调者发送了No响应，或者等待超时之后，协调者都没有接到参与者的响应，那么就执行事务的中断。\n__doCommit阶段：__ 该阶段由协调者通知参与者的PreCommit阶段反馈进行判断，最终决定是真正的事务提交，还是执行事务回滚。\n\n__缺点:__\n在doCommit阶段，如果参与者无法及时接收到来自协调者的doCommit或者rebort请求时，会在等待超时之后，会继续进行事务的提交。（其实这个应该是基于概率来决定的，当进入第三阶段时，说明参与者在第二阶段已经收到了PreCommit请求，那么协调者产生PreCommit请求的前提条件是他在第二阶段开始之前，收到所有参与者的CanCommit响应都是Yes。（一旦参与者收到了PreCommit，意味他知道大家其实都同意修改了）所以，一句话概括就是，当进入第三阶段时，由于网络超时等原因，虽然参与者没有收到commit或者abort响应，但是他有理由相信：成功提交的几率很大。 ）\n\n### 3、Paxos算法\n  待补充\n\n## 三、最终一致性解决方案\n### 1、本地消息表\n__设计思想：__ 是将远程分布式事务拆分成一系列的本地事务。借助关系型数据库中的表即可实现。\n__集群节点同步：__ 定时扫描本地消息表，将需要同步状态的消息产生MQ消息通过向时效性高的MQ放入消息，再由其它集群节点消费该消息完成通知，通过消息消费状态表来避免MQ消息的重复消费。\n\n### 2、RocketMQ（事务消息）\n以网传处理流程为例进行说明\n![](/images/rmq-1.png)\n说明：\n1、当第3步confirmB失败时，则交由RMQ定时调用checkTransaction进行处理结果的检测，如果为失败，则rollback,否则发送消息到B账户。\n2、当第5步consumeB失败时，则交由RMQ定时进行重试，但需要设置最大重试次数，如果达到最大次数依然失败，则需要人工介入进行修正。\n\n所以RMQ需要一个人工修正的控制台，当系统通过重试无法进行修正时以人工做为做终的修正手段来做保障最终事务一致性。\n\n\n-----\n\n*观点仅代表自己，期待你的留言。*\n","source":"_posts/transaction-distributed.md","raw":"---\ntitle: 分布式下数据事务\nkeywords:\n  - 数据库事务\n  - CAP\n  - ACID\n  - BASE\n  - 最终一致性\ntags:\n  - 原创\n  - 总结\nlist_number: false\ndate: 2017-09-18 15:13:57\n---\n\n## 一、概念\n### 1、CAP定律\n__Consistency(一致性)：__ 数据一致更新，针对集群内所有节点数据变动都是同步完成。\n__Availability(可用性)：__ 在集群中一部分节点故障后，集群整体是否还能响应客户端的读写请求。\n__Partition tolerance(分区容错性)：__ 以实际效果而言，分区相当于对通信的时限要求。系统如果不能在时限内达成数据一致性，就意味着发生了分区的情况，必须就当前操作在C和A之间做出选择。\n\nIt states, that though its desirable to have Consistency, High-Availability and Partition-tolerance in every system, unfortunately no system can achieve all three at the same time.\n在分布式系统的设计中，没有一种设计可以同时满足一致性，可用性，分区容错性 3个特性\n\n![CAP定制](/images/cap-theorem.png)\n\n### 2、ACID模型\n__Atomicity(原子性)：__ 事务作为一个整体被执行，包含在其中的对数据库的操作要么全部被执行，要么都不执行。\n__Consistency(一致性)：__ 事务应确保数据库的状态从一个一致状态转变为另一个一致状态。一致状态的含义是数据库中的数据应满足完整性约束。\n__Isolation(隔离性)：__ 多个事务并发执行时，一个事务的执行不应影响其他事务的执行。\n__Durability(持久性)：__ 一个事务一旦提交，他对数据库的修改应该永久保存在数据库中。\n\n### 3、BASE模型（反ACID模型）\n__Basically Available（基本可用）：__ 基本可用是指分布式系统在出现不可预知故障的时候，允许损失部分可用性。\n__Soft state（软状态）：__ 软状态和硬状态相对，是指允许系统中的数据存在中间状态，并认为该中间状态的存在不会影响系统的整体可用性，数据更改时允许集群的不同节点有一段时间进行数据状态同步。\n__Eventually consistent（最终一致性）：__ 事务处理过程中，会有短暂不一致的情况，但通过恢复系统，可以让事务的数据达到最终一致的目标。\n\n## 二、强一致性解决方案\n### 1、2PC (二阶段提交)\n__算法思路：__ 参与者将操作成败通知协调者，再由协调者根据所有参与者的反馈情报决定各参与者是否要提交操作还是中止操作。\n__XA协议：__ XA是一个分布式事务协议，由Tuxedo提出。XA中大致分为两部分：事务管理器(Transaction Manager)和本地资源管理器(Local Resource Manager)。其中本地资源管理器往往由数据库实现，比如Oracle、DB2这些商业数据库都实现了XA接口，而事务管理器作为全局的调度者，负责各个本地资源的提交和回滚。\n\n![X/Open DTP模型](/images/xopen-dtp.gif)\n\n__二阶段：__\n1. 准备阶段： 事务协调者(事务管理器)给每个参与者(资源管理器)发送Prepare消息，每个参与者要么直接返回失败(如权限验证失败)，要么在本地执行事务，写本地的redo和undo日志，但不提交本地事务。\n2. 提交阶段： 如果协调者收到了参与者的失败消息或者超时，直接给每个参与者发送回滚(Rollback)消息；否则，发送提交(Commit)消息；参与者根据协调者的指令执行提交或者回滚操作，释放所有事务处理过程中使用的锁资源。(注意:必须在最后阶段释放锁资源)\n\n__缺点:__\n1. 同步阻塞问题。执行过程中，所有参与节点都是事务阻塞型的。当参与者占有公共资源时，其他第三方节点访问公共资源不得不处于阻塞状态。\n2. 单点故障。由于协调者的重要性，一旦协调者发生故障。参与者会一直阻塞下去。尤其在第二阶段，协调者发生故障，那么所有的参与者还都处于锁定事务资源的状态中，而无法继续完成事务操作。（如果是协调者挂掉，可以重新选举一个协调者，但是无法解决因为协调者宕机导致的参与者处于阻塞状态的问题）\n3. 数据不一致。在二阶段提交的阶段二中，当协调者向参与者发送commit请求之后，发生了局部网络异常或者在发送commit请求过程中协调者发生了故障，这回导致只有一部分参与者接受到了commit请求。而在这部分参与者接到commit请求之后就会执行commit操作。但是其他部分未接到commit请求的机器则无法执行事务提交。于是整个分布式系统便出现了数据部一致性的现象。\n4. 二阶段无法解决的问题：协调者再发出commit消息之后宕机，而唯一接收到这条消息的参与者同时也宕机了。那么即使协调者通过选举协议产生了新的协调者，这条事务的状态也是不确定的，没人知道事务是否被已经提交。\n\n### 2、3PC (三阶段提交)\n与两阶段提交不同的是，三阶段(CanCommit、PreCommit、DoCommit)提交有两个改动点:\n1. 引入超时机制。同时在协调者和参与者中都引入超时机制。\n2. 在第一阶段和第二阶段中插入一个准备阶段。保证了在最后提交阶段之前各参与节点的状态是一致的。\n\n__CanCommit阶段：__ 3PC的CanCommit阶段其实和2PC的准备阶段很像。协调者向参与者发送commit请求，参与者如果可以提交就返回Yes响应，否则返回No响应。\n__PreCommit阶段：__ 协调者根据参与者的反应情况来决定是否可以继续事务的PreCommit操作。如果参与者执行完本地事务操作则返回YES，假如有任何一个参与者向协调者发送了No响应，或者等待超时之后，协调者都没有接到参与者的响应，那么就执行事务的中断。\n__doCommit阶段：__ 该阶段由协调者通知参与者的PreCommit阶段反馈进行判断，最终决定是真正的事务提交，还是执行事务回滚。\n\n__缺点:__\n在doCommit阶段，如果参与者无法及时接收到来自协调者的doCommit或者rebort请求时，会在等待超时之后，会继续进行事务的提交。（其实这个应该是基于概率来决定的，当进入第三阶段时，说明参与者在第二阶段已经收到了PreCommit请求，那么协调者产生PreCommit请求的前提条件是他在第二阶段开始之前，收到所有参与者的CanCommit响应都是Yes。（一旦参与者收到了PreCommit，意味他知道大家其实都同意修改了）所以，一句话概括就是，当进入第三阶段时，由于网络超时等原因，虽然参与者没有收到commit或者abort响应，但是他有理由相信：成功提交的几率很大。 ）\n\n### 3、Paxos算法\n  待补充\n\n## 三、最终一致性解决方案\n### 1、本地消息表\n__设计思想：__ 是将远程分布式事务拆分成一系列的本地事务。借助关系型数据库中的表即可实现。\n__集群节点同步：__ 定时扫描本地消息表，将需要同步状态的消息产生MQ消息通过向时效性高的MQ放入消息，再由其它集群节点消费该消息完成通知，通过消息消费状态表来避免MQ消息的重复消费。\n\n### 2、RocketMQ（事务消息）\n以网传处理流程为例进行说明\n![](/images/rmq-1.png)\n说明：\n1、当第3步confirmB失败时，则交由RMQ定时调用checkTransaction进行处理结果的检测，如果为失败，则rollback,否则发送消息到B账户。\n2、当第5步consumeB失败时，则交由RMQ定时进行重试，但需要设置最大重试次数，如果达到最大次数依然失败，则需要人工介入进行修正。\n\n所以RMQ需要一个人工修正的控制台，当系统通过重试无法进行修正时以人工做为做终的修正手段来做保障最终事务一致性。\n\n\n-----\n\n*观点仅代表自己，期待你的留言。*\n","slug":"transaction-distributed","published":1,"updated":"2021-08-31T14:23:11.553Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cku52dypq005lbbinf2cs7jzh","content":"<h2 id=\"一、概念\"><a href=\"#一、概念\" class=\"headerlink\" title=\"一、概念\"></a>一、概念</h2><h3 id=\"1、CAP定律\"><a href=\"#1、CAP定律\" class=\"headerlink\" title=\"1、CAP定律\"></a>1、CAP定律</h3><p><strong>Consistency(一致性)：</strong> 数据一致更新，针对集群内所有节点数据变动都是同步完成。<br><strong>Availability(可用性)：</strong> 在集群中一部分节点故障后，集群整体是否还能响应客户端的读写请求。<br><strong>Partition tolerance(分区容错性)：</strong> 以实际效果而言，分区相当于对通信的时限要求。系统如果不能在时限内达成数据一致性，就意味着发生了分区的情况，必须就当前操作在C和A之间做出选择。</p>\n<p>It states, that though its desirable to have Consistency, High-Availability and Partition-tolerance in every system, unfortunately no system can achieve all three at the same time.<br>在分布式系统的设计中，没有一种设计可以同时满足一致性，可用性，分区容错性 3个特性</p>\n<p><img src=\"/images/cap-theorem.png\" alt=\"CAP定制\"></p>\n<h3 id=\"2、ACID模型\"><a href=\"#2、ACID模型\" class=\"headerlink\" title=\"2、ACID模型\"></a>2、ACID模型</h3><p><strong>Atomicity(原子性)：</strong> 事务作为一个整体被执行，包含在其中的对数据库的操作要么全部被执行，要么都不执行。<br><strong>Consistency(一致性)：</strong> 事务应确保数据库的状态从一个一致状态转变为另一个一致状态。一致状态的含义是数据库中的数据应满足完整性约束。<br><strong>Isolation(隔离性)：</strong> 多个事务并发执行时，一个事务的执行不应影响其他事务的执行。<br><strong>Durability(持久性)：</strong> 一个事务一旦提交，他对数据库的修改应该永久保存在数据库中。</p>\n<h3 id=\"3、BASE模型（反ACID模型）\"><a href=\"#3、BASE模型（反ACID模型）\" class=\"headerlink\" title=\"3、BASE模型（反ACID模型）\"></a>3、BASE模型（反ACID模型）</h3><p><strong>Basically Available（基本可用）：</strong> 基本可用是指分布式系统在出现不可预知故障的时候，允许损失部分可用性。<br><strong>Soft state（软状态）：</strong> 软状态和硬状态相对，是指允许系统中的数据存在中间状态，并认为该中间状态的存在不会影响系统的整体可用性，数据更改时允许集群的不同节点有一段时间进行数据状态同步。<br><strong>Eventually consistent（最终一致性）：</strong> 事务处理过程中，会有短暂不一致的情况，但通过恢复系统，可以让事务的数据达到最终一致的目标。</p>\n<h2 id=\"二、强一致性解决方案\"><a href=\"#二、强一致性解决方案\" class=\"headerlink\" title=\"二、强一致性解决方案\"></a>二、强一致性解决方案</h2><h3 id=\"1、2PC-二阶段提交\"><a href=\"#1、2PC-二阶段提交\" class=\"headerlink\" title=\"1、2PC (二阶段提交)\"></a>1、2PC (二阶段提交)</h3><p><strong>算法思路：</strong> 参与者将操作成败通知协调者，再由协调者根据所有参与者的反馈情报决定各参与者是否要提交操作还是中止操作。<br><strong>XA协议：</strong> XA是一个分布式事务协议，由Tuxedo提出。XA中大致分为两部分：事务管理器(Transaction Manager)和本地资源管理器(Local Resource Manager)。其中本地资源管理器往往由数据库实现，比如Oracle、DB2这些商业数据库都实现了XA接口，而事务管理器作为全局的调度者，负责各个本地资源的提交和回滚。</p>\n<p><img src=\"/images/xopen-dtp.gif\" alt=\"X/Open DTP模型\"></p>\n<p><strong>二阶段：</strong></p>\n<ol>\n<li>准备阶段： 事务协调者(事务管理器)给每个参与者(资源管理器)发送Prepare消息，每个参与者要么直接返回失败(如权限验证失败)，要么在本地执行事务，写本地的redo和undo日志，但不提交本地事务。</li>\n<li>提交阶段： 如果协调者收到了参与者的失败消息或者超时，直接给每个参与者发送回滚(Rollback)消息；否则，发送提交(Commit)消息；参与者根据协调者的指令执行提交或者回滚操作，释放所有事务处理过程中使用的锁资源。(注意:必须在最后阶段释放锁资源)</li>\n</ol>\n<p><strong>缺点:</strong></p>\n<ol>\n<li>同步阻塞问题。执行过程中，所有参与节点都是事务阻塞型的。当参与者占有公共资源时，其他第三方节点访问公共资源不得不处于阻塞状态。</li>\n<li>单点故障。由于协调者的重要性，一旦协调者发生故障。参与者会一直阻塞下去。尤其在第二阶段，协调者发生故障，那么所有的参与者还都处于锁定事务资源的状态中，而无法继续完成事务操作。（如果是协调者挂掉，可以重新选举一个协调者，但是无法解决因为协调者宕机导致的参与者处于阻塞状态的问题）</li>\n<li>数据不一致。在二阶段提交的阶段二中，当协调者向参与者发送commit请求之后，发生了局部网络异常或者在发送commit请求过程中协调者发生了故障，这回导致只有一部分参与者接受到了commit请求。而在这部分参与者接到commit请求之后就会执行commit操作。但是其他部分未接到commit请求的机器则无法执行事务提交。于是整个分布式系统便出现了数据部一致性的现象。</li>\n<li>二阶段无法解决的问题：协调者再发出commit消息之后宕机，而唯一接收到这条消息的参与者同时也宕机了。那么即使协调者通过选举协议产生了新的协调者，这条事务的状态也是不确定的，没人知道事务是否被已经提交。</li>\n</ol>\n<h3 id=\"2、3PC-三阶段提交\"><a href=\"#2、3PC-三阶段提交\" class=\"headerlink\" title=\"2、3PC (三阶段提交)\"></a>2、3PC (三阶段提交)</h3><p>与两阶段提交不同的是，三阶段(CanCommit、PreCommit、DoCommit)提交有两个改动点:</p>\n<ol>\n<li>引入超时机制。同时在协调者和参与者中都引入超时机制。</li>\n<li>在第一阶段和第二阶段中插入一个准备阶段。保证了在最后提交阶段之前各参与节点的状态是一致的。</li>\n</ol>\n<p><strong>CanCommit阶段：</strong> 3PC的CanCommit阶段其实和2PC的准备阶段很像。协调者向参与者发送commit请求，参与者如果可以提交就返回Yes响应，否则返回No响应。<br><strong>PreCommit阶段：</strong> 协调者根据参与者的反应情况来决定是否可以继续事务的PreCommit操作。如果参与者执行完本地事务操作则返回YES，假如有任何一个参与者向协调者发送了No响应，或者等待超时之后，协调者都没有接到参与者的响应，那么就执行事务的中断。<br><strong>doCommit阶段：</strong> 该阶段由协调者通知参与者的PreCommit阶段反馈进行判断，最终决定是真正的事务提交，还是执行事务回滚。</p>\n<p><strong>缺点:</strong><br>在doCommit阶段，如果参与者无法及时接收到来自协调者的doCommit或者rebort请求时，会在等待超时之后，会继续进行事务的提交。（其实这个应该是基于概率来决定的，当进入第三阶段时，说明参与者在第二阶段已经收到了PreCommit请求，那么协调者产生PreCommit请求的前提条件是他在第二阶段开始之前，收到所有参与者的CanCommit响应都是Yes。（一旦参与者收到了PreCommit，意味他知道大家其实都同意修改了）所以，一句话概括就是，当进入第三阶段时，由于网络超时等原因，虽然参与者没有收到commit或者abort响应，但是他有理由相信：成功提交的几率很大。 ）</p>\n<h3 id=\"3、Paxos算法\"><a href=\"#3、Paxos算法\" class=\"headerlink\" title=\"3、Paxos算法\"></a>3、Paxos算法</h3><p>  待补充</p>\n<h2 id=\"三、最终一致性解决方案\"><a href=\"#三、最终一致性解决方案\" class=\"headerlink\" title=\"三、最终一致性解决方案\"></a>三、最终一致性解决方案</h2><h3 id=\"1、本地消息表\"><a href=\"#1、本地消息表\" class=\"headerlink\" title=\"1、本地消息表\"></a>1、本地消息表</h3><p><strong>设计思想：</strong> 是将远程分布式事务拆分成一系列的本地事务。借助关系型数据库中的表即可实现。<br><strong>集群节点同步：</strong> 定时扫描本地消息表，将需要同步状态的消息产生MQ消息通过向时效性高的MQ放入消息，再由其它集群节点消费该消息完成通知，通过消息消费状态表来避免MQ消息的重复消费。</p>\n<h3 id=\"2、RocketMQ（事务消息）\"><a href=\"#2、RocketMQ（事务消息）\" class=\"headerlink\" title=\"2、RocketMQ（事务消息）\"></a>2、RocketMQ（事务消息）</h3><p>以网传处理流程为例进行说明<br><img src=\"/images/rmq-1.png\"><br>说明：<br>1、当第3步confirmB失败时，则交由RMQ定时调用checkTransaction进行处理结果的检测，如果为失败，则rollback,否则发送消息到B账户。<br>2、当第5步consumeB失败时，则交由RMQ定时进行重试，但需要设置最大重试次数，如果达到最大次数依然失败，则需要人工介入进行修正。</p>\n<p>所以RMQ需要一个人工修正的控制台，当系统通过重试无法进行修正时以人工做为做终的修正手段来做保障最终事务一致性。</p>\n<hr>\n<p><em>观点仅代表自己，期待你的留言。</em></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"一、概念\"><a href=\"#一、概念\" class=\"headerlink\" title=\"一、概念\"></a>一、概念</h2><h3 id=\"1、CAP定律\"><a href=\"#1、CAP定律\" class=\"headerlink\" title=\"1、CAP定律\"></a>1、CAP定律</h3><p><strong>Consistency(一致性)：</strong> 数据一致更新，针对集群内所有节点数据变动都是同步完成。<br><strong>Availability(可用性)：</strong> 在集群中一部分节点故障后，集群整体是否还能响应客户端的读写请求。<br><strong>Partition tolerance(分区容错性)：</strong> 以实际效果而言，分区相当于对通信的时限要求。系统如果不能在时限内达成数据一致性，就意味着发生了分区的情况，必须就当前操作在C和A之间做出选择。</p>\n<p>It states, that though its desirable to have Consistency, High-Availability and Partition-tolerance in every system, unfortunately no system can achieve all three at the same time.<br>在分布式系统的设计中，没有一种设计可以同时满足一致性，可用性，分区容错性 3个特性</p>\n<p><img src=\"/images/cap-theorem.png\" alt=\"CAP定制\"></p>\n<h3 id=\"2、ACID模型\"><a href=\"#2、ACID模型\" class=\"headerlink\" title=\"2、ACID模型\"></a>2、ACID模型</h3><p><strong>Atomicity(原子性)：</strong> 事务作为一个整体被执行，包含在其中的对数据库的操作要么全部被执行，要么都不执行。<br><strong>Consistency(一致性)：</strong> 事务应确保数据库的状态从一个一致状态转变为另一个一致状态。一致状态的含义是数据库中的数据应满足完整性约束。<br><strong>Isolation(隔离性)：</strong> 多个事务并发执行时，一个事务的执行不应影响其他事务的执行。<br><strong>Durability(持久性)：</strong> 一个事务一旦提交，他对数据库的修改应该永久保存在数据库中。</p>\n<h3 id=\"3、BASE模型（反ACID模型）\"><a href=\"#3、BASE模型（反ACID模型）\" class=\"headerlink\" title=\"3、BASE模型（反ACID模型）\"></a>3、BASE模型（反ACID模型）</h3><p><strong>Basically Available（基本可用）：</strong> 基本可用是指分布式系统在出现不可预知故障的时候，允许损失部分可用性。<br><strong>Soft state（软状态）：</strong> 软状态和硬状态相对，是指允许系统中的数据存在中间状态，并认为该中间状态的存在不会影响系统的整体可用性，数据更改时允许集群的不同节点有一段时间进行数据状态同步。<br><strong>Eventually consistent（最终一致性）：</strong> 事务处理过程中，会有短暂不一致的情况，但通过恢复系统，可以让事务的数据达到最终一致的目标。</p>\n<h2 id=\"二、强一致性解决方案\"><a href=\"#二、强一致性解决方案\" class=\"headerlink\" title=\"二、强一致性解决方案\"></a>二、强一致性解决方案</h2><h3 id=\"1、2PC-二阶段提交\"><a href=\"#1、2PC-二阶段提交\" class=\"headerlink\" title=\"1、2PC (二阶段提交)\"></a>1、2PC (二阶段提交)</h3><p><strong>算法思路：</strong> 参与者将操作成败通知协调者，再由协调者根据所有参与者的反馈情报决定各参与者是否要提交操作还是中止操作。<br><strong>XA协议：</strong> XA是一个分布式事务协议，由Tuxedo提出。XA中大致分为两部分：事务管理器(Transaction Manager)和本地资源管理器(Local Resource Manager)。其中本地资源管理器往往由数据库实现，比如Oracle、DB2这些商业数据库都实现了XA接口，而事务管理器作为全局的调度者，负责各个本地资源的提交和回滚。</p>\n<p><img src=\"/images/xopen-dtp.gif\" alt=\"X/Open DTP模型\"></p>\n<p><strong>二阶段：</strong></p>\n<ol>\n<li>准备阶段： 事务协调者(事务管理器)给每个参与者(资源管理器)发送Prepare消息，每个参与者要么直接返回失败(如权限验证失败)，要么在本地执行事务，写本地的redo和undo日志，但不提交本地事务。</li>\n<li>提交阶段： 如果协调者收到了参与者的失败消息或者超时，直接给每个参与者发送回滚(Rollback)消息；否则，发送提交(Commit)消息；参与者根据协调者的指令执行提交或者回滚操作，释放所有事务处理过程中使用的锁资源。(注意:必须在最后阶段释放锁资源)</li>\n</ol>\n<p><strong>缺点:</strong></p>\n<ol>\n<li>同步阻塞问题。执行过程中，所有参与节点都是事务阻塞型的。当参与者占有公共资源时，其他第三方节点访问公共资源不得不处于阻塞状态。</li>\n<li>单点故障。由于协调者的重要性，一旦协调者发生故障。参与者会一直阻塞下去。尤其在第二阶段，协调者发生故障，那么所有的参与者还都处于锁定事务资源的状态中，而无法继续完成事务操作。（如果是协调者挂掉，可以重新选举一个协调者，但是无法解决因为协调者宕机导致的参与者处于阻塞状态的问题）</li>\n<li>数据不一致。在二阶段提交的阶段二中，当协调者向参与者发送commit请求之后，发生了局部网络异常或者在发送commit请求过程中协调者发生了故障，这回导致只有一部分参与者接受到了commit请求。而在这部分参与者接到commit请求之后就会执行commit操作。但是其他部分未接到commit请求的机器则无法执行事务提交。于是整个分布式系统便出现了数据部一致性的现象。</li>\n<li>二阶段无法解决的问题：协调者再发出commit消息之后宕机，而唯一接收到这条消息的参与者同时也宕机了。那么即使协调者通过选举协议产生了新的协调者，这条事务的状态也是不确定的，没人知道事务是否被已经提交。</li>\n</ol>\n<h3 id=\"2、3PC-三阶段提交\"><a href=\"#2、3PC-三阶段提交\" class=\"headerlink\" title=\"2、3PC (三阶段提交)\"></a>2、3PC (三阶段提交)</h3><p>与两阶段提交不同的是，三阶段(CanCommit、PreCommit、DoCommit)提交有两个改动点:</p>\n<ol>\n<li>引入超时机制。同时在协调者和参与者中都引入超时机制。</li>\n<li>在第一阶段和第二阶段中插入一个准备阶段。保证了在最后提交阶段之前各参与节点的状态是一致的。</li>\n</ol>\n<p><strong>CanCommit阶段：</strong> 3PC的CanCommit阶段其实和2PC的准备阶段很像。协调者向参与者发送commit请求，参与者如果可以提交就返回Yes响应，否则返回No响应。<br><strong>PreCommit阶段：</strong> 协调者根据参与者的反应情况来决定是否可以继续事务的PreCommit操作。如果参与者执行完本地事务操作则返回YES，假如有任何一个参与者向协调者发送了No响应，或者等待超时之后，协调者都没有接到参与者的响应，那么就执行事务的中断。<br><strong>doCommit阶段：</strong> 该阶段由协调者通知参与者的PreCommit阶段反馈进行判断，最终决定是真正的事务提交，还是执行事务回滚。</p>\n<p><strong>缺点:</strong><br>在doCommit阶段，如果参与者无法及时接收到来自协调者的doCommit或者rebort请求时，会在等待超时之后，会继续进行事务的提交。（其实这个应该是基于概率来决定的，当进入第三阶段时，说明参与者在第二阶段已经收到了PreCommit请求，那么协调者产生PreCommit请求的前提条件是他在第二阶段开始之前，收到所有参与者的CanCommit响应都是Yes。（一旦参与者收到了PreCommit，意味他知道大家其实都同意修改了）所以，一句话概括就是，当进入第三阶段时，由于网络超时等原因，虽然参与者没有收到commit或者abort响应，但是他有理由相信：成功提交的几率很大。 ）</p>\n<h3 id=\"3、Paxos算法\"><a href=\"#3、Paxos算法\" class=\"headerlink\" title=\"3、Paxos算法\"></a>3、Paxos算法</h3><p>  待补充</p>\n<h2 id=\"三、最终一致性解决方案\"><a href=\"#三、最终一致性解决方案\" class=\"headerlink\" title=\"三、最终一致性解决方案\"></a>三、最终一致性解决方案</h2><h3 id=\"1、本地消息表\"><a href=\"#1、本地消息表\" class=\"headerlink\" title=\"1、本地消息表\"></a>1、本地消息表</h3><p><strong>设计思想：</strong> 是将远程分布式事务拆分成一系列的本地事务。借助关系型数据库中的表即可实现。<br><strong>集群节点同步：</strong> 定时扫描本地消息表，将需要同步状态的消息产生MQ消息通过向时效性高的MQ放入消息，再由其它集群节点消费该消息完成通知，通过消息消费状态表来避免MQ消息的重复消费。</p>\n<h3 id=\"2、RocketMQ（事务消息）\"><a href=\"#2、RocketMQ（事务消息）\" class=\"headerlink\" title=\"2、RocketMQ（事务消息）\"></a>2、RocketMQ（事务消息）</h3><p>以网传处理流程为例进行说明<br><img src=\"/images/rmq-1.png\"><br>说明：<br>1、当第3步confirmB失败时，则交由RMQ定时调用checkTransaction进行处理结果的检测，如果为失败，则rollback,否则发送消息到B账户。<br>2、当第5步consumeB失败时，则交由RMQ定时进行重试，但需要设置最大重试次数，如果达到最大次数依然失败，则需要人工介入进行修正。</p>\n<p>所以RMQ需要一个人工修正的控制台，当系统通过重试无法进行修正时以人工做为做终的修正手段来做保障最终事务一致性。</p>\n<hr>\n<p><em>观点仅代表自己，期待你的留言。</em></p>\n"},{"title":"数据库事务隔离级别与并发事务控制（悲观锁与乐观锁）","keywords":["数据库事务","脏读","幻读","数据库并发控制","悲观锁","乐观锁"],"date":"2016-05-27T13:34:55.000Z","_content":"\n## 事务特性\n事务具有4个属性：原子性、一致性、隔离性、持久性。这四个属性通常称为ACID特性。\n\n1. 原子性（Atomicity）：事务作为一个整体被执行，包含在其中的对数据库的操作要么全部被执行，要么都不执行。\n2. 一致性（Consistency）：事务应确保数据库的状态从一个一致状态转变为另一个一致状态。一致状态的含义是数据库中的数据应满足完整性约束。\n3. 隔离性（Isolation）：多个事务并发执行时，一个事务的执行不应影响其他事务的执行。\n4. 持久性（Durability）：一个事务一旦提交，他对数据库的修改应该永久保存在数据库中。\n\n## 事务的隔离级别\n由于事务的隔离性允许多个事务同时处理同一数据，所以，在多个事务并发操作的过程中，如果控制不好隔离级别，就有可能产生_脏读_、_不可重复读_或者_幻读_等现象。因此在操作数据的过程中需要合理利用数据库锁机制或者多版本并发控制机制获取更高的隔离等级，但是，随着数据库隔离级别的提高，数据的并发能力也会有所下降。所以，如何在并发性和隔离性之间做一个很好的权衡就成了一个至关重要的问题。\n\nANSI/ISO SQL定义的标准隔离级别从高到低依次为：可串行化(Serializable)、可重复读(Repeatable reads)、提交读(Read committed)、未提交读(Read uncommitted)。\n\n|隔离级别     \t\t\t\t|脏读（Dirty Read） |不可重复读（NonRepeatable Read） |幻读（Phantom Read）\n|:- |:- |:- |:- \n|未提交读（Read uncommitted）  |可能\t\t       |可能\t\t\t\t\t\t\t   |可能\n|提交读（Read committed）\t\t |不可能\t\t\t   |可能\t\t\t\t\t\t       |可能\n|可重复读（Repeatable Read）   |不可能\t\t\t   |不可能\t\t\t\t\t\t   |可能\n|可串行化（Serializable）\t\t |不可能\t\t\t   |不可能\t\t\t\t\t\t   |不可能\n\n===========================================================================================\n\n* 未提交读(Read Uncommitted)：允许脏读，也就是可能读取到其他会话中未提交事务修改的数据。\n* 提交读(Read Committed)：被读取的数据可以被其他事务修改。这样就可能导致不可重复读。也就是说，事务的读取数据的时候获取读锁，但是读完之后立即释放（不需要等到事务结束），而写锁则是事务提交之后才释放。释放读锁之后，就可能被其他事物修改数据。Oracle等多数数据库默认都是该级别 (不重复读)\n* 可重复读(Repeated Read)：所有被Select获取的数据都不能被修改，这样就可以避免一个事务前后读取数据不一致的情况。但是却没有办法控制幻读，因为这个时候其他事务不能更改所选的数据，但是可以增加数据，因为前一个事务没有范围锁。Mysql的InnoDB引擎默认隔离级别。\n* 可串行化(Serializable)：所有事务都一个接一个地串行执行，这样可以避免幻读（phantom reads）,每次读都需要获得表级共享锁，读写相互都会阻塞。\n\n## 数据库并发控制\n虽然将事务串形化可以保证数据在多事务并发处理下不存在数据不一致的问题，但串行执行使得数据库的处理性能大幅度地下降，常常是你接受不了的。所以，一般来说，数据库的隔离级别都会设置为read committed（只能读取其他事务已提交的数据），然后由应用程序使用__乐观锁/悲观锁__来弥补数据不一致的问题。\n\n### 乐观锁\n虽然名字中带“锁”，但是乐观锁并不锁住任何东西，而是在提交事务时检查自己上次读取这条记录后，是否有其他事务修改了这条记录，如果没有则提交，如果被修改了则回滚。如果并发的可能性并不大，那么锁定策略带来的性能消耗是非常小的。\n\n常见实现方式：在数据表增加version字段，每次事务开始时将取出version字段值，而后在更新数据的同时version增加1（如：`update xxx set data=#{data},version=version+1 where version=#{version}`），如没有数据被更新，那么说明数据由其它的事务进行了更新，此时就可以判断当前事务所操作的历史快照数据。\n\n### 悲观锁\n和乐观锁相比，悲观锁则是一把真正的锁了，它通过SQL语句“select for update”锁住select出的那批数据，这时如果其他事务来更新这批数据时会等待。\n\n总的来说，悲观锁相对乐观锁更安全一些，但是开销也更大，甚至可能出现数据库死锁的情况，建议只在乐观锁无法工作时才使用。\n\n-----\n\n*观点仅代表自己，期待你的留言。*\n","source":"_posts/transaction-isolation-levels.md","raw":"---\ntitle: 数据库事务隔离级别与并发事务控制（悲观锁与乐观锁）\nkeywords:\n  - 数据库事务\n  - 脏读\n  - 幻读\n  - 数据库并发控制\n  - 悲观锁\n  - 乐观锁\ntags:\n  - 原创\ndate: 2016-05-27 21:34:55\n---\n\n## 事务特性\n事务具有4个属性：原子性、一致性、隔离性、持久性。这四个属性通常称为ACID特性。\n\n1. 原子性（Atomicity）：事务作为一个整体被执行，包含在其中的对数据库的操作要么全部被执行，要么都不执行。\n2. 一致性（Consistency）：事务应确保数据库的状态从一个一致状态转变为另一个一致状态。一致状态的含义是数据库中的数据应满足完整性约束。\n3. 隔离性（Isolation）：多个事务并发执行时，一个事务的执行不应影响其他事务的执行。\n4. 持久性（Durability）：一个事务一旦提交，他对数据库的修改应该永久保存在数据库中。\n\n## 事务的隔离级别\n由于事务的隔离性允许多个事务同时处理同一数据，所以，在多个事务并发操作的过程中，如果控制不好隔离级别，就有可能产生_脏读_、_不可重复读_或者_幻读_等现象。因此在操作数据的过程中需要合理利用数据库锁机制或者多版本并发控制机制获取更高的隔离等级，但是，随着数据库隔离级别的提高，数据的并发能力也会有所下降。所以，如何在并发性和隔离性之间做一个很好的权衡就成了一个至关重要的问题。\n\nANSI/ISO SQL定义的标准隔离级别从高到低依次为：可串行化(Serializable)、可重复读(Repeatable reads)、提交读(Read committed)、未提交读(Read uncommitted)。\n\n|隔离级别     \t\t\t\t|脏读（Dirty Read） |不可重复读（NonRepeatable Read） |幻读（Phantom Read）\n|:- |:- |:- |:- \n|未提交读（Read uncommitted）  |可能\t\t       |可能\t\t\t\t\t\t\t   |可能\n|提交读（Read committed）\t\t |不可能\t\t\t   |可能\t\t\t\t\t\t       |可能\n|可重复读（Repeatable Read）   |不可能\t\t\t   |不可能\t\t\t\t\t\t   |可能\n|可串行化（Serializable）\t\t |不可能\t\t\t   |不可能\t\t\t\t\t\t   |不可能\n\n===========================================================================================\n\n* 未提交读(Read Uncommitted)：允许脏读，也就是可能读取到其他会话中未提交事务修改的数据。\n* 提交读(Read Committed)：被读取的数据可以被其他事务修改。这样就可能导致不可重复读。也就是说，事务的读取数据的时候获取读锁，但是读完之后立即释放（不需要等到事务结束），而写锁则是事务提交之后才释放。释放读锁之后，就可能被其他事物修改数据。Oracle等多数数据库默认都是该级别 (不重复读)\n* 可重复读(Repeated Read)：所有被Select获取的数据都不能被修改，这样就可以避免一个事务前后读取数据不一致的情况。但是却没有办法控制幻读，因为这个时候其他事务不能更改所选的数据，但是可以增加数据，因为前一个事务没有范围锁。Mysql的InnoDB引擎默认隔离级别。\n* 可串行化(Serializable)：所有事务都一个接一个地串行执行，这样可以避免幻读（phantom reads）,每次读都需要获得表级共享锁，读写相互都会阻塞。\n\n## 数据库并发控制\n虽然将事务串形化可以保证数据在多事务并发处理下不存在数据不一致的问题，但串行执行使得数据库的处理性能大幅度地下降，常常是你接受不了的。所以，一般来说，数据库的隔离级别都会设置为read committed（只能读取其他事务已提交的数据），然后由应用程序使用__乐观锁/悲观锁__来弥补数据不一致的问题。\n\n### 乐观锁\n虽然名字中带“锁”，但是乐观锁并不锁住任何东西，而是在提交事务时检查自己上次读取这条记录后，是否有其他事务修改了这条记录，如果没有则提交，如果被修改了则回滚。如果并发的可能性并不大，那么锁定策略带来的性能消耗是非常小的。\n\n常见实现方式：在数据表增加version字段，每次事务开始时将取出version字段值，而后在更新数据的同时version增加1（如：`update xxx set data=#{data},version=version+1 where version=#{version}`），如没有数据被更新，那么说明数据由其它的事务进行了更新，此时就可以判断当前事务所操作的历史快照数据。\n\n### 悲观锁\n和乐观锁相比，悲观锁则是一把真正的锁了，它通过SQL语句“select for update”锁住select出的那批数据，这时如果其他事务来更新这批数据时会等待。\n\n总的来说，悲观锁相对乐观锁更安全一些，但是开销也更大，甚至可能出现数据库死锁的情况，建议只在乐观锁无法工作时才使用。\n\n-----\n\n*观点仅代表自己，期待你的留言。*\n","slug":"transaction-isolation-levels","published":1,"updated":"2021-09-18T03:05:28.371Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cku52dypq005nbbin8gpbhlzd","content":"<h2 id=\"事务特性\"><a href=\"#事务特性\" class=\"headerlink\" title=\"事务特性\"></a>事务特性</h2><p>事务具有4个属性：原子性、一致性、隔离性、持久性。这四个属性通常称为ACID特性。</p>\n<ol>\n<li>原子性（Atomicity）：事务作为一个整体被执行，包含在其中的对数据库的操作要么全部被执行，要么都不执行。</li>\n<li>一致性（Consistency）：事务应确保数据库的状态从一个一致状态转变为另一个一致状态。一致状态的含义是数据库中的数据应满足完整性约束。</li>\n<li>隔离性（Isolation）：多个事务并发执行时，一个事务的执行不应影响其他事务的执行。</li>\n<li>持久性（Durability）：一个事务一旦提交，他对数据库的修改应该永久保存在数据库中。</li>\n</ol>\n<h2 id=\"事务的隔离级别\"><a href=\"#事务的隔离级别\" class=\"headerlink\" title=\"事务的隔离级别\"></a>事务的隔离级别</h2><p>由于事务的隔离性允许多个事务同时处理同一数据，所以，在多个事务并发操作的过程中，如果控制不好隔离级别，就有可能产生_脏读_、_不可重复读_或者_幻读_等现象。因此在操作数据的过程中需要合理利用数据库锁机制或者多版本并发控制机制获取更高的隔离等级，但是，随着数据库隔离级别的提高，数据的并发能力也会有所下降。所以，如何在并发性和隔离性之间做一个很好的权衡就成了一个至关重要的问题。</p>\n<p>ANSI/ISO SQL定义的标准隔离级别从高到低依次为：可串行化(Serializable)、可重复读(Repeatable reads)、提交读(Read committed)、未提交读(Read uncommitted)。</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">隔离级别</th>\n<th align=\"left\">脏读（Dirty Read）</th>\n<th align=\"left\">不可重复读（NonRepeatable Read）</th>\n<th align=\"left\">幻读（Phantom Read）</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">未提交读（Read uncommitted）</td>\n<td align=\"left\">可能</td>\n<td align=\"left\">可能</td>\n<td align=\"left\">可能</td>\n</tr>\n<tr>\n<td align=\"left\">提交读（Read committed）</td>\n<td align=\"left\">不可能</td>\n<td align=\"left\">可能</td>\n<td align=\"left\">可能</td>\n</tr>\n<tr>\n<td align=\"left\">可重复读（Repeatable Read）</td>\n<td align=\"left\">不可能</td>\n<td align=\"left\">不可能</td>\n<td align=\"left\">可能</td>\n</tr>\n<tr>\n<td align=\"left\">可串行化（Serializable）</td>\n<td align=\"left\">不可能</td>\n<td align=\"left\">不可能</td>\n<td align=\"left\">不可能</td>\n</tr>\n</tbody></table>\n<p>===========================================================================================</p>\n<ul>\n<li>未提交读(Read Uncommitted)：允许脏读，也就是可能读取到其他会话中未提交事务修改的数据。</li>\n<li>提交读(Read Committed)：被读取的数据可以被其他事务修改。这样就可能导致不可重复读。也就是说，事务的读取数据的时候获取读锁，但是读完之后立即释放（不需要等到事务结束），而写锁则是事务提交之后才释放。释放读锁之后，就可能被其他事物修改数据。Oracle等多数数据库默认都是该级别 (不重复读)</li>\n<li>可重复读(Repeated Read)：所有被Select获取的数据都不能被修改，这样就可以避免一个事务前后读取数据不一致的情况。但是却没有办法控制幻读，因为这个时候其他事务不能更改所选的数据，但是可以增加数据，因为前一个事务没有范围锁。Mysql的InnoDB引擎默认隔离级别。</li>\n<li>可串行化(Serializable)：所有事务都一个接一个地串行执行，这样可以避免幻读（phantom reads）,每次读都需要获得表级共享锁，读写相互都会阻塞。</li>\n</ul>\n<h2 id=\"数据库并发控制\"><a href=\"#数据库并发控制\" class=\"headerlink\" title=\"数据库并发控制\"></a>数据库并发控制</h2><p>虽然将事务串形化可以保证数据在多事务并发处理下不存在数据不一致的问题，但串行执行使得数据库的处理性能大幅度地下降，常常是你接受不了的。所以，一般来说，数据库的隔离级别都会设置为read committed（只能读取其他事务已提交的数据），然后由应用程序使用__乐观锁/悲观锁__来弥补数据不一致的问题。</p>\n<h3 id=\"乐观锁\"><a href=\"#乐观锁\" class=\"headerlink\" title=\"乐观锁\"></a>乐观锁</h3><p>虽然名字中带“锁”，但是乐观锁并不锁住任何东西，而是在提交事务时检查自己上次读取这条记录后，是否有其他事务修改了这条记录，如果没有则提交，如果被修改了则回滚。如果并发的可能性并不大，那么锁定策略带来的性能消耗是非常小的。</p>\n<p>常见实现方式：在数据表增加version字段，每次事务开始时将取出version字段值，而后在更新数据的同时version增加1（如：<code>update xxx set data=#&#123;data&#125;,version=version+1 where version=#&#123;version&#125;</code>），如没有数据被更新，那么说明数据由其它的事务进行了更新，此时就可以判断当前事务所操作的历史快照数据。</p>\n<h3 id=\"悲观锁\"><a href=\"#悲观锁\" class=\"headerlink\" title=\"悲观锁\"></a>悲观锁</h3><p>和乐观锁相比，悲观锁则是一把真正的锁了，它通过SQL语句“select for update”锁住select出的那批数据，这时如果其他事务来更新这批数据时会等待。</p>\n<p>总的来说，悲观锁相对乐观锁更安全一些，但是开销也更大，甚至可能出现数据库死锁的情况，建议只在乐观锁无法工作时才使用。</p>\n<hr>\n<p><em>观点仅代表自己，期待你的留言。</em></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"事务特性\"><a href=\"#事务特性\" class=\"headerlink\" title=\"事务特性\"></a>事务特性</h2><p>事务具有4个属性：原子性、一致性、隔离性、持久性。这四个属性通常称为ACID特性。</p>\n<ol>\n<li>原子性（Atomicity）：事务作为一个整体被执行，包含在其中的对数据库的操作要么全部被执行，要么都不执行。</li>\n<li>一致性（Consistency）：事务应确保数据库的状态从一个一致状态转变为另一个一致状态。一致状态的含义是数据库中的数据应满足完整性约束。</li>\n<li>隔离性（Isolation）：多个事务并发执行时，一个事务的执行不应影响其他事务的执行。</li>\n<li>持久性（Durability）：一个事务一旦提交，他对数据库的修改应该永久保存在数据库中。</li>\n</ol>\n<h2 id=\"事务的隔离级别\"><a href=\"#事务的隔离级别\" class=\"headerlink\" title=\"事务的隔离级别\"></a>事务的隔离级别</h2><p>由于事务的隔离性允许多个事务同时处理同一数据，所以，在多个事务并发操作的过程中，如果控制不好隔离级别，就有可能产生_脏读_、_不可重复读_或者_幻读_等现象。因此在操作数据的过程中需要合理利用数据库锁机制或者多版本并发控制机制获取更高的隔离等级，但是，随着数据库隔离级别的提高，数据的并发能力也会有所下降。所以，如何在并发性和隔离性之间做一个很好的权衡就成了一个至关重要的问题。</p>\n<p>ANSI/ISO SQL定义的标准隔离级别从高到低依次为：可串行化(Serializable)、可重复读(Repeatable reads)、提交读(Read committed)、未提交读(Read uncommitted)。</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">隔离级别</th>\n<th align=\"left\">脏读（Dirty Read）</th>\n<th align=\"left\">不可重复读（NonRepeatable Read）</th>\n<th align=\"left\">幻读（Phantom Read）</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">未提交读（Read uncommitted）</td>\n<td align=\"left\">可能</td>\n<td align=\"left\">可能</td>\n<td align=\"left\">可能</td>\n</tr>\n<tr>\n<td align=\"left\">提交读（Read committed）</td>\n<td align=\"left\">不可能</td>\n<td align=\"left\">可能</td>\n<td align=\"left\">可能</td>\n</tr>\n<tr>\n<td align=\"left\">可重复读（Repeatable Read）</td>\n<td align=\"left\">不可能</td>\n<td align=\"left\">不可能</td>\n<td align=\"left\">可能</td>\n</tr>\n<tr>\n<td align=\"left\">可串行化（Serializable）</td>\n<td align=\"left\">不可能</td>\n<td align=\"left\">不可能</td>\n<td align=\"left\">不可能</td>\n</tr>\n</tbody></table>\n<p>===========================================================================================</p>\n<ul>\n<li>未提交读(Read Uncommitted)：允许脏读，也就是可能读取到其他会话中未提交事务修改的数据。</li>\n<li>提交读(Read Committed)：被读取的数据可以被其他事务修改。这样就可能导致不可重复读。也就是说，事务的读取数据的时候获取读锁，但是读完之后立即释放（不需要等到事务结束），而写锁则是事务提交之后才释放。释放读锁之后，就可能被其他事物修改数据。Oracle等多数数据库默认都是该级别 (不重复读)</li>\n<li>可重复读(Repeated Read)：所有被Select获取的数据都不能被修改，这样就可以避免一个事务前后读取数据不一致的情况。但是却没有办法控制幻读，因为这个时候其他事务不能更改所选的数据，但是可以增加数据，因为前一个事务没有范围锁。Mysql的InnoDB引擎默认隔离级别。</li>\n<li>可串行化(Serializable)：所有事务都一个接一个地串行执行，这样可以避免幻读（phantom reads）,每次读都需要获得表级共享锁，读写相互都会阻塞。</li>\n</ul>\n<h2 id=\"数据库并发控制\"><a href=\"#数据库并发控制\" class=\"headerlink\" title=\"数据库并发控制\"></a>数据库并发控制</h2><p>虽然将事务串形化可以保证数据在多事务并发处理下不存在数据不一致的问题，但串行执行使得数据库的处理性能大幅度地下降，常常是你接受不了的。所以，一般来说，数据库的隔离级别都会设置为read committed（只能读取其他事务已提交的数据），然后由应用程序使用__乐观锁/悲观锁__来弥补数据不一致的问题。</p>\n<h3 id=\"乐观锁\"><a href=\"#乐观锁\" class=\"headerlink\" title=\"乐观锁\"></a>乐观锁</h3><p>虽然名字中带“锁”，但是乐观锁并不锁住任何东西，而是在提交事务时检查自己上次读取这条记录后，是否有其他事务修改了这条记录，如果没有则提交，如果被修改了则回滚。如果并发的可能性并不大，那么锁定策略带来的性能消耗是非常小的。</p>\n<p>常见实现方式：在数据表增加version字段，每次事务开始时将取出version字段值，而后在更新数据的同时version增加1（如：<code>update xxx set data=#&#123;data&#125;,version=version+1 where version=#&#123;version&#125;</code>），如没有数据被更新，那么说明数据由其它的事务进行了更新，此时就可以判断当前事务所操作的历史快照数据。</p>\n<h3 id=\"悲观锁\"><a href=\"#悲观锁\" class=\"headerlink\" title=\"悲观锁\"></a>悲观锁</h3><p>和乐观锁相比，悲观锁则是一把真正的锁了，它通过SQL语句“select for update”锁住select出的那批数据，这时如果其他事务来更新这批数据时会等待。</p>\n<p>总的来说，悲观锁相对乐观锁更安全一些，但是开销也更大，甚至可能出现数据库死锁的情况，建议只在乐观锁无法工作时才使用。</p>\n<hr>\n<p><em>观点仅代表自己，期待你的留言。</em></p>\n"},{"title":"问题分析 之 Transaction marked as rollbackOnly","keywords":["数据库事务","Transaction marked as rollbackOnly"],"date":"2017-07-21T09:01:27.000Z","_content":"\n## 问题现象\n```java\norg.springframework.transaction.TransactionSystemException: Could not commit JPA transaction; nested exception is javax.persistence.RollbackException: Transaction marked as rollbackOnly\n        at org.springframework.orm.jpa.JpaTransactionManager.doCommit(JpaTransactionManager.java:526)\n        at org.springframework.transaction.support.AbstractPlatformTransactionManager.processCommit(AbstractPlatformTransactionManager.java:757)\n        at org.springframework.transaction.support.AbstractPlatformTransactionManager.commit(AbstractPlatformTransactionManager.java:726)\n        at org.springframework.transaction.interceptor.TransactionAspectSupport.commitTransactionAfterReturning(TransactionAspectSupport.java:521)\n        at org.springframework.transaction.interceptor.TransactionAspectSupport.invokeWithinTransaction(TransactionAspectSupport.java:291)\n        at org.springframework.transaction.interceptor.TransactionInterceptor.invoke(TransactionInterceptor.java:96)\n        at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:179)\n        at org.springframework.aop.framework.JdkDynamicAopProxy.invoke(JdkDynamicAopProxy.java:207)\n        at com.sun.proxy.$Proxy49.lazyAssignOrder(Unknown Source)\n        at com.smzc.provider.order.facade.OrderFacade.lazyAssignOrder(OrderFacade.java:1015)\n        at com.smzc.provider.order.schedule.LazyAssignOrderTask$2.run(LazyAssignOrderTask.java:51)\n        at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1145)\n        at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:615)\n        at java.lang.Thread.run(Thread.java:745)\nCaused by: javax.persistence.RollbackException: Transaction marked as rollbackOnly\n        at org.hibernate.jpa.internal.TransactionImpl.commit(TransactionImpl.java:74)\n        at org.springframework.orm.jpa.JpaTransactionManager.doCommit(JpaTransactionManager.java:517)\n        ... 13 more\n\n```\n## 代码示例-事务嵌套\n```java\n@Transaction\npublic void doA() {\n  // do something\n  try {\n    doB();\n  } catch(Exception e) {\n    doC();\n  }\n  // do something\n}\n\n@Transaction\npublic void doA2() {\n  // do something\n  try {\n    doB();\n  } catch(Exception e) {\n\n  }\n  // do save or update\n}\n\n@Transaction\npublic void doB() {\n  // do save or update\n  if(true) {\n    throw new Exception(\"模拟异常\");\n  }\n}\n\n@Transaction\npublic void doC() {\n  // do save or update\n}\n```\n__问题分析：__\n如上代码段，由于事务的传播性，doA,doB,doC方法其实共用的是由doA开启的同一个事务对象。\n当doB方法抛出异常后事务被标记为回滚状态，再尝试执行doC方法或者执行任何的更改方法，在进行数据更新后进行事务commit时，此时则为抛出以上的异常。\n\n__解决方法：__\n```java\npublic class ClassA {\n  private ClassB classB;\n  //@Transaction\n  public void doA() {\n    try {\n      classB.doB();\n    } catch(Exception e) {\n      classB.doC();\n    }\n  }\n}\n\npublic class ClassB {\n  @Transaction\n  public void doB() {\n    if(1==1) {\n      throw new Exception(\"模拟异常\");\n    }\n  }\n\n  @Transaction\n  public void doC() {\n    //有数据更改动作\n  }\n}\n```\n以上的解决方法去掉了doA的事务，交由doB与doC分别开启两个事务解决，当doB失败时只标记doB的事务回滚，doC的事务依然能进行提交。\n\n\n-----\n\n*观点仅代表自己，期待你的留言。*\n","source":"_posts/transaction-mark-rollbackonly.md","raw":"---\ntitle: 问题分析 之 Transaction marked as rollbackOnly\nkeywords:\n  - 数据库事务\n  - Transaction marked as rollbackOnly\ntags:\n  - 原创\n  - Transaction\n  - spring\ndate: 2017-07-21 17:01:27\n---\n\n## 问题现象\n```java\norg.springframework.transaction.TransactionSystemException: Could not commit JPA transaction; nested exception is javax.persistence.RollbackException: Transaction marked as rollbackOnly\n        at org.springframework.orm.jpa.JpaTransactionManager.doCommit(JpaTransactionManager.java:526)\n        at org.springframework.transaction.support.AbstractPlatformTransactionManager.processCommit(AbstractPlatformTransactionManager.java:757)\n        at org.springframework.transaction.support.AbstractPlatformTransactionManager.commit(AbstractPlatformTransactionManager.java:726)\n        at org.springframework.transaction.interceptor.TransactionAspectSupport.commitTransactionAfterReturning(TransactionAspectSupport.java:521)\n        at org.springframework.transaction.interceptor.TransactionAspectSupport.invokeWithinTransaction(TransactionAspectSupport.java:291)\n        at org.springframework.transaction.interceptor.TransactionInterceptor.invoke(TransactionInterceptor.java:96)\n        at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:179)\n        at org.springframework.aop.framework.JdkDynamicAopProxy.invoke(JdkDynamicAopProxy.java:207)\n        at com.sun.proxy.$Proxy49.lazyAssignOrder(Unknown Source)\n        at com.smzc.provider.order.facade.OrderFacade.lazyAssignOrder(OrderFacade.java:1015)\n        at com.smzc.provider.order.schedule.LazyAssignOrderTask$2.run(LazyAssignOrderTask.java:51)\n        at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1145)\n        at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:615)\n        at java.lang.Thread.run(Thread.java:745)\nCaused by: javax.persistence.RollbackException: Transaction marked as rollbackOnly\n        at org.hibernate.jpa.internal.TransactionImpl.commit(TransactionImpl.java:74)\n        at org.springframework.orm.jpa.JpaTransactionManager.doCommit(JpaTransactionManager.java:517)\n        ... 13 more\n\n```\n## 代码示例-事务嵌套\n```java\n@Transaction\npublic void doA() {\n  // do something\n  try {\n    doB();\n  } catch(Exception e) {\n    doC();\n  }\n  // do something\n}\n\n@Transaction\npublic void doA2() {\n  // do something\n  try {\n    doB();\n  } catch(Exception e) {\n\n  }\n  // do save or update\n}\n\n@Transaction\npublic void doB() {\n  // do save or update\n  if(true) {\n    throw new Exception(\"模拟异常\");\n  }\n}\n\n@Transaction\npublic void doC() {\n  // do save or update\n}\n```\n__问题分析：__\n如上代码段，由于事务的传播性，doA,doB,doC方法其实共用的是由doA开启的同一个事务对象。\n当doB方法抛出异常后事务被标记为回滚状态，再尝试执行doC方法或者执行任何的更改方法，在进行数据更新后进行事务commit时，此时则为抛出以上的异常。\n\n__解决方法：__\n```java\npublic class ClassA {\n  private ClassB classB;\n  //@Transaction\n  public void doA() {\n    try {\n      classB.doB();\n    } catch(Exception e) {\n      classB.doC();\n    }\n  }\n}\n\npublic class ClassB {\n  @Transaction\n  public void doB() {\n    if(1==1) {\n      throw new Exception(\"模拟异常\");\n    }\n  }\n\n  @Transaction\n  public void doC() {\n    //有数据更改动作\n  }\n}\n```\n以上的解决方法去掉了doA的事务，交由doB与doC分别开启两个事务解决，当doB失败时只标记doB的事务回滚，doC的事务依然能进行提交。\n\n\n-----\n\n*观点仅代表自己，期待你的留言。*\n","slug":"transaction-mark-rollbackonly","published":1,"updated":"2021-08-31T14:23:11.553Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cku52dypr005qbbingsvrcjyn","content":"<h2 id=\"问题现象\"><a href=\"#问题现象\" class=\"headerlink\" title=\"问题现象\"></a>问题现象</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">org.springframework.transaction.TransactionSystemException: Could not commit JPA transaction; nested exception is javax.persistence.RollbackException: Transaction marked as rollbackOnly</span><br><span class=\"line\">        at org.springframework.orm.jpa.JpaTransactionManager.doCommit(JpaTransactionManager.java:<span class=\"number\">526</span>)</span><br><span class=\"line\">        at org.springframework.transaction.support.AbstractPlatformTransactionManager.processCommit(AbstractPlatformTransactionManager.java:<span class=\"number\">757</span>)</span><br><span class=\"line\">        at org.springframework.transaction.support.AbstractPlatformTransactionManager.commit(AbstractPlatformTransactionManager.java:<span class=\"number\">726</span>)</span><br><span class=\"line\">        at org.springframework.transaction.interceptor.TransactionAspectSupport.commitTransactionAfterReturning(TransactionAspectSupport.java:<span class=\"number\">521</span>)</span><br><span class=\"line\">        at org.springframework.transaction.interceptor.TransactionAspectSupport.invokeWithinTransaction(TransactionAspectSupport.java:<span class=\"number\">291</span>)</span><br><span class=\"line\">        at org.springframework.transaction.interceptor.TransactionInterceptor.invoke(TransactionInterceptor.java:<span class=\"number\">96</span>)</span><br><span class=\"line\">        at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:<span class=\"number\">179</span>)</span><br><span class=\"line\">        at org.springframework.aop.framework.JdkDynamicAopProxy.invoke(JdkDynamicAopProxy.java:<span class=\"number\">207</span>)</span><br><span class=\"line\">        at com.sun.proxy.$Proxy49.lazyAssignOrder(Unknown Source)</span><br><span class=\"line\">        at com.smzc.provider.order.facade.OrderFacade.lazyAssignOrder(OrderFacade.java:<span class=\"number\">1015</span>)</span><br><span class=\"line\">        at com.smzc.provider.order.schedule.LazyAssignOrderTask$<span class=\"number\">2.</span>run(LazyAssignOrderTask.java:<span class=\"number\">51</span>)</span><br><span class=\"line\">        at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:<span class=\"number\">1145</span>)</span><br><span class=\"line\">        at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:<span class=\"number\">615</span>)</span><br><span class=\"line\">        at java.lang.Thread.run(Thread.java:<span class=\"number\">745</span>)</span><br><span class=\"line\">Caused by: javax.persistence.RollbackException: Transaction marked as rollbackOnly</span><br><span class=\"line\">        at org.hibernate.jpa.internal.TransactionImpl.commit(TransactionImpl.java:<span class=\"number\">74</span>)</span><br><span class=\"line\">        at org.springframework.orm.jpa.JpaTransactionManager.doCommit(JpaTransactionManager.java:<span class=\"number\">517</span>)</span><br><span class=\"line\">        ... <span class=\"number\">13</span> more</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h2 id=\"代码示例-事务嵌套\"><a href=\"#代码示例-事务嵌套\" class=\"headerlink\" title=\"代码示例-事务嵌套\"></a>代码示例-事务嵌套</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Transaction</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">doA</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// do something</span></span><br><span class=\"line\">  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    doB();</span><br><span class=\"line\">  &#125; <span class=\"keyword\">catch</span>(Exception e) &#123;</span><br><span class=\"line\">    doC();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// do something</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Transaction</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">doA2</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// do something</span></span><br><span class=\"line\">  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    doB();</span><br><span class=\"line\">  &#125; <span class=\"keyword\">catch</span>(Exception e) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// do save or update</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Transaction</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">doB</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// do save or update</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span>(<span class=\"keyword\">true</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> Exception(<span class=\"string\">&quot;模拟异常&quot;</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Transaction</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">doC</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// do save or update</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>问题分析：</strong><br>如上代码段，由于事务的传播性，doA,doB,doC方法其实共用的是由doA开启的同一个事务对象。<br>当doB方法抛出异常后事务被标记为回滚状态，再尝试执行doC方法或者执行任何的更改方法，在进行数据更新后进行事务commit时，此时则为抛出以上的异常。</p>\n<p><strong>解决方法：</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ClassA</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> ClassB classB;</span><br><span class=\"line\">  <span class=\"comment\">//@Transaction</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">doA</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">      classB.doB();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span>(Exception e) &#123;</span><br><span class=\"line\">      classB.doC();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ClassB</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"meta\">@Transaction</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">doB</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"number\">1</span>==<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> Exception(<span class=\"string\">&quot;模拟异常&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@Transaction</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">doC</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//有数据更改动作</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>以上的解决方法去掉了doA的事务，交由doB与doC分别开启两个事务解决，当doB失败时只标记doB的事务回滚，doC的事务依然能进行提交。</p>\n<hr>\n<p><em>观点仅代表自己，期待你的留言。</em></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"问题现象\"><a href=\"#问题现象\" class=\"headerlink\" title=\"问题现象\"></a>问题现象</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">org.springframework.transaction.TransactionSystemException: Could not commit JPA transaction; nested exception is javax.persistence.RollbackException: Transaction marked as rollbackOnly</span><br><span class=\"line\">        at org.springframework.orm.jpa.JpaTransactionManager.doCommit(JpaTransactionManager.java:<span class=\"number\">526</span>)</span><br><span class=\"line\">        at org.springframework.transaction.support.AbstractPlatformTransactionManager.processCommit(AbstractPlatformTransactionManager.java:<span class=\"number\">757</span>)</span><br><span class=\"line\">        at org.springframework.transaction.support.AbstractPlatformTransactionManager.commit(AbstractPlatformTransactionManager.java:<span class=\"number\">726</span>)</span><br><span class=\"line\">        at org.springframework.transaction.interceptor.TransactionAspectSupport.commitTransactionAfterReturning(TransactionAspectSupport.java:<span class=\"number\">521</span>)</span><br><span class=\"line\">        at org.springframework.transaction.interceptor.TransactionAspectSupport.invokeWithinTransaction(TransactionAspectSupport.java:<span class=\"number\">291</span>)</span><br><span class=\"line\">        at org.springframework.transaction.interceptor.TransactionInterceptor.invoke(TransactionInterceptor.java:<span class=\"number\">96</span>)</span><br><span class=\"line\">        at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:<span class=\"number\">179</span>)</span><br><span class=\"line\">        at org.springframework.aop.framework.JdkDynamicAopProxy.invoke(JdkDynamicAopProxy.java:<span class=\"number\">207</span>)</span><br><span class=\"line\">        at com.sun.proxy.$Proxy49.lazyAssignOrder(Unknown Source)</span><br><span class=\"line\">        at com.smzc.provider.order.facade.OrderFacade.lazyAssignOrder(OrderFacade.java:<span class=\"number\">1015</span>)</span><br><span class=\"line\">        at com.smzc.provider.order.schedule.LazyAssignOrderTask$<span class=\"number\">2.</span>run(LazyAssignOrderTask.java:<span class=\"number\">51</span>)</span><br><span class=\"line\">        at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:<span class=\"number\">1145</span>)</span><br><span class=\"line\">        at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:<span class=\"number\">615</span>)</span><br><span class=\"line\">        at java.lang.Thread.run(Thread.java:<span class=\"number\">745</span>)</span><br><span class=\"line\">Caused by: javax.persistence.RollbackException: Transaction marked as rollbackOnly</span><br><span class=\"line\">        at org.hibernate.jpa.internal.TransactionImpl.commit(TransactionImpl.java:<span class=\"number\">74</span>)</span><br><span class=\"line\">        at org.springframework.orm.jpa.JpaTransactionManager.doCommit(JpaTransactionManager.java:<span class=\"number\">517</span>)</span><br><span class=\"line\">        ... <span class=\"number\">13</span> more</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h2 id=\"代码示例-事务嵌套\"><a href=\"#代码示例-事务嵌套\" class=\"headerlink\" title=\"代码示例-事务嵌套\"></a>代码示例-事务嵌套</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Transaction</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">doA</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// do something</span></span><br><span class=\"line\">  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    doB();</span><br><span class=\"line\">  &#125; <span class=\"keyword\">catch</span>(Exception e) &#123;</span><br><span class=\"line\">    doC();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// do something</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Transaction</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">doA2</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// do something</span></span><br><span class=\"line\">  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    doB();</span><br><span class=\"line\">  &#125; <span class=\"keyword\">catch</span>(Exception e) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// do save or update</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Transaction</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">doB</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// do save or update</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span>(<span class=\"keyword\">true</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> Exception(<span class=\"string\">&quot;模拟异常&quot;</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Transaction</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">doC</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// do save or update</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>问题分析：</strong><br>如上代码段，由于事务的传播性，doA,doB,doC方法其实共用的是由doA开启的同一个事务对象。<br>当doB方法抛出异常后事务被标记为回滚状态，再尝试执行doC方法或者执行任何的更改方法，在进行数据更新后进行事务commit时，此时则为抛出以上的异常。</p>\n<p><strong>解决方法：</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ClassA</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> ClassB classB;</span><br><span class=\"line\">  <span class=\"comment\">//@Transaction</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">doA</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">      classB.doB();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span>(Exception e) &#123;</span><br><span class=\"line\">      classB.doC();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ClassB</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"meta\">@Transaction</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">doB</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"number\">1</span>==<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> Exception(<span class=\"string\">&quot;模拟异常&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@Transaction</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">doC</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//有数据更改动作</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>以上的解决方法去掉了doA的事务，交由doB与doC分别开启两个事务解决，当doB失败时只标记doB的事务回滚，doC的事务依然能进行提交。</p>\n<hr>\n<p><em>观点仅代表自己，期待你的留言。</em></p>\n"},{"title":"Zookeeper学习笔记","keywords":["Zookeeper","分布式服务框架"],"date":"2016-06-03T10:32:58.000Z","_content":"\n## 简介\nZookeeper 分布式服务框架是 Apache Hadoop 的一个子项目，它主要是用来解决分布式应用中经常遇到的一些数据管理问题，如：统一命名服务、状态同步服务、集群管理、分布式应用配置项的管理等。\n\nZookeeper的数据存储模型：ZK会维护一个具有层次关系的数据结构，它非常类似于一个标准的文件系统。\n![Zookeeper的数据存储模型](/images/zk_data_model.gif)\n\nZookeeper 数据结构有如下这些特点：\n1. 每个子目录项如 NameService 都被称作为 znode，这个 znode 是被它所在的路径唯一标识，如 Server1 这个 znode 的标识为 /NameService/Server1\n2. znode 可以有子节点目录，并且每个 znode 可以存储数据，注意 EPHEMERAL 类型的目录节点不能有子节点目录\n3. znode 是有版本的，每个 znode 中存储的数据可以有多个版本，也就是一个访问路径中可以存储多份数据\n4. znode 可以是临时节点，一旦创建这个 znode 的客户端与服务器失去联系，这个 znode 也将自动删除，Zookeeper 的客户端和服务器通信采用长连接方式，每个客户端和服务器通过心跳来保持连接，这个连接状态称为 session，如果 znode 是临时节点，这个 session 失效，znode 也就删除了\n5. znode 的目录名可以自动编号，如 App1 已经存在，再创建的话，将会自动命名为 App2\n6. znode 可以被监控，包括这个目录节点中存储的数据的修改，子节点目录的变化等，一旦变化可以通知设置监控的客户端，这个是 Zookeeper 的核心特性，Zookeeper 的很多功能都是基于这个特性实现的\n\nZnode目录节点类型：\n1. PERSISTENT：持久化目录节点，这个目录节点存储的数据不会丢失；\n2. PERSISTENT_SEQUENTIAL：顺序自动编号的目录节点，这种目录节点会根据当前已近存在的节点数自动加 1，然后返回给客户端已经成功创建的目录节点名；\n3. EPHEMERAL：临时目录节点，一旦创建这个节点的客户端与服务器端口也就是 session 超时，这种节点会被自动删除；\n4. EPHEMERAL_SEQUENTIAL：临时自动编号节点\n\n## 适用场景\n### 统一命名服务（Name Service）\n分布式应用中，通常需要有一套完整的命名规则，既能够产生唯一的名称又便于人识别和记住，通常情况下用树形的名称结构是一个理想的选择，树形的名称结构是一个有层次的目录结构，既对人友好又不会重复。说到这里你可能想到了 JNDI，没错 Zookeeper 的 Name Service 与 JNDI 能够完成的功能是差不多的，它们都是将有层次的目录结构关联到一定资源上，但是 Zookeeper 的 Name Service 更加是广泛意义上的关联，也许你并不需要将名称关联到特定资源上，你可能只需要一个不会重复名称，就像数据库中产生一个唯一的数字主键一样。\nName Service 已经是 Zookeeper 内置的功能，你只要调用 Zookeeper 的 API 就能实现。如调用 create 接口就可以很容易创建一个目录节点。\n### 配置管理（Configuration Management）\n配置的管理在分布式应用环境中很常见，例如同一个应用系统需要多台 PC Server 运行，但是它们运行的应用系统的某些配置项是相同的，如果要修改这些相同的配置项，那么就必须同时修改每台运行这个应用系统的 PC Server，这样非常麻烦而且容易出错。\n像这样的配置信息完全可以交给 Zookeeper 来管理，将配置信息保存在 Zookeeper 的某个目录节点中，然后将所有需要修改的应用机器监控配置信息的状态，一旦配置信息发生变化，每台应用机器就会收到 Zookeeper 的通知，然后从 Zookeeper 获取新的配置信息应用到系统中。\n![配置管理结构图](/images/zk-config-manager.gif)\n### 集群管理（Group Membership）\nZookeeper 能够很容易的实现集群管理的功能，如有多台 Server 组成一个服务集群，那么必须要一个“总管”知道当前集群中每台机器的服务状态，一旦有机器不能提供服务，集群中其它集群必须知道，从而做出调整重新分配服务策略。同样当增加集群的服务能力时，就会增加一台或多台 Server，同样也必须让“总管”知道。\nZookeeper 不仅能够帮你维护当前的集群中机器的服务状态，而且能够帮你选出一个“总管”，让这个总管来管理集群，这就是 Zookeeper 的另一个功能 Leader Election。\n它们的实现方式都是在 Zookeeper 上创建一个 EPHEMERAL 类型的目录节点，然后每个 Server 在它们创建目录节点的父目录节点上调用 getChildren(String path, boolean watch) 方法并设置 watch 为 true，由于是 EPHEMERAL 目录节点，当创建它的 Server 死去，这个目录节点也随之被删除，所以 Children 将会变化，这时 getChildren上的 Watch 将会被调用，所以其它 Server 就知道已经有某台 Server 死去了。新增 Server 也是同样的原理。\nZookeeper 如何实现 Leader Election，也就是选出一个 Master Server。和前面的一样每台 Server 创建一个 EPHEMERAL 目录节点，不同的是它还是一个 SEQUENTIAL 目录节点，所以它是个 EPHEMERAL_SEQUENTIAL 目录节点。之所以它是 EPHEMERAL_SEQUENTIAL 目录节点，是因为我们可以给每台 Server 编号，我们可以选择当前是最小编号的 Server 为 Master，假如这个最小编号的 Server 死去，由于是 EPHEMERAL 节点，死去的 Server 对应的节点也被删除，所以当前的节点列表中又出现一个最小编号的节点，我们就选择这个节点为当前 Master。这样就实现了动态选择 Master，避免了传统意义上单 Master 容易出现单点故障的问题。\n![集群管理结构图](/images/zk-cluster-manager.gif)\n### 共享锁（Locks）\n共享锁在同一个进程中很容易实现，但是在跨进程或者在不同 Server 之间就不好实现了。Zookeeper 却很容易实现这个功能，实现方式也是需要获得锁的 Server 创建一个 EPHEMERAL_SEQUENTIAL 目录节点，然后调用 getChildren方法获取当前的目录节点列表中最小的目录节点是不是就是自己创建的目录节点，如果正是自己创建的，那么它就获得了这个锁，如果不是那么它就调用 exists(String path, boolean watch) 方法并监控 Zookeeper 上目录节点列表的变化，一直到自己创建的节点是列表中最小编号的目录节点，从而获得锁，释放锁很简单，只要删除前面它自己所创建的目录节点就行了。\n### 队列管理\nZookeeper 可以处理两种类型的队列：\n1. 当一个队列的成员都聚齐时，这个队列才可用，否则一直等待所有成员到达，这种是同步队列。\n2. 队列按照 FIFO 方式进行入队和出队操作，例如实现生产者和消费者模型。\n同步队列用 Zookeeper 实现的实现思路如下：\n创建一个父目录 /synchronizing，每个成员都监控标志（Set Watch）位目录 /synchronizing/start 是否存在，然后每个成员都加入这个队列，加入队列的方式就是创建 /synchronizing/member_i 的临时目录节点，然后每个成员获取 / synchronizing 目录的所有目录节点，也就是 member_i。判断 i 的值是否已经是成员的个数，如果小于成员个数等待 /synchronizing/start 的出现，如果已经相等就创建 /synchronizing/start。\n## 集群配置\n_zoo.cfg_\n```\ninitLimit=5 \nsyncLimit=2 \nserver.1=192.168.211.1:2888:3888 \nserver.2=192.168.211.2:2888:3888\n```\n_说明:_\n* initLimit：这个配置项是用来配置 Zookeeper 接受客户端（这里所说的客户端不是用户连接 Zookeeper 服务器的客户端，而是 Zookeeper 服务器集群中连接到 Leader 的 Follower 服务器）初始化连接时最长能忍受多少个心跳时间间隔数。当已经超过 10 个心跳的时间（也就是 tickTime）长度后 Zookeeper 服务器还没有收到客户端的返回信息，那么表明这个客户端连接失败。总的时间长度就是 5*2000=10 秒\n* syncLimit：这个配置项标识 Leader 与 Follower 之间发送消息，请求和应答时间长度，最长不能超过多少个 tickTime 的时间长度，总的时间长度就是 2*2000=4 秒\n* server.A=B：C：D：其中 A 是一个数字，表示这个是第几号服务器；B 是这个服务器的 ip 地址；C 表示的是这个服务器与集群中的 Leader 服务器交换信息的端口；D 表示的是万一集群中的 Leader 服务器挂了，需要一个端口来重新进行选举，选出一个新的 Leader，而这个端口就是用来执行选举时服务器相互通信的端口。如果是伪集群的配置方式，由于 B 都是一样，所以不同的 Zookeeper 实例通信端口号不能一样，所以要给它们分配不同的端口号。\n\n-----\n除了修改 zoo.cfg 配置文件，集群模式下还要配置一个文件 myid，这个文件在 dataDir 目录下，这个文件里面就有一个数据就是 A 的值，Zookeeper 启动时会读取这个文件，拿到里面的数据与 zoo.cfg 里面的配置信息比较从而判断到底是那个 server。\n\n-----\n\n*观点仅代表自己，期待你的留言。*\n\nhttps://www.ibm.com/developerworks/cn/opensource/os-cn-zookeeper/","source":"_posts/zookeeper-note.md","raw":"---\ntitle: Zookeeper学习笔记\nkeywords: \n  - Zookeeper\n  - 分布式服务框架\ntags:\n  - 关键笔记\ndate: 2016-06-03 18:32:58\n---\n\n## 简介\nZookeeper 分布式服务框架是 Apache Hadoop 的一个子项目，它主要是用来解决分布式应用中经常遇到的一些数据管理问题，如：统一命名服务、状态同步服务、集群管理、分布式应用配置项的管理等。\n\nZookeeper的数据存储模型：ZK会维护一个具有层次关系的数据结构，它非常类似于一个标准的文件系统。\n![Zookeeper的数据存储模型](/images/zk_data_model.gif)\n\nZookeeper 数据结构有如下这些特点：\n1. 每个子目录项如 NameService 都被称作为 znode，这个 znode 是被它所在的路径唯一标识，如 Server1 这个 znode 的标识为 /NameService/Server1\n2. znode 可以有子节点目录，并且每个 znode 可以存储数据，注意 EPHEMERAL 类型的目录节点不能有子节点目录\n3. znode 是有版本的，每个 znode 中存储的数据可以有多个版本，也就是一个访问路径中可以存储多份数据\n4. znode 可以是临时节点，一旦创建这个 znode 的客户端与服务器失去联系，这个 znode 也将自动删除，Zookeeper 的客户端和服务器通信采用长连接方式，每个客户端和服务器通过心跳来保持连接，这个连接状态称为 session，如果 znode 是临时节点，这个 session 失效，znode 也就删除了\n5. znode 的目录名可以自动编号，如 App1 已经存在，再创建的话，将会自动命名为 App2\n6. znode 可以被监控，包括这个目录节点中存储的数据的修改，子节点目录的变化等，一旦变化可以通知设置监控的客户端，这个是 Zookeeper 的核心特性，Zookeeper 的很多功能都是基于这个特性实现的\n\nZnode目录节点类型：\n1. PERSISTENT：持久化目录节点，这个目录节点存储的数据不会丢失；\n2. PERSISTENT_SEQUENTIAL：顺序自动编号的目录节点，这种目录节点会根据当前已近存在的节点数自动加 1，然后返回给客户端已经成功创建的目录节点名；\n3. EPHEMERAL：临时目录节点，一旦创建这个节点的客户端与服务器端口也就是 session 超时，这种节点会被自动删除；\n4. EPHEMERAL_SEQUENTIAL：临时自动编号节点\n\n## 适用场景\n### 统一命名服务（Name Service）\n分布式应用中，通常需要有一套完整的命名规则，既能够产生唯一的名称又便于人识别和记住，通常情况下用树形的名称结构是一个理想的选择，树形的名称结构是一个有层次的目录结构，既对人友好又不会重复。说到这里你可能想到了 JNDI，没错 Zookeeper 的 Name Service 与 JNDI 能够完成的功能是差不多的，它们都是将有层次的目录结构关联到一定资源上，但是 Zookeeper 的 Name Service 更加是广泛意义上的关联，也许你并不需要将名称关联到特定资源上，你可能只需要一个不会重复名称，就像数据库中产生一个唯一的数字主键一样。\nName Service 已经是 Zookeeper 内置的功能，你只要调用 Zookeeper 的 API 就能实现。如调用 create 接口就可以很容易创建一个目录节点。\n### 配置管理（Configuration Management）\n配置的管理在分布式应用环境中很常见，例如同一个应用系统需要多台 PC Server 运行，但是它们运行的应用系统的某些配置项是相同的，如果要修改这些相同的配置项，那么就必须同时修改每台运行这个应用系统的 PC Server，这样非常麻烦而且容易出错。\n像这样的配置信息完全可以交给 Zookeeper 来管理，将配置信息保存在 Zookeeper 的某个目录节点中，然后将所有需要修改的应用机器监控配置信息的状态，一旦配置信息发生变化，每台应用机器就会收到 Zookeeper 的通知，然后从 Zookeeper 获取新的配置信息应用到系统中。\n![配置管理结构图](/images/zk-config-manager.gif)\n### 集群管理（Group Membership）\nZookeeper 能够很容易的实现集群管理的功能，如有多台 Server 组成一个服务集群，那么必须要一个“总管”知道当前集群中每台机器的服务状态，一旦有机器不能提供服务，集群中其它集群必须知道，从而做出调整重新分配服务策略。同样当增加集群的服务能力时，就会增加一台或多台 Server，同样也必须让“总管”知道。\nZookeeper 不仅能够帮你维护当前的集群中机器的服务状态，而且能够帮你选出一个“总管”，让这个总管来管理集群，这就是 Zookeeper 的另一个功能 Leader Election。\n它们的实现方式都是在 Zookeeper 上创建一个 EPHEMERAL 类型的目录节点，然后每个 Server 在它们创建目录节点的父目录节点上调用 getChildren(String path, boolean watch) 方法并设置 watch 为 true，由于是 EPHEMERAL 目录节点，当创建它的 Server 死去，这个目录节点也随之被删除，所以 Children 将会变化，这时 getChildren上的 Watch 将会被调用，所以其它 Server 就知道已经有某台 Server 死去了。新增 Server 也是同样的原理。\nZookeeper 如何实现 Leader Election，也就是选出一个 Master Server。和前面的一样每台 Server 创建一个 EPHEMERAL 目录节点，不同的是它还是一个 SEQUENTIAL 目录节点，所以它是个 EPHEMERAL_SEQUENTIAL 目录节点。之所以它是 EPHEMERAL_SEQUENTIAL 目录节点，是因为我们可以给每台 Server 编号，我们可以选择当前是最小编号的 Server 为 Master，假如这个最小编号的 Server 死去，由于是 EPHEMERAL 节点，死去的 Server 对应的节点也被删除，所以当前的节点列表中又出现一个最小编号的节点，我们就选择这个节点为当前 Master。这样就实现了动态选择 Master，避免了传统意义上单 Master 容易出现单点故障的问题。\n![集群管理结构图](/images/zk-cluster-manager.gif)\n### 共享锁（Locks）\n共享锁在同一个进程中很容易实现，但是在跨进程或者在不同 Server 之间就不好实现了。Zookeeper 却很容易实现这个功能，实现方式也是需要获得锁的 Server 创建一个 EPHEMERAL_SEQUENTIAL 目录节点，然后调用 getChildren方法获取当前的目录节点列表中最小的目录节点是不是就是自己创建的目录节点，如果正是自己创建的，那么它就获得了这个锁，如果不是那么它就调用 exists(String path, boolean watch) 方法并监控 Zookeeper 上目录节点列表的变化，一直到自己创建的节点是列表中最小编号的目录节点，从而获得锁，释放锁很简单，只要删除前面它自己所创建的目录节点就行了。\n### 队列管理\nZookeeper 可以处理两种类型的队列：\n1. 当一个队列的成员都聚齐时，这个队列才可用，否则一直等待所有成员到达，这种是同步队列。\n2. 队列按照 FIFO 方式进行入队和出队操作，例如实现生产者和消费者模型。\n同步队列用 Zookeeper 实现的实现思路如下：\n创建一个父目录 /synchronizing，每个成员都监控标志（Set Watch）位目录 /synchronizing/start 是否存在，然后每个成员都加入这个队列，加入队列的方式就是创建 /synchronizing/member_i 的临时目录节点，然后每个成员获取 / synchronizing 目录的所有目录节点，也就是 member_i。判断 i 的值是否已经是成员的个数，如果小于成员个数等待 /synchronizing/start 的出现，如果已经相等就创建 /synchronizing/start。\n## 集群配置\n_zoo.cfg_\n```\ninitLimit=5 \nsyncLimit=2 \nserver.1=192.168.211.1:2888:3888 \nserver.2=192.168.211.2:2888:3888\n```\n_说明:_\n* initLimit：这个配置项是用来配置 Zookeeper 接受客户端（这里所说的客户端不是用户连接 Zookeeper 服务器的客户端，而是 Zookeeper 服务器集群中连接到 Leader 的 Follower 服务器）初始化连接时最长能忍受多少个心跳时间间隔数。当已经超过 10 个心跳的时间（也就是 tickTime）长度后 Zookeeper 服务器还没有收到客户端的返回信息，那么表明这个客户端连接失败。总的时间长度就是 5*2000=10 秒\n* syncLimit：这个配置项标识 Leader 与 Follower 之间发送消息，请求和应答时间长度，最长不能超过多少个 tickTime 的时间长度，总的时间长度就是 2*2000=4 秒\n* server.A=B：C：D：其中 A 是一个数字，表示这个是第几号服务器；B 是这个服务器的 ip 地址；C 表示的是这个服务器与集群中的 Leader 服务器交换信息的端口；D 表示的是万一集群中的 Leader 服务器挂了，需要一个端口来重新进行选举，选出一个新的 Leader，而这个端口就是用来执行选举时服务器相互通信的端口。如果是伪集群的配置方式，由于 B 都是一样，所以不同的 Zookeeper 实例通信端口号不能一样，所以要给它们分配不同的端口号。\n\n-----\n除了修改 zoo.cfg 配置文件，集群模式下还要配置一个文件 myid，这个文件在 dataDir 目录下，这个文件里面就有一个数据就是 A 的值，Zookeeper 启动时会读取这个文件，拿到里面的数据与 zoo.cfg 里面的配置信息比较从而判断到底是那个 server。\n\n-----\n\n*观点仅代表自己，期待你的留言。*\n\nhttps://www.ibm.com/developerworks/cn/opensource/os-cn-zookeeper/","slug":"zookeeper-note","published":1,"updated":"2021-08-31T14:23:11.553Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cku52dyqg007sbbin8sd8614f","content":"<h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><p>Zookeeper 分布式服务框架是 Apache Hadoop 的一个子项目，它主要是用来解决分布式应用中经常遇到的一些数据管理问题，如：统一命名服务、状态同步服务、集群管理、分布式应用配置项的管理等。</p>\n<p>Zookeeper的数据存储模型：ZK会维护一个具有层次关系的数据结构，它非常类似于一个标准的文件系统。<br><img src=\"/images/zk_data_model.gif\" alt=\"Zookeeper的数据存储模型\"></p>\n<p>Zookeeper 数据结构有如下这些特点：</p>\n<ol>\n<li>每个子目录项如 NameService 都被称作为 znode，这个 znode 是被它所在的路径唯一标识，如 Server1 这个 znode 的标识为 /NameService/Server1</li>\n<li>znode 可以有子节点目录，并且每个 znode 可以存储数据，注意 EPHEMERAL 类型的目录节点不能有子节点目录</li>\n<li>znode 是有版本的，每个 znode 中存储的数据可以有多个版本，也就是一个访问路径中可以存储多份数据</li>\n<li>znode 可以是临时节点，一旦创建这个 znode 的客户端与服务器失去联系，这个 znode 也将自动删除，Zookeeper 的客户端和服务器通信采用长连接方式，每个客户端和服务器通过心跳来保持连接，这个连接状态称为 session，如果 znode 是临时节点，这个 session 失效，znode 也就删除了</li>\n<li>znode 的目录名可以自动编号，如 App1 已经存在，再创建的话，将会自动命名为 App2</li>\n<li>znode 可以被监控，包括这个目录节点中存储的数据的修改，子节点目录的变化等，一旦变化可以通知设置监控的客户端，这个是 Zookeeper 的核心特性，Zookeeper 的很多功能都是基于这个特性实现的</li>\n</ol>\n<p>Znode目录节点类型：</p>\n<ol>\n<li>PERSISTENT：持久化目录节点，这个目录节点存储的数据不会丢失；</li>\n<li>PERSISTENT_SEQUENTIAL：顺序自动编号的目录节点，这种目录节点会根据当前已近存在的节点数自动加 1，然后返回给客户端已经成功创建的目录节点名；</li>\n<li>EPHEMERAL：临时目录节点，一旦创建这个节点的客户端与服务器端口也就是 session 超时，这种节点会被自动删除；</li>\n<li>EPHEMERAL_SEQUENTIAL：临时自动编号节点</li>\n</ol>\n<h2 id=\"适用场景\"><a href=\"#适用场景\" class=\"headerlink\" title=\"适用场景\"></a>适用场景</h2><h3 id=\"统一命名服务（Name-Service）\"><a href=\"#统一命名服务（Name-Service）\" class=\"headerlink\" title=\"统一命名服务（Name Service）\"></a>统一命名服务（Name Service）</h3><p>分布式应用中，通常需要有一套完整的命名规则，既能够产生唯一的名称又便于人识别和记住，通常情况下用树形的名称结构是一个理想的选择，树形的名称结构是一个有层次的目录结构，既对人友好又不会重复。说到这里你可能想到了 JNDI，没错 Zookeeper 的 Name Service 与 JNDI 能够完成的功能是差不多的，它们都是将有层次的目录结构关联到一定资源上，但是 Zookeeper 的 Name Service 更加是广泛意义上的关联，也许你并不需要将名称关联到特定资源上，你可能只需要一个不会重复名称，就像数据库中产生一个唯一的数字主键一样。<br>Name Service 已经是 Zookeeper 内置的功能，你只要调用 Zookeeper 的 API 就能实现。如调用 create 接口就可以很容易创建一个目录节点。</p>\n<h3 id=\"配置管理（Configuration-Management）\"><a href=\"#配置管理（Configuration-Management）\" class=\"headerlink\" title=\"配置管理（Configuration Management）\"></a>配置管理（Configuration Management）</h3><p>配置的管理在分布式应用环境中很常见，例如同一个应用系统需要多台 PC Server 运行，但是它们运行的应用系统的某些配置项是相同的，如果要修改这些相同的配置项，那么就必须同时修改每台运行这个应用系统的 PC Server，这样非常麻烦而且容易出错。<br>像这样的配置信息完全可以交给 Zookeeper 来管理，将配置信息保存在 Zookeeper 的某个目录节点中，然后将所有需要修改的应用机器监控配置信息的状态，一旦配置信息发生变化，每台应用机器就会收到 Zookeeper 的通知，然后从 Zookeeper 获取新的配置信息应用到系统中。<br><img src=\"/images/zk-config-manager.gif\" alt=\"配置管理结构图\"></p>\n<h3 id=\"集群管理（Group-Membership）\"><a href=\"#集群管理（Group-Membership）\" class=\"headerlink\" title=\"集群管理（Group Membership）\"></a>集群管理（Group Membership）</h3><p>Zookeeper 能够很容易的实现集群管理的功能，如有多台 Server 组成一个服务集群，那么必须要一个“总管”知道当前集群中每台机器的服务状态，一旦有机器不能提供服务，集群中其它集群必须知道，从而做出调整重新分配服务策略。同样当增加集群的服务能力时，就会增加一台或多台 Server，同样也必须让“总管”知道。<br>Zookeeper 不仅能够帮你维护当前的集群中机器的服务状态，而且能够帮你选出一个“总管”，让这个总管来管理集群，这就是 Zookeeper 的另一个功能 Leader Election。<br>它们的实现方式都是在 Zookeeper 上创建一个 EPHEMERAL 类型的目录节点，然后每个 Server 在它们创建目录节点的父目录节点上调用 getChildren(String path, boolean watch) 方法并设置 watch 为 true，由于是 EPHEMERAL 目录节点，当创建它的 Server 死去，这个目录节点也随之被删除，所以 Children 将会变化，这时 getChildren上的 Watch 将会被调用，所以其它 Server 就知道已经有某台 Server 死去了。新增 Server 也是同样的原理。<br>Zookeeper 如何实现 Leader Election，也就是选出一个 Master Server。和前面的一样每台 Server 创建一个 EPHEMERAL 目录节点，不同的是它还是一个 SEQUENTIAL 目录节点，所以它是个 EPHEMERAL_SEQUENTIAL 目录节点。之所以它是 EPHEMERAL_SEQUENTIAL 目录节点，是因为我们可以给每台 Server 编号，我们可以选择当前是最小编号的 Server 为 Master，假如这个最小编号的 Server 死去，由于是 EPHEMERAL 节点，死去的 Server 对应的节点也被删除，所以当前的节点列表中又出现一个最小编号的节点，我们就选择这个节点为当前 Master。这样就实现了动态选择 Master，避免了传统意义上单 Master 容易出现单点故障的问题。<br><img src=\"/images/zk-cluster-manager.gif\" alt=\"集群管理结构图\"></p>\n<h3 id=\"共享锁（Locks）\"><a href=\"#共享锁（Locks）\" class=\"headerlink\" title=\"共享锁（Locks）\"></a>共享锁（Locks）</h3><p>共享锁在同一个进程中很容易实现，但是在跨进程或者在不同 Server 之间就不好实现了。Zookeeper 却很容易实现这个功能，实现方式也是需要获得锁的 Server 创建一个 EPHEMERAL_SEQUENTIAL 目录节点，然后调用 getChildren方法获取当前的目录节点列表中最小的目录节点是不是就是自己创建的目录节点，如果正是自己创建的，那么它就获得了这个锁，如果不是那么它就调用 exists(String path, boolean watch) 方法并监控 Zookeeper 上目录节点列表的变化，一直到自己创建的节点是列表中最小编号的目录节点，从而获得锁，释放锁很简单，只要删除前面它自己所创建的目录节点就行了。</p>\n<h3 id=\"队列管理\"><a href=\"#队列管理\" class=\"headerlink\" title=\"队列管理\"></a>队列管理</h3><p>Zookeeper 可以处理两种类型的队列：</p>\n<ol>\n<li>当一个队列的成员都聚齐时，这个队列才可用，否则一直等待所有成员到达，这种是同步队列。</li>\n<li>队列按照 FIFO 方式进行入队和出队操作，例如实现生产者和消费者模型。<br>同步队列用 Zookeeper 实现的实现思路如下：<br>创建一个父目录 /synchronizing，每个成员都监控标志（Set Watch）位目录 /synchronizing/start 是否存在，然后每个成员都加入这个队列，加入队列的方式就是创建 /synchronizing/member_i 的临时目录节点，然后每个成员获取 / synchronizing 目录的所有目录节点，也就是 member_i。判断 i 的值是否已经是成员的个数，如果小于成员个数等待 /synchronizing/start 的出现，如果已经相等就创建 /synchronizing/start。<h2 id=\"集群配置\"><a href=\"#集群配置\" class=\"headerlink\" title=\"集群配置\"></a>集群配置</h2><em>zoo.cfg</em><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">initLimit=5 </span><br><span class=\"line\">syncLimit=2 </span><br><span class=\"line\">server.1=192.168.211.1:2888:3888 </span><br><span class=\"line\">server.2=192.168.211.2:2888:3888</span><br></pre></td></tr></table></figure>\n<em>说明:</em></li>\n</ol>\n<ul>\n<li>initLimit：这个配置项是用来配置 Zookeeper 接受客户端（这里所说的客户端不是用户连接 Zookeeper 服务器的客户端，而是 Zookeeper 服务器集群中连接到 Leader 的 Follower 服务器）初始化连接时最长能忍受多少个心跳时间间隔数。当已经超过 10 个心跳的时间（也就是 tickTime）长度后 Zookeeper 服务器还没有收到客户端的返回信息，那么表明这个客户端连接失败。总的时间长度就是 5*2000=10 秒</li>\n<li>syncLimit：这个配置项标识 Leader 与 Follower 之间发送消息，请求和应答时间长度，最长不能超过多少个 tickTime 的时间长度，总的时间长度就是 2*2000=4 秒</li>\n<li>server.A=B：C：D：其中 A 是一个数字，表示这个是第几号服务器；B 是这个服务器的 ip 地址；C 表示的是这个服务器与集群中的 Leader 服务器交换信息的端口；D 表示的是万一集群中的 Leader 服务器挂了，需要一个端口来重新进行选举，选出一个新的 Leader，而这个端口就是用来执行选举时服务器相互通信的端口。如果是伪集群的配置方式，由于 B 都是一样，所以不同的 Zookeeper 实例通信端口号不能一样，所以要给它们分配不同的端口号。</li>\n</ul>\n<hr>\n<p>除了修改 zoo.cfg 配置文件，集群模式下还要配置一个文件 myid，这个文件在 dataDir 目录下，这个文件里面就有一个数据就是 A 的值，Zookeeper 启动时会读取这个文件，拿到里面的数据与 zoo.cfg 里面的配置信息比较从而判断到底是那个 server。</p>\n<hr>\n<p><em>观点仅代表自己，期待你的留言。</em></p>\n<p><a href=\"https://www.ibm.com/developerworks/cn/opensource/os-cn-zookeeper/\">https://www.ibm.com/developerworks/cn/opensource/os-cn-zookeeper/</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><p>Zookeeper 分布式服务框架是 Apache Hadoop 的一个子项目，它主要是用来解决分布式应用中经常遇到的一些数据管理问题，如：统一命名服务、状态同步服务、集群管理、分布式应用配置项的管理等。</p>\n<p>Zookeeper的数据存储模型：ZK会维护一个具有层次关系的数据结构，它非常类似于一个标准的文件系统。<br><img src=\"/images/zk_data_model.gif\" alt=\"Zookeeper的数据存储模型\"></p>\n<p>Zookeeper 数据结构有如下这些特点：</p>\n<ol>\n<li>每个子目录项如 NameService 都被称作为 znode，这个 znode 是被它所在的路径唯一标识，如 Server1 这个 znode 的标识为 /NameService/Server1</li>\n<li>znode 可以有子节点目录，并且每个 znode 可以存储数据，注意 EPHEMERAL 类型的目录节点不能有子节点目录</li>\n<li>znode 是有版本的，每个 znode 中存储的数据可以有多个版本，也就是一个访问路径中可以存储多份数据</li>\n<li>znode 可以是临时节点，一旦创建这个 znode 的客户端与服务器失去联系，这个 znode 也将自动删除，Zookeeper 的客户端和服务器通信采用长连接方式，每个客户端和服务器通过心跳来保持连接，这个连接状态称为 session，如果 znode 是临时节点，这个 session 失效，znode 也就删除了</li>\n<li>znode 的目录名可以自动编号，如 App1 已经存在，再创建的话，将会自动命名为 App2</li>\n<li>znode 可以被监控，包括这个目录节点中存储的数据的修改，子节点目录的变化等，一旦变化可以通知设置监控的客户端，这个是 Zookeeper 的核心特性，Zookeeper 的很多功能都是基于这个特性实现的</li>\n</ol>\n<p>Znode目录节点类型：</p>\n<ol>\n<li>PERSISTENT：持久化目录节点，这个目录节点存储的数据不会丢失；</li>\n<li>PERSISTENT_SEQUENTIAL：顺序自动编号的目录节点，这种目录节点会根据当前已近存在的节点数自动加 1，然后返回给客户端已经成功创建的目录节点名；</li>\n<li>EPHEMERAL：临时目录节点，一旦创建这个节点的客户端与服务器端口也就是 session 超时，这种节点会被自动删除；</li>\n<li>EPHEMERAL_SEQUENTIAL：临时自动编号节点</li>\n</ol>\n<h2 id=\"适用场景\"><a href=\"#适用场景\" class=\"headerlink\" title=\"适用场景\"></a>适用场景</h2><h3 id=\"统一命名服务（Name-Service）\"><a href=\"#统一命名服务（Name-Service）\" class=\"headerlink\" title=\"统一命名服务（Name Service）\"></a>统一命名服务（Name Service）</h3><p>分布式应用中，通常需要有一套完整的命名规则，既能够产生唯一的名称又便于人识别和记住，通常情况下用树形的名称结构是一个理想的选择，树形的名称结构是一个有层次的目录结构，既对人友好又不会重复。说到这里你可能想到了 JNDI，没错 Zookeeper 的 Name Service 与 JNDI 能够完成的功能是差不多的，它们都是将有层次的目录结构关联到一定资源上，但是 Zookeeper 的 Name Service 更加是广泛意义上的关联，也许你并不需要将名称关联到特定资源上，你可能只需要一个不会重复名称，就像数据库中产生一个唯一的数字主键一样。<br>Name Service 已经是 Zookeeper 内置的功能，你只要调用 Zookeeper 的 API 就能实现。如调用 create 接口就可以很容易创建一个目录节点。</p>\n<h3 id=\"配置管理（Configuration-Management）\"><a href=\"#配置管理（Configuration-Management）\" class=\"headerlink\" title=\"配置管理（Configuration Management）\"></a>配置管理（Configuration Management）</h3><p>配置的管理在分布式应用环境中很常见，例如同一个应用系统需要多台 PC Server 运行，但是它们运行的应用系统的某些配置项是相同的，如果要修改这些相同的配置项，那么就必须同时修改每台运行这个应用系统的 PC Server，这样非常麻烦而且容易出错。<br>像这样的配置信息完全可以交给 Zookeeper 来管理，将配置信息保存在 Zookeeper 的某个目录节点中，然后将所有需要修改的应用机器监控配置信息的状态，一旦配置信息发生变化，每台应用机器就会收到 Zookeeper 的通知，然后从 Zookeeper 获取新的配置信息应用到系统中。<br><img src=\"/images/zk-config-manager.gif\" alt=\"配置管理结构图\"></p>\n<h3 id=\"集群管理（Group-Membership）\"><a href=\"#集群管理（Group-Membership）\" class=\"headerlink\" title=\"集群管理（Group Membership）\"></a>集群管理（Group Membership）</h3><p>Zookeeper 能够很容易的实现集群管理的功能，如有多台 Server 组成一个服务集群，那么必须要一个“总管”知道当前集群中每台机器的服务状态，一旦有机器不能提供服务，集群中其它集群必须知道，从而做出调整重新分配服务策略。同样当增加集群的服务能力时，就会增加一台或多台 Server，同样也必须让“总管”知道。<br>Zookeeper 不仅能够帮你维护当前的集群中机器的服务状态，而且能够帮你选出一个“总管”，让这个总管来管理集群，这就是 Zookeeper 的另一个功能 Leader Election。<br>它们的实现方式都是在 Zookeeper 上创建一个 EPHEMERAL 类型的目录节点，然后每个 Server 在它们创建目录节点的父目录节点上调用 getChildren(String path, boolean watch) 方法并设置 watch 为 true，由于是 EPHEMERAL 目录节点，当创建它的 Server 死去，这个目录节点也随之被删除，所以 Children 将会变化，这时 getChildren上的 Watch 将会被调用，所以其它 Server 就知道已经有某台 Server 死去了。新增 Server 也是同样的原理。<br>Zookeeper 如何实现 Leader Election，也就是选出一个 Master Server。和前面的一样每台 Server 创建一个 EPHEMERAL 目录节点，不同的是它还是一个 SEQUENTIAL 目录节点，所以它是个 EPHEMERAL_SEQUENTIAL 目录节点。之所以它是 EPHEMERAL_SEQUENTIAL 目录节点，是因为我们可以给每台 Server 编号，我们可以选择当前是最小编号的 Server 为 Master，假如这个最小编号的 Server 死去，由于是 EPHEMERAL 节点，死去的 Server 对应的节点也被删除，所以当前的节点列表中又出现一个最小编号的节点，我们就选择这个节点为当前 Master。这样就实现了动态选择 Master，避免了传统意义上单 Master 容易出现单点故障的问题。<br><img src=\"/images/zk-cluster-manager.gif\" alt=\"集群管理结构图\"></p>\n<h3 id=\"共享锁（Locks）\"><a href=\"#共享锁（Locks）\" class=\"headerlink\" title=\"共享锁（Locks）\"></a>共享锁（Locks）</h3><p>共享锁在同一个进程中很容易实现，但是在跨进程或者在不同 Server 之间就不好实现了。Zookeeper 却很容易实现这个功能，实现方式也是需要获得锁的 Server 创建一个 EPHEMERAL_SEQUENTIAL 目录节点，然后调用 getChildren方法获取当前的目录节点列表中最小的目录节点是不是就是自己创建的目录节点，如果正是自己创建的，那么它就获得了这个锁，如果不是那么它就调用 exists(String path, boolean watch) 方法并监控 Zookeeper 上目录节点列表的变化，一直到自己创建的节点是列表中最小编号的目录节点，从而获得锁，释放锁很简单，只要删除前面它自己所创建的目录节点就行了。</p>\n<h3 id=\"队列管理\"><a href=\"#队列管理\" class=\"headerlink\" title=\"队列管理\"></a>队列管理</h3><p>Zookeeper 可以处理两种类型的队列：</p>\n<ol>\n<li>当一个队列的成员都聚齐时，这个队列才可用，否则一直等待所有成员到达，这种是同步队列。</li>\n<li>队列按照 FIFO 方式进行入队和出队操作，例如实现生产者和消费者模型。<br>同步队列用 Zookeeper 实现的实现思路如下：<br>创建一个父目录 /synchronizing，每个成员都监控标志（Set Watch）位目录 /synchronizing/start 是否存在，然后每个成员都加入这个队列，加入队列的方式就是创建 /synchronizing/member_i 的临时目录节点，然后每个成员获取 / synchronizing 目录的所有目录节点，也就是 member_i。判断 i 的值是否已经是成员的个数，如果小于成员个数等待 /synchronizing/start 的出现，如果已经相等就创建 /synchronizing/start。<h2 id=\"集群配置\"><a href=\"#集群配置\" class=\"headerlink\" title=\"集群配置\"></a>集群配置</h2><em>zoo.cfg</em><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">initLimit=5 </span><br><span class=\"line\">syncLimit=2 </span><br><span class=\"line\">server.1=192.168.211.1:2888:3888 </span><br><span class=\"line\">server.2=192.168.211.2:2888:3888</span><br></pre></td></tr></table></figure>\n<em>说明:</em></li>\n</ol>\n<ul>\n<li>initLimit：这个配置项是用来配置 Zookeeper 接受客户端（这里所说的客户端不是用户连接 Zookeeper 服务器的客户端，而是 Zookeeper 服务器集群中连接到 Leader 的 Follower 服务器）初始化连接时最长能忍受多少个心跳时间间隔数。当已经超过 10 个心跳的时间（也就是 tickTime）长度后 Zookeeper 服务器还没有收到客户端的返回信息，那么表明这个客户端连接失败。总的时间长度就是 5*2000=10 秒</li>\n<li>syncLimit：这个配置项标识 Leader 与 Follower 之间发送消息，请求和应答时间长度，最长不能超过多少个 tickTime 的时间长度，总的时间长度就是 2*2000=4 秒</li>\n<li>server.A=B：C：D：其中 A 是一个数字，表示这个是第几号服务器；B 是这个服务器的 ip 地址；C 表示的是这个服务器与集群中的 Leader 服务器交换信息的端口；D 表示的是万一集群中的 Leader 服务器挂了，需要一个端口来重新进行选举，选出一个新的 Leader，而这个端口就是用来执行选举时服务器相互通信的端口。如果是伪集群的配置方式，由于 B 都是一样，所以不同的 Zookeeper 实例通信端口号不能一样，所以要给它们分配不同的端口号。</li>\n</ul>\n<hr>\n<p>除了修改 zoo.cfg 配置文件，集群模式下还要配置一个文件 myid，这个文件在 dataDir 目录下，这个文件里面就有一个数据就是 A 的值，Zookeeper 启动时会读取这个文件，拿到里面的数据与 zoo.cfg 里面的配置信息比较从而判断到底是那个 server。</p>\n<hr>\n<p><em>观点仅代表自己，期待你的留言。</em></p>\n<p><a href=\"https://www.ibm.com/developerworks/cn/opensource/os-cn-zookeeper/\">https://www.ibm.com/developerworks/cn/opensource/os-cn-zookeeper/</a></p>\n"},{"title":"iOS 7 的多任务","date":"2016-04-01T10:05:52.000Z","_content":"在 iOS 7 之前，当程序置于后台之后开发者们对他们程序所能做的事情非常有限。除了 VOIP 和基于地理位置特性以外，唯一能做的地方就是使用后台任务（background tasks）让代码可以执行几分钟。如果你想下载比较大的视频文件以便离线浏览，亦或者备份用户的照片到你的服务器上，你都仅能完成一部分工作。\n\niOS 7 添加了两个新的 API 以便你的程序可以在后台更新界面以及内容。首先是后台获取（Background Fetch），它允许你定期地从网络获取新的内容。第二个 API 就是远程通知（Remote Notifications），这是一个当事件发生时可以让推送通知主动提醒应用的新特性，这两者都为你的应用界面保持最新提供了极大的帮助。在新的后台传输服务 (Background Transfer Service) 中执行定期的任务，也允许你在进程之外可以执行网络传输（下载和上传）工作。\n\n后台获取 (Background Fetch) 和远程通知 (Remote Notification) 基于简单的 ApplicationDelegate 钩子，在应用程序挂起之前的 30 秒时钟时间执行工作。它们不是用于 CPU 频繁工作或者长时间运行任务，而是用来处理长时间运行的网络请求队列，例如下载一部很大的电影，或者执行快速的内容更新。\n\n对用户来说，多任务处理有一点显而易见的改变就是新的应用切换程序 (the new app switcher)，它用来呈现应用到后台时的界面快照。这些快照的存在是有一定理由的--现在你可以在后台完成工作后更新程序快照，以用来呈现新的内容。社交网络、新闻或者天气等应用现在都可以直接呈现最新的内容而不需要用户重新打开应用。我们稍后会介绍如何更新屏幕快照。\n\n## 后台获取\n后台获取是一种智能的轮询机制，它很适合需要经常更新内容的程序，像社交网络，新闻或天气的程序。为了在用户启动程序前提前触发后台获取，系统会根据用户行为唤醒应用程序。举个例子，如果用户经常在下午 1 点使用某个应用程序，系统会学习，适应并在使用周期前执行后台获取。为了减少电池使用，使用设备无线通信的所有应用的后台获取会被合并，如果你向系统报告新数据无法获取，iOS 会适应并使用此信息避免会继续获取。\n\n开启后台获取的第一步是在 info plist 文件中对 [UIBackgroundModes](https://developer.apple.com/library/ios/documentation/general/Reference/InfoPlistKeyReference/Articles/iPhoneOSKeys.html#//apple_ref/doc/uid/TP40009252-SW22) 键指定特定的值。最简单的途径是在 Xcode 5 的 project editor 中新的 Capabilities 标签页中设置，这个标签页包含了后台模式部分，可以方便配置多任务选项。\n![](/images/capabilities-on-bgfetch.jpg)\n或者，你可以手动编辑这个值\n```\n<key>UIBackgroundModes</key>\n<array>\n    <string>fetch</string>\n</array>  \n```\n接下来，告诉 iOS 多久进行一次数据获取\n```\n- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions\n{\n    [application setMinimumBackgroundFetchInterval:UIApplicationBackgroundFetchIntervalMinimum];\n\n    return YES;\n}\n```\niOS 默认不进行后台获取，所以你需要设置一个时间间隔，否则，你的应用程序永远不能在后台被唤醒。UIApplicationBackgroundFetchIntervalMinimum 这个值要求系统尽可能频繁地去管理你的程序到底什么时候应该被唤醒，但如果你不需要这样的话，你也应该指定一个你想要的的时间间隔。例如，一个天气的应用程序，可能只需要几个小时才更新一次，iOS 将会在后台获取之间至少等待你指定的时间间隔。\n\n如果你的应用允许用户退出登录，那么就没有获取新数据的需要了，你应该把 minimumBackgroundFetchInterval 设置为 UIApplicationBackgroundFetchIntervalNever，这样可以节省资源。\n\n最后一步是在应用程序委托中实现下列方法：\n```\n- (void) application:(UIApplication *)application \n  performFetchWithCompletionHandler:(void (^)(UIBackgroundFetchResult))completionHandler\n{\n    NSURLSessionConfiguration *sessionConfiguration = [NSURLSessionConfiguration defaultSessionConfiguration];\n    NSURLSession *session = [NSURLSession sessionWithConfiguration:sessionConfiguration];\n\n    NSURL *url = [[NSURL alloc] initWithString:@\"http://yourserver.com/data.json\"];\n    NSURLSessionDataTask *task = [session dataTaskWithURL:url \n                                        completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n\n        if (error) {\n            completionHandler(UIBackgroundFetchResultFailed);\n            return;\n        }\n\n        // 解析响应/数据以决定新内容是否可用\n        BOOL hasNewData = ...\n        if (hasNewData) {\n            completionHandler(UIBackgroundFetchResultNewData);\n        } else {\n            completionHandler(UIBackgroundFetchResultNoData);\n        }\n    }];\n\n    // 开始任务\n    [task resume];\n}\n```\n系统唤醒应用程序后将会执行这个委托方法。需要注意的是，你只有 30 秒的时间来确定获取的新内容是否可用，然后处理新内容并更新界面。30 秒时间应该足够去从网络获取数据和获取界面的缩略图，但是最多只有 30 秒。当完成了网络请求和更新界面后，你应该执行完成的回调。\n\n完成回调的执行有两个目的。首先，系统会估量你的进程消耗的电量，并根据你传递的 UIBackgroundFetchResult 参数记录新数据是否可用。其次，当你调用完成的处理代码时，应用的界面缩略图会被采用，并更新应用程序切换器。当用户在应用间切换时，用户将会看到新内容。这种通过 completion handler 来报告并且生成截图的方法，在新的多任务处理 API 中是很常见的。\n\n在实际应用中，你应该将 completionHandler 传递到应用程序的子组件，然后在处理完数据和更新界面后调用。\n\n在这里，你可能想知道 iOS 是如何在应用程序后台运行时获得界面截图的，并且想知道应用程序的生命周期与后台获取之间有什么关系。如果应用程序处于挂起状态，系统会先唤醒应用，然后再调用 application: performFetchWithCompletionHandler:。如果应用程序还没有启动，系统将会启动它，然后调用常见的委托方法，包括 application: didFinishLaunchingWithOptions:。你可以把这种应用程序运行的方式想像为用户从 Springboard 启动这个程序，区别仅仅在于界面是看不见的，在屏幕外渲染的。\n\n大多数情况下，无论应用在后台启动或者在前台，你会执行相同的工作，但你可以通过查看 UIApplication 的 applicationState 属性来判断应用是不是从后台启动。\n```\n- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions\n{\n    NSLog(@\"Launched in background %d\", UIApplicationStateBackground == application.applicationState);\n\n    return YES;\n}\n```\n## 测试后台数据获取\n有两种可以模拟后台获取的途径。最简单是从 Xcode 运行你的应用，当应用运行时，在 Xcode 的 Debug 菜单选择 Simulate Background Fetch.\n\n第二种方法，使用 scheme 更改 Xcode 运行程序的方式。在 Xcode 菜单的 Product 选项，选择 Scheme 然后选择 Manage Schemes。在这里，你可以编辑或者添加一个新的 scheme，然后选中 Launch due to a background fetch event 。如下图：\n![](/images/edit-scheme-simulate-background-fetch.png)\n## 远程通知\n远程通知允许你在重要事件发生时，告知你的应用。你可能需要发送新的即时信息，突发新闻的提醒，或者用户喜爱电视的最新剧集已经可以下载以便离线观看的消息。远程通知很适合用于那些偶尔出现，但却很重要的内容，如果使用后台获取模式中在两次获取间需要等待的时间是不可接受的话，远程通知会是一个不错的选择。远程通知会比后台获取更有效率，因为应用程序只有在需要的时候才会启动。\n\n一条远程通知实际上只是一条普通的带有 content-available 标志的推送通知。你可以发送一条带有提醒信息的推送去告诉用户有事请发生了，同时在后台对界面进行更新。但远程通知也可以做到在安静地，没有提醒消息或者任何声音的情况下，只去更新应用界面或者触发后台工作。然后你可以在完成下载或者处理完新内容后，发送一条本地通知。\n\n静默的推送通知有速度限制，所以你可以大胆地根据应用程序的需要发送尽可能多的通知。iOS 和苹果推送服务会控制推送通知多久被递送，发送很多推送通知是没有问题的。如果你的推送通知达到了限制，推送通知可能会被延迟，直到设备下次发送保持活动状态的数据包，或者收到另外一个通知。\n## 发送远程通知\n要发送一条远程通知，需要在推送通知的有效负载（payload）设置 content－available 标志。content-available 标志和用来通知 报刊应用（Newsstand）的健值是一样的，因此，大多数推送脚本和库都已经支持远程通知。当你发送一条远程通知时，你可能还想要包含一些通知有效负载中的数据，让你应用程序可以引用事件。这可以为你节省一些网络请求，并提高应用程序的响应度。\n\n我建议在开发的时候，使用 [Nomad CLI’s Houston](http://nomad-cli.com/#houston) 工具发送推送消息，当然你也可以使用你喜欢的库或脚本。\n\n你可以通过 nomad-cli ruby gem 来安装 Houston\n```\ngem install nomad-cli\n```\n然后通过包含在 Nomad 的 apn 实用工具发送一条通知：\n```\n# Send a Push Notification to your Device\napn push <device token> -c /path/to/key-cert.pem -n -d content-id=42\n```\n在这里，-n 标志指定应该包含 content-available 健值，-d 标志允许添加我们自定义的数据健值到有效负荷。\n\n通知的有效负荷（payload）结果和下面类似：\n```\n{\n    \"aps\" : {\n        \"content-available\" : 1\n    },\n    \"content-id\" : 42\n}\n```\niOS 7 添加了一个新的应用程序委托方法，当接收到一条带有 content－available 的推送通知时，下面的方法会被调用：\n```\n- (void)application:(UIApplication *)application \n  didReceiveRemoteNotification:(NSDictionary *)userInfo \n        fetchCompletionHandler:(void (^)(UIBackgroundFetchResult))completionHandler\n{\n    NSLog(@\"Remote Notification userInfo is %@\", userInfo);\n\n    NSNumber *contentID = userInfo[@\"content-id\"];\n    // 根据 content ID 进行操作\n    completionHandler(UIBackgroundFetchResultNewData);\n}\n```\n和后台抓取一样，应用程序进入后台启动，也有 30 秒的时间去获取新内容并更新界面，最后调用完成的处理代码。我们可以像后台获取那样，执行快速的网络请求，但我们可以使用新的强大的后台传输服务，处理任务队列，下面看看我们如何在任务完成后更新界面。\n## NSURLSession 和 后台传输服务（Background Transfer Service）\nNSURLSession 是 iOS 7 添加的一个新类，它也是 Foundation networking 中的新技术。作为 NSURLConnection 的替代品，一些熟悉的概念和类都保留下来了，例如 NSURL，NSURLRequest 和 NSURLResponse。所以，你可以使用 NSURLSessionTask 这一 NSURLConnection 的替代品，来处理网络请求及响应。一共有 3 种会话任务：数据，下载和上传。每一种都向 NSURLSessionTask 添加了语法糖，根据你的需要，适当选择一种。\n\n一个 NSURLSession 对象协调一个或多个 NSURLSessionTask 对象，并根据 NSURLSessionTask 创建的 NSURLSessionConfiguration 实现不同的功能。使用相同的配置，你也可以创建多组具有相关任务的 NSURLSession 对象。要利用后台传输服务，你将会使用 [NSURLSessionConfiguration backgroundSessionConfiguration] 来创建一个会话配置。添加到后台会话的任务在外部进程运行，即使应用程序被挂起，崩溃，或者被杀死，它依然会运行。\n\nNSURLSessionConfiguration 允许你设置默认的 HTTP 头，配置缓存策略，限制使用蜂窝数据等等。其中一个选项是 discretionary 标志，这个标志允许系统为分配任务进行性能优化。这意味着只有当设备有足够电量时，设备才通过 Wifi 进行数据传输。如果电量低，或者只仅有一个蜂窝连接，传输任务是不会运行的。后台传输总是在 discretionary 模式下运行。\n\n目前为止，我们大概了解了 NSURLSession，以及一个后台会话如何进行，接下来，让我们回到远程通知的例子，添加一些代码来处理后台传输服务的下载队列。当下载完成后，我们会通知用户该文件已经可以使用了。\n## NSURLSessionDownloadTask\n首先，我们先处理一条远程通知，并把一个 NSURLSessionDownloadTask 添加到后台传输服务的队列。在 backgroundURLSession 方法中，我们根据后台会话配置，创建一个 NSURLSession 对象，并把 application delegate 作为会话的委托对象。文档不建议对于相同的标识符 (identifier) 创建多个会话对象，所以我们使用 dispatch_once 来避免潜在的问题：\n```\n- (NSURLSession *)backgroundURLSession\n{\n    static NSURLSession *session = nil;\n    static dispatch_once_t onceToken;\n    dispatch_once(&onceToken, ^{\n        NSString *identifier = @\"io.objc.backgroundTransferExample\";\n        NSURLSessionConfiguration* sessionConfig = [NSURLSessionConfiguration backgroundSessionConfiguration:identifier];\n        session = [NSURLSession sessionWithConfiguration:sessionConfig \n                                                delegate:self \n                                           delegateQueue:[NSOperationQueue mainQueue]];\n    });\n\n    return session;\n}\n\n- (void)           application:(UIApplication *)application \n  didReceiveRemoteNotification:(NSDictionary *)userInfo \n        fetchCompletionHandler:(void (^)(UIBackgroundFetchResult))completionHandler\n{\n    NSLog(@\"Received remote notification with userInfo %@\", userInfo);\n\n    NSNumber *contentID = userInfo[@\"content-id\"];\n    NSString *downloadURLString = [NSString stringWithFormat:@\"http://yourserver.com/downloads/%d.mp3\", [contentID intValue]];\n    NSURL* downloadURL = [NSURL URLWithString:downloadURLString];\n\n    NSURLRequest *request = [NSURLRequest requestWithURL:downloadURL];\n    NSURLSessionDownloadTask *task = [[self backgroundURLSession] downloadTaskWithRequest:request];\n    task.taskDescription = [NSString stringWithFormat:@\"Podcast Episode %d\", [contentID intValue]];\n    [task resume];\n\n    completionHandler(UIBackgroundFetchResultNewData);\n}\n```\n我们使用 NSURLSession 类方法创建一个下载任务，配置请求，并提供说明供以后使用。因为所有会话任务一开始处于挂起状态，你必须谨记要调用 [task resume] 保证开始了任务。\n\n现在，我们需要实现 NSURLSessionDownloadDelegate 的委托方法，当下载完成时，调用回调函数。如果你需要处理认证或会话生命周期的其他事件，你可能还需要实现 NSURLSessionDelegate 或 NSURLSessionTaskDelegate 的方法。你应该阅读 Apple 的 [Life Cycle of a URL Session with Custom Delegates](https://developer.apple.com/library/ios/documentation/cocoa/Conceptual/URLLoadingSystem/NSURLSessionConcepts/NSURLSessionConcepts.html#//apple_ref/doc/uid/10000165i-CH2-SW42) 文档，它讲解了所有类型的会话任务的完整生命周期。\n\nNSURLSessionDownloadDelegate 中的委托方法全部是必须实现的，尽管在这个例子中我们只需要用到 [NSURLSession downloadTask:didFinishDownloadingToURL:]。任务完成下载时，你会得到一个磁盘上该文件的临时 URL。你必须把这个文件移动或复制你的应用程序空间，因为当你从这个委托方法返回时，该文件将从临时存储中删除。\n```\n#Pragma Mark - NSURLSessionDownloadDelegate\n\n- (void)         URLSession:(NSURLSession *)session \n               downloadTask:(NSURLSessionDownloadTask *)downloadTask\n  didFinishDownloadingToURL:(NSURL *)location\n{\n    NSLog(@\"downloadTask:%@ didFinishDownloadingToURL:%@\", downloadTask.taskDescription, location);\n\n    // 用 NSFileManager 将文件复制到应用的存储中\n    // ...\n\n    // 通知 UI 刷新\n}\n\n- (void)  URLSession:(NSURLSession *)session \n        downloadTask:(NSURLSessionDownloadTask *)downloadTask \n   didResumeAtOffset:(int64_t)fileOffset \n  expectedTotalBytes:(int64_t)expectedTotalBytes\n{\n}\n\n- (void)         URLSession:(NSURLSession *)session \n               downloadTask:(NSURLSessionDownloadTask *)downloadTask \n               didWriteData:(int64_t)bytesWritten totalBytesWritten:(int64_t)totalBytesWritten \n  totalBytesExpectedToWrite:(int64_t)totalBytesExpectedToWrite\n{\n}\n```\n当后台会话任务完成时，如果你的应用程序仍然在前台运行，上面的代码已经足够了。然而，在大多数情况下，你的应用程序可能是没有运行的，或者在后台被挂起。在这些情况下，你必须实现应用程序委托的两个方法，这样系统就可以唤醒你的应用程序。不同于以往的委托回调，该应用程序委托会被调用两次，因为您的会话和任务委托可能会收到一系列消息。app delegate 的：handleEventsForBackgroundURLSession： 方法会在这些 NSURLSession 委托的消息发送前被调用，然后，URLSessionDidFinishEventsForBackgroundURLSession 在随后被调用。在前面的方法中，包含了一个后台完成的回调（completionHandler），并在后面的方法中执行回调以便更新界面:\n```\n- (void)                  application:(UIApplication *)application \n  handleEventsForBackgroundURLSession:(NSString *)identifier completionHandler:(void (^)())completionHandler\n{\n    // 你必须重新建立一个后台 seesiong 的参照\n    // 否则 NSURLSessionDownloadDelegate 和 NSURLSessionDelegate 方法会因为\n    // 没有 对 session 的 delegate 设定而不会被调用。参见上面的 backgroundURLSession\n    NSURLSession *backgroundSession = [self backgroundURLSession];\n\n    NSLog(@\"Rejoining session with identifier %@ %@\", identifier, backgroundSession);\n\n    // 保存 completion handler 以在处理 session 事件后更新 UI\n    [self addCompletionHandler:completionHandler forSession:identifier];\n}\n\n- (void)URLSessionDidFinishEventsForBackgroundURLSession:(NSURLSession *)session\n{\n    NSLog(@\"Background URL session %@ finished events.\\n\", session);\n\n    if (session.configuration.identifier) {\n        // 调用在 -application:handleEventsForBackgroundURLSession: 中保存的 handler\n        [self callCompletionHandlerForSession:session.configuration.identifier];\n    }\n}\n\n- (void)addCompletionHandler:(CompletionHandlerType)handler forSession:(NSString *)identifier\n{\n    if ([self.completionHandlerDictionary objectForKey:identifier]) {\n        NSLog(@\"Error: Got multiple handlers for a single session identifier.  This should not happen.\\n\");\n    }\n\n    [self.completionHandlerDictionary setObject:handler forKey:identifier];\n}\n\n- (void)callCompletionHandlerForSession: (NSString *)identifier\n{\n    CompletionHandlerType handler = [self.completionHandlerDictionary objectForKey: identifier];\n\n    if (handler) {\n        [self.completionHandlerDictionary removeObjectForKey: identifier];\n        NSLog(@\"Calling completion handler for session %@\", identifier);\n\n        handler();\n    }\n}\n\n```\n如果当后台传输完成时，应用程序不再停留在前台，那么，对于更新程序界面来说，这个两步处理过程是必要的。此外，如果当后台传输完成时，应用程序根本没有在运行，iOS 将会在后台启动该应用程序，然后前面的应用程序和会话的委托方法会在 application:didFinishLaunchingWithOptions: 方法被调用之后被调用。\n## 配置和限制\n我们简单地体验了后台传输的强大之处，但你应该深入文档，阅读 NSURLSessionConfiguration 部分，以便最好地满足你的使用场景。例如，NSURLSessionTasks 通过 NSURLSessionConfiguration 的 timeoutIntervalForResource 属性，支持资源超时特性。你可以使用这个特性指定你允许完成一个传输所需的最长时间。内容只在有限的时间可用，或者在用户只有有限 Wifi 带宽的时间内无法下载或上传资源的情况下，你也可以使用这个特性。\n\n除了下载任务，NSURLSession 也全面支持上传任务，因此，你可能会在后台将视频上传到服务器，这保证用户不需要再像 iOS 6 那样保持应用程序前台运行。如果当传输完成时你的应用程序不需要在后台运行，一个比较好的做法是，把 NSURLSessionConfiguration 的 sessionSendsLaunchEvents 属性设置为 NO。高效利用系统资源，是一件让 iOS 和用户都高兴的事。\n\n最后，我们来说一说使用后台会话的几个限制。作为一个必须实现的委托，您不能对 NSURLSession 使用简单的基于 block 的回调方法。后台启动应用程序，是相对耗费较多资源的，所以总是采用 HTTP 重定向。后台传输服务只支持 HTTP 和 HTTPS，你不能使用自定义的协议。系统会根据可用的资源进行优化，在任何时候你都不能强制传输任务在后台进行。\n\n另外，要注意的是在后台会话中，NSURLSessionDataTasks 是完全不支持的，你应该只出于短期的，小请求为目的使用这些任务，而不是用来下载或上传。\n## 总结\niOS 7 中强大的多任务和网络 API 为现有应用和新应用开启了一系列全新的可能性。如果你的应用程序可以从进程外的网络传输和数据中获益，那么尽情地使用这些美妙的 API。一般情况下，你可以就像你的应用正在前台运行那样去实现后台传输，并进行适当的界面更新，而这里绝大多数的工作都已经为你完成了。\n* 使用适当的新 API 来为你的应用程序提供内容。\n* 尽可能早地调用 completion handler 以提高效率。\n* 让 completion handler 为应用程序更新界面快照。\n## 扩展阅读\n[WWDC 2013 session “What’s New with Multitasking”](https://developer.apple.com/wwdc/videos/?id=204)\n[WWDC 2013 session “What’s New in Foundation Networking”](https://developer.apple.com/wwdc/videos/?id=705)\n[URL Loading System Programming Guide](https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/URLLoadingSystem/URLLoadingSystem.html#//apple_ref/doc/uid/10000165i)\n\n-----\n\n*观点仅代表自己，期待你的留言。*\nhttp://objccn.io/issue-5-5/\n\n","source":"_posts/ios-muti-task.md","raw":"---\ntitle: iOS 7 的多任务\ntags:\n  - iOS\n  - 转载\ndate: 2016-04-01 18:05:52\n---\n在 iOS 7 之前，当程序置于后台之后开发者们对他们程序所能做的事情非常有限。除了 VOIP 和基于地理位置特性以外，唯一能做的地方就是使用后台任务（background tasks）让代码可以执行几分钟。如果你想下载比较大的视频文件以便离线浏览，亦或者备份用户的照片到你的服务器上，你都仅能完成一部分工作。\n\niOS 7 添加了两个新的 API 以便你的程序可以在后台更新界面以及内容。首先是后台获取（Background Fetch），它允许你定期地从网络获取新的内容。第二个 API 就是远程通知（Remote Notifications），这是一个当事件发生时可以让推送通知主动提醒应用的新特性，这两者都为你的应用界面保持最新提供了极大的帮助。在新的后台传输服务 (Background Transfer Service) 中执行定期的任务，也允许你在进程之外可以执行网络传输（下载和上传）工作。\n\n后台获取 (Background Fetch) 和远程通知 (Remote Notification) 基于简单的 ApplicationDelegate 钩子，在应用程序挂起之前的 30 秒时钟时间执行工作。它们不是用于 CPU 频繁工作或者长时间运行任务，而是用来处理长时间运行的网络请求队列，例如下载一部很大的电影，或者执行快速的内容更新。\n\n对用户来说，多任务处理有一点显而易见的改变就是新的应用切换程序 (the new app switcher)，它用来呈现应用到后台时的界面快照。这些快照的存在是有一定理由的--现在你可以在后台完成工作后更新程序快照，以用来呈现新的内容。社交网络、新闻或者天气等应用现在都可以直接呈现最新的内容而不需要用户重新打开应用。我们稍后会介绍如何更新屏幕快照。\n\n## 后台获取\n后台获取是一种智能的轮询机制，它很适合需要经常更新内容的程序，像社交网络，新闻或天气的程序。为了在用户启动程序前提前触发后台获取，系统会根据用户行为唤醒应用程序。举个例子，如果用户经常在下午 1 点使用某个应用程序，系统会学习，适应并在使用周期前执行后台获取。为了减少电池使用，使用设备无线通信的所有应用的后台获取会被合并，如果你向系统报告新数据无法获取，iOS 会适应并使用此信息避免会继续获取。\n\n开启后台获取的第一步是在 info plist 文件中对 [UIBackgroundModes](https://developer.apple.com/library/ios/documentation/general/Reference/InfoPlistKeyReference/Articles/iPhoneOSKeys.html#//apple_ref/doc/uid/TP40009252-SW22) 键指定特定的值。最简单的途径是在 Xcode 5 的 project editor 中新的 Capabilities 标签页中设置，这个标签页包含了后台模式部分，可以方便配置多任务选项。\n![](/images/capabilities-on-bgfetch.jpg)\n或者，你可以手动编辑这个值\n```\n<key>UIBackgroundModes</key>\n<array>\n    <string>fetch</string>\n</array>  \n```\n接下来，告诉 iOS 多久进行一次数据获取\n```\n- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions\n{\n    [application setMinimumBackgroundFetchInterval:UIApplicationBackgroundFetchIntervalMinimum];\n\n    return YES;\n}\n```\niOS 默认不进行后台获取，所以你需要设置一个时间间隔，否则，你的应用程序永远不能在后台被唤醒。UIApplicationBackgroundFetchIntervalMinimum 这个值要求系统尽可能频繁地去管理你的程序到底什么时候应该被唤醒，但如果你不需要这样的话，你也应该指定一个你想要的的时间间隔。例如，一个天气的应用程序，可能只需要几个小时才更新一次，iOS 将会在后台获取之间至少等待你指定的时间间隔。\n\n如果你的应用允许用户退出登录，那么就没有获取新数据的需要了，你应该把 minimumBackgroundFetchInterval 设置为 UIApplicationBackgroundFetchIntervalNever，这样可以节省资源。\n\n最后一步是在应用程序委托中实现下列方法：\n```\n- (void) application:(UIApplication *)application \n  performFetchWithCompletionHandler:(void (^)(UIBackgroundFetchResult))completionHandler\n{\n    NSURLSessionConfiguration *sessionConfiguration = [NSURLSessionConfiguration defaultSessionConfiguration];\n    NSURLSession *session = [NSURLSession sessionWithConfiguration:sessionConfiguration];\n\n    NSURL *url = [[NSURL alloc] initWithString:@\"http://yourserver.com/data.json\"];\n    NSURLSessionDataTask *task = [session dataTaskWithURL:url \n                                        completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n\n        if (error) {\n            completionHandler(UIBackgroundFetchResultFailed);\n            return;\n        }\n\n        // 解析响应/数据以决定新内容是否可用\n        BOOL hasNewData = ...\n        if (hasNewData) {\n            completionHandler(UIBackgroundFetchResultNewData);\n        } else {\n            completionHandler(UIBackgroundFetchResultNoData);\n        }\n    }];\n\n    // 开始任务\n    [task resume];\n}\n```\n系统唤醒应用程序后将会执行这个委托方法。需要注意的是，你只有 30 秒的时间来确定获取的新内容是否可用，然后处理新内容并更新界面。30 秒时间应该足够去从网络获取数据和获取界面的缩略图，但是最多只有 30 秒。当完成了网络请求和更新界面后，你应该执行完成的回调。\n\n完成回调的执行有两个目的。首先，系统会估量你的进程消耗的电量，并根据你传递的 UIBackgroundFetchResult 参数记录新数据是否可用。其次，当你调用完成的处理代码时，应用的界面缩略图会被采用，并更新应用程序切换器。当用户在应用间切换时，用户将会看到新内容。这种通过 completion handler 来报告并且生成截图的方法，在新的多任务处理 API 中是很常见的。\n\n在实际应用中，你应该将 completionHandler 传递到应用程序的子组件，然后在处理完数据和更新界面后调用。\n\n在这里，你可能想知道 iOS 是如何在应用程序后台运行时获得界面截图的，并且想知道应用程序的生命周期与后台获取之间有什么关系。如果应用程序处于挂起状态，系统会先唤醒应用，然后再调用 application: performFetchWithCompletionHandler:。如果应用程序还没有启动，系统将会启动它，然后调用常见的委托方法，包括 application: didFinishLaunchingWithOptions:。你可以把这种应用程序运行的方式想像为用户从 Springboard 启动这个程序，区别仅仅在于界面是看不见的，在屏幕外渲染的。\n\n大多数情况下，无论应用在后台启动或者在前台，你会执行相同的工作，但你可以通过查看 UIApplication 的 applicationState 属性来判断应用是不是从后台启动。\n```\n- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions\n{\n    NSLog(@\"Launched in background %d\", UIApplicationStateBackground == application.applicationState);\n\n    return YES;\n}\n```\n## 测试后台数据获取\n有两种可以模拟后台获取的途径。最简单是从 Xcode 运行你的应用，当应用运行时，在 Xcode 的 Debug 菜单选择 Simulate Background Fetch.\n\n第二种方法，使用 scheme 更改 Xcode 运行程序的方式。在 Xcode 菜单的 Product 选项，选择 Scheme 然后选择 Manage Schemes。在这里，你可以编辑或者添加一个新的 scheme，然后选中 Launch due to a background fetch event 。如下图：\n![](/images/edit-scheme-simulate-background-fetch.png)\n## 远程通知\n远程通知允许你在重要事件发生时，告知你的应用。你可能需要发送新的即时信息，突发新闻的提醒，或者用户喜爱电视的最新剧集已经可以下载以便离线观看的消息。远程通知很适合用于那些偶尔出现，但却很重要的内容，如果使用后台获取模式中在两次获取间需要等待的时间是不可接受的话，远程通知会是一个不错的选择。远程通知会比后台获取更有效率，因为应用程序只有在需要的时候才会启动。\n\n一条远程通知实际上只是一条普通的带有 content-available 标志的推送通知。你可以发送一条带有提醒信息的推送去告诉用户有事请发生了，同时在后台对界面进行更新。但远程通知也可以做到在安静地，没有提醒消息或者任何声音的情况下，只去更新应用界面或者触发后台工作。然后你可以在完成下载或者处理完新内容后，发送一条本地通知。\n\n静默的推送通知有速度限制，所以你可以大胆地根据应用程序的需要发送尽可能多的通知。iOS 和苹果推送服务会控制推送通知多久被递送，发送很多推送通知是没有问题的。如果你的推送通知达到了限制，推送通知可能会被延迟，直到设备下次发送保持活动状态的数据包，或者收到另外一个通知。\n## 发送远程通知\n要发送一条远程通知，需要在推送通知的有效负载（payload）设置 content－available 标志。content-available 标志和用来通知 报刊应用（Newsstand）的健值是一样的，因此，大多数推送脚本和库都已经支持远程通知。当你发送一条远程通知时，你可能还想要包含一些通知有效负载中的数据，让你应用程序可以引用事件。这可以为你节省一些网络请求，并提高应用程序的响应度。\n\n我建议在开发的时候，使用 [Nomad CLI’s Houston](http://nomad-cli.com/#houston) 工具发送推送消息，当然你也可以使用你喜欢的库或脚本。\n\n你可以通过 nomad-cli ruby gem 来安装 Houston\n```\ngem install nomad-cli\n```\n然后通过包含在 Nomad 的 apn 实用工具发送一条通知：\n```\n# Send a Push Notification to your Device\napn push <device token> -c /path/to/key-cert.pem -n -d content-id=42\n```\n在这里，-n 标志指定应该包含 content-available 健值，-d 标志允许添加我们自定义的数据健值到有效负荷。\n\n通知的有效负荷（payload）结果和下面类似：\n```\n{\n    \"aps\" : {\n        \"content-available\" : 1\n    },\n    \"content-id\" : 42\n}\n```\niOS 7 添加了一个新的应用程序委托方法，当接收到一条带有 content－available 的推送通知时，下面的方法会被调用：\n```\n- (void)application:(UIApplication *)application \n  didReceiveRemoteNotification:(NSDictionary *)userInfo \n        fetchCompletionHandler:(void (^)(UIBackgroundFetchResult))completionHandler\n{\n    NSLog(@\"Remote Notification userInfo is %@\", userInfo);\n\n    NSNumber *contentID = userInfo[@\"content-id\"];\n    // 根据 content ID 进行操作\n    completionHandler(UIBackgroundFetchResultNewData);\n}\n```\n和后台抓取一样，应用程序进入后台启动，也有 30 秒的时间去获取新内容并更新界面，最后调用完成的处理代码。我们可以像后台获取那样，执行快速的网络请求，但我们可以使用新的强大的后台传输服务，处理任务队列，下面看看我们如何在任务完成后更新界面。\n## NSURLSession 和 后台传输服务（Background Transfer Service）\nNSURLSession 是 iOS 7 添加的一个新类，它也是 Foundation networking 中的新技术。作为 NSURLConnection 的替代品，一些熟悉的概念和类都保留下来了，例如 NSURL，NSURLRequest 和 NSURLResponse。所以，你可以使用 NSURLSessionTask 这一 NSURLConnection 的替代品，来处理网络请求及响应。一共有 3 种会话任务：数据，下载和上传。每一种都向 NSURLSessionTask 添加了语法糖，根据你的需要，适当选择一种。\n\n一个 NSURLSession 对象协调一个或多个 NSURLSessionTask 对象，并根据 NSURLSessionTask 创建的 NSURLSessionConfiguration 实现不同的功能。使用相同的配置，你也可以创建多组具有相关任务的 NSURLSession 对象。要利用后台传输服务，你将会使用 [NSURLSessionConfiguration backgroundSessionConfiguration] 来创建一个会话配置。添加到后台会话的任务在外部进程运行，即使应用程序被挂起，崩溃，或者被杀死，它依然会运行。\n\nNSURLSessionConfiguration 允许你设置默认的 HTTP 头，配置缓存策略，限制使用蜂窝数据等等。其中一个选项是 discretionary 标志，这个标志允许系统为分配任务进行性能优化。这意味着只有当设备有足够电量时，设备才通过 Wifi 进行数据传输。如果电量低，或者只仅有一个蜂窝连接，传输任务是不会运行的。后台传输总是在 discretionary 模式下运行。\n\n目前为止，我们大概了解了 NSURLSession，以及一个后台会话如何进行，接下来，让我们回到远程通知的例子，添加一些代码来处理后台传输服务的下载队列。当下载完成后，我们会通知用户该文件已经可以使用了。\n## NSURLSessionDownloadTask\n首先，我们先处理一条远程通知，并把一个 NSURLSessionDownloadTask 添加到后台传输服务的队列。在 backgroundURLSession 方法中，我们根据后台会话配置，创建一个 NSURLSession 对象，并把 application delegate 作为会话的委托对象。文档不建议对于相同的标识符 (identifier) 创建多个会话对象，所以我们使用 dispatch_once 来避免潜在的问题：\n```\n- (NSURLSession *)backgroundURLSession\n{\n    static NSURLSession *session = nil;\n    static dispatch_once_t onceToken;\n    dispatch_once(&onceToken, ^{\n        NSString *identifier = @\"io.objc.backgroundTransferExample\";\n        NSURLSessionConfiguration* sessionConfig = [NSURLSessionConfiguration backgroundSessionConfiguration:identifier];\n        session = [NSURLSession sessionWithConfiguration:sessionConfig \n                                                delegate:self \n                                           delegateQueue:[NSOperationQueue mainQueue]];\n    });\n\n    return session;\n}\n\n- (void)           application:(UIApplication *)application \n  didReceiveRemoteNotification:(NSDictionary *)userInfo \n        fetchCompletionHandler:(void (^)(UIBackgroundFetchResult))completionHandler\n{\n    NSLog(@\"Received remote notification with userInfo %@\", userInfo);\n\n    NSNumber *contentID = userInfo[@\"content-id\"];\n    NSString *downloadURLString = [NSString stringWithFormat:@\"http://yourserver.com/downloads/%d.mp3\", [contentID intValue]];\n    NSURL* downloadURL = [NSURL URLWithString:downloadURLString];\n\n    NSURLRequest *request = [NSURLRequest requestWithURL:downloadURL];\n    NSURLSessionDownloadTask *task = [[self backgroundURLSession] downloadTaskWithRequest:request];\n    task.taskDescription = [NSString stringWithFormat:@\"Podcast Episode %d\", [contentID intValue]];\n    [task resume];\n\n    completionHandler(UIBackgroundFetchResultNewData);\n}\n```\n我们使用 NSURLSession 类方法创建一个下载任务，配置请求，并提供说明供以后使用。因为所有会话任务一开始处于挂起状态，你必须谨记要调用 [task resume] 保证开始了任务。\n\n现在，我们需要实现 NSURLSessionDownloadDelegate 的委托方法，当下载完成时，调用回调函数。如果你需要处理认证或会话生命周期的其他事件，你可能还需要实现 NSURLSessionDelegate 或 NSURLSessionTaskDelegate 的方法。你应该阅读 Apple 的 [Life Cycle of a URL Session with Custom Delegates](https://developer.apple.com/library/ios/documentation/cocoa/Conceptual/URLLoadingSystem/NSURLSessionConcepts/NSURLSessionConcepts.html#//apple_ref/doc/uid/10000165i-CH2-SW42) 文档，它讲解了所有类型的会话任务的完整生命周期。\n\nNSURLSessionDownloadDelegate 中的委托方法全部是必须实现的，尽管在这个例子中我们只需要用到 [NSURLSession downloadTask:didFinishDownloadingToURL:]。任务完成下载时，你会得到一个磁盘上该文件的临时 URL。你必须把这个文件移动或复制你的应用程序空间，因为当你从这个委托方法返回时，该文件将从临时存储中删除。\n```\n#Pragma Mark - NSURLSessionDownloadDelegate\n\n- (void)         URLSession:(NSURLSession *)session \n               downloadTask:(NSURLSessionDownloadTask *)downloadTask\n  didFinishDownloadingToURL:(NSURL *)location\n{\n    NSLog(@\"downloadTask:%@ didFinishDownloadingToURL:%@\", downloadTask.taskDescription, location);\n\n    // 用 NSFileManager 将文件复制到应用的存储中\n    // ...\n\n    // 通知 UI 刷新\n}\n\n- (void)  URLSession:(NSURLSession *)session \n        downloadTask:(NSURLSessionDownloadTask *)downloadTask \n   didResumeAtOffset:(int64_t)fileOffset \n  expectedTotalBytes:(int64_t)expectedTotalBytes\n{\n}\n\n- (void)         URLSession:(NSURLSession *)session \n               downloadTask:(NSURLSessionDownloadTask *)downloadTask \n               didWriteData:(int64_t)bytesWritten totalBytesWritten:(int64_t)totalBytesWritten \n  totalBytesExpectedToWrite:(int64_t)totalBytesExpectedToWrite\n{\n}\n```\n当后台会话任务完成时，如果你的应用程序仍然在前台运行，上面的代码已经足够了。然而，在大多数情况下，你的应用程序可能是没有运行的，或者在后台被挂起。在这些情况下，你必须实现应用程序委托的两个方法，这样系统就可以唤醒你的应用程序。不同于以往的委托回调，该应用程序委托会被调用两次，因为您的会话和任务委托可能会收到一系列消息。app delegate 的：handleEventsForBackgroundURLSession： 方法会在这些 NSURLSession 委托的消息发送前被调用，然后，URLSessionDidFinishEventsForBackgroundURLSession 在随后被调用。在前面的方法中，包含了一个后台完成的回调（completionHandler），并在后面的方法中执行回调以便更新界面:\n```\n- (void)                  application:(UIApplication *)application \n  handleEventsForBackgroundURLSession:(NSString *)identifier completionHandler:(void (^)())completionHandler\n{\n    // 你必须重新建立一个后台 seesiong 的参照\n    // 否则 NSURLSessionDownloadDelegate 和 NSURLSessionDelegate 方法会因为\n    // 没有 对 session 的 delegate 设定而不会被调用。参见上面的 backgroundURLSession\n    NSURLSession *backgroundSession = [self backgroundURLSession];\n\n    NSLog(@\"Rejoining session with identifier %@ %@\", identifier, backgroundSession);\n\n    // 保存 completion handler 以在处理 session 事件后更新 UI\n    [self addCompletionHandler:completionHandler forSession:identifier];\n}\n\n- (void)URLSessionDidFinishEventsForBackgroundURLSession:(NSURLSession *)session\n{\n    NSLog(@\"Background URL session %@ finished events.\\n\", session);\n\n    if (session.configuration.identifier) {\n        // 调用在 -application:handleEventsForBackgroundURLSession: 中保存的 handler\n        [self callCompletionHandlerForSession:session.configuration.identifier];\n    }\n}\n\n- (void)addCompletionHandler:(CompletionHandlerType)handler forSession:(NSString *)identifier\n{\n    if ([self.completionHandlerDictionary objectForKey:identifier]) {\n        NSLog(@\"Error: Got multiple handlers for a single session identifier.  This should not happen.\\n\");\n    }\n\n    [self.completionHandlerDictionary setObject:handler forKey:identifier];\n}\n\n- (void)callCompletionHandlerForSession: (NSString *)identifier\n{\n    CompletionHandlerType handler = [self.completionHandlerDictionary objectForKey: identifier];\n\n    if (handler) {\n        [self.completionHandlerDictionary removeObjectForKey: identifier];\n        NSLog(@\"Calling completion handler for session %@\", identifier);\n\n        handler();\n    }\n}\n\n```\n如果当后台传输完成时，应用程序不再停留在前台，那么，对于更新程序界面来说，这个两步处理过程是必要的。此外，如果当后台传输完成时，应用程序根本没有在运行，iOS 将会在后台启动该应用程序，然后前面的应用程序和会话的委托方法会在 application:didFinishLaunchingWithOptions: 方法被调用之后被调用。\n## 配置和限制\n我们简单地体验了后台传输的强大之处，但你应该深入文档，阅读 NSURLSessionConfiguration 部分，以便最好地满足你的使用场景。例如，NSURLSessionTasks 通过 NSURLSessionConfiguration 的 timeoutIntervalForResource 属性，支持资源超时特性。你可以使用这个特性指定你允许完成一个传输所需的最长时间。内容只在有限的时间可用，或者在用户只有有限 Wifi 带宽的时间内无法下载或上传资源的情况下，你也可以使用这个特性。\n\n除了下载任务，NSURLSession 也全面支持上传任务，因此，你可能会在后台将视频上传到服务器，这保证用户不需要再像 iOS 6 那样保持应用程序前台运行。如果当传输完成时你的应用程序不需要在后台运行，一个比较好的做法是，把 NSURLSessionConfiguration 的 sessionSendsLaunchEvents 属性设置为 NO。高效利用系统资源，是一件让 iOS 和用户都高兴的事。\n\n最后，我们来说一说使用后台会话的几个限制。作为一个必须实现的委托，您不能对 NSURLSession 使用简单的基于 block 的回调方法。后台启动应用程序，是相对耗费较多资源的，所以总是采用 HTTP 重定向。后台传输服务只支持 HTTP 和 HTTPS，你不能使用自定义的协议。系统会根据可用的资源进行优化，在任何时候你都不能强制传输任务在后台进行。\n\n另外，要注意的是在后台会话中，NSURLSessionDataTasks 是完全不支持的，你应该只出于短期的，小请求为目的使用这些任务，而不是用来下载或上传。\n## 总结\niOS 7 中强大的多任务和网络 API 为现有应用和新应用开启了一系列全新的可能性。如果你的应用程序可以从进程外的网络传输和数据中获益，那么尽情地使用这些美妙的 API。一般情况下，你可以就像你的应用正在前台运行那样去实现后台传输，并进行适当的界面更新，而这里绝大多数的工作都已经为你完成了。\n* 使用适当的新 API 来为你的应用程序提供内容。\n* 尽可能早地调用 completion handler 以提高效率。\n* 让 completion handler 为应用程序更新界面快照。\n## 扩展阅读\n[WWDC 2013 session “What’s New with Multitasking”](https://developer.apple.com/wwdc/videos/?id=204)\n[WWDC 2013 session “What’s New in Foundation Networking”](https://developer.apple.com/wwdc/videos/?id=705)\n[URL Loading System Programming Guide](https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/URLLoadingSystem/URLLoadingSystem.html#//apple_ref/doc/uid/10000165i)\n\n-----\n\n*观点仅代表自己，期待你的留言。*\nhttp://objccn.io/issue-5-5/\n\n","slug":"ios-muti-task","published":1,"updated":"2021-08-31T14:23:11.543Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cku52dyqh007tbbin8bzdagce","content":"<p>在 iOS 7 之前，当程序置于后台之后开发者们对他们程序所能做的事情非常有限。除了 VOIP 和基于地理位置特性以外，唯一能做的地方就是使用后台任务（background tasks）让代码可以执行几分钟。如果你想下载比较大的视频文件以便离线浏览，亦或者备份用户的照片到你的服务器上，你都仅能完成一部分工作。</p>\n<p>iOS 7 添加了两个新的 API 以便你的程序可以在后台更新界面以及内容。首先是后台获取（Background Fetch），它允许你定期地从网络获取新的内容。第二个 API 就是远程通知（Remote Notifications），这是一个当事件发生时可以让推送通知主动提醒应用的新特性，这两者都为你的应用界面保持最新提供了极大的帮助。在新的后台传输服务 (Background Transfer Service) 中执行定期的任务，也允许你在进程之外可以执行网络传输（下载和上传）工作。</p>\n<p>后台获取 (Background Fetch) 和远程通知 (Remote Notification) 基于简单的 ApplicationDelegate 钩子，在应用程序挂起之前的 30 秒时钟时间执行工作。它们不是用于 CPU 频繁工作或者长时间运行任务，而是用来处理长时间运行的网络请求队列，例如下载一部很大的电影，或者执行快速的内容更新。</p>\n<p>对用户来说，多任务处理有一点显而易见的改变就是新的应用切换程序 (the new app switcher)，它用来呈现应用到后台时的界面快照。这些快照的存在是有一定理由的–现在你可以在后台完成工作后更新程序快照，以用来呈现新的内容。社交网络、新闻或者天气等应用现在都可以直接呈现最新的内容而不需要用户重新打开应用。我们稍后会介绍如何更新屏幕快照。</p>\n<h2 id=\"后台获取\"><a href=\"#后台获取\" class=\"headerlink\" title=\"后台获取\"></a>后台获取</h2><p>后台获取是一种智能的轮询机制，它很适合需要经常更新内容的程序，像社交网络，新闻或天气的程序。为了在用户启动程序前提前触发后台获取，系统会根据用户行为唤醒应用程序。举个例子，如果用户经常在下午 1 点使用某个应用程序，系统会学习，适应并在使用周期前执行后台获取。为了减少电池使用，使用设备无线通信的所有应用的后台获取会被合并，如果你向系统报告新数据无法获取，iOS 会适应并使用此信息避免会继续获取。</p>\n<p>开启后台获取的第一步是在 info plist 文件中对 <a href=\"https://developer.apple.com/library/ios/documentation/general/Reference/InfoPlistKeyReference/Articles/iPhoneOSKeys.html#//apple_ref/doc/uid/TP40009252-SW22\">UIBackgroundModes</a> 键指定特定的值。最简单的途径是在 Xcode 5 的 project editor 中新的 Capabilities 标签页中设置，这个标签页包含了后台模式部分，可以方便配置多任务选项。<br><img src=\"/images/capabilities-on-bgfetch.jpg\"><br>或者，你可以手动编辑这个值</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;key&gt;UIBackgroundModes&lt;/key&gt;</span><br><span class=\"line\">&lt;array&gt;</span><br><span class=\"line\">    &lt;string&gt;fetch&lt;/string&gt;</span><br><span class=\"line\">&lt;/array&gt;  </span><br></pre></td></tr></table></figure>\n<p>接下来，告诉 iOS 多久进行一次数据获取</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    [application setMinimumBackgroundFetchInterval:UIApplicationBackgroundFetchIntervalMinimum];</span><br><span class=\"line\"></span><br><span class=\"line\">    return YES;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>iOS 默认不进行后台获取，所以你需要设置一个时间间隔，否则，你的应用程序永远不能在后台被唤醒。UIApplicationBackgroundFetchIntervalMinimum 这个值要求系统尽可能频繁地去管理你的程序到底什么时候应该被唤醒，但如果你不需要这样的话，你也应该指定一个你想要的的时间间隔。例如，一个天气的应用程序，可能只需要几个小时才更新一次，iOS 将会在后台获取之间至少等待你指定的时间间隔。</p>\n<p>如果你的应用允许用户退出登录，那么就没有获取新数据的需要了，你应该把 minimumBackgroundFetchInterval 设置为 UIApplicationBackgroundFetchIntervalNever，这样可以节省资源。</p>\n<p>最后一步是在应用程序委托中实现下列方法：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (void) application:(UIApplication *)application </span><br><span class=\"line\">  performFetchWithCompletionHandler:(void (^)(UIBackgroundFetchResult))completionHandler</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    NSURLSessionConfiguration *sessionConfiguration = [NSURLSessionConfiguration defaultSessionConfiguration];</span><br><span class=\"line\">    NSURLSession *session = [NSURLSession sessionWithConfiguration:sessionConfiguration];</span><br><span class=\"line\"></span><br><span class=\"line\">    NSURL *url = [[NSURL alloc] initWithString:@&quot;http://yourserver.com/data.json&quot;];</span><br><span class=\"line\">    NSURLSessionDataTask *task = [session dataTaskWithURL:url </span><br><span class=\"line\">                                        completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        if (error) &#123;</span><br><span class=\"line\">            completionHandler(UIBackgroundFetchResultFailed);</span><br><span class=\"line\">            return;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        // 解析响应/数据以决定新内容是否可用</span><br><span class=\"line\">        BOOL hasNewData = ...</span><br><span class=\"line\">        if (hasNewData) &#123;</span><br><span class=\"line\">            completionHandler(UIBackgroundFetchResultNewData);</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">            completionHandler(UIBackgroundFetchResultNoData);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;];</span><br><span class=\"line\"></span><br><span class=\"line\">    // 开始任务</span><br><span class=\"line\">    [task resume];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>系统唤醒应用程序后将会执行这个委托方法。需要注意的是，你只有 30 秒的时间来确定获取的新内容是否可用，然后处理新内容并更新界面。30 秒时间应该足够去从网络获取数据和获取界面的缩略图，但是最多只有 30 秒。当完成了网络请求和更新界面后，你应该执行完成的回调。</p>\n<p>完成回调的执行有两个目的。首先，系统会估量你的进程消耗的电量，并根据你传递的 UIBackgroundFetchResult 参数记录新数据是否可用。其次，当你调用完成的处理代码时，应用的界面缩略图会被采用，并更新应用程序切换器。当用户在应用间切换时，用户将会看到新内容。这种通过 completion handler 来报告并且生成截图的方法，在新的多任务处理 API 中是很常见的。</p>\n<p>在实际应用中，你应该将 completionHandler 传递到应用程序的子组件，然后在处理完数据和更新界面后调用。</p>\n<p>在这里，你可能想知道 iOS 是如何在应用程序后台运行时获得界面截图的，并且想知道应用程序的生命周期与后台获取之间有什么关系。如果应用程序处于挂起状态，系统会先唤醒应用，然后再调用 application: performFetchWithCompletionHandler:。如果应用程序还没有启动，系统将会启动它，然后调用常见的委托方法，包括 application: didFinishLaunchingWithOptions:。你可以把这种应用程序运行的方式想像为用户从 Springboard 启动这个程序，区别仅仅在于界面是看不见的，在屏幕外渲染的。</p>\n<p>大多数情况下，无论应用在后台启动或者在前台，你会执行相同的工作，但你可以通过查看 UIApplication 的 applicationState 属性来判断应用是不是从后台启动。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    NSLog(@&quot;Launched in background %d&quot;, UIApplicationStateBackground == application.applicationState);</span><br><span class=\"line\"></span><br><span class=\"line\">    return YES;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"测试后台数据获取\"><a href=\"#测试后台数据获取\" class=\"headerlink\" title=\"测试后台数据获取\"></a>测试后台数据获取</h2><p>有两种可以模拟后台获取的途径。最简单是从 Xcode 运行你的应用，当应用运行时，在 Xcode 的 Debug 菜单选择 Simulate Background Fetch.</p>\n<p>第二种方法，使用 scheme 更改 Xcode 运行程序的方式。在 Xcode 菜单的 Product 选项，选择 Scheme 然后选择 Manage Schemes。在这里，你可以编辑或者添加一个新的 scheme，然后选中 Launch due to a background fetch event 。如下图：<br><img src=\"/images/edit-scheme-simulate-background-fetch.png\"></p>\n<h2 id=\"远程通知\"><a href=\"#远程通知\" class=\"headerlink\" title=\"远程通知\"></a>远程通知</h2><p>远程通知允许你在重要事件发生时，告知你的应用。你可能需要发送新的即时信息，突发新闻的提醒，或者用户喜爱电视的最新剧集已经可以下载以便离线观看的消息。远程通知很适合用于那些偶尔出现，但却很重要的内容，如果使用后台获取模式中在两次获取间需要等待的时间是不可接受的话，远程通知会是一个不错的选择。远程通知会比后台获取更有效率，因为应用程序只有在需要的时候才会启动。</p>\n<p>一条远程通知实际上只是一条普通的带有 content-available 标志的推送通知。你可以发送一条带有提醒信息的推送去告诉用户有事请发生了，同时在后台对界面进行更新。但远程通知也可以做到在安静地，没有提醒消息或者任何声音的情况下，只去更新应用界面或者触发后台工作。然后你可以在完成下载或者处理完新内容后，发送一条本地通知。</p>\n<p>静默的推送通知有速度限制，所以你可以大胆地根据应用程序的需要发送尽可能多的通知。iOS 和苹果推送服务会控制推送通知多久被递送，发送很多推送通知是没有问题的。如果你的推送通知达到了限制，推送通知可能会被延迟，直到设备下次发送保持活动状态的数据包，或者收到另外一个通知。</p>\n<h2 id=\"发送远程通知\"><a href=\"#发送远程通知\" class=\"headerlink\" title=\"发送远程通知\"></a>发送远程通知</h2><p>要发送一条远程通知，需要在推送通知的有效负载（payload）设置 content－available 标志。content-available 标志和用来通知 报刊应用（Newsstand）的健值是一样的，因此，大多数推送脚本和库都已经支持远程通知。当你发送一条远程通知时，你可能还想要包含一些通知有效负载中的数据，让你应用程序可以引用事件。这可以为你节省一些网络请求，并提高应用程序的响应度。</p>\n<p>我建议在开发的时候，使用 <a href=\"http://nomad-cli.com/#houston\">Nomad CLI’s Houston</a> 工具发送推送消息，当然你也可以使用你喜欢的库或脚本。</p>\n<p>你可以通过 nomad-cli ruby gem 来安装 Houston</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gem install nomad-cli</span><br></pre></td></tr></table></figure>\n<p>然后通过包含在 Nomad 的 apn 实用工具发送一条通知：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># Send a Push Notification to your Device</span><br><span class=\"line\">apn push &lt;device token&gt; -c /path/to/key-cert.pem -n -d content-id=42</span><br></pre></td></tr></table></figure>\n<p>在这里，-n 标志指定应该包含 content-available 健值，-d 标志允许添加我们自定义的数据健值到有效负荷。</p>\n<p>通知的有效负荷（payload）结果和下面类似：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    &quot;aps&quot; : &#123;</span><br><span class=\"line\">        &quot;content-available&quot; : 1</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    &quot;content-id&quot; : 42</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>iOS 7 添加了一个新的应用程序委托方法，当接收到一条带有 content－available 的推送通知时，下面的方法会被调用：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (void)application:(UIApplication *)application </span><br><span class=\"line\">  didReceiveRemoteNotification:(NSDictionary *)userInfo </span><br><span class=\"line\">        fetchCompletionHandler:(void (^)(UIBackgroundFetchResult))completionHandler</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    NSLog(@&quot;Remote Notification userInfo is %@&quot;, userInfo);</span><br><span class=\"line\"></span><br><span class=\"line\">    NSNumber *contentID = userInfo[@&quot;content-id&quot;];</span><br><span class=\"line\">    // 根据 content ID 进行操作</span><br><span class=\"line\">    completionHandler(UIBackgroundFetchResultNewData);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>和后台抓取一样，应用程序进入后台启动，也有 30 秒的时间去获取新内容并更新界面，最后调用完成的处理代码。我们可以像后台获取那样，执行快速的网络请求，但我们可以使用新的强大的后台传输服务，处理任务队列，下面看看我们如何在任务完成后更新界面。</p>\n<h2 id=\"NSURLSession-和-后台传输服务（Background-Transfer-Service）\"><a href=\"#NSURLSession-和-后台传输服务（Background-Transfer-Service）\" class=\"headerlink\" title=\"NSURLSession 和 后台传输服务（Background Transfer Service）\"></a>NSURLSession 和 后台传输服务（Background Transfer Service）</h2><p>NSURLSession 是 iOS 7 添加的一个新类，它也是 Foundation networking 中的新技术。作为 NSURLConnection 的替代品，一些熟悉的概念和类都保留下来了，例如 NSURL，NSURLRequest 和 NSURLResponse。所以，你可以使用 NSURLSessionTask 这一 NSURLConnection 的替代品，来处理网络请求及响应。一共有 3 种会话任务：数据，下载和上传。每一种都向 NSURLSessionTask 添加了语法糖，根据你的需要，适当选择一种。</p>\n<p>一个 NSURLSession 对象协调一个或多个 NSURLSessionTask 对象，并根据 NSURLSessionTask 创建的 NSURLSessionConfiguration 实现不同的功能。使用相同的配置，你也可以创建多组具有相关任务的 NSURLSession 对象。要利用后台传输服务，你将会使用 [NSURLSessionConfiguration backgroundSessionConfiguration] 来创建一个会话配置。添加到后台会话的任务在外部进程运行，即使应用程序被挂起，崩溃，或者被杀死，它依然会运行。</p>\n<p>NSURLSessionConfiguration 允许你设置默认的 HTTP 头，配置缓存策略，限制使用蜂窝数据等等。其中一个选项是 discretionary 标志，这个标志允许系统为分配任务进行性能优化。这意味着只有当设备有足够电量时，设备才通过 Wifi 进行数据传输。如果电量低，或者只仅有一个蜂窝连接，传输任务是不会运行的。后台传输总是在 discretionary 模式下运行。</p>\n<p>目前为止，我们大概了解了 NSURLSession，以及一个后台会话如何进行，接下来，让我们回到远程通知的例子，添加一些代码来处理后台传输服务的下载队列。当下载完成后，我们会通知用户该文件已经可以使用了。</p>\n<h2 id=\"NSURLSessionDownloadTask\"><a href=\"#NSURLSessionDownloadTask\" class=\"headerlink\" title=\"NSURLSessionDownloadTask\"></a>NSURLSessionDownloadTask</h2><p>首先，我们先处理一条远程通知，并把一个 NSURLSessionDownloadTask 添加到后台传输服务的队列。在 backgroundURLSession 方法中，我们根据后台会话配置，创建一个 NSURLSession 对象，并把 application delegate 作为会话的委托对象。文档不建议对于相同的标识符 (identifier) 创建多个会话对象，所以我们使用 dispatch_once 来避免潜在的问题：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (NSURLSession *)backgroundURLSession</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    static NSURLSession *session = nil;</span><br><span class=\"line\">    static dispatch_once_t onceToken;</span><br><span class=\"line\">    dispatch_once(&amp;onceToken, ^&#123;</span><br><span class=\"line\">        NSString *identifier = @&quot;io.objc.backgroundTransferExample&quot;;</span><br><span class=\"line\">        NSURLSessionConfiguration* sessionConfig = [NSURLSessionConfiguration backgroundSessionConfiguration:identifier];</span><br><span class=\"line\">        session = [NSURLSession sessionWithConfiguration:sessionConfig </span><br><span class=\"line\">                                                delegate:self </span><br><span class=\"line\">                                           delegateQueue:[NSOperationQueue mainQueue]];</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    return session;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)           application:(UIApplication *)application </span><br><span class=\"line\">  didReceiveRemoteNotification:(NSDictionary *)userInfo </span><br><span class=\"line\">        fetchCompletionHandler:(void (^)(UIBackgroundFetchResult))completionHandler</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    NSLog(@&quot;Received remote notification with userInfo %@&quot;, userInfo);</span><br><span class=\"line\"></span><br><span class=\"line\">    NSNumber *contentID = userInfo[@&quot;content-id&quot;];</span><br><span class=\"line\">    NSString *downloadURLString = [NSString stringWithFormat:@&quot;http://yourserver.com/downloads/%d.mp3&quot;, [contentID intValue]];</span><br><span class=\"line\">    NSURL* downloadURL = [NSURL URLWithString:downloadURLString];</span><br><span class=\"line\"></span><br><span class=\"line\">    NSURLRequest *request = [NSURLRequest requestWithURL:downloadURL];</span><br><span class=\"line\">    NSURLSessionDownloadTask *task = [[self backgroundURLSession] downloadTaskWithRequest:request];</span><br><span class=\"line\">    task.taskDescription = [NSString stringWithFormat:@&quot;Podcast Episode %d&quot;, [contentID intValue]];</span><br><span class=\"line\">    [task resume];</span><br><span class=\"line\"></span><br><span class=\"line\">    completionHandler(UIBackgroundFetchResultNewData);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们使用 NSURLSession 类方法创建一个下载任务，配置请求，并提供说明供以后使用。因为所有会话任务一开始处于挂起状态，你必须谨记要调用 [task resume] 保证开始了任务。</p>\n<p>现在，我们需要实现 NSURLSessionDownloadDelegate 的委托方法，当下载完成时，调用回调函数。如果你需要处理认证或会话生命周期的其他事件，你可能还需要实现 NSURLSessionDelegate 或 NSURLSessionTaskDelegate 的方法。你应该阅读 Apple 的 <a href=\"https://developer.apple.com/library/ios/documentation/cocoa/Conceptual/URLLoadingSystem/NSURLSessionConcepts/NSURLSessionConcepts.html#//apple_ref/doc/uid/10000165i-CH2-SW42\">Life Cycle of a URL Session with Custom Delegates</a> 文档，它讲解了所有类型的会话任务的完整生命周期。</p>\n<p>NSURLSessionDownloadDelegate 中的委托方法全部是必须实现的，尽管在这个例子中我们只需要用到 [NSURLSession downloadTask:didFinishDownloadingToURL:]。任务完成下载时，你会得到一个磁盘上该文件的临时 URL。你必须把这个文件移动或复制你的应用程序空间，因为当你从这个委托方法返回时，该文件将从临时存储中删除。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#Pragma Mark - NSURLSessionDownloadDelegate</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)         URLSession:(NSURLSession *)session </span><br><span class=\"line\">               downloadTask:(NSURLSessionDownloadTask *)downloadTask</span><br><span class=\"line\">  didFinishDownloadingToURL:(NSURL *)location</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    NSLog(@&quot;downloadTask:%@ didFinishDownloadingToURL:%@&quot;, downloadTask.taskDescription, location);</span><br><span class=\"line\"></span><br><span class=\"line\">    // 用 NSFileManager 将文件复制到应用的存储中</span><br><span class=\"line\">    // ...</span><br><span class=\"line\"></span><br><span class=\"line\">    // 通知 UI 刷新</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)  URLSession:(NSURLSession *)session </span><br><span class=\"line\">        downloadTask:(NSURLSessionDownloadTask *)downloadTask </span><br><span class=\"line\">   didResumeAtOffset:(int64_t)fileOffset </span><br><span class=\"line\">  expectedTotalBytes:(int64_t)expectedTotalBytes</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)         URLSession:(NSURLSession *)session </span><br><span class=\"line\">               downloadTask:(NSURLSessionDownloadTask *)downloadTask </span><br><span class=\"line\">               didWriteData:(int64_t)bytesWritten totalBytesWritten:(int64_t)totalBytesWritten </span><br><span class=\"line\">  totalBytesExpectedToWrite:(int64_t)totalBytesExpectedToWrite</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>当后台会话任务完成时，如果你的应用程序仍然在前台运行，上面的代码已经足够了。然而，在大多数情况下，你的应用程序可能是没有运行的，或者在后台被挂起。在这些情况下，你必须实现应用程序委托的两个方法，这样系统就可以唤醒你的应用程序。不同于以往的委托回调，该应用程序委托会被调用两次，因为您的会话和任务委托可能会收到一系列消息。app delegate 的：handleEventsForBackgroundURLSession： 方法会在这些 NSURLSession 委托的消息发送前被调用，然后，URLSessionDidFinishEventsForBackgroundURLSession 在随后被调用。在前面的方法中，包含了一个后台完成的回调（completionHandler），并在后面的方法中执行回调以便更新界面:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (void)                  application:(UIApplication *)application </span><br><span class=\"line\">  handleEventsForBackgroundURLSession:(NSString *)identifier completionHandler:(void (^)())completionHandler</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    // 你必须重新建立一个后台 seesiong 的参照</span><br><span class=\"line\">    // 否则 NSURLSessionDownloadDelegate 和 NSURLSessionDelegate 方法会因为</span><br><span class=\"line\">    // 没有 对 session 的 delegate 设定而不会被调用。参见上面的 backgroundURLSession</span><br><span class=\"line\">    NSURLSession *backgroundSession = [self backgroundURLSession];</span><br><span class=\"line\"></span><br><span class=\"line\">    NSLog(@&quot;Rejoining session with identifier %@ %@&quot;, identifier, backgroundSession);</span><br><span class=\"line\"></span><br><span class=\"line\">    // 保存 completion handler 以在处理 session 事件后更新 UI</span><br><span class=\"line\">    [self addCompletionHandler:completionHandler forSession:identifier];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)URLSessionDidFinishEventsForBackgroundURLSession:(NSURLSession *)session</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    NSLog(@&quot;Background URL session %@ finished events.\\n&quot;, session);</span><br><span class=\"line\"></span><br><span class=\"line\">    if (session.configuration.identifier) &#123;</span><br><span class=\"line\">        // 调用在 -application:handleEventsForBackgroundURLSession: 中保存的 handler</span><br><span class=\"line\">        [self callCompletionHandlerForSession:session.configuration.identifier];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)addCompletionHandler:(CompletionHandlerType)handler forSession:(NSString *)identifier</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    if ([self.completionHandlerDictionary objectForKey:identifier]) &#123;</span><br><span class=\"line\">        NSLog(@&quot;Error: Got multiple handlers for a single session identifier.  This should not happen.\\n&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    [self.completionHandlerDictionary setObject:handler forKey:identifier];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)callCompletionHandlerForSession: (NSString *)identifier</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    CompletionHandlerType handler = [self.completionHandlerDictionary objectForKey: identifier];</span><br><span class=\"line\"></span><br><span class=\"line\">    if (handler) &#123;</span><br><span class=\"line\">        [self.completionHandlerDictionary removeObjectForKey: identifier];</span><br><span class=\"line\">        NSLog(@&quot;Calling completion handler for session %@&quot;, identifier);</span><br><span class=\"line\"></span><br><span class=\"line\">        handler();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>如果当后台传输完成时，应用程序不再停留在前台，那么，对于更新程序界面来说，这个两步处理过程是必要的。此外，如果当后台传输完成时，应用程序根本没有在运行，iOS 将会在后台启动该应用程序，然后前面的应用程序和会话的委托方法会在 application:didFinishLaunchingWithOptions: 方法被调用之后被调用。</p>\n<h2 id=\"配置和限制\"><a href=\"#配置和限制\" class=\"headerlink\" title=\"配置和限制\"></a>配置和限制</h2><p>我们简单地体验了后台传输的强大之处，但你应该深入文档，阅读 NSURLSessionConfiguration 部分，以便最好地满足你的使用场景。例如，NSURLSessionTasks 通过 NSURLSessionConfiguration 的 timeoutIntervalForResource 属性，支持资源超时特性。你可以使用这个特性指定你允许完成一个传输所需的最长时间。内容只在有限的时间可用，或者在用户只有有限 Wifi 带宽的时间内无法下载或上传资源的情况下，你也可以使用这个特性。</p>\n<p>除了下载任务，NSURLSession 也全面支持上传任务，因此，你可能会在后台将视频上传到服务器，这保证用户不需要再像 iOS 6 那样保持应用程序前台运行。如果当传输完成时你的应用程序不需要在后台运行，一个比较好的做法是，把 NSURLSessionConfiguration 的 sessionSendsLaunchEvents 属性设置为 NO。高效利用系统资源，是一件让 iOS 和用户都高兴的事。</p>\n<p>最后，我们来说一说使用后台会话的几个限制。作为一个必须实现的委托，您不能对 NSURLSession 使用简单的基于 block 的回调方法。后台启动应用程序，是相对耗费较多资源的，所以总是采用 HTTP 重定向。后台传输服务只支持 HTTP 和 HTTPS，你不能使用自定义的协议。系统会根据可用的资源进行优化，在任何时候你都不能强制传输任务在后台进行。</p>\n<p>另外，要注意的是在后台会话中，NSURLSessionDataTasks 是完全不支持的，你应该只出于短期的，小请求为目的使用这些任务，而不是用来下载或上传。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>iOS 7 中强大的多任务和网络 API 为现有应用和新应用开启了一系列全新的可能性。如果你的应用程序可以从进程外的网络传输和数据中获益，那么尽情地使用这些美妙的 API。一般情况下，你可以就像你的应用正在前台运行那样去实现后台传输，并进行适当的界面更新，而这里绝大多数的工作都已经为你完成了。</p>\n<ul>\n<li>使用适当的新 API 来为你的应用程序提供内容。</li>\n<li>尽可能早地调用 completion handler 以提高效率。</li>\n<li>让 completion handler 为应用程序更新界面快照。<h2 id=\"扩展阅读\"><a href=\"#扩展阅读\" class=\"headerlink\" title=\"扩展阅读\"></a>扩展阅读</h2><a href=\"https://developer.apple.com/wwdc/videos/?id=204\">WWDC 2013 session “What’s New with Multitasking”</a><br><a href=\"https://developer.apple.com/wwdc/videos/?id=705\">WWDC 2013 session “What’s New in Foundation Networking”</a><br><a href=\"https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/URLLoadingSystem/URLLoadingSystem.html#//apple_ref/doc/uid/10000165i\">URL Loading System Programming Guide</a></li>\n</ul>\n<hr>\n<p><em>观点仅代表自己，期待你的留言。</em><br><a href=\"http://objccn.io/issue-5-5/\">http://objccn.io/issue-5-5/</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>在 iOS 7 之前，当程序置于后台之后开发者们对他们程序所能做的事情非常有限。除了 VOIP 和基于地理位置特性以外，唯一能做的地方就是使用后台任务（background tasks）让代码可以执行几分钟。如果你想下载比较大的视频文件以便离线浏览，亦或者备份用户的照片到你的服务器上，你都仅能完成一部分工作。</p>\n<p>iOS 7 添加了两个新的 API 以便你的程序可以在后台更新界面以及内容。首先是后台获取（Background Fetch），它允许你定期地从网络获取新的内容。第二个 API 就是远程通知（Remote Notifications），这是一个当事件发生时可以让推送通知主动提醒应用的新特性，这两者都为你的应用界面保持最新提供了极大的帮助。在新的后台传输服务 (Background Transfer Service) 中执行定期的任务，也允许你在进程之外可以执行网络传输（下载和上传）工作。</p>\n<p>后台获取 (Background Fetch) 和远程通知 (Remote Notification) 基于简单的 ApplicationDelegate 钩子，在应用程序挂起之前的 30 秒时钟时间执行工作。它们不是用于 CPU 频繁工作或者长时间运行任务，而是用来处理长时间运行的网络请求队列，例如下载一部很大的电影，或者执行快速的内容更新。</p>\n<p>对用户来说，多任务处理有一点显而易见的改变就是新的应用切换程序 (the new app switcher)，它用来呈现应用到后台时的界面快照。这些快照的存在是有一定理由的–现在你可以在后台完成工作后更新程序快照，以用来呈现新的内容。社交网络、新闻或者天气等应用现在都可以直接呈现最新的内容而不需要用户重新打开应用。我们稍后会介绍如何更新屏幕快照。</p>\n<h2 id=\"后台获取\"><a href=\"#后台获取\" class=\"headerlink\" title=\"后台获取\"></a>后台获取</h2><p>后台获取是一种智能的轮询机制，它很适合需要经常更新内容的程序，像社交网络，新闻或天气的程序。为了在用户启动程序前提前触发后台获取，系统会根据用户行为唤醒应用程序。举个例子，如果用户经常在下午 1 点使用某个应用程序，系统会学习，适应并在使用周期前执行后台获取。为了减少电池使用，使用设备无线通信的所有应用的后台获取会被合并，如果你向系统报告新数据无法获取，iOS 会适应并使用此信息避免会继续获取。</p>\n<p>开启后台获取的第一步是在 info plist 文件中对 <a href=\"https://developer.apple.com/library/ios/documentation/general/Reference/InfoPlistKeyReference/Articles/iPhoneOSKeys.html#//apple_ref/doc/uid/TP40009252-SW22\">UIBackgroundModes</a> 键指定特定的值。最简单的途径是在 Xcode 5 的 project editor 中新的 Capabilities 标签页中设置，这个标签页包含了后台模式部分，可以方便配置多任务选项。<br><img src=\"/images/capabilities-on-bgfetch.jpg\"><br>或者，你可以手动编辑这个值</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;key&gt;UIBackgroundModes&lt;/key&gt;</span><br><span class=\"line\">&lt;array&gt;</span><br><span class=\"line\">    &lt;string&gt;fetch&lt;/string&gt;</span><br><span class=\"line\">&lt;/array&gt;  </span><br></pre></td></tr></table></figure>\n<p>接下来，告诉 iOS 多久进行一次数据获取</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    [application setMinimumBackgroundFetchInterval:UIApplicationBackgroundFetchIntervalMinimum];</span><br><span class=\"line\"></span><br><span class=\"line\">    return YES;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>iOS 默认不进行后台获取，所以你需要设置一个时间间隔，否则，你的应用程序永远不能在后台被唤醒。UIApplicationBackgroundFetchIntervalMinimum 这个值要求系统尽可能频繁地去管理你的程序到底什么时候应该被唤醒，但如果你不需要这样的话，你也应该指定一个你想要的的时间间隔。例如，一个天气的应用程序，可能只需要几个小时才更新一次，iOS 将会在后台获取之间至少等待你指定的时间间隔。</p>\n<p>如果你的应用允许用户退出登录，那么就没有获取新数据的需要了，你应该把 minimumBackgroundFetchInterval 设置为 UIApplicationBackgroundFetchIntervalNever，这样可以节省资源。</p>\n<p>最后一步是在应用程序委托中实现下列方法：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (void) application:(UIApplication *)application </span><br><span class=\"line\">  performFetchWithCompletionHandler:(void (^)(UIBackgroundFetchResult))completionHandler</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    NSURLSessionConfiguration *sessionConfiguration = [NSURLSessionConfiguration defaultSessionConfiguration];</span><br><span class=\"line\">    NSURLSession *session = [NSURLSession sessionWithConfiguration:sessionConfiguration];</span><br><span class=\"line\"></span><br><span class=\"line\">    NSURL *url = [[NSURL alloc] initWithString:@&quot;http://yourserver.com/data.json&quot;];</span><br><span class=\"line\">    NSURLSessionDataTask *task = [session dataTaskWithURL:url </span><br><span class=\"line\">                                        completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        if (error) &#123;</span><br><span class=\"line\">            completionHandler(UIBackgroundFetchResultFailed);</span><br><span class=\"line\">            return;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        // 解析响应/数据以决定新内容是否可用</span><br><span class=\"line\">        BOOL hasNewData = ...</span><br><span class=\"line\">        if (hasNewData) &#123;</span><br><span class=\"line\">            completionHandler(UIBackgroundFetchResultNewData);</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">            completionHandler(UIBackgroundFetchResultNoData);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;];</span><br><span class=\"line\"></span><br><span class=\"line\">    // 开始任务</span><br><span class=\"line\">    [task resume];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>系统唤醒应用程序后将会执行这个委托方法。需要注意的是，你只有 30 秒的时间来确定获取的新内容是否可用，然后处理新内容并更新界面。30 秒时间应该足够去从网络获取数据和获取界面的缩略图，但是最多只有 30 秒。当完成了网络请求和更新界面后，你应该执行完成的回调。</p>\n<p>完成回调的执行有两个目的。首先，系统会估量你的进程消耗的电量，并根据你传递的 UIBackgroundFetchResult 参数记录新数据是否可用。其次，当你调用完成的处理代码时，应用的界面缩略图会被采用，并更新应用程序切换器。当用户在应用间切换时，用户将会看到新内容。这种通过 completion handler 来报告并且生成截图的方法，在新的多任务处理 API 中是很常见的。</p>\n<p>在实际应用中，你应该将 completionHandler 传递到应用程序的子组件，然后在处理完数据和更新界面后调用。</p>\n<p>在这里，你可能想知道 iOS 是如何在应用程序后台运行时获得界面截图的，并且想知道应用程序的生命周期与后台获取之间有什么关系。如果应用程序处于挂起状态，系统会先唤醒应用，然后再调用 application: performFetchWithCompletionHandler:。如果应用程序还没有启动，系统将会启动它，然后调用常见的委托方法，包括 application: didFinishLaunchingWithOptions:。你可以把这种应用程序运行的方式想像为用户从 Springboard 启动这个程序，区别仅仅在于界面是看不见的，在屏幕外渲染的。</p>\n<p>大多数情况下，无论应用在后台启动或者在前台，你会执行相同的工作，但你可以通过查看 UIApplication 的 applicationState 属性来判断应用是不是从后台启动。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    NSLog(@&quot;Launched in background %d&quot;, UIApplicationStateBackground == application.applicationState);</span><br><span class=\"line\"></span><br><span class=\"line\">    return YES;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"测试后台数据获取\"><a href=\"#测试后台数据获取\" class=\"headerlink\" title=\"测试后台数据获取\"></a>测试后台数据获取</h2><p>有两种可以模拟后台获取的途径。最简单是从 Xcode 运行你的应用，当应用运行时，在 Xcode 的 Debug 菜单选择 Simulate Background Fetch.</p>\n<p>第二种方法，使用 scheme 更改 Xcode 运行程序的方式。在 Xcode 菜单的 Product 选项，选择 Scheme 然后选择 Manage Schemes。在这里，你可以编辑或者添加一个新的 scheme，然后选中 Launch due to a background fetch event 。如下图：<br><img src=\"/images/edit-scheme-simulate-background-fetch.png\"></p>\n<h2 id=\"远程通知\"><a href=\"#远程通知\" class=\"headerlink\" title=\"远程通知\"></a>远程通知</h2><p>远程通知允许你在重要事件发生时，告知你的应用。你可能需要发送新的即时信息，突发新闻的提醒，或者用户喜爱电视的最新剧集已经可以下载以便离线观看的消息。远程通知很适合用于那些偶尔出现，但却很重要的内容，如果使用后台获取模式中在两次获取间需要等待的时间是不可接受的话，远程通知会是一个不错的选择。远程通知会比后台获取更有效率，因为应用程序只有在需要的时候才会启动。</p>\n<p>一条远程通知实际上只是一条普通的带有 content-available 标志的推送通知。你可以发送一条带有提醒信息的推送去告诉用户有事请发生了，同时在后台对界面进行更新。但远程通知也可以做到在安静地，没有提醒消息或者任何声音的情况下，只去更新应用界面或者触发后台工作。然后你可以在完成下载或者处理完新内容后，发送一条本地通知。</p>\n<p>静默的推送通知有速度限制，所以你可以大胆地根据应用程序的需要发送尽可能多的通知。iOS 和苹果推送服务会控制推送通知多久被递送，发送很多推送通知是没有问题的。如果你的推送通知达到了限制，推送通知可能会被延迟，直到设备下次发送保持活动状态的数据包，或者收到另外一个通知。</p>\n<h2 id=\"发送远程通知\"><a href=\"#发送远程通知\" class=\"headerlink\" title=\"发送远程通知\"></a>发送远程通知</h2><p>要发送一条远程通知，需要在推送通知的有效负载（payload）设置 content－available 标志。content-available 标志和用来通知 报刊应用（Newsstand）的健值是一样的，因此，大多数推送脚本和库都已经支持远程通知。当你发送一条远程通知时，你可能还想要包含一些通知有效负载中的数据，让你应用程序可以引用事件。这可以为你节省一些网络请求，并提高应用程序的响应度。</p>\n<p>我建议在开发的时候，使用 <a href=\"http://nomad-cli.com/#houston\">Nomad CLI’s Houston</a> 工具发送推送消息，当然你也可以使用你喜欢的库或脚本。</p>\n<p>你可以通过 nomad-cli ruby gem 来安装 Houston</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gem install nomad-cli</span><br></pre></td></tr></table></figure>\n<p>然后通过包含在 Nomad 的 apn 实用工具发送一条通知：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># Send a Push Notification to your Device</span><br><span class=\"line\">apn push &lt;device token&gt; -c /path/to/key-cert.pem -n -d content-id=42</span><br></pre></td></tr></table></figure>\n<p>在这里，-n 标志指定应该包含 content-available 健值，-d 标志允许添加我们自定义的数据健值到有效负荷。</p>\n<p>通知的有效负荷（payload）结果和下面类似：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    &quot;aps&quot; : &#123;</span><br><span class=\"line\">        &quot;content-available&quot; : 1</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    &quot;content-id&quot; : 42</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>iOS 7 添加了一个新的应用程序委托方法，当接收到一条带有 content－available 的推送通知时，下面的方法会被调用：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (void)application:(UIApplication *)application </span><br><span class=\"line\">  didReceiveRemoteNotification:(NSDictionary *)userInfo </span><br><span class=\"line\">        fetchCompletionHandler:(void (^)(UIBackgroundFetchResult))completionHandler</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    NSLog(@&quot;Remote Notification userInfo is %@&quot;, userInfo);</span><br><span class=\"line\"></span><br><span class=\"line\">    NSNumber *contentID = userInfo[@&quot;content-id&quot;];</span><br><span class=\"line\">    // 根据 content ID 进行操作</span><br><span class=\"line\">    completionHandler(UIBackgroundFetchResultNewData);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>和后台抓取一样，应用程序进入后台启动，也有 30 秒的时间去获取新内容并更新界面，最后调用完成的处理代码。我们可以像后台获取那样，执行快速的网络请求，但我们可以使用新的强大的后台传输服务，处理任务队列，下面看看我们如何在任务完成后更新界面。</p>\n<h2 id=\"NSURLSession-和-后台传输服务（Background-Transfer-Service）\"><a href=\"#NSURLSession-和-后台传输服务（Background-Transfer-Service）\" class=\"headerlink\" title=\"NSURLSession 和 后台传输服务（Background Transfer Service）\"></a>NSURLSession 和 后台传输服务（Background Transfer Service）</h2><p>NSURLSession 是 iOS 7 添加的一个新类，它也是 Foundation networking 中的新技术。作为 NSURLConnection 的替代品，一些熟悉的概念和类都保留下来了，例如 NSURL，NSURLRequest 和 NSURLResponse。所以，你可以使用 NSURLSessionTask 这一 NSURLConnection 的替代品，来处理网络请求及响应。一共有 3 种会话任务：数据，下载和上传。每一种都向 NSURLSessionTask 添加了语法糖，根据你的需要，适当选择一种。</p>\n<p>一个 NSURLSession 对象协调一个或多个 NSURLSessionTask 对象，并根据 NSURLSessionTask 创建的 NSURLSessionConfiguration 实现不同的功能。使用相同的配置，你也可以创建多组具有相关任务的 NSURLSession 对象。要利用后台传输服务，你将会使用 [NSURLSessionConfiguration backgroundSessionConfiguration] 来创建一个会话配置。添加到后台会话的任务在外部进程运行，即使应用程序被挂起，崩溃，或者被杀死，它依然会运行。</p>\n<p>NSURLSessionConfiguration 允许你设置默认的 HTTP 头，配置缓存策略，限制使用蜂窝数据等等。其中一个选项是 discretionary 标志，这个标志允许系统为分配任务进行性能优化。这意味着只有当设备有足够电量时，设备才通过 Wifi 进行数据传输。如果电量低，或者只仅有一个蜂窝连接，传输任务是不会运行的。后台传输总是在 discretionary 模式下运行。</p>\n<p>目前为止，我们大概了解了 NSURLSession，以及一个后台会话如何进行，接下来，让我们回到远程通知的例子，添加一些代码来处理后台传输服务的下载队列。当下载完成后，我们会通知用户该文件已经可以使用了。</p>\n<h2 id=\"NSURLSessionDownloadTask\"><a href=\"#NSURLSessionDownloadTask\" class=\"headerlink\" title=\"NSURLSessionDownloadTask\"></a>NSURLSessionDownloadTask</h2><p>首先，我们先处理一条远程通知，并把一个 NSURLSessionDownloadTask 添加到后台传输服务的队列。在 backgroundURLSession 方法中，我们根据后台会话配置，创建一个 NSURLSession 对象，并把 application delegate 作为会话的委托对象。文档不建议对于相同的标识符 (identifier) 创建多个会话对象，所以我们使用 dispatch_once 来避免潜在的问题：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (NSURLSession *)backgroundURLSession</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    static NSURLSession *session = nil;</span><br><span class=\"line\">    static dispatch_once_t onceToken;</span><br><span class=\"line\">    dispatch_once(&amp;onceToken, ^&#123;</span><br><span class=\"line\">        NSString *identifier = @&quot;io.objc.backgroundTransferExample&quot;;</span><br><span class=\"line\">        NSURLSessionConfiguration* sessionConfig = [NSURLSessionConfiguration backgroundSessionConfiguration:identifier];</span><br><span class=\"line\">        session = [NSURLSession sessionWithConfiguration:sessionConfig </span><br><span class=\"line\">                                                delegate:self </span><br><span class=\"line\">                                           delegateQueue:[NSOperationQueue mainQueue]];</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    return session;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)           application:(UIApplication *)application </span><br><span class=\"line\">  didReceiveRemoteNotification:(NSDictionary *)userInfo </span><br><span class=\"line\">        fetchCompletionHandler:(void (^)(UIBackgroundFetchResult))completionHandler</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    NSLog(@&quot;Received remote notification with userInfo %@&quot;, userInfo);</span><br><span class=\"line\"></span><br><span class=\"line\">    NSNumber *contentID = userInfo[@&quot;content-id&quot;];</span><br><span class=\"line\">    NSString *downloadURLString = [NSString stringWithFormat:@&quot;http://yourserver.com/downloads/%d.mp3&quot;, [contentID intValue]];</span><br><span class=\"line\">    NSURL* downloadURL = [NSURL URLWithString:downloadURLString];</span><br><span class=\"line\"></span><br><span class=\"line\">    NSURLRequest *request = [NSURLRequest requestWithURL:downloadURL];</span><br><span class=\"line\">    NSURLSessionDownloadTask *task = [[self backgroundURLSession] downloadTaskWithRequest:request];</span><br><span class=\"line\">    task.taskDescription = [NSString stringWithFormat:@&quot;Podcast Episode %d&quot;, [contentID intValue]];</span><br><span class=\"line\">    [task resume];</span><br><span class=\"line\"></span><br><span class=\"line\">    completionHandler(UIBackgroundFetchResultNewData);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们使用 NSURLSession 类方法创建一个下载任务，配置请求，并提供说明供以后使用。因为所有会话任务一开始处于挂起状态，你必须谨记要调用 [task resume] 保证开始了任务。</p>\n<p>现在，我们需要实现 NSURLSessionDownloadDelegate 的委托方法，当下载完成时，调用回调函数。如果你需要处理认证或会话生命周期的其他事件，你可能还需要实现 NSURLSessionDelegate 或 NSURLSessionTaskDelegate 的方法。你应该阅读 Apple 的 <a href=\"https://developer.apple.com/library/ios/documentation/cocoa/Conceptual/URLLoadingSystem/NSURLSessionConcepts/NSURLSessionConcepts.html#//apple_ref/doc/uid/10000165i-CH2-SW42\">Life Cycle of a URL Session with Custom Delegates</a> 文档，它讲解了所有类型的会话任务的完整生命周期。</p>\n<p>NSURLSessionDownloadDelegate 中的委托方法全部是必须实现的，尽管在这个例子中我们只需要用到 [NSURLSession downloadTask:didFinishDownloadingToURL:]。任务完成下载时，你会得到一个磁盘上该文件的临时 URL。你必须把这个文件移动或复制你的应用程序空间，因为当你从这个委托方法返回时，该文件将从临时存储中删除。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#Pragma Mark - NSURLSessionDownloadDelegate</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)         URLSession:(NSURLSession *)session </span><br><span class=\"line\">               downloadTask:(NSURLSessionDownloadTask *)downloadTask</span><br><span class=\"line\">  didFinishDownloadingToURL:(NSURL *)location</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    NSLog(@&quot;downloadTask:%@ didFinishDownloadingToURL:%@&quot;, downloadTask.taskDescription, location);</span><br><span class=\"line\"></span><br><span class=\"line\">    // 用 NSFileManager 将文件复制到应用的存储中</span><br><span class=\"line\">    // ...</span><br><span class=\"line\"></span><br><span class=\"line\">    // 通知 UI 刷新</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)  URLSession:(NSURLSession *)session </span><br><span class=\"line\">        downloadTask:(NSURLSessionDownloadTask *)downloadTask </span><br><span class=\"line\">   didResumeAtOffset:(int64_t)fileOffset </span><br><span class=\"line\">  expectedTotalBytes:(int64_t)expectedTotalBytes</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)         URLSession:(NSURLSession *)session </span><br><span class=\"line\">               downloadTask:(NSURLSessionDownloadTask *)downloadTask </span><br><span class=\"line\">               didWriteData:(int64_t)bytesWritten totalBytesWritten:(int64_t)totalBytesWritten </span><br><span class=\"line\">  totalBytesExpectedToWrite:(int64_t)totalBytesExpectedToWrite</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>当后台会话任务完成时，如果你的应用程序仍然在前台运行，上面的代码已经足够了。然而，在大多数情况下，你的应用程序可能是没有运行的，或者在后台被挂起。在这些情况下，你必须实现应用程序委托的两个方法，这样系统就可以唤醒你的应用程序。不同于以往的委托回调，该应用程序委托会被调用两次，因为您的会话和任务委托可能会收到一系列消息。app delegate 的：handleEventsForBackgroundURLSession： 方法会在这些 NSURLSession 委托的消息发送前被调用，然后，URLSessionDidFinishEventsForBackgroundURLSession 在随后被调用。在前面的方法中，包含了一个后台完成的回调（completionHandler），并在后面的方法中执行回调以便更新界面:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (void)                  application:(UIApplication *)application </span><br><span class=\"line\">  handleEventsForBackgroundURLSession:(NSString *)identifier completionHandler:(void (^)())completionHandler</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    // 你必须重新建立一个后台 seesiong 的参照</span><br><span class=\"line\">    // 否则 NSURLSessionDownloadDelegate 和 NSURLSessionDelegate 方法会因为</span><br><span class=\"line\">    // 没有 对 session 的 delegate 设定而不会被调用。参见上面的 backgroundURLSession</span><br><span class=\"line\">    NSURLSession *backgroundSession = [self backgroundURLSession];</span><br><span class=\"line\"></span><br><span class=\"line\">    NSLog(@&quot;Rejoining session with identifier %@ %@&quot;, identifier, backgroundSession);</span><br><span class=\"line\"></span><br><span class=\"line\">    // 保存 completion handler 以在处理 session 事件后更新 UI</span><br><span class=\"line\">    [self addCompletionHandler:completionHandler forSession:identifier];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)URLSessionDidFinishEventsForBackgroundURLSession:(NSURLSession *)session</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    NSLog(@&quot;Background URL session %@ finished events.\\n&quot;, session);</span><br><span class=\"line\"></span><br><span class=\"line\">    if (session.configuration.identifier) &#123;</span><br><span class=\"line\">        // 调用在 -application:handleEventsForBackgroundURLSession: 中保存的 handler</span><br><span class=\"line\">        [self callCompletionHandlerForSession:session.configuration.identifier];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)addCompletionHandler:(CompletionHandlerType)handler forSession:(NSString *)identifier</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    if ([self.completionHandlerDictionary objectForKey:identifier]) &#123;</span><br><span class=\"line\">        NSLog(@&quot;Error: Got multiple handlers for a single session identifier.  This should not happen.\\n&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    [self.completionHandlerDictionary setObject:handler forKey:identifier];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)callCompletionHandlerForSession: (NSString *)identifier</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    CompletionHandlerType handler = [self.completionHandlerDictionary objectForKey: identifier];</span><br><span class=\"line\"></span><br><span class=\"line\">    if (handler) &#123;</span><br><span class=\"line\">        [self.completionHandlerDictionary removeObjectForKey: identifier];</span><br><span class=\"line\">        NSLog(@&quot;Calling completion handler for session %@&quot;, identifier);</span><br><span class=\"line\"></span><br><span class=\"line\">        handler();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>如果当后台传输完成时，应用程序不再停留在前台，那么，对于更新程序界面来说，这个两步处理过程是必要的。此外，如果当后台传输完成时，应用程序根本没有在运行，iOS 将会在后台启动该应用程序，然后前面的应用程序和会话的委托方法会在 application:didFinishLaunchingWithOptions: 方法被调用之后被调用。</p>\n<h2 id=\"配置和限制\"><a href=\"#配置和限制\" class=\"headerlink\" title=\"配置和限制\"></a>配置和限制</h2><p>我们简单地体验了后台传输的强大之处，但你应该深入文档，阅读 NSURLSessionConfiguration 部分，以便最好地满足你的使用场景。例如，NSURLSessionTasks 通过 NSURLSessionConfiguration 的 timeoutIntervalForResource 属性，支持资源超时特性。你可以使用这个特性指定你允许完成一个传输所需的最长时间。内容只在有限的时间可用，或者在用户只有有限 Wifi 带宽的时间内无法下载或上传资源的情况下，你也可以使用这个特性。</p>\n<p>除了下载任务，NSURLSession 也全面支持上传任务，因此，你可能会在后台将视频上传到服务器，这保证用户不需要再像 iOS 6 那样保持应用程序前台运行。如果当传输完成时你的应用程序不需要在后台运行，一个比较好的做法是，把 NSURLSessionConfiguration 的 sessionSendsLaunchEvents 属性设置为 NO。高效利用系统资源，是一件让 iOS 和用户都高兴的事。</p>\n<p>最后，我们来说一说使用后台会话的几个限制。作为一个必须实现的委托，您不能对 NSURLSession 使用简单的基于 block 的回调方法。后台启动应用程序，是相对耗费较多资源的，所以总是采用 HTTP 重定向。后台传输服务只支持 HTTP 和 HTTPS，你不能使用自定义的协议。系统会根据可用的资源进行优化，在任何时候你都不能强制传输任务在后台进行。</p>\n<p>另外，要注意的是在后台会话中，NSURLSessionDataTasks 是完全不支持的，你应该只出于短期的，小请求为目的使用这些任务，而不是用来下载或上传。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>iOS 7 中强大的多任务和网络 API 为现有应用和新应用开启了一系列全新的可能性。如果你的应用程序可以从进程外的网络传输和数据中获益，那么尽情地使用这些美妙的 API。一般情况下，你可以就像你的应用正在前台运行那样去实现后台传输，并进行适当的界面更新，而这里绝大多数的工作都已经为你完成了。</p>\n<ul>\n<li>使用适当的新 API 来为你的应用程序提供内容。</li>\n<li>尽可能早地调用 completion handler 以提高效率。</li>\n<li>让 completion handler 为应用程序更新界面快照。<h2 id=\"扩展阅读\"><a href=\"#扩展阅读\" class=\"headerlink\" title=\"扩展阅读\"></a>扩展阅读</h2><a href=\"https://developer.apple.com/wwdc/videos/?id=204\">WWDC 2013 session “What’s New with Multitasking”</a><br><a href=\"https://developer.apple.com/wwdc/videos/?id=705\">WWDC 2013 session “What’s New in Foundation Networking”</a><br><a href=\"https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/URLLoadingSystem/URLLoadingSystem.html#//apple_ref/doc/uid/10000165i\">URL Loading System Programming Guide</a></li>\n</ul>\n<hr>\n<p><em>观点仅代表自己，期待你的留言。</em><br><a href=\"http://objccn.io/issue-5-5/\">http://objccn.io/issue-5-5/</a></p>\n"},{"title":"Java8 Stream之实例玩转集合的筛选、归约、分组、聚合","date":"2021-09-18T03:11:57.000Z","_content":"\n## 功能全景\n![Java8Stream全景](/images/java-stream-1.png)\n\n## Stream概述\nJava 8 是一个非常成功的版本，这个版本新增的`Stream`，配合同版本出现的 `Lambda` ，给我们操作集合（Collection）提供了极大的便利。\n\n那么什么是`Stream`？\n> Stream将要处理的元素集合看作一种流，在流的过程中，借助Stream API对流中的元素进行操作，比如：筛选、排序、聚合等。\n\nStream可以由数组或集合创建，对流的操作分为两种：\n1. 中间操作，每次返回一个新的流，可以有多个。\n2. 终端操作，每个流只能进行一次终端操作，终端操作结束后流无法再次使用。终端操作会产生一个新的集合或值。\n\n另外，Stream有几个特性：\n1. stream不存储数据，而是按照特定的规则对数据进行计算，一般会输出结果。\n2. stream不会改变数据源，通常情况下会产生一个新的集合或一个值。\n3. stream具有延迟执行特性，只有调用终端操作时，中间操作才会执行。\n\n## Stream的创建\n### Stream可以通过集合数组创建。\n1. 通过 java.util.Collection.stream()方法用集合创建流\n\n```\nList<String> list = Arrays.asList(\"a\", \"b\", \"c\");\n// 创建一个顺序流\nStream<String> stream = list.stream();\n// 创建一个并行流\nStream<String> parallelStream = list.parallelStream();\n```\n\n2. 使用java.util.Arrays.stream(T[] array)方法用数组创建流\n\n```\nint[] array={1,3,5,6,8};\nIntStream stream = Arrays.stream(array);\n```\n\n3. 使用Stream的静态方法：of()、iterate()、generate()\n\n```\nStream<Integer> stream = Stream.of(1, 2, 3, 4, 5, 6);\n\nStream<Integer> stream2 = Stream.iterate(0, (x) -> x + 3).limit(4);\nstream2.forEach(System.out::println);\n\nStream<Double> stream3 = Stream.generate(Math::random).limit(3);\nstream3.forEach(System.out::println);\n```\n\n**stream和parallelStream的简单区分**\n\nstream是顺序流，由主线程按顺序对流执行操作。\n\nparallelStream是并行流，内部以多线程并行执行的方式对流进行操作，但前提是流中的数据处理没有顺序要求。例如筛选集合中的奇数，两者的处理不同之处：\n\n![stream和parallelStream](/images/java-stream-2.png)\n\n如果流中的数据量足够大，并行流可以加快处速度。\n\n除了直接创建并行流，还可以通过parallel()把顺序流转换成并行流：\n\n```\nOptional<Integer> findFirst = list.stream().parallel().filter(x->x>6).findFirst();\n```\n\n## Stream的使用\n在使用stream之前，先理解一个概念：Optional。\n> Optional类是一个可以为null的容器对象。如果值存在则isPresent()方法会返回true，调用get()方法会返回该对象。 更详细说明请见：菜鸟教程Java 8 Optional类\n\n案例使用的员工类\n\n```\nList<Person> personList = new ArrayList<Person>();\npersonList.add(new Person(\"Tom\", 8900, \"male\", \"New York\"));\npersonList.add(new Person(\"Jack\", 7000, \"male\", \"Washington\"));\npersonList.add(new Person(\"Lily\", 7800, \"female\", \"Washington\"));\npersonList.add(new Person(\"Anni\", 8200, \"female\", \"New York\"));\npersonList.add(new Person(\"Owen\", 9500, \"male\", \"New York\"));\npersonList.add(new Person(\"Alisa\", 7900, \"female\", \"New York\"));\n\nclass Person {\n    private String name;  // 姓名\n    private int salary; // 薪资\n    private int age; // 年龄\n    private String sex; //性别\n    private String area;  // 地区\n\n    // 构造方法\n    public Person(String name, int salary, int age,String sex,String area) {\n        this.name = name;\n        this.salary = salary;\n        this.age = age;\n        this.sex = sex;\n        this.area = area;\n    }\n    // 省略了get和set，请自行添加\n\n}\n```\n\n### 遍历/匹配（foreach/find/match）\nStream也是支持类似集合的遍历和匹配元素的，只是Stream中的元素是以Optional类型存在的。Stream的遍历、匹配非常简单。\n\n```\n// import已省略，请自行添加，后面代码亦是\npublic class StreamTest {\n    public static void main(String[] args) {\n        List<Integer> list = Arrays.asList(7, 6, 9, 3, 8, 2, 1);\n\n        // 遍历输出符合条件的元素\n        list.stream().filter(x -> x > 6).forEach(System.out::println);\n        // 匹配第一个\n        Optional<Integer> findFirst = list.stream().filter(x -> x > 6).findFirst();\n        // 匹配任意（适用于并行流）\n        Optional<Integer> findAny = list.parallelStream().filter(x -> x > 6).findAny();\n        // 是否包含符合特定条件的元素\n        boolean anyMatch = list.stream().anyMatch(x -> x < 6);\n        System.out.println(\"匹配第一个值：\" + findFirst.get());\n        System.out.println(\"匹配任意一个值：\" + findAny.get());\n        System.out.println(\"是否存在大于6的值：\" + anyMatch);\n    }\n}\n```\n\n### 筛选（filter）\n筛选，是按照一定的规则校验流中的元素，将符合条件的元素提取到新的流中的操作。\n- 案例一：筛选出Integer集合中大于7的元素，并打印出来\n```\npublic class StreamTest {\n    public static void main(String[] args) {\n        List<Integer> list = Arrays.asList(6, 7, 3, 8, 1, 2, 9);\n        Stream<Integer> stream = list.stream();\n        stream.filter(x -> x > 7).forEach(System.out::println);\n    }\n}\n```\n运行结果：\n> 8 9\n\n- 案例二： 筛选员工中工资高于8000的人，并形成新的集合。 形成新集合依赖collect（收集），后文有详细介绍。\n```\npublic class StreamTest {\n    public static void main(String[] args) {\n        List<Person> personList = new ArrayList<Person>();\n        personList.add(new Person(\"Tom\", 8900, 23, \"male\", \"New York\"));\n        personList.add(new Person(\"Jack\", 7000, 25, \"male\", \"Washington\"));\n        personList.add(new Person(\"Lily\", 7800, 21, \"female\", \"Washington\"));\n        personList.add(new Person(\"Anni\", 8200, 24, \"female\", \"New York\"));\n        personList.add(new Person(\"Owen\", 9500, 25, \"male\", \"New York\"));\n        personList.add(new Person(\"Alisa\", 7900, 26, \"female\", \"New York\"));\n\n        List<String> fiterList = personList.stream().filter(x -> x.getSalary() > 8000).map(Person::getName)\n                .collect(Collectors.toList());\n        System.out.print(\"高于8000的员工姓名：\" + fiterList);\n    }\n}\n```\n运行结果：\n> 高于8000的员工姓名：[Tom, Anni, Owen]\n\n### 聚合（max/min/count)\nmax、min、count这些字眼你一定不陌生，没错，在mysql中我们常用它们进行数据统计。Java stream中也引入了这些概念和用法，极大地方便了我们对集合、数组的数据统计工作。\n\n- 案例一：获取String集合中最长的元素。\n```\npublic class StreamTest {\n\tpublic static void main(String[] args) {\n\t\tList<String> list = Arrays.asList(\"adnm\", \"admmt\", \"pot\", \"xbangd\", \"weoujgsd\");\n\n\t\tOptional<String> max = list.stream().max(Comparator.comparing(String::length));\n\t\tSystem.out.println(\"最长的字符串：\" + max.get());\n\t}\n}\n```\n运行结果：\n> 最长的字符串：weoujgsd\n\n- 案例二：获取Integer集合中的最大值。\n```\npublic class StreamTest {\n\tpublic static void main(String[] args) {\n\t\tList<Integer> list = Arrays.asList(7, 6, 9, 4, 11, 6);\n\n\t\t// 自然排序\n\t\tOptional<Integer> max = list.stream().max(Integer::compareTo);\n\t\t// 自定义排序\n\t\tOptional<Integer> max2 = list.stream().max(new Comparator<Integer>() {\n\t\t\t@Override\n\t\t\tpublic int compare(Integer o1, Integer o2) {\n\t\t\t\treturn o1.compareTo(o2);\n\t\t\t}\n\t\t});\n\t\tSystem.out.println(\"自然排序的最大值：\" + max.get());\n\t\tSystem.out.println(\"自定义排序的最大值：\" + max2.get());\n\t}\n}\n```\n运行结果：\n> 自然排序的最大值：11\n>\n>自定义排序的最大值：11\n\n- 案例三：获取员工工资最高的人。\n```\npublic class StreamTest {\n\tpublic static void main(String[] args) {\n\t\tList<Person> personList = new ArrayList<Person>();\n\t\tpersonList.add(new Person(\"Tom\", 8900, 23, \"male\", \"New York\"));\n\t\tpersonList.add(new Person(\"Jack\", 7000, 25, \"male\", \"Washington\"));\n\t\tpersonList.add(new Person(\"Lily\", 7800, 21, \"female\", \"Washington\"));\n\t\tpersonList.add(new Person(\"Anni\", 8200, 24, \"female\", \"New York\"));\n\t\tpersonList.add(new Person(\"Owen\", 9500, 25, \"male\", \"New York\"));\n\t\tpersonList.add(new Person(\"Alisa\", 7900, 26, \"female\", \"New York\"));\n\n\t\tOptional<Person> max = personList.stream().max(Comparator.comparingInt(Person::getSalary));\n\t\tSystem.out.println(\"员工工资最大值：\" + max.get().getSalary());\n\t}\n}\n```\n运行结果：\n> 员工工资最大值：9500\n\n- 案例四：计算Integer集合中大于6的元素的个数。\n```\npublic class StreamTest {\n\tpublic static void main(String[] args) {\n\t\tList<Integer> list = Arrays.asList(7, 6, 4, 8, 2, 11, 9);\n\n\t\tlong count = list.stream().filter(x -> x > 6).count();\n\t\tSystem.out.println(\"list中大于6的元素个数：\" + count);\n\t}\n}\n```\n运行结果：\n> list中大于6的元素个数：4\n\n### 映射(map/flatMap)\n映射，可以将一个流的元素按照一定的映射规则映射到另一个流中。分为map和flatMap：\n1. map：接收一个函数作为参数，该函数会被应用到每个元素上，并将其映射成一个新的元素。\n2. flatMap：接收一个函数作为参数，将流中的每个值都换成另一个流，然后把所有流连接成一个流。\n\n- 案例一：英文字符串数组的元素全部改为大写。整数数组每个元素+3。\n```\npublic class StreamTest {\n\tpublic static void main(String[] args) {\n\t\tString[] strArr = { \"abcd\", \"bcdd\", \"defde\", \"fTr\" };\n\t\tList<String> strList = Arrays.stream(strArr).map(String::toUpperCase).collect(Collectors.toList());\n\n\t\tList<Integer> intList = Arrays.asList(1, 3, 5, 7, 9, 11);\n\t\tList<Integer> intListNew = intList.stream().map(x -> x + 3).collect(Collectors.toList());\n\n\t\tSystem.out.println(\"每个元素大写：\" + strList);\n\t\tSystem.out.println(\"每个元素+3：\" + intListNew);\n\t}\n}\n```\n运行结果：\n> 每个元素大写：[ABCD, BCDD, DEFDE, FTR]\n>\n>每个元素+3：[4, 6, 8, 10, 12, 14]\n\n- 案例二：将员工的薪资全部增加1000\n```\npublic class StreamTest {\n\tpublic static void main(String[] args) {\n\t\tList<Person> personList = new ArrayList<Person>();\n\t\tpersonList.add(new Person(\"Tom\", 8900, 23, \"male\", \"New York\"));\n\t\tpersonList.add(new Person(\"Jack\", 7000, 25, \"male\", \"Washington\"));\n\t\tpersonList.add(new Person(\"Lily\", 7800, 21, \"female\", \"Washington\"));\n\t\tpersonList.add(new Person(\"Anni\", 8200, 24, \"female\", \"New York\"));\n\t\tpersonList.add(new Person(\"Owen\", 9500, 25, \"male\", \"New York\"));\n\t\tpersonList.add(new Person(\"Alisa\", 7900, 26, \"female\", \"New York\"));\n\n\t\t// 不改变原来员工集合的方式\n\t\tList<Person> personListNew = personList.stream().map(person -> {\n\t\t\tPerson personNew = new Person(person.getName(), 0, 0, null, null);\n\t\t\tpersonNew.setSalary(person.getSalary() + 10000);\n\t\t\treturn personNew;\n\t\t}).collect(Collectors.toList());\n\t\tSystem.out.println(\"一次改动前：\" + personList.get(0).getName() + \"-->\" + personList.get(0).getSalary());\n\t\tSystem.out.println(\"一次改动后：\" + personListNew.get(0).getName() + \"-->\" + personListNew.get(0).getSalary());\n\n\t\t// 改变原来员工集合的方式\n\t\tList<Person> personListNew2 = personList.stream().map(person -> {\n\t\t\tperson.setSalary(person.getSalary() + 10000);\n\t\t\treturn person;\n\t\t}).collect(Collectors.toList());\n\t\tSystem.out.println(\"二次改动前：\" + personList.get(0).getName() + \"-->\" + personListNew.get(0).getSalary());\n\t\tSystem.out.println(\"二次改动后：\" + personListNew2.get(0).getName() + \"-->\" + personListNew.get(0).getSalary());\n\t}\n}\n```\n运行结果：\n> 一次改动前：Tom–>8900\n>\n>一次改动后：Tom–>18900\n>\n>二次改动前：Tom–>18900\n>\n>二次改动后：Tom–>18900\n\n- 案例三：将两个字符数组合并成一个新的字符数组。\n```\npublic class StreamTest {\n\tpublic static void main(String[] args) {\n\t\tList<String> list = Arrays.asList(\"m,k,l,a\", \"1,3,5,7\");\n\t\tList<String> listNew = list.stream().flatMap(s -> {\n\t\t\t// 将每个元素转换成一个stream\n\t\t\tString[] split = s.split(\",\");\n\t\t\tStream<String> s2 = Arrays.stream(split);\n\t\t\treturn s2;\n\t\t}).collect(Collectors.toList());\n\n\t\tSystem.out.println(\"处理前的集合：\" + list);\n\t\tSystem.out.println(\"处理后的集合：\" + listNew);\n\t}\n}\n```\n运行结果：\n>处理前的集合：[m-k-l-a, 1-3-5]\n>\n>处理后的集合：[m, k, l, a, 1, 3, 5]\n\n### 归约(reduce)\n归约，也称缩减，顾名思义，是把一个流缩减成一个值，能实现对集合求和、求乘积和求最值操作。\n\n- 案例一：求Integer集合的元素之和、乘积和最大值。\n```\npublic class StreamTest {\n\tpublic static void main(String[] args) {\n\t\tList<Integer> list = Arrays.asList(1, 3, 2, 8, 11, 4);\n\t\t// 求和方式1\n\t\tOptional<Integer> sum = list.stream().reduce((x, y) -> x + y);\n\t\t// 求和方式2\n\t\tOptional<Integer> sum2 = list.stream().reduce(Integer::sum);\n\t\t// 求和方式3\n\t\tInteger sum3 = list.stream().reduce(0, Integer::sum);\n\n\t\t// 求乘积\n\t\tOptional<Integer> product = list.stream().reduce((x, y) -> x * y);\n\n\t\t// 求最大值方式1\n\t\tOptional<Integer> max = list.stream().reduce((x, y) -> x > y ? x : y);\n\t\t// 求最大值写法2\n\t\tInteger max2 = list.stream().reduce(1, Integer::max);\n\n\t\tSystem.out.println(\"list求和：\" + sum.get() + \",\" + sum2.get() + \",\" + sum3);\n\t\tSystem.out.println(\"list求积：\" + product.get());\n\t\tSystem.out.println(\"list求和：\" + max.get() + \",\" + max2);\n\t}\n}\n```\n运行结果：\n>list求和：29,29,29\n>\n>list求积：2112\n>\n>list求和：11,11\n\n- 案例二：求所有员工的工资之和和最高工资。\n```\npublic class StreamTest {\n\tpublic static void main(String[] args) {\n\t\tList<Person> personList = new ArrayList<Person>();\n\t\tpersonList.add(new Person(\"Tom\", 8900, 23, \"male\", \"New York\"));\n\t\tpersonList.add(new Person(\"Jack\", 7000, 25, \"male\", \"Washington\"));\n\t\tpersonList.add(new Person(\"Lily\", 7800, 21, \"female\", \"Washington\"));\n\t\tpersonList.add(new Person(\"Anni\", 8200, 24, \"female\", \"New York\"));\n\t\tpersonList.add(new Person(\"Owen\", 9500, 25, \"male\", \"New York\"));\n\t\tpersonList.add(new Person(\"Alisa\", 7900, 26, \"female\", \"New York\"));\n\n\t\t// 求工资之和方式1：\n\t\tOptional<Integer> sumSalary = personList.stream().map(Person::getSalary).reduce(Integer::sum);\n\t\t// 求工资之和方式2：\n\t\tInteger sumSalary2 = personList.stream().reduce(0, (sum, p) -> sum += p.getSalary(),\n\t\t\t\t(sum1, sum2) -> sum1 + sum2);\n\t\t// 求工资之和方式3：\n\t\tInteger sumSalary3 = personList.stream().reduce(0, (sum, p) -> sum += p.getSalary(), Integer::sum);\n\n\t\t// 求最高工资方式1：\n\t\tInteger maxSalary = personList.stream().reduce(0, (max, p) -> max > p.getSalary() ? max : p.getSalary(),\n\t\t\t\tInteger::max);\n\t\t// 求最高工资方式2：\n\t\tInteger maxSalary2 = personList.stream().reduce(0, (max, p) -> max > p.getSalary() ? max : p.getSalary(),\n\t\t\t\t(max1, max2) -> max1 > max2 ? max1 : max2);\n\n\t\tSystem.out.println(\"工资之和：\" + sumSalary.get() + \",\" + sumSalary2 + \",\" + sumSalary3);\n\t\tSystem.out.println(\"最高工资：\" + maxSalary + \",\" + maxSalary2);\n\t}\n}\n```\n运行结果：\n>工资之和：49300,49300,49300\n>\n>最高工资：9500,9500\n\n### 收集(collect)\ncollect，收集，可以说是内容最繁多、功能最丰富的部分了。从字面上去理解，就是把一个流收集起来，最终可以是收集成一个值也可以收集成一个新的集合。\n>collect主要依赖java.util.stream.Collectors类内置的静态方法。\n\n#### 归集(toList/toSet/toMap)\n因为流不存储数据，那么在流中的数据完成处理后，需要将流中的数据重新归集到新的集合里。toList、toSet和toMap比较常用，另外还有toCollection、toConcurrentMap等复杂一些的用法。\n\n下面用一个案例演示toList、toSet和toMap：\n```\npublic class StreamTest {\n\tpublic static void main(String[] args) {\n\t\tList<Integer> list = Arrays.asList(1, 6, 3, 4, 6, 7, 9, 6, 20);\n\t\tList<Integer> listNew = list.stream().filter(x -> x % 2 == 0).collect(Collectors.toList());\n\t\tSet<Integer> set = list.stream().filter(x -> x % 2 == 0).collect(Collectors.toSet());\n\n\t\tList<Person> personList = new ArrayList<Person>();\n\t\tpersonList.add(new Person(\"Tom\", 8900, 23, \"male\", \"New York\"));\n\t\tpersonList.add(new Person(\"Jack\", 7000, 25, \"male\", \"Washington\"));\n\t\tpersonList.add(new Person(\"Lily\", 7800, 21, \"female\", \"Washington\"));\n\t\tpersonList.add(new Person(\"Anni\", 8200, 24, \"female\", \"New York\"));\n\n\t\tMap<?, Person> map = personList.stream().filter(p -> p.getSalary() > 8000)\n\t\t\t\t.collect(Collectors.toMap(Person::getName, p -> p));\n\t\tSystem.out.println(\"toList:\" + listNew);\n\t\tSystem.out.println(\"toSet:\" + set);\n\t\tSystem.out.println(\"toMap:\" + map);\n\t}\n}\n```\n运行结果：\n>toList：[6, 4, 6, 6, 20]\n>\n>toSet：[4, 20, 6]\n>\n>toMap：{Tom=mutest.Person@5fd0d5ae, Anni=mutest.Person@2d98a335}\n#### 统计(count/averaging)\nCollectors提供了一系列用于数据统计的静态方法：\n1. 计数：count\n2. 平均值：averagingInt、averagingLong、averagingDouble\n3. 最值：maxBy、minBy\n4. 求和：summingInt、summingLong、summingDouble\n5. 统计以上所有：summarizingInt、summarizingLong、summarizingDouble\n\n案例：统计员工人数、平均工资、工资总额、最高工资。\n```\npublic class StreamTest {\n\tpublic static void main(String[] args) {\n\t\tList<Person> personList = new ArrayList<Person>();\n\t\tpersonList.add(new Person(\"Tom\", 8900, 23, \"male\", \"New York\"));\n\t\tpersonList.add(new Person(\"Jack\", 7000, 25, \"male\", \"Washington\"));\n\t\tpersonList.add(new Person(\"Lily\", 7800, 21, \"female\", \"Washington\"));\n\n\t\t// 求总数\n\t\tLong count = personList.stream().collect(Collectors.counting());\n\t\t// 求平均工资\n\t\tDouble average = personList.stream().collect(Collectors.averagingDouble(Person::getSalary));\n\t\t// 求最高工资\n\t\tOptional<Integer> max = personList.stream().map(Person::getSalary).collect(Collectors.maxBy(Integer::compare));\n\t\t// 求工资之和\n\t\tInteger sum = personList.stream().collect(Collectors.summingInt(Person::getSalary));\n\t\t// 一次性统计所有信息\n\t\tDoubleSummaryStatistics collect = personList.stream().collect(Collectors.summarizingDouble(Person::getSalary));\n\n\t\tSystem.out.println(\"员工总数：\" + count);\n\t\tSystem.out.println(\"员工平均工资：\" + average);\n\t\tSystem.out.println(\"员工工资总和：\" + sum);\n\t\tSystem.out.println(\"员工工资所有统计：\" + collect);\n\t}\n}\n```\n运行结果：\n>员工总数：3\n>\n>员工平均工资：7900.0\n>\n>员工工资总和：23700\n>\n>员工工资所有统计：DoubleSummaryStatistics{count=3, sum=23700.000000,min=7000.000000, average=7900.000000, max=8900.000000}\n\n#### 分组(partitioningBy/groupingBy)\n1. 分区：将stream按条件分为两个Map，比如员工按薪资是否高于8000分为两部分。\n2. 分组：将集合分为多个Map，比如员工按性别分组。有单级分组和多级分组。\n\n案例：将员工按薪资是否高于8000分为两部分；将员工按性别和地区分组\n```\npublic class StreamTest {\n\tpublic static void main(String[] args) {\n\t\tList<Person> personList = new ArrayList<Person>();\n\t\tpersonList.add(new Person(\"Tom\", 8900, \"male\", \"New York\"));\n\t\tpersonList.add(new Person(\"Jack\", 7000, \"male\", \"Washington\"));\n\t\tpersonList.add(new Person(\"Lily\", 7800, \"female\", \"Washington\"));\n\t\tpersonList.add(new Person(\"Anni\", 8200, \"female\", \"New York\"));\n\t\tpersonList.add(new Person(\"Owen\", 9500, \"male\", \"New York\"));\n\t\tpersonList.add(new Person(\"Alisa\", 7900, \"female\", \"New York\"));\n\n\t\t// 将员工按薪资是否高于8000分组\n        Map<Boolean, List<Person>> part = personList.stream().collect(Collectors.partitioningBy(x -> x.getSalary() > 8000));\n        // 将员工按性别分组\n        Map<String, List<Person>> group = personList.stream().collect(Collectors.groupingBy(Person::getSex));\n        // 将员工先按性别分组，再按地区分组\n        Map<String, Map<String, List<Person>>> group2 = personList.stream().collect(Collectors.groupingBy(Person::getSex, Collectors.groupingBy(Person::getArea)));\n        System.out.println(\"员工按薪资是否大于8000分组情况：\" + part);\n        System.out.println(\"员工按性别分组情况：\" + group);\n        System.out.println(\"员工按性别、地区：\" + group2);\n\t}\n}\n```\n运行结果：\n> 员工按薪资是否大于8000分组情况：{false=[mutest.Person@2d98a335, mutest.Person@16b98e56, mutest.Person@7ef20235], true=[mutest.Person@27d6c5e0, mutest.Person@4f3f5b24, mutest.Person@15aeb7ab]}\n>\n>员工按性别分组情况：{female=[mutest.Person@16b98e56, mutest.Person@4f3f5b24, mutest.Person@7ef20235], male=[mutest.Person@27d6c5e0, mutest.Person@2d98a335, mutest.Person@15aeb7ab]}\n>\n>员工按性别、地区：{female={New York=[mutest.Person@4f3f5b24, mutest.Person@7ef20235], Washington=[mutest.Person@16b98e56]}, male={New York=[mutest.Person@27d6c5e0, mutest.Person@15aeb7ab], Washington=[mutest.Person@2d98a335]}}\n\n#### 接合(joining)\njoining可以将stream中的元素用特定的连接符（没有的话，则直接连接）连接成一个字符串。\n```\npublic class StreamTest {\n\tpublic static void main(String[] args) {\n\t\tList<Person> personList = new ArrayList<Person>();\n\t\tpersonList.add(new Person(\"Tom\", 8900, 23, \"male\", \"New York\"));\n\t\tpersonList.add(new Person(\"Jack\", 7000, 25, \"male\", \"Washington\"));\n\t\tpersonList.add(new Person(\"Lily\", 7800, 21, \"female\", \"Washington\"));\n\n\t\tString names = personList.stream().map(p -> p.getName()).collect(Collectors.joining(\",\"));\n\t\tSystem.out.println(\"所有员工的姓名：\" + names);\n\t\tList<String> list = Arrays.asList(\"A\", \"B\", \"C\");\n\t\tString string = list.stream().collect(Collectors.joining(\"-\"));\n\t\tSystem.out.println(\"拼接后的字符串：\" + string);\n\t}\n}\n```\n运行结果：\n>所有员工的姓名：Tom,Jack,Lily\n>\n>拼接后的字符串：A-B-C\n\n#### 归约(reducing)\nCollectors类提供的reducing方法，相比于stream本身的reduce方法，增加了对自定义归约的支持。\n```\npublic class StreamTest {\n\tpublic static void main(String[] args) {\n\t\tList<Person> personList = new ArrayList<Person>();\n\t\tpersonList.add(new Person(\"Tom\", 8900, 23, \"male\", \"New York\"));\n\t\tpersonList.add(new Person(\"Jack\", 7000, 25, \"male\", \"Washington\"));\n\t\tpersonList.add(new Person(\"Lily\", 7800, 21, \"female\", \"Washington\"));\n\n\t\t// 每个员工减去起征点后的薪资之和（这个例子并不严谨，但一时没想到好的例子）\n\t\tInteger sum = personList.stream().collect(Collectors.reducing(0, Person::getSalary, (i, j) -> (i + j - 5000)));\n\t\tSystem.out.println(\"员工扣税薪资总和：\" + sum);\n\n\t\t// stream的reduce\n\t\tOptional<Integer> sum2 = personList.stream().map(Person::getSalary).reduce(Integer::sum);\n\t\tSystem.out.println(\"员工薪资总和：\" + sum2.get());\n\t}\n}\n```\n运行结果：\n>员工扣税薪资总和：8700\n>\n>员工薪资总和：23700\n\n### 排序(sorted)\nsorted，中间操作。有两种排序：\n1. sorted()：自然排序，流中元素需实现Comparable接口\n2. sorted(Comparator com)：Comparator排序器自定义排序\n\n案例：将员工按工资由高到低（工资一样则按年龄由大到小）排序\n```\npublic class StreamTest {\n\tpublic static void main(String[] args) {\n\t\tList<Person> personList = new ArrayList<Person>();\n\n\t\tpersonList.add(new Person(\"Sherry\", 9000, 24, \"female\", \"New York\"));\n\t\tpersonList.add(new Person(\"Tom\", 8900, 22, \"male\", \"Washington\"));\n\t\tpersonList.add(new Person(\"Jack\", 9000, 25, \"male\", \"Washington\"));\n\t\tpersonList.add(new Person(\"Lily\", 8800, 26, \"male\", \"New York\"));\n\t\tpersonList.add(new Person(\"Alisa\", 9000, 26, \"female\", \"New York\"));\n\n\t\t// 按工资升序排序（自然排序）\n\t\tList<String> newList = personList.stream().sorted(Comparator.comparing(Person::getSalary)).map(Person::getName)\n\t\t\t\t.collect(Collectors.toList());\n\t\t// 按工资倒序排序\n\t\tList<String> newList2 = personList.stream().sorted(Comparator.comparing(Person::getSalary).reversed())\n\t\t\t\t.map(Person::getName).collect(Collectors.toList());\n\t\t// 先按工资再按年龄升序排序\n\t\tList<String> newList3 = personList.stream()\n\t\t\t\t.sorted(Comparator.comparing(Person::getSalary).thenComparing(Person::getAge)).map(Person::getName)\n\t\t\t\t.collect(Collectors.toList());\n\t\t// 先按工资再按年龄自定义排序（降序）\n\t\tList<String> newList4 = personList.stream().sorted((p1, p2) -> {\n\t\t\tif (p1.getSalary() == p2.getSalary()) {\n\t\t\t\treturn p2.getAge() - p1.getAge();\n\t\t\t} else {\n\t\t\t\treturn p2.getSalary() - p1.getSalary();\n\t\t\t}\n\t\t}).map(Person::getName).collect(Collectors.toList());\n\n\t\tSystem.out.println(\"按工资升序排序：\" + newList);\n\t\tSystem.out.println(\"按工资降序排序：\" + newList2);\n\t\tSystem.out.println(\"先按工资再按年龄升序排序：\" + newList3);\n\t\tSystem.out.println(\"先按工资再按年龄自定义降序排序：\" + newList4);\n\t}\n}\n```\n运行结果：\n>按工资升序排序：[Lily, Tom, Sherry, Jack, Alisa]\n>\n>按工资降序排序：[Sherry, Jack, Alisa, Tom, Lily]\n>\n>先按工资再按年龄升序排序：[Lily, Tom, Sherry, Jack, Alisa]\n>\n>先按工资再按年龄自定义降序排序：[Alisa, Jack, Sherry, Tom, Lily]\n\n### 提取/组合\n流也可以进行合并、去重、限制、跳过等操作。\n```\npublic class StreamTest {\n\tpublic static void main(String[] args) {\n\t\tString[] arr1 = { \"a\", \"b\", \"c\", \"d\" };\n\t\tString[] arr2 = { \"d\", \"e\", \"f\", \"g\" };\n\n\t\tStream<String> stream1 = Stream.of(arr1);\n\t\tStream<String> stream2 = Stream.of(arr2);\n\t\t// concat:合并两个流 distinct：去重\n\t\tList<String> newList = Stream.concat(stream1, stream2).distinct().collect(Collectors.toList());\n\t\t// limit：限制从流中获得前n个数据\n\t\tList<Integer> collect = Stream.iterate(1, x -> x + 2).limit(10).collect(Collectors.toList());\n\t\t// skip：跳过前n个数据\n\t\tList<Integer> collect2 = Stream.iterate(1, x -> x + 2).skip(1).limit(5).collect(Collectors.toList());\n\n\t\tSystem.out.println(\"流合并：\" + newList);\n\t\tSystem.out.println(\"limit：\" + collect);\n\t\tSystem.out.println(\"skip：\" + collect2);\n\t}\n}\n```\n运行结果：\n>流合并：[a, b, c, d, e, f, g]\n>\n>limit：[1, 3, 5, 7, 9, 11, 13, 15, 17, 19]\n>\n>skip：[3, 5, 7, 9, 11]\n\n-----\n转载自 https://blog.csdn.net/mu_wind/article/details/109516995\n\n*观点仅代表自己，期待你的留言。*\n","source":"_posts/java8-stream.md","raw":"---\ntitle: Java8 Stream之实例玩转集合的筛选、归约、分组、聚合\ntags:\n  - 转载\ndate: 2021-09-18 11:11:57\n---\n\n## 功能全景\n![Java8Stream全景](/images/java-stream-1.png)\n\n## Stream概述\nJava 8 是一个非常成功的版本，这个版本新增的`Stream`，配合同版本出现的 `Lambda` ，给我们操作集合（Collection）提供了极大的便利。\n\n那么什么是`Stream`？\n> Stream将要处理的元素集合看作一种流，在流的过程中，借助Stream API对流中的元素进行操作，比如：筛选、排序、聚合等。\n\nStream可以由数组或集合创建，对流的操作分为两种：\n1. 中间操作，每次返回一个新的流，可以有多个。\n2. 终端操作，每个流只能进行一次终端操作，终端操作结束后流无法再次使用。终端操作会产生一个新的集合或值。\n\n另外，Stream有几个特性：\n1. stream不存储数据，而是按照特定的规则对数据进行计算，一般会输出结果。\n2. stream不会改变数据源，通常情况下会产生一个新的集合或一个值。\n3. stream具有延迟执行特性，只有调用终端操作时，中间操作才会执行。\n\n## Stream的创建\n### Stream可以通过集合数组创建。\n1. 通过 java.util.Collection.stream()方法用集合创建流\n\n```\nList<String> list = Arrays.asList(\"a\", \"b\", \"c\");\n// 创建一个顺序流\nStream<String> stream = list.stream();\n// 创建一个并行流\nStream<String> parallelStream = list.parallelStream();\n```\n\n2. 使用java.util.Arrays.stream(T[] array)方法用数组创建流\n\n```\nint[] array={1,3,5,6,8};\nIntStream stream = Arrays.stream(array);\n```\n\n3. 使用Stream的静态方法：of()、iterate()、generate()\n\n```\nStream<Integer> stream = Stream.of(1, 2, 3, 4, 5, 6);\n\nStream<Integer> stream2 = Stream.iterate(0, (x) -> x + 3).limit(4);\nstream2.forEach(System.out::println);\n\nStream<Double> stream3 = Stream.generate(Math::random).limit(3);\nstream3.forEach(System.out::println);\n```\n\n**stream和parallelStream的简单区分**\n\nstream是顺序流，由主线程按顺序对流执行操作。\n\nparallelStream是并行流，内部以多线程并行执行的方式对流进行操作，但前提是流中的数据处理没有顺序要求。例如筛选集合中的奇数，两者的处理不同之处：\n\n![stream和parallelStream](/images/java-stream-2.png)\n\n如果流中的数据量足够大，并行流可以加快处速度。\n\n除了直接创建并行流，还可以通过parallel()把顺序流转换成并行流：\n\n```\nOptional<Integer> findFirst = list.stream().parallel().filter(x->x>6).findFirst();\n```\n\n## Stream的使用\n在使用stream之前，先理解一个概念：Optional。\n> Optional类是一个可以为null的容器对象。如果值存在则isPresent()方法会返回true，调用get()方法会返回该对象。 更详细说明请见：菜鸟教程Java 8 Optional类\n\n案例使用的员工类\n\n```\nList<Person> personList = new ArrayList<Person>();\npersonList.add(new Person(\"Tom\", 8900, \"male\", \"New York\"));\npersonList.add(new Person(\"Jack\", 7000, \"male\", \"Washington\"));\npersonList.add(new Person(\"Lily\", 7800, \"female\", \"Washington\"));\npersonList.add(new Person(\"Anni\", 8200, \"female\", \"New York\"));\npersonList.add(new Person(\"Owen\", 9500, \"male\", \"New York\"));\npersonList.add(new Person(\"Alisa\", 7900, \"female\", \"New York\"));\n\nclass Person {\n    private String name;  // 姓名\n    private int salary; // 薪资\n    private int age; // 年龄\n    private String sex; //性别\n    private String area;  // 地区\n\n    // 构造方法\n    public Person(String name, int salary, int age,String sex,String area) {\n        this.name = name;\n        this.salary = salary;\n        this.age = age;\n        this.sex = sex;\n        this.area = area;\n    }\n    // 省略了get和set，请自行添加\n\n}\n```\n\n### 遍历/匹配（foreach/find/match）\nStream也是支持类似集合的遍历和匹配元素的，只是Stream中的元素是以Optional类型存在的。Stream的遍历、匹配非常简单。\n\n```\n// import已省略，请自行添加，后面代码亦是\npublic class StreamTest {\n    public static void main(String[] args) {\n        List<Integer> list = Arrays.asList(7, 6, 9, 3, 8, 2, 1);\n\n        // 遍历输出符合条件的元素\n        list.stream().filter(x -> x > 6).forEach(System.out::println);\n        // 匹配第一个\n        Optional<Integer> findFirst = list.stream().filter(x -> x > 6).findFirst();\n        // 匹配任意（适用于并行流）\n        Optional<Integer> findAny = list.parallelStream().filter(x -> x > 6).findAny();\n        // 是否包含符合特定条件的元素\n        boolean anyMatch = list.stream().anyMatch(x -> x < 6);\n        System.out.println(\"匹配第一个值：\" + findFirst.get());\n        System.out.println(\"匹配任意一个值：\" + findAny.get());\n        System.out.println(\"是否存在大于6的值：\" + anyMatch);\n    }\n}\n```\n\n### 筛选（filter）\n筛选，是按照一定的规则校验流中的元素，将符合条件的元素提取到新的流中的操作。\n- 案例一：筛选出Integer集合中大于7的元素，并打印出来\n```\npublic class StreamTest {\n    public static void main(String[] args) {\n        List<Integer> list = Arrays.asList(6, 7, 3, 8, 1, 2, 9);\n        Stream<Integer> stream = list.stream();\n        stream.filter(x -> x > 7).forEach(System.out::println);\n    }\n}\n```\n运行结果：\n> 8 9\n\n- 案例二： 筛选员工中工资高于8000的人，并形成新的集合。 形成新集合依赖collect（收集），后文有详细介绍。\n```\npublic class StreamTest {\n    public static void main(String[] args) {\n        List<Person> personList = new ArrayList<Person>();\n        personList.add(new Person(\"Tom\", 8900, 23, \"male\", \"New York\"));\n        personList.add(new Person(\"Jack\", 7000, 25, \"male\", \"Washington\"));\n        personList.add(new Person(\"Lily\", 7800, 21, \"female\", \"Washington\"));\n        personList.add(new Person(\"Anni\", 8200, 24, \"female\", \"New York\"));\n        personList.add(new Person(\"Owen\", 9500, 25, \"male\", \"New York\"));\n        personList.add(new Person(\"Alisa\", 7900, 26, \"female\", \"New York\"));\n\n        List<String> fiterList = personList.stream().filter(x -> x.getSalary() > 8000).map(Person::getName)\n                .collect(Collectors.toList());\n        System.out.print(\"高于8000的员工姓名：\" + fiterList);\n    }\n}\n```\n运行结果：\n> 高于8000的员工姓名：[Tom, Anni, Owen]\n\n### 聚合（max/min/count)\nmax、min、count这些字眼你一定不陌生，没错，在mysql中我们常用它们进行数据统计。Java stream中也引入了这些概念和用法，极大地方便了我们对集合、数组的数据统计工作。\n\n- 案例一：获取String集合中最长的元素。\n```\npublic class StreamTest {\n\tpublic static void main(String[] args) {\n\t\tList<String> list = Arrays.asList(\"adnm\", \"admmt\", \"pot\", \"xbangd\", \"weoujgsd\");\n\n\t\tOptional<String> max = list.stream().max(Comparator.comparing(String::length));\n\t\tSystem.out.println(\"最长的字符串：\" + max.get());\n\t}\n}\n```\n运行结果：\n> 最长的字符串：weoujgsd\n\n- 案例二：获取Integer集合中的最大值。\n```\npublic class StreamTest {\n\tpublic static void main(String[] args) {\n\t\tList<Integer> list = Arrays.asList(7, 6, 9, 4, 11, 6);\n\n\t\t// 自然排序\n\t\tOptional<Integer> max = list.stream().max(Integer::compareTo);\n\t\t// 自定义排序\n\t\tOptional<Integer> max2 = list.stream().max(new Comparator<Integer>() {\n\t\t\t@Override\n\t\t\tpublic int compare(Integer o1, Integer o2) {\n\t\t\t\treturn o1.compareTo(o2);\n\t\t\t}\n\t\t});\n\t\tSystem.out.println(\"自然排序的最大值：\" + max.get());\n\t\tSystem.out.println(\"自定义排序的最大值：\" + max2.get());\n\t}\n}\n```\n运行结果：\n> 自然排序的最大值：11\n>\n>自定义排序的最大值：11\n\n- 案例三：获取员工工资最高的人。\n```\npublic class StreamTest {\n\tpublic static void main(String[] args) {\n\t\tList<Person> personList = new ArrayList<Person>();\n\t\tpersonList.add(new Person(\"Tom\", 8900, 23, \"male\", \"New York\"));\n\t\tpersonList.add(new Person(\"Jack\", 7000, 25, \"male\", \"Washington\"));\n\t\tpersonList.add(new Person(\"Lily\", 7800, 21, \"female\", \"Washington\"));\n\t\tpersonList.add(new Person(\"Anni\", 8200, 24, \"female\", \"New York\"));\n\t\tpersonList.add(new Person(\"Owen\", 9500, 25, \"male\", \"New York\"));\n\t\tpersonList.add(new Person(\"Alisa\", 7900, 26, \"female\", \"New York\"));\n\n\t\tOptional<Person> max = personList.stream().max(Comparator.comparingInt(Person::getSalary));\n\t\tSystem.out.println(\"员工工资最大值：\" + max.get().getSalary());\n\t}\n}\n```\n运行结果：\n> 员工工资最大值：9500\n\n- 案例四：计算Integer集合中大于6的元素的个数。\n```\npublic class StreamTest {\n\tpublic static void main(String[] args) {\n\t\tList<Integer> list = Arrays.asList(7, 6, 4, 8, 2, 11, 9);\n\n\t\tlong count = list.stream().filter(x -> x > 6).count();\n\t\tSystem.out.println(\"list中大于6的元素个数：\" + count);\n\t}\n}\n```\n运行结果：\n> list中大于6的元素个数：4\n\n### 映射(map/flatMap)\n映射，可以将一个流的元素按照一定的映射规则映射到另一个流中。分为map和flatMap：\n1. map：接收一个函数作为参数，该函数会被应用到每个元素上，并将其映射成一个新的元素。\n2. flatMap：接收一个函数作为参数，将流中的每个值都换成另一个流，然后把所有流连接成一个流。\n\n- 案例一：英文字符串数组的元素全部改为大写。整数数组每个元素+3。\n```\npublic class StreamTest {\n\tpublic static void main(String[] args) {\n\t\tString[] strArr = { \"abcd\", \"bcdd\", \"defde\", \"fTr\" };\n\t\tList<String> strList = Arrays.stream(strArr).map(String::toUpperCase).collect(Collectors.toList());\n\n\t\tList<Integer> intList = Arrays.asList(1, 3, 5, 7, 9, 11);\n\t\tList<Integer> intListNew = intList.stream().map(x -> x + 3).collect(Collectors.toList());\n\n\t\tSystem.out.println(\"每个元素大写：\" + strList);\n\t\tSystem.out.println(\"每个元素+3：\" + intListNew);\n\t}\n}\n```\n运行结果：\n> 每个元素大写：[ABCD, BCDD, DEFDE, FTR]\n>\n>每个元素+3：[4, 6, 8, 10, 12, 14]\n\n- 案例二：将员工的薪资全部增加1000\n```\npublic class StreamTest {\n\tpublic static void main(String[] args) {\n\t\tList<Person> personList = new ArrayList<Person>();\n\t\tpersonList.add(new Person(\"Tom\", 8900, 23, \"male\", \"New York\"));\n\t\tpersonList.add(new Person(\"Jack\", 7000, 25, \"male\", \"Washington\"));\n\t\tpersonList.add(new Person(\"Lily\", 7800, 21, \"female\", \"Washington\"));\n\t\tpersonList.add(new Person(\"Anni\", 8200, 24, \"female\", \"New York\"));\n\t\tpersonList.add(new Person(\"Owen\", 9500, 25, \"male\", \"New York\"));\n\t\tpersonList.add(new Person(\"Alisa\", 7900, 26, \"female\", \"New York\"));\n\n\t\t// 不改变原来员工集合的方式\n\t\tList<Person> personListNew = personList.stream().map(person -> {\n\t\t\tPerson personNew = new Person(person.getName(), 0, 0, null, null);\n\t\t\tpersonNew.setSalary(person.getSalary() + 10000);\n\t\t\treturn personNew;\n\t\t}).collect(Collectors.toList());\n\t\tSystem.out.println(\"一次改动前：\" + personList.get(0).getName() + \"-->\" + personList.get(0).getSalary());\n\t\tSystem.out.println(\"一次改动后：\" + personListNew.get(0).getName() + \"-->\" + personListNew.get(0).getSalary());\n\n\t\t// 改变原来员工集合的方式\n\t\tList<Person> personListNew2 = personList.stream().map(person -> {\n\t\t\tperson.setSalary(person.getSalary() + 10000);\n\t\t\treturn person;\n\t\t}).collect(Collectors.toList());\n\t\tSystem.out.println(\"二次改动前：\" + personList.get(0).getName() + \"-->\" + personListNew.get(0).getSalary());\n\t\tSystem.out.println(\"二次改动后：\" + personListNew2.get(0).getName() + \"-->\" + personListNew.get(0).getSalary());\n\t}\n}\n```\n运行结果：\n> 一次改动前：Tom–>8900\n>\n>一次改动后：Tom–>18900\n>\n>二次改动前：Tom–>18900\n>\n>二次改动后：Tom–>18900\n\n- 案例三：将两个字符数组合并成一个新的字符数组。\n```\npublic class StreamTest {\n\tpublic static void main(String[] args) {\n\t\tList<String> list = Arrays.asList(\"m,k,l,a\", \"1,3,5,7\");\n\t\tList<String> listNew = list.stream().flatMap(s -> {\n\t\t\t// 将每个元素转换成一个stream\n\t\t\tString[] split = s.split(\",\");\n\t\t\tStream<String> s2 = Arrays.stream(split);\n\t\t\treturn s2;\n\t\t}).collect(Collectors.toList());\n\n\t\tSystem.out.println(\"处理前的集合：\" + list);\n\t\tSystem.out.println(\"处理后的集合：\" + listNew);\n\t}\n}\n```\n运行结果：\n>处理前的集合：[m-k-l-a, 1-3-5]\n>\n>处理后的集合：[m, k, l, a, 1, 3, 5]\n\n### 归约(reduce)\n归约，也称缩减，顾名思义，是把一个流缩减成一个值，能实现对集合求和、求乘积和求最值操作。\n\n- 案例一：求Integer集合的元素之和、乘积和最大值。\n```\npublic class StreamTest {\n\tpublic static void main(String[] args) {\n\t\tList<Integer> list = Arrays.asList(1, 3, 2, 8, 11, 4);\n\t\t// 求和方式1\n\t\tOptional<Integer> sum = list.stream().reduce((x, y) -> x + y);\n\t\t// 求和方式2\n\t\tOptional<Integer> sum2 = list.stream().reduce(Integer::sum);\n\t\t// 求和方式3\n\t\tInteger sum3 = list.stream().reduce(0, Integer::sum);\n\n\t\t// 求乘积\n\t\tOptional<Integer> product = list.stream().reduce((x, y) -> x * y);\n\n\t\t// 求最大值方式1\n\t\tOptional<Integer> max = list.stream().reduce((x, y) -> x > y ? x : y);\n\t\t// 求最大值写法2\n\t\tInteger max2 = list.stream().reduce(1, Integer::max);\n\n\t\tSystem.out.println(\"list求和：\" + sum.get() + \",\" + sum2.get() + \",\" + sum3);\n\t\tSystem.out.println(\"list求积：\" + product.get());\n\t\tSystem.out.println(\"list求和：\" + max.get() + \",\" + max2);\n\t}\n}\n```\n运行结果：\n>list求和：29,29,29\n>\n>list求积：2112\n>\n>list求和：11,11\n\n- 案例二：求所有员工的工资之和和最高工资。\n```\npublic class StreamTest {\n\tpublic static void main(String[] args) {\n\t\tList<Person> personList = new ArrayList<Person>();\n\t\tpersonList.add(new Person(\"Tom\", 8900, 23, \"male\", \"New York\"));\n\t\tpersonList.add(new Person(\"Jack\", 7000, 25, \"male\", \"Washington\"));\n\t\tpersonList.add(new Person(\"Lily\", 7800, 21, \"female\", \"Washington\"));\n\t\tpersonList.add(new Person(\"Anni\", 8200, 24, \"female\", \"New York\"));\n\t\tpersonList.add(new Person(\"Owen\", 9500, 25, \"male\", \"New York\"));\n\t\tpersonList.add(new Person(\"Alisa\", 7900, 26, \"female\", \"New York\"));\n\n\t\t// 求工资之和方式1：\n\t\tOptional<Integer> sumSalary = personList.stream().map(Person::getSalary).reduce(Integer::sum);\n\t\t// 求工资之和方式2：\n\t\tInteger sumSalary2 = personList.stream().reduce(0, (sum, p) -> sum += p.getSalary(),\n\t\t\t\t(sum1, sum2) -> sum1 + sum2);\n\t\t// 求工资之和方式3：\n\t\tInteger sumSalary3 = personList.stream().reduce(0, (sum, p) -> sum += p.getSalary(), Integer::sum);\n\n\t\t// 求最高工资方式1：\n\t\tInteger maxSalary = personList.stream().reduce(0, (max, p) -> max > p.getSalary() ? max : p.getSalary(),\n\t\t\t\tInteger::max);\n\t\t// 求最高工资方式2：\n\t\tInteger maxSalary2 = personList.stream().reduce(0, (max, p) -> max > p.getSalary() ? max : p.getSalary(),\n\t\t\t\t(max1, max2) -> max1 > max2 ? max1 : max2);\n\n\t\tSystem.out.println(\"工资之和：\" + sumSalary.get() + \",\" + sumSalary2 + \",\" + sumSalary3);\n\t\tSystem.out.println(\"最高工资：\" + maxSalary + \",\" + maxSalary2);\n\t}\n}\n```\n运行结果：\n>工资之和：49300,49300,49300\n>\n>最高工资：9500,9500\n\n### 收集(collect)\ncollect，收集，可以说是内容最繁多、功能最丰富的部分了。从字面上去理解，就是把一个流收集起来，最终可以是收集成一个值也可以收集成一个新的集合。\n>collect主要依赖java.util.stream.Collectors类内置的静态方法。\n\n#### 归集(toList/toSet/toMap)\n因为流不存储数据，那么在流中的数据完成处理后，需要将流中的数据重新归集到新的集合里。toList、toSet和toMap比较常用，另外还有toCollection、toConcurrentMap等复杂一些的用法。\n\n下面用一个案例演示toList、toSet和toMap：\n```\npublic class StreamTest {\n\tpublic static void main(String[] args) {\n\t\tList<Integer> list = Arrays.asList(1, 6, 3, 4, 6, 7, 9, 6, 20);\n\t\tList<Integer> listNew = list.stream().filter(x -> x % 2 == 0).collect(Collectors.toList());\n\t\tSet<Integer> set = list.stream().filter(x -> x % 2 == 0).collect(Collectors.toSet());\n\n\t\tList<Person> personList = new ArrayList<Person>();\n\t\tpersonList.add(new Person(\"Tom\", 8900, 23, \"male\", \"New York\"));\n\t\tpersonList.add(new Person(\"Jack\", 7000, 25, \"male\", \"Washington\"));\n\t\tpersonList.add(new Person(\"Lily\", 7800, 21, \"female\", \"Washington\"));\n\t\tpersonList.add(new Person(\"Anni\", 8200, 24, \"female\", \"New York\"));\n\n\t\tMap<?, Person> map = personList.stream().filter(p -> p.getSalary() > 8000)\n\t\t\t\t.collect(Collectors.toMap(Person::getName, p -> p));\n\t\tSystem.out.println(\"toList:\" + listNew);\n\t\tSystem.out.println(\"toSet:\" + set);\n\t\tSystem.out.println(\"toMap:\" + map);\n\t}\n}\n```\n运行结果：\n>toList：[6, 4, 6, 6, 20]\n>\n>toSet：[4, 20, 6]\n>\n>toMap：{Tom=mutest.Person@5fd0d5ae, Anni=mutest.Person@2d98a335}\n#### 统计(count/averaging)\nCollectors提供了一系列用于数据统计的静态方法：\n1. 计数：count\n2. 平均值：averagingInt、averagingLong、averagingDouble\n3. 最值：maxBy、minBy\n4. 求和：summingInt、summingLong、summingDouble\n5. 统计以上所有：summarizingInt、summarizingLong、summarizingDouble\n\n案例：统计员工人数、平均工资、工资总额、最高工资。\n```\npublic class StreamTest {\n\tpublic static void main(String[] args) {\n\t\tList<Person> personList = new ArrayList<Person>();\n\t\tpersonList.add(new Person(\"Tom\", 8900, 23, \"male\", \"New York\"));\n\t\tpersonList.add(new Person(\"Jack\", 7000, 25, \"male\", \"Washington\"));\n\t\tpersonList.add(new Person(\"Lily\", 7800, 21, \"female\", \"Washington\"));\n\n\t\t// 求总数\n\t\tLong count = personList.stream().collect(Collectors.counting());\n\t\t// 求平均工资\n\t\tDouble average = personList.stream().collect(Collectors.averagingDouble(Person::getSalary));\n\t\t// 求最高工资\n\t\tOptional<Integer> max = personList.stream().map(Person::getSalary).collect(Collectors.maxBy(Integer::compare));\n\t\t// 求工资之和\n\t\tInteger sum = personList.stream().collect(Collectors.summingInt(Person::getSalary));\n\t\t// 一次性统计所有信息\n\t\tDoubleSummaryStatistics collect = personList.stream().collect(Collectors.summarizingDouble(Person::getSalary));\n\n\t\tSystem.out.println(\"员工总数：\" + count);\n\t\tSystem.out.println(\"员工平均工资：\" + average);\n\t\tSystem.out.println(\"员工工资总和：\" + sum);\n\t\tSystem.out.println(\"员工工资所有统计：\" + collect);\n\t}\n}\n```\n运行结果：\n>员工总数：3\n>\n>员工平均工资：7900.0\n>\n>员工工资总和：23700\n>\n>员工工资所有统计：DoubleSummaryStatistics{count=3, sum=23700.000000,min=7000.000000, average=7900.000000, max=8900.000000}\n\n#### 分组(partitioningBy/groupingBy)\n1. 分区：将stream按条件分为两个Map，比如员工按薪资是否高于8000分为两部分。\n2. 分组：将集合分为多个Map，比如员工按性别分组。有单级分组和多级分组。\n\n案例：将员工按薪资是否高于8000分为两部分；将员工按性别和地区分组\n```\npublic class StreamTest {\n\tpublic static void main(String[] args) {\n\t\tList<Person> personList = new ArrayList<Person>();\n\t\tpersonList.add(new Person(\"Tom\", 8900, \"male\", \"New York\"));\n\t\tpersonList.add(new Person(\"Jack\", 7000, \"male\", \"Washington\"));\n\t\tpersonList.add(new Person(\"Lily\", 7800, \"female\", \"Washington\"));\n\t\tpersonList.add(new Person(\"Anni\", 8200, \"female\", \"New York\"));\n\t\tpersonList.add(new Person(\"Owen\", 9500, \"male\", \"New York\"));\n\t\tpersonList.add(new Person(\"Alisa\", 7900, \"female\", \"New York\"));\n\n\t\t// 将员工按薪资是否高于8000分组\n        Map<Boolean, List<Person>> part = personList.stream().collect(Collectors.partitioningBy(x -> x.getSalary() > 8000));\n        // 将员工按性别分组\n        Map<String, List<Person>> group = personList.stream().collect(Collectors.groupingBy(Person::getSex));\n        // 将员工先按性别分组，再按地区分组\n        Map<String, Map<String, List<Person>>> group2 = personList.stream().collect(Collectors.groupingBy(Person::getSex, Collectors.groupingBy(Person::getArea)));\n        System.out.println(\"员工按薪资是否大于8000分组情况：\" + part);\n        System.out.println(\"员工按性别分组情况：\" + group);\n        System.out.println(\"员工按性别、地区：\" + group2);\n\t}\n}\n```\n运行结果：\n> 员工按薪资是否大于8000分组情况：{false=[mutest.Person@2d98a335, mutest.Person@16b98e56, mutest.Person@7ef20235], true=[mutest.Person@27d6c5e0, mutest.Person@4f3f5b24, mutest.Person@15aeb7ab]}\n>\n>员工按性别分组情况：{female=[mutest.Person@16b98e56, mutest.Person@4f3f5b24, mutest.Person@7ef20235], male=[mutest.Person@27d6c5e0, mutest.Person@2d98a335, mutest.Person@15aeb7ab]}\n>\n>员工按性别、地区：{female={New York=[mutest.Person@4f3f5b24, mutest.Person@7ef20235], Washington=[mutest.Person@16b98e56]}, male={New York=[mutest.Person@27d6c5e0, mutest.Person@15aeb7ab], Washington=[mutest.Person@2d98a335]}}\n\n#### 接合(joining)\njoining可以将stream中的元素用特定的连接符（没有的话，则直接连接）连接成一个字符串。\n```\npublic class StreamTest {\n\tpublic static void main(String[] args) {\n\t\tList<Person> personList = new ArrayList<Person>();\n\t\tpersonList.add(new Person(\"Tom\", 8900, 23, \"male\", \"New York\"));\n\t\tpersonList.add(new Person(\"Jack\", 7000, 25, \"male\", \"Washington\"));\n\t\tpersonList.add(new Person(\"Lily\", 7800, 21, \"female\", \"Washington\"));\n\n\t\tString names = personList.stream().map(p -> p.getName()).collect(Collectors.joining(\",\"));\n\t\tSystem.out.println(\"所有员工的姓名：\" + names);\n\t\tList<String> list = Arrays.asList(\"A\", \"B\", \"C\");\n\t\tString string = list.stream().collect(Collectors.joining(\"-\"));\n\t\tSystem.out.println(\"拼接后的字符串：\" + string);\n\t}\n}\n```\n运行结果：\n>所有员工的姓名：Tom,Jack,Lily\n>\n>拼接后的字符串：A-B-C\n\n#### 归约(reducing)\nCollectors类提供的reducing方法，相比于stream本身的reduce方法，增加了对自定义归约的支持。\n```\npublic class StreamTest {\n\tpublic static void main(String[] args) {\n\t\tList<Person> personList = new ArrayList<Person>();\n\t\tpersonList.add(new Person(\"Tom\", 8900, 23, \"male\", \"New York\"));\n\t\tpersonList.add(new Person(\"Jack\", 7000, 25, \"male\", \"Washington\"));\n\t\tpersonList.add(new Person(\"Lily\", 7800, 21, \"female\", \"Washington\"));\n\n\t\t// 每个员工减去起征点后的薪资之和（这个例子并不严谨，但一时没想到好的例子）\n\t\tInteger sum = personList.stream().collect(Collectors.reducing(0, Person::getSalary, (i, j) -> (i + j - 5000)));\n\t\tSystem.out.println(\"员工扣税薪资总和：\" + sum);\n\n\t\t// stream的reduce\n\t\tOptional<Integer> sum2 = personList.stream().map(Person::getSalary).reduce(Integer::sum);\n\t\tSystem.out.println(\"员工薪资总和：\" + sum2.get());\n\t}\n}\n```\n运行结果：\n>员工扣税薪资总和：8700\n>\n>员工薪资总和：23700\n\n### 排序(sorted)\nsorted，中间操作。有两种排序：\n1. sorted()：自然排序，流中元素需实现Comparable接口\n2. sorted(Comparator com)：Comparator排序器自定义排序\n\n案例：将员工按工资由高到低（工资一样则按年龄由大到小）排序\n```\npublic class StreamTest {\n\tpublic static void main(String[] args) {\n\t\tList<Person> personList = new ArrayList<Person>();\n\n\t\tpersonList.add(new Person(\"Sherry\", 9000, 24, \"female\", \"New York\"));\n\t\tpersonList.add(new Person(\"Tom\", 8900, 22, \"male\", \"Washington\"));\n\t\tpersonList.add(new Person(\"Jack\", 9000, 25, \"male\", \"Washington\"));\n\t\tpersonList.add(new Person(\"Lily\", 8800, 26, \"male\", \"New York\"));\n\t\tpersonList.add(new Person(\"Alisa\", 9000, 26, \"female\", \"New York\"));\n\n\t\t// 按工资升序排序（自然排序）\n\t\tList<String> newList = personList.stream().sorted(Comparator.comparing(Person::getSalary)).map(Person::getName)\n\t\t\t\t.collect(Collectors.toList());\n\t\t// 按工资倒序排序\n\t\tList<String> newList2 = personList.stream().sorted(Comparator.comparing(Person::getSalary).reversed())\n\t\t\t\t.map(Person::getName).collect(Collectors.toList());\n\t\t// 先按工资再按年龄升序排序\n\t\tList<String> newList3 = personList.stream()\n\t\t\t\t.sorted(Comparator.comparing(Person::getSalary).thenComparing(Person::getAge)).map(Person::getName)\n\t\t\t\t.collect(Collectors.toList());\n\t\t// 先按工资再按年龄自定义排序（降序）\n\t\tList<String> newList4 = personList.stream().sorted((p1, p2) -> {\n\t\t\tif (p1.getSalary() == p2.getSalary()) {\n\t\t\t\treturn p2.getAge() - p1.getAge();\n\t\t\t} else {\n\t\t\t\treturn p2.getSalary() - p1.getSalary();\n\t\t\t}\n\t\t}).map(Person::getName).collect(Collectors.toList());\n\n\t\tSystem.out.println(\"按工资升序排序：\" + newList);\n\t\tSystem.out.println(\"按工资降序排序：\" + newList2);\n\t\tSystem.out.println(\"先按工资再按年龄升序排序：\" + newList3);\n\t\tSystem.out.println(\"先按工资再按年龄自定义降序排序：\" + newList4);\n\t}\n}\n```\n运行结果：\n>按工资升序排序：[Lily, Tom, Sherry, Jack, Alisa]\n>\n>按工资降序排序：[Sherry, Jack, Alisa, Tom, Lily]\n>\n>先按工资再按年龄升序排序：[Lily, Tom, Sherry, Jack, Alisa]\n>\n>先按工资再按年龄自定义降序排序：[Alisa, Jack, Sherry, Tom, Lily]\n\n### 提取/组合\n流也可以进行合并、去重、限制、跳过等操作。\n```\npublic class StreamTest {\n\tpublic static void main(String[] args) {\n\t\tString[] arr1 = { \"a\", \"b\", \"c\", \"d\" };\n\t\tString[] arr2 = { \"d\", \"e\", \"f\", \"g\" };\n\n\t\tStream<String> stream1 = Stream.of(arr1);\n\t\tStream<String> stream2 = Stream.of(arr2);\n\t\t// concat:合并两个流 distinct：去重\n\t\tList<String> newList = Stream.concat(stream1, stream2).distinct().collect(Collectors.toList());\n\t\t// limit：限制从流中获得前n个数据\n\t\tList<Integer> collect = Stream.iterate(1, x -> x + 2).limit(10).collect(Collectors.toList());\n\t\t// skip：跳过前n个数据\n\t\tList<Integer> collect2 = Stream.iterate(1, x -> x + 2).skip(1).limit(5).collect(Collectors.toList());\n\n\t\tSystem.out.println(\"流合并：\" + newList);\n\t\tSystem.out.println(\"limit：\" + collect);\n\t\tSystem.out.println(\"skip：\" + collect2);\n\t}\n}\n```\n运行结果：\n>流合并：[a, b, c, d, e, f, g]\n>\n>limit：[1, 3, 5, 7, 9, 11, 13, 15, 17, 19]\n>\n>skip：[3, 5, 7, 9, 11]\n\n-----\n转载自 https://blog.csdn.net/mu_wind/article/details/109516995\n\n*观点仅代表自己，期待你的留言。*\n","slug":"java8-stream","published":1,"updated":"2021-09-18T05:19:58.729Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cku52dyqj007vbbinci10c030","content":"<h2 id=\"功能全景\"><a href=\"#功能全景\" class=\"headerlink\" title=\"功能全景\"></a>功能全景</h2><p><img src=\"/images/java-stream-1.png\" alt=\"Java8Stream全景\"></p>\n<h2 id=\"Stream概述\"><a href=\"#Stream概述\" class=\"headerlink\" title=\"Stream概述\"></a>Stream概述</h2><p>Java 8 是一个非常成功的版本，这个版本新增的<code>Stream</code>，配合同版本出现的 <code>Lambda</code> ，给我们操作集合（Collection）提供了极大的便利。</p>\n<p>那么什么是<code>Stream</code>？</p>\n<blockquote>\n<p>Stream将要处理的元素集合看作一种流，在流的过程中，借助Stream API对流中的元素进行操作，比如：筛选、排序、聚合等。</p>\n</blockquote>\n<p>Stream可以由数组或集合创建，对流的操作分为两种：</p>\n<ol>\n<li>中间操作，每次返回一个新的流，可以有多个。</li>\n<li>终端操作，每个流只能进行一次终端操作，终端操作结束后流无法再次使用。终端操作会产生一个新的集合或值。</li>\n</ol>\n<p>另外，Stream有几个特性：</p>\n<ol>\n<li>stream不存储数据，而是按照特定的规则对数据进行计算，一般会输出结果。</li>\n<li>stream不会改变数据源，通常情况下会产生一个新的集合或一个值。</li>\n<li>stream具有延迟执行特性，只有调用终端操作时，中间操作才会执行。</li>\n</ol>\n<h2 id=\"Stream的创建\"><a href=\"#Stream的创建\" class=\"headerlink\" title=\"Stream的创建\"></a>Stream的创建</h2><h3 id=\"Stream可以通过集合数组创建。\"><a href=\"#Stream可以通过集合数组创建。\" class=\"headerlink\" title=\"Stream可以通过集合数组创建。\"></a>Stream可以通过集合数组创建。</h3><ol>\n<li>通过 java.util.Collection.stream()方法用集合创建流</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;String&gt; list = Arrays.asList(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;);</span><br><span class=\"line\">// 创建一个顺序流</span><br><span class=\"line\">Stream&lt;String&gt; stream = list.stream();</span><br><span class=\"line\">// 创建一个并行流</span><br><span class=\"line\">Stream&lt;String&gt; parallelStream = list.parallelStream();</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>使用java.util.Arrays.stream(T[] array)方法用数组创建流</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int[] array=&#123;1,3,5,6,8&#125;;</span><br><span class=\"line\">IntStream stream = Arrays.stream(array);</span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li>使用Stream的静态方法：of()、iterate()、generate()</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Stream&lt;Integer&gt; stream = Stream.of(1, 2, 3, 4, 5, 6);</span><br><span class=\"line\"></span><br><span class=\"line\">Stream&lt;Integer&gt; stream2 = Stream.iterate(0, (x) -&gt; x + 3).limit(4);</span><br><span class=\"line\">stream2.forEach(System.out::println);</span><br><span class=\"line\"></span><br><span class=\"line\">Stream&lt;Double&gt; stream3 = Stream.generate(Math::random).limit(3);</span><br><span class=\"line\">stream3.forEach(System.out::println);</span><br></pre></td></tr></table></figure>\n\n<p><strong>stream和parallelStream的简单区分</strong></p>\n<p>stream是顺序流，由主线程按顺序对流执行操作。</p>\n<p>parallelStream是并行流，内部以多线程并行执行的方式对流进行操作，但前提是流中的数据处理没有顺序要求。例如筛选集合中的奇数，两者的处理不同之处：</p>\n<p><img src=\"/images/java-stream-2.png\" alt=\"stream和parallelStream\"></p>\n<p>如果流中的数据量足够大，并行流可以加快处速度。</p>\n<p>除了直接创建并行流，还可以通过parallel()把顺序流转换成并行流：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Optional&lt;Integer&gt; findFirst = list.stream().parallel().filter(x-&gt;x&gt;6).findFirst();</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Stream的使用\"><a href=\"#Stream的使用\" class=\"headerlink\" title=\"Stream的使用\"></a>Stream的使用</h2><p>在使用stream之前，先理解一个概念：Optional。</p>\n<blockquote>\n<p>Optional类是一个可以为null的容器对象。如果值存在则isPresent()方法会返回true，调用get()方法会返回该对象。 更详细说明请见：菜鸟教程Java 8 Optional类</p>\n</blockquote>\n<p>案例使用的员工类</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;Person&gt; personList = new ArrayList&lt;Person&gt;();</span><br><span class=\"line\">personList.add(new Person(&quot;Tom&quot;, 8900, &quot;male&quot;, &quot;New York&quot;));</span><br><span class=\"line\">personList.add(new Person(&quot;Jack&quot;, 7000, &quot;male&quot;, &quot;Washington&quot;));</span><br><span class=\"line\">personList.add(new Person(&quot;Lily&quot;, 7800, &quot;female&quot;, &quot;Washington&quot;));</span><br><span class=\"line\">personList.add(new Person(&quot;Anni&quot;, 8200, &quot;female&quot;, &quot;New York&quot;));</span><br><span class=\"line\">personList.add(new Person(&quot;Owen&quot;, 9500, &quot;male&quot;, &quot;New York&quot;));</span><br><span class=\"line\">personList.add(new Person(&quot;Alisa&quot;, 7900, &quot;female&quot;, &quot;New York&quot;));</span><br><span class=\"line\"></span><br><span class=\"line\">class Person &#123;</span><br><span class=\"line\">    private String name;  // 姓名</span><br><span class=\"line\">    private int salary; // 薪资</span><br><span class=\"line\">    private int age; // 年龄</span><br><span class=\"line\">    private String sex; //性别</span><br><span class=\"line\">    private String area;  // 地区</span><br><span class=\"line\"></span><br><span class=\"line\">    // 构造方法</span><br><span class=\"line\">    public Person(String name, int salary, int age,String sex,String area) &#123;</span><br><span class=\"line\">        this.name = name;</span><br><span class=\"line\">        this.salary = salary;</span><br><span class=\"line\">        this.age = age;</span><br><span class=\"line\">        this.sex = sex;</span><br><span class=\"line\">        this.area = area;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    // 省略了get和set，请自行添加</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"遍历-匹配（foreach-find-match）\"><a href=\"#遍历-匹配（foreach-find-match）\" class=\"headerlink\" title=\"遍历/匹配（foreach/find/match）\"></a>遍历/匹配（foreach/find/match）</h3><p>Stream也是支持类似集合的遍历和匹配元素的，只是Stream中的元素是以Optional类型存在的。Stream的遍历、匹配非常简单。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// import已省略，请自行添加，后面代码亦是</span><br><span class=\"line\">public class StreamTest &#123;</span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        List&lt;Integer&gt; list = Arrays.asList(7, 6, 9, 3, 8, 2, 1);</span><br><span class=\"line\"></span><br><span class=\"line\">        // 遍历输出符合条件的元素</span><br><span class=\"line\">        list.stream().filter(x -&gt; x &gt; 6).forEach(System.out::println);</span><br><span class=\"line\">        // 匹配第一个</span><br><span class=\"line\">        Optional&lt;Integer&gt; findFirst = list.stream().filter(x -&gt; x &gt; 6).findFirst();</span><br><span class=\"line\">        // 匹配任意（适用于并行流）</span><br><span class=\"line\">        Optional&lt;Integer&gt; findAny = list.parallelStream().filter(x -&gt; x &gt; 6).findAny();</span><br><span class=\"line\">        // 是否包含符合特定条件的元素</span><br><span class=\"line\">        boolean anyMatch = list.stream().anyMatch(x -&gt; x &lt; 6);</span><br><span class=\"line\">        System.out.println(&quot;匹配第一个值：&quot; + findFirst.get());</span><br><span class=\"line\">        System.out.println(&quot;匹配任意一个值：&quot; + findAny.get());</span><br><span class=\"line\">        System.out.println(&quot;是否存在大于6的值：&quot; + anyMatch);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"筛选（filter）\"><a href=\"#筛选（filter）\" class=\"headerlink\" title=\"筛选（filter）\"></a>筛选（filter）</h3><p>筛选，是按照一定的规则校验流中的元素，将符合条件的元素提取到新的流中的操作。</p>\n<ul>\n<li><p>案例一：筛选出Integer集合中大于7的元素，并打印出来</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class StreamTest &#123;</span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        List&lt;Integer&gt; list = Arrays.asList(6, 7, 3, 8, 1, 2, 9);</span><br><span class=\"line\">        Stream&lt;Integer&gt; stream = list.stream();</span><br><span class=\"line\">        stream.filter(x -&gt; x &gt; 7).forEach(System.out::println);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>运行结果：</p>\n<blockquote>\n<p>8 9</p>\n</blockquote>\n</li>\n<li><p>案例二： 筛选员工中工资高于8000的人，并形成新的集合。 形成新集合依赖collect（收集），后文有详细介绍。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class StreamTest &#123;</span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        List&lt;Person&gt; personList = new ArrayList&lt;Person&gt;();</span><br><span class=\"line\">        personList.add(new Person(&quot;Tom&quot;, 8900, 23, &quot;male&quot;, &quot;New York&quot;));</span><br><span class=\"line\">        personList.add(new Person(&quot;Jack&quot;, 7000, 25, &quot;male&quot;, &quot;Washington&quot;));</span><br><span class=\"line\">        personList.add(new Person(&quot;Lily&quot;, 7800, 21, &quot;female&quot;, &quot;Washington&quot;));</span><br><span class=\"line\">        personList.add(new Person(&quot;Anni&quot;, 8200, 24, &quot;female&quot;, &quot;New York&quot;));</span><br><span class=\"line\">        personList.add(new Person(&quot;Owen&quot;, 9500, 25, &quot;male&quot;, &quot;New York&quot;));</span><br><span class=\"line\">        personList.add(new Person(&quot;Alisa&quot;, 7900, 26, &quot;female&quot;, &quot;New York&quot;));</span><br><span class=\"line\"></span><br><span class=\"line\">        List&lt;String&gt; fiterList = personList.stream().filter(x -&gt; x.getSalary() &gt; 8000).map(Person::getName)</span><br><span class=\"line\">                .collect(Collectors.toList());</span><br><span class=\"line\">        System.out.print(&quot;高于8000的员工姓名：&quot; + fiterList);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>运行结果：</p>\n<blockquote>\n<p>高于8000的员工姓名：[Tom, Anni, Owen]</p>\n</blockquote>\n</li>\n</ul>\n<h3 id=\"聚合（max-min-count\"><a href=\"#聚合（max-min-count\" class=\"headerlink\" title=\"聚合（max/min/count)\"></a>聚合（max/min/count)</h3><p>max、min、count这些字眼你一定不陌生，没错，在mysql中我们常用它们进行数据统计。Java stream中也引入了这些概念和用法，极大地方便了我们对集合、数组的数据统计工作。</p>\n<ul>\n<li><p>案例一：获取String集合中最长的元素。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class StreamTest &#123;</span><br><span class=\"line\">\tpublic static void main(String[] args) &#123;</span><br><span class=\"line\">\t\tList&lt;String&gt; list = Arrays.asList(&quot;adnm&quot;, &quot;admmt&quot;, &quot;pot&quot;, &quot;xbangd&quot;, &quot;weoujgsd&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tOptional&lt;String&gt; max = list.stream().max(Comparator.comparing(String::length));</span><br><span class=\"line\">\t\tSystem.out.println(&quot;最长的字符串：&quot; + max.get());</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>运行结果：</p>\n<blockquote>\n<p>最长的字符串：weoujgsd</p>\n</blockquote>\n</li>\n<li><p>案例二：获取Integer集合中的最大值。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class StreamTest &#123;</span><br><span class=\"line\">\tpublic static void main(String[] args) &#123;</span><br><span class=\"line\">\t\tList&lt;Integer&gt; list = Arrays.asList(7, 6, 9, 4, 11, 6);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t// 自然排序</span><br><span class=\"line\">\t\tOptional&lt;Integer&gt; max = list.stream().max(Integer::compareTo);</span><br><span class=\"line\">\t\t// 自定义排序</span><br><span class=\"line\">\t\tOptional&lt;Integer&gt; max2 = list.stream().max(new Comparator&lt;Integer&gt;() &#123;</span><br><span class=\"line\">\t\t\t@Override</span><br><span class=\"line\">\t\t\tpublic int compare(Integer o1, Integer o2) &#123;</span><br><span class=\"line\">\t\t\t\treturn o1.compareTo(o2);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;);</span><br><span class=\"line\">\t\tSystem.out.println(&quot;自然排序的最大值：&quot; + max.get());</span><br><span class=\"line\">\t\tSystem.out.println(&quot;自定义排序的最大值：&quot; + max2.get());</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>运行结果：</p>\n<blockquote>\n<p>自然排序的最大值：11</p>\n<p>自定义排序的最大值：11</p>\n</blockquote>\n</li>\n<li><p>案例三：获取员工工资最高的人。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class StreamTest &#123;</span><br><span class=\"line\">\tpublic static void main(String[] args) &#123;</span><br><span class=\"line\">\t\tList&lt;Person&gt; personList = new ArrayList&lt;Person&gt;();</span><br><span class=\"line\">\t\tpersonList.add(new Person(&quot;Tom&quot;, 8900, 23, &quot;male&quot;, &quot;New York&quot;));</span><br><span class=\"line\">\t\tpersonList.add(new Person(&quot;Jack&quot;, 7000, 25, &quot;male&quot;, &quot;Washington&quot;));</span><br><span class=\"line\">\t\tpersonList.add(new Person(&quot;Lily&quot;, 7800, 21, &quot;female&quot;, &quot;Washington&quot;));</span><br><span class=\"line\">\t\tpersonList.add(new Person(&quot;Anni&quot;, 8200, 24, &quot;female&quot;, &quot;New York&quot;));</span><br><span class=\"line\">\t\tpersonList.add(new Person(&quot;Owen&quot;, 9500, 25, &quot;male&quot;, &quot;New York&quot;));</span><br><span class=\"line\">\t\tpersonList.add(new Person(&quot;Alisa&quot;, 7900, 26, &quot;female&quot;, &quot;New York&quot;));</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tOptional&lt;Person&gt; max = personList.stream().max(Comparator.comparingInt(Person::getSalary));</span><br><span class=\"line\">\t\tSystem.out.println(&quot;员工工资最大值：&quot; + max.get().getSalary());</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>运行结果：</p>\n<blockquote>\n<p>员工工资最大值：9500</p>\n</blockquote>\n</li>\n<li><p>案例四：计算Integer集合中大于6的元素的个数。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class StreamTest &#123;</span><br><span class=\"line\">\tpublic static void main(String[] args) &#123;</span><br><span class=\"line\">\t\tList&lt;Integer&gt; list = Arrays.asList(7, 6, 4, 8, 2, 11, 9);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tlong count = list.stream().filter(x -&gt; x &gt; 6).count();</span><br><span class=\"line\">\t\tSystem.out.println(&quot;list中大于6的元素个数：&quot; + count);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>运行结果：</p>\n<blockquote>\n<p>list中大于6的元素个数：4</p>\n</blockquote>\n</li>\n</ul>\n<h3 id=\"映射-map-flatMap\"><a href=\"#映射-map-flatMap\" class=\"headerlink\" title=\"映射(map/flatMap)\"></a>映射(map/flatMap)</h3><p>映射，可以将一个流的元素按照一定的映射规则映射到另一个流中。分为map和flatMap：</p>\n<ol>\n<li>map：接收一个函数作为参数，该函数会被应用到每个元素上，并将其映射成一个新的元素。</li>\n<li>flatMap：接收一个函数作为参数，将流中的每个值都换成另一个流，然后把所有流连接成一个流。</li>\n</ol>\n<ul>\n<li><p>案例一：英文字符串数组的元素全部改为大写。整数数组每个元素+3。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class StreamTest &#123;</span><br><span class=\"line\">\tpublic static void main(String[] args) &#123;</span><br><span class=\"line\">\t\tString[] strArr = &#123; &quot;abcd&quot;, &quot;bcdd&quot;, &quot;defde&quot;, &quot;fTr&quot; &#125;;</span><br><span class=\"line\">\t\tList&lt;String&gt; strList = Arrays.stream(strArr).map(String::toUpperCase).collect(Collectors.toList());</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tList&lt;Integer&gt; intList = Arrays.asList(1, 3, 5, 7, 9, 11);</span><br><span class=\"line\">\t\tList&lt;Integer&gt; intListNew = intList.stream().map(x -&gt; x + 3).collect(Collectors.toList());</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tSystem.out.println(&quot;每个元素大写：&quot; + strList);</span><br><span class=\"line\">\t\tSystem.out.println(&quot;每个元素+3：&quot; + intListNew);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>运行结果：</p>\n<blockquote>\n<p>每个元素大写：[ABCD, BCDD, DEFDE, FTR]</p>\n<p>每个元素+3：[4, 6, 8, 10, 12, 14]</p>\n</blockquote>\n</li>\n<li><p>案例二：将员工的薪资全部增加1000</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class StreamTest &#123;</span><br><span class=\"line\">\tpublic static void main(String[] args) &#123;</span><br><span class=\"line\">\t\tList&lt;Person&gt; personList = new ArrayList&lt;Person&gt;();</span><br><span class=\"line\">\t\tpersonList.add(new Person(&quot;Tom&quot;, 8900, 23, &quot;male&quot;, &quot;New York&quot;));</span><br><span class=\"line\">\t\tpersonList.add(new Person(&quot;Jack&quot;, 7000, 25, &quot;male&quot;, &quot;Washington&quot;));</span><br><span class=\"line\">\t\tpersonList.add(new Person(&quot;Lily&quot;, 7800, 21, &quot;female&quot;, &quot;Washington&quot;));</span><br><span class=\"line\">\t\tpersonList.add(new Person(&quot;Anni&quot;, 8200, 24, &quot;female&quot;, &quot;New York&quot;));</span><br><span class=\"line\">\t\tpersonList.add(new Person(&quot;Owen&quot;, 9500, 25, &quot;male&quot;, &quot;New York&quot;));</span><br><span class=\"line\">\t\tpersonList.add(new Person(&quot;Alisa&quot;, 7900, 26, &quot;female&quot;, &quot;New York&quot;));</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t// 不改变原来员工集合的方式</span><br><span class=\"line\">\t\tList&lt;Person&gt; personListNew = personList.stream().map(person -&gt; &#123;</span><br><span class=\"line\">\t\t\tPerson personNew = new Person(person.getName(), 0, 0, null, null);</span><br><span class=\"line\">\t\t\tpersonNew.setSalary(person.getSalary() + 10000);</span><br><span class=\"line\">\t\t\treturn personNew;</span><br><span class=\"line\">\t\t&#125;).collect(Collectors.toList());</span><br><span class=\"line\">\t\tSystem.out.println(&quot;一次改动前：&quot; + personList.get(0).getName() + &quot;--&gt;&quot; + personList.get(0).getSalary());</span><br><span class=\"line\">\t\tSystem.out.println(&quot;一次改动后：&quot; + personListNew.get(0).getName() + &quot;--&gt;&quot; + personListNew.get(0).getSalary());</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t// 改变原来员工集合的方式</span><br><span class=\"line\">\t\tList&lt;Person&gt; personListNew2 = personList.stream().map(person -&gt; &#123;</span><br><span class=\"line\">\t\t\tperson.setSalary(person.getSalary() + 10000);</span><br><span class=\"line\">\t\t\treturn person;</span><br><span class=\"line\">\t\t&#125;).collect(Collectors.toList());</span><br><span class=\"line\">\t\tSystem.out.println(&quot;二次改动前：&quot; + personList.get(0).getName() + &quot;--&gt;&quot; + personListNew.get(0).getSalary());</span><br><span class=\"line\">\t\tSystem.out.println(&quot;二次改动后：&quot; + personListNew2.get(0).getName() + &quot;--&gt;&quot; + personListNew.get(0).getSalary());</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>运行结果：</p>\n<blockquote>\n<p>一次改动前：Tom–&gt;8900</p>\n<p>一次改动后：Tom–&gt;18900</p>\n<p>二次改动前：Tom–&gt;18900</p>\n<p>二次改动后：Tom–&gt;18900</p>\n</blockquote>\n</li>\n<li><p>案例三：将两个字符数组合并成一个新的字符数组。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class StreamTest &#123;</span><br><span class=\"line\">\tpublic static void main(String[] args) &#123;</span><br><span class=\"line\">\t\tList&lt;String&gt; list = Arrays.asList(&quot;m,k,l,a&quot;, &quot;1,3,5,7&quot;);</span><br><span class=\"line\">\t\tList&lt;String&gt; listNew = list.stream().flatMap(s -&gt; &#123;</span><br><span class=\"line\">\t\t\t// 将每个元素转换成一个stream</span><br><span class=\"line\">\t\t\tString[] split = s.split(&quot;,&quot;);</span><br><span class=\"line\">\t\t\tStream&lt;String&gt; s2 = Arrays.stream(split);</span><br><span class=\"line\">\t\t\treturn s2;</span><br><span class=\"line\">\t\t&#125;).collect(Collectors.toList());</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tSystem.out.println(&quot;处理前的集合：&quot; + list);</span><br><span class=\"line\">\t\tSystem.out.println(&quot;处理后的集合：&quot; + listNew);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>运行结果：</p>\n<blockquote>\n<p>处理前的集合：[m-k-l-a, 1-3-5]</p>\n<p>处理后的集合：[m, k, l, a, 1, 3, 5]</p>\n</blockquote>\n</li>\n</ul>\n<h3 id=\"归约-reduce\"><a href=\"#归约-reduce\" class=\"headerlink\" title=\"归约(reduce)\"></a>归约(reduce)</h3><p>归约，也称缩减，顾名思义，是把一个流缩减成一个值，能实现对集合求和、求乘积和求最值操作。</p>\n<ul>\n<li><p>案例一：求Integer集合的元素之和、乘积和最大值。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class StreamTest &#123;</span><br><span class=\"line\">\tpublic static void main(String[] args) &#123;</span><br><span class=\"line\">\t\tList&lt;Integer&gt; list = Arrays.asList(1, 3, 2, 8, 11, 4);</span><br><span class=\"line\">\t\t// 求和方式1</span><br><span class=\"line\">\t\tOptional&lt;Integer&gt; sum = list.stream().reduce((x, y) -&gt; x + y);</span><br><span class=\"line\">\t\t// 求和方式2</span><br><span class=\"line\">\t\tOptional&lt;Integer&gt; sum2 = list.stream().reduce(Integer::sum);</span><br><span class=\"line\">\t\t// 求和方式3</span><br><span class=\"line\">\t\tInteger sum3 = list.stream().reduce(0, Integer::sum);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t// 求乘积</span><br><span class=\"line\">\t\tOptional&lt;Integer&gt; product = list.stream().reduce((x, y) -&gt; x * y);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t// 求最大值方式1</span><br><span class=\"line\">\t\tOptional&lt;Integer&gt; max = list.stream().reduce((x, y) -&gt; x &gt; y ? x : y);</span><br><span class=\"line\">\t\t// 求最大值写法2</span><br><span class=\"line\">\t\tInteger max2 = list.stream().reduce(1, Integer::max);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tSystem.out.println(&quot;list求和：&quot; + sum.get() + &quot;,&quot; + sum2.get() + &quot;,&quot; + sum3);</span><br><span class=\"line\">\t\tSystem.out.println(&quot;list求积：&quot; + product.get());</span><br><span class=\"line\">\t\tSystem.out.println(&quot;list求和：&quot; + max.get() + &quot;,&quot; + max2);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>运行结果：</p>\n<blockquote>\n<p>list求和：29,29,29</p>\n<p>list求积：2112</p>\n<p>list求和：11,11</p>\n</blockquote>\n</li>\n<li><p>案例二：求所有员工的工资之和和最高工资。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class StreamTest &#123;</span><br><span class=\"line\">\tpublic static void main(String[] args) &#123;</span><br><span class=\"line\">\t\tList&lt;Person&gt; personList = new ArrayList&lt;Person&gt;();</span><br><span class=\"line\">\t\tpersonList.add(new Person(&quot;Tom&quot;, 8900, 23, &quot;male&quot;, &quot;New York&quot;));</span><br><span class=\"line\">\t\tpersonList.add(new Person(&quot;Jack&quot;, 7000, 25, &quot;male&quot;, &quot;Washington&quot;));</span><br><span class=\"line\">\t\tpersonList.add(new Person(&quot;Lily&quot;, 7800, 21, &quot;female&quot;, &quot;Washington&quot;));</span><br><span class=\"line\">\t\tpersonList.add(new Person(&quot;Anni&quot;, 8200, 24, &quot;female&quot;, &quot;New York&quot;));</span><br><span class=\"line\">\t\tpersonList.add(new Person(&quot;Owen&quot;, 9500, 25, &quot;male&quot;, &quot;New York&quot;));</span><br><span class=\"line\">\t\tpersonList.add(new Person(&quot;Alisa&quot;, 7900, 26, &quot;female&quot;, &quot;New York&quot;));</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t// 求工资之和方式1：</span><br><span class=\"line\">\t\tOptional&lt;Integer&gt; sumSalary = personList.stream().map(Person::getSalary).reduce(Integer::sum);</span><br><span class=\"line\">\t\t// 求工资之和方式2：</span><br><span class=\"line\">\t\tInteger sumSalary2 = personList.stream().reduce(0, (sum, p) -&gt; sum += p.getSalary(),</span><br><span class=\"line\">\t\t\t\t(sum1, sum2) -&gt; sum1 + sum2);</span><br><span class=\"line\">\t\t// 求工资之和方式3：</span><br><span class=\"line\">\t\tInteger sumSalary3 = personList.stream().reduce(0, (sum, p) -&gt; sum += p.getSalary(), Integer::sum);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t// 求最高工资方式1：</span><br><span class=\"line\">\t\tInteger maxSalary = personList.stream().reduce(0, (max, p) -&gt; max &gt; p.getSalary() ? max : p.getSalary(),</span><br><span class=\"line\">\t\t\t\tInteger::max);</span><br><span class=\"line\">\t\t// 求最高工资方式2：</span><br><span class=\"line\">\t\tInteger maxSalary2 = personList.stream().reduce(0, (max, p) -&gt; max &gt; p.getSalary() ? max : p.getSalary(),</span><br><span class=\"line\">\t\t\t\t(max1, max2) -&gt; max1 &gt; max2 ? max1 : max2);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tSystem.out.println(&quot;工资之和：&quot; + sumSalary.get() + &quot;,&quot; + sumSalary2 + &quot;,&quot; + sumSalary3);</span><br><span class=\"line\">\t\tSystem.out.println(&quot;最高工资：&quot; + maxSalary + &quot;,&quot; + maxSalary2);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>运行结果：</p>\n<blockquote>\n<p>工资之和：49300,49300,49300</p>\n<p>最高工资：9500,9500</p>\n</blockquote>\n</li>\n</ul>\n<h3 id=\"收集-collect\"><a href=\"#收集-collect\" class=\"headerlink\" title=\"收集(collect)\"></a>收集(collect)</h3><p>collect，收集，可以说是内容最繁多、功能最丰富的部分了。从字面上去理解，就是把一个流收集起来，最终可以是收集成一个值也可以收集成一个新的集合。</p>\n<blockquote>\n<p>collect主要依赖java.util.stream.Collectors类内置的静态方法。</p>\n</blockquote>\n<h4 id=\"归集-toList-toSet-toMap\"><a href=\"#归集-toList-toSet-toMap\" class=\"headerlink\" title=\"归集(toList/toSet/toMap)\"></a>归集(toList/toSet/toMap)</h4><p>因为流不存储数据，那么在流中的数据完成处理后，需要将流中的数据重新归集到新的集合里。toList、toSet和toMap比较常用，另外还有toCollection、toConcurrentMap等复杂一些的用法。</p>\n<p>下面用一个案例演示toList、toSet和toMap：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class StreamTest &#123;</span><br><span class=\"line\">\tpublic static void main(String[] args) &#123;</span><br><span class=\"line\">\t\tList&lt;Integer&gt; list = Arrays.asList(1, 6, 3, 4, 6, 7, 9, 6, 20);</span><br><span class=\"line\">\t\tList&lt;Integer&gt; listNew = list.stream().filter(x -&gt; x % 2 == 0).collect(Collectors.toList());</span><br><span class=\"line\">\t\tSet&lt;Integer&gt; set = list.stream().filter(x -&gt; x % 2 == 0).collect(Collectors.toSet());</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tList&lt;Person&gt; personList = new ArrayList&lt;Person&gt;();</span><br><span class=\"line\">\t\tpersonList.add(new Person(&quot;Tom&quot;, 8900, 23, &quot;male&quot;, &quot;New York&quot;));</span><br><span class=\"line\">\t\tpersonList.add(new Person(&quot;Jack&quot;, 7000, 25, &quot;male&quot;, &quot;Washington&quot;));</span><br><span class=\"line\">\t\tpersonList.add(new Person(&quot;Lily&quot;, 7800, 21, &quot;female&quot;, &quot;Washington&quot;));</span><br><span class=\"line\">\t\tpersonList.add(new Person(&quot;Anni&quot;, 8200, 24, &quot;female&quot;, &quot;New York&quot;));</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tMap&lt;?, Person&gt; map = personList.stream().filter(p -&gt; p.getSalary() &gt; 8000)</span><br><span class=\"line\">\t\t\t\t.collect(Collectors.toMap(Person::getName, p -&gt; p));</span><br><span class=\"line\">\t\tSystem.out.println(&quot;toList:&quot; + listNew);</span><br><span class=\"line\">\t\tSystem.out.println(&quot;toSet:&quot; + set);</span><br><span class=\"line\">\t\tSystem.out.println(&quot;toMap:&quot; + map);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>运行结果：</p>\n<blockquote>\n<p>toList：[6, 4, 6, 6, 20]</p>\n<p>toSet：[4, 20, 6]</p>\n<p>toMap：{Tom=mutest.Person@5fd0d5ae, Anni=mutest.Person@2d98a335}</p>\n</blockquote>\n<h4 id=\"统计-count-averaging\"><a href=\"#统计-count-averaging\" class=\"headerlink\" title=\"统计(count/averaging)\"></a>统计(count/averaging)</h4><p>Collectors提供了一系列用于数据统计的静态方法：</p>\n<ol>\n<li>计数：count</li>\n<li>平均值：averagingInt、averagingLong、averagingDouble</li>\n<li>最值：maxBy、minBy</li>\n<li>求和：summingInt、summingLong、summingDouble</li>\n<li>统计以上所有：summarizingInt、summarizingLong、summarizingDouble</li>\n</ol>\n<p>案例：统计员工人数、平均工资、工资总额、最高工资。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class StreamTest &#123;</span><br><span class=\"line\">\tpublic static void main(String[] args) &#123;</span><br><span class=\"line\">\t\tList&lt;Person&gt; personList = new ArrayList&lt;Person&gt;();</span><br><span class=\"line\">\t\tpersonList.add(new Person(&quot;Tom&quot;, 8900, 23, &quot;male&quot;, &quot;New York&quot;));</span><br><span class=\"line\">\t\tpersonList.add(new Person(&quot;Jack&quot;, 7000, 25, &quot;male&quot;, &quot;Washington&quot;));</span><br><span class=\"line\">\t\tpersonList.add(new Person(&quot;Lily&quot;, 7800, 21, &quot;female&quot;, &quot;Washington&quot;));</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t// 求总数</span><br><span class=\"line\">\t\tLong count = personList.stream().collect(Collectors.counting());</span><br><span class=\"line\">\t\t// 求平均工资</span><br><span class=\"line\">\t\tDouble average = personList.stream().collect(Collectors.averagingDouble(Person::getSalary));</span><br><span class=\"line\">\t\t// 求最高工资</span><br><span class=\"line\">\t\tOptional&lt;Integer&gt; max = personList.stream().map(Person::getSalary).collect(Collectors.maxBy(Integer::compare));</span><br><span class=\"line\">\t\t// 求工资之和</span><br><span class=\"line\">\t\tInteger sum = personList.stream().collect(Collectors.summingInt(Person::getSalary));</span><br><span class=\"line\">\t\t// 一次性统计所有信息</span><br><span class=\"line\">\t\tDoubleSummaryStatistics collect = personList.stream().collect(Collectors.summarizingDouble(Person::getSalary));</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tSystem.out.println(&quot;员工总数：&quot; + count);</span><br><span class=\"line\">\t\tSystem.out.println(&quot;员工平均工资：&quot; + average);</span><br><span class=\"line\">\t\tSystem.out.println(&quot;员工工资总和：&quot; + sum);</span><br><span class=\"line\">\t\tSystem.out.println(&quot;员工工资所有统计：&quot; + collect);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>运行结果：</p>\n<blockquote>\n<p>员工总数：3</p>\n<p>员工平均工资：7900.0</p>\n<p>员工工资总和：23700</p>\n<p>员工工资所有统计：DoubleSummaryStatistics{count=3, sum=23700.000000,min=7000.000000, average=7900.000000, max=8900.000000}</p>\n</blockquote>\n<h4 id=\"分组-partitioningBy-groupingBy\"><a href=\"#分组-partitioningBy-groupingBy\" class=\"headerlink\" title=\"分组(partitioningBy/groupingBy)\"></a>分组(partitioningBy/groupingBy)</h4><ol>\n<li>分区：将stream按条件分为两个Map，比如员工按薪资是否高于8000分为两部分。</li>\n<li>分组：将集合分为多个Map，比如员工按性别分组。有单级分组和多级分组。</li>\n</ol>\n<p>案例：将员工按薪资是否高于8000分为两部分；将员工按性别和地区分组</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class StreamTest &#123;</span><br><span class=\"line\">\tpublic static void main(String[] args) &#123;</span><br><span class=\"line\">\t\tList&lt;Person&gt; personList = new ArrayList&lt;Person&gt;();</span><br><span class=\"line\">\t\tpersonList.add(new Person(&quot;Tom&quot;, 8900, &quot;male&quot;, &quot;New York&quot;));</span><br><span class=\"line\">\t\tpersonList.add(new Person(&quot;Jack&quot;, 7000, &quot;male&quot;, &quot;Washington&quot;));</span><br><span class=\"line\">\t\tpersonList.add(new Person(&quot;Lily&quot;, 7800, &quot;female&quot;, &quot;Washington&quot;));</span><br><span class=\"line\">\t\tpersonList.add(new Person(&quot;Anni&quot;, 8200, &quot;female&quot;, &quot;New York&quot;));</span><br><span class=\"line\">\t\tpersonList.add(new Person(&quot;Owen&quot;, 9500, &quot;male&quot;, &quot;New York&quot;));</span><br><span class=\"line\">\t\tpersonList.add(new Person(&quot;Alisa&quot;, 7900, &quot;female&quot;, &quot;New York&quot;));</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t// 将员工按薪资是否高于8000分组</span><br><span class=\"line\">        Map&lt;Boolean, List&lt;Person&gt;&gt; part = personList.stream().collect(Collectors.partitioningBy(x -&gt; x.getSalary() &gt; 8000));</span><br><span class=\"line\">        // 将员工按性别分组</span><br><span class=\"line\">        Map&lt;String, List&lt;Person&gt;&gt; group = personList.stream().collect(Collectors.groupingBy(Person::getSex));</span><br><span class=\"line\">        // 将员工先按性别分组，再按地区分组</span><br><span class=\"line\">        Map&lt;String, Map&lt;String, List&lt;Person&gt;&gt;&gt; group2 = personList.stream().collect(Collectors.groupingBy(Person::getSex, Collectors.groupingBy(Person::getArea)));</span><br><span class=\"line\">        System.out.println(&quot;员工按薪资是否大于8000分组情况：&quot; + part);</span><br><span class=\"line\">        System.out.println(&quot;员工按性别分组情况：&quot; + group);</span><br><span class=\"line\">        System.out.println(&quot;员工按性别、地区：&quot; + group2);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>运行结果：</p>\n<blockquote>\n<p>员工按薪资是否大于8000分组情况：{false=[mutest.Person@2d98a335, mutest.Person@16b98e56, mutest.Person@7ef20235], true=[mutest.Person@27d6c5e0, mutest.Person@4f3f5b24, mutest.Person@15aeb7ab]}</p>\n<p>员工按性别分组情况：{female=[mutest.Person@16b98e56, mutest.Person@4f3f5b24, mutest.Person@7ef20235], male=[mutest.Person@27d6c5e0, mutest.Person@2d98a335, mutest.Person@15aeb7ab]}</p>\n<p>员工按性别、地区：{female={New York=[mutest.Person@4f3f5b24, mutest.Person@7ef20235], Washington=[mutest.Person@16b98e56]}, male={New York=[mutest.Person@27d6c5e0, mutest.Person@15aeb7ab], Washington=[mutest.Person@2d98a335]}}</p>\n</blockquote>\n<h4 id=\"接合-joining\"><a href=\"#接合-joining\" class=\"headerlink\" title=\"接合(joining)\"></a>接合(joining)</h4><p>joining可以将stream中的元素用特定的连接符（没有的话，则直接连接）连接成一个字符串。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class StreamTest &#123;</span><br><span class=\"line\">\tpublic static void main(String[] args) &#123;</span><br><span class=\"line\">\t\tList&lt;Person&gt; personList = new ArrayList&lt;Person&gt;();</span><br><span class=\"line\">\t\tpersonList.add(new Person(&quot;Tom&quot;, 8900, 23, &quot;male&quot;, &quot;New York&quot;));</span><br><span class=\"line\">\t\tpersonList.add(new Person(&quot;Jack&quot;, 7000, 25, &quot;male&quot;, &quot;Washington&quot;));</span><br><span class=\"line\">\t\tpersonList.add(new Person(&quot;Lily&quot;, 7800, 21, &quot;female&quot;, &quot;Washington&quot;));</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tString names = personList.stream().map(p -&gt; p.getName()).collect(Collectors.joining(&quot;,&quot;));</span><br><span class=\"line\">\t\tSystem.out.println(&quot;所有员工的姓名：&quot; + names);</span><br><span class=\"line\">\t\tList&lt;String&gt; list = Arrays.asList(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;);</span><br><span class=\"line\">\t\tString string = list.stream().collect(Collectors.joining(&quot;-&quot;));</span><br><span class=\"line\">\t\tSystem.out.println(&quot;拼接后的字符串：&quot; + string);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>运行结果：</p>\n<blockquote>\n<p>所有员工的姓名：Tom,Jack,Lily</p>\n<p>拼接后的字符串：A-B-C</p>\n</blockquote>\n<h4 id=\"归约-reducing\"><a href=\"#归约-reducing\" class=\"headerlink\" title=\"归约(reducing)\"></a>归约(reducing)</h4><p>Collectors类提供的reducing方法，相比于stream本身的reduce方法，增加了对自定义归约的支持。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class StreamTest &#123;</span><br><span class=\"line\">\tpublic static void main(String[] args) &#123;</span><br><span class=\"line\">\t\tList&lt;Person&gt; personList = new ArrayList&lt;Person&gt;();</span><br><span class=\"line\">\t\tpersonList.add(new Person(&quot;Tom&quot;, 8900, 23, &quot;male&quot;, &quot;New York&quot;));</span><br><span class=\"line\">\t\tpersonList.add(new Person(&quot;Jack&quot;, 7000, 25, &quot;male&quot;, &quot;Washington&quot;));</span><br><span class=\"line\">\t\tpersonList.add(new Person(&quot;Lily&quot;, 7800, 21, &quot;female&quot;, &quot;Washington&quot;));</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t// 每个员工减去起征点后的薪资之和（这个例子并不严谨，但一时没想到好的例子）</span><br><span class=\"line\">\t\tInteger sum = personList.stream().collect(Collectors.reducing(0, Person::getSalary, (i, j) -&gt; (i + j - 5000)));</span><br><span class=\"line\">\t\tSystem.out.println(&quot;员工扣税薪资总和：&quot; + sum);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t// stream的reduce</span><br><span class=\"line\">\t\tOptional&lt;Integer&gt; sum2 = personList.stream().map(Person::getSalary).reduce(Integer::sum);</span><br><span class=\"line\">\t\tSystem.out.println(&quot;员工薪资总和：&quot; + sum2.get());</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>运行结果：</p>\n<blockquote>\n<p>员工扣税薪资总和：8700</p>\n<p>员工薪资总和：23700</p>\n</blockquote>\n<h3 id=\"排序-sorted\"><a href=\"#排序-sorted\" class=\"headerlink\" title=\"排序(sorted)\"></a>排序(sorted)</h3><p>sorted，中间操作。有两种排序：</p>\n<ol>\n<li>sorted()：自然排序，流中元素需实现Comparable接口</li>\n<li>sorted(Comparator com)：Comparator排序器自定义排序</li>\n</ol>\n<p>案例：将员工按工资由高到低（工资一样则按年龄由大到小）排序</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class StreamTest &#123;</span><br><span class=\"line\">\tpublic static void main(String[] args) &#123;</span><br><span class=\"line\">\t\tList&lt;Person&gt; personList = new ArrayList&lt;Person&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tpersonList.add(new Person(&quot;Sherry&quot;, 9000, 24, &quot;female&quot;, &quot;New York&quot;));</span><br><span class=\"line\">\t\tpersonList.add(new Person(&quot;Tom&quot;, 8900, 22, &quot;male&quot;, &quot;Washington&quot;));</span><br><span class=\"line\">\t\tpersonList.add(new Person(&quot;Jack&quot;, 9000, 25, &quot;male&quot;, &quot;Washington&quot;));</span><br><span class=\"line\">\t\tpersonList.add(new Person(&quot;Lily&quot;, 8800, 26, &quot;male&quot;, &quot;New York&quot;));</span><br><span class=\"line\">\t\tpersonList.add(new Person(&quot;Alisa&quot;, 9000, 26, &quot;female&quot;, &quot;New York&quot;));</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t// 按工资升序排序（自然排序）</span><br><span class=\"line\">\t\tList&lt;String&gt; newList = personList.stream().sorted(Comparator.comparing(Person::getSalary)).map(Person::getName)</span><br><span class=\"line\">\t\t\t\t.collect(Collectors.toList());</span><br><span class=\"line\">\t\t// 按工资倒序排序</span><br><span class=\"line\">\t\tList&lt;String&gt; newList2 = personList.stream().sorted(Comparator.comparing(Person::getSalary).reversed())</span><br><span class=\"line\">\t\t\t\t.map(Person::getName).collect(Collectors.toList());</span><br><span class=\"line\">\t\t// 先按工资再按年龄升序排序</span><br><span class=\"line\">\t\tList&lt;String&gt; newList3 = personList.stream()</span><br><span class=\"line\">\t\t\t\t.sorted(Comparator.comparing(Person::getSalary).thenComparing(Person::getAge)).map(Person::getName)</span><br><span class=\"line\">\t\t\t\t.collect(Collectors.toList());</span><br><span class=\"line\">\t\t// 先按工资再按年龄自定义排序（降序）</span><br><span class=\"line\">\t\tList&lt;String&gt; newList4 = personList.stream().sorted((p1, p2) -&gt; &#123;</span><br><span class=\"line\">\t\t\tif (p1.getSalary() == p2.getSalary()) &#123;</span><br><span class=\"line\">\t\t\t\treturn p2.getAge() - p1.getAge();</span><br><span class=\"line\">\t\t\t&#125; else &#123;</span><br><span class=\"line\">\t\t\t\treturn p2.getSalary() - p1.getSalary();</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;).map(Person::getName).collect(Collectors.toList());</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tSystem.out.println(&quot;按工资升序排序：&quot; + newList);</span><br><span class=\"line\">\t\tSystem.out.println(&quot;按工资降序排序：&quot; + newList2);</span><br><span class=\"line\">\t\tSystem.out.println(&quot;先按工资再按年龄升序排序：&quot; + newList3);</span><br><span class=\"line\">\t\tSystem.out.println(&quot;先按工资再按年龄自定义降序排序：&quot; + newList4);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>运行结果：</p>\n<blockquote>\n<p>按工资升序排序：[Lily, Tom, Sherry, Jack, Alisa]</p>\n<p>按工资降序排序：[Sherry, Jack, Alisa, Tom, Lily]</p>\n<p>先按工资再按年龄升序排序：[Lily, Tom, Sherry, Jack, Alisa]</p>\n<p>先按工资再按年龄自定义降序排序：[Alisa, Jack, Sherry, Tom, Lily]</p>\n</blockquote>\n<h3 id=\"提取-组合\"><a href=\"#提取-组合\" class=\"headerlink\" title=\"提取/组合\"></a>提取/组合</h3><p>流也可以进行合并、去重、限制、跳过等操作。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class StreamTest &#123;</span><br><span class=\"line\">\tpublic static void main(String[] args) &#123;</span><br><span class=\"line\">\t\tString[] arr1 = &#123; &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot; &#125;;</span><br><span class=\"line\">\t\tString[] arr2 = &#123; &quot;d&quot;, &quot;e&quot;, &quot;f&quot;, &quot;g&quot; &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tStream&lt;String&gt; stream1 = Stream.of(arr1);</span><br><span class=\"line\">\t\tStream&lt;String&gt; stream2 = Stream.of(arr2);</span><br><span class=\"line\">\t\t// concat:合并两个流 distinct：去重</span><br><span class=\"line\">\t\tList&lt;String&gt; newList = Stream.concat(stream1, stream2).distinct().collect(Collectors.toList());</span><br><span class=\"line\">\t\t// limit：限制从流中获得前n个数据</span><br><span class=\"line\">\t\tList&lt;Integer&gt; collect = Stream.iterate(1, x -&gt; x + 2).limit(10).collect(Collectors.toList());</span><br><span class=\"line\">\t\t// skip：跳过前n个数据</span><br><span class=\"line\">\t\tList&lt;Integer&gt; collect2 = Stream.iterate(1, x -&gt; x + 2).skip(1).limit(5).collect(Collectors.toList());</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tSystem.out.println(&quot;流合并：&quot; + newList);</span><br><span class=\"line\">\t\tSystem.out.println(&quot;limit：&quot; + collect);</span><br><span class=\"line\">\t\tSystem.out.println(&quot;skip：&quot; + collect2);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>运行结果：</p>\n<blockquote>\n<p>流合并：[a, b, c, d, e, f, g]</p>\n<p>limit：[1, 3, 5, 7, 9, 11, 13, 15, 17, 19]</p>\n<p>skip：[3, 5, 7, 9, 11]</p>\n</blockquote>\n<hr>\n<p>转载自 <a href=\"https://blog.csdn.net/mu_wind/article/details/109516995\">https://blog.csdn.net/mu_wind/article/details/109516995</a></p>\n<p><em>观点仅代表自己，期待你的留言。</em></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"功能全景\"><a href=\"#功能全景\" class=\"headerlink\" title=\"功能全景\"></a>功能全景</h2><p><img src=\"/images/java-stream-1.png\" alt=\"Java8Stream全景\"></p>\n<h2 id=\"Stream概述\"><a href=\"#Stream概述\" class=\"headerlink\" title=\"Stream概述\"></a>Stream概述</h2><p>Java 8 是一个非常成功的版本，这个版本新增的<code>Stream</code>，配合同版本出现的 <code>Lambda</code> ，给我们操作集合（Collection）提供了极大的便利。</p>\n<p>那么什么是<code>Stream</code>？</p>\n<blockquote>\n<p>Stream将要处理的元素集合看作一种流，在流的过程中，借助Stream API对流中的元素进行操作，比如：筛选、排序、聚合等。</p>\n</blockquote>\n<p>Stream可以由数组或集合创建，对流的操作分为两种：</p>\n<ol>\n<li>中间操作，每次返回一个新的流，可以有多个。</li>\n<li>终端操作，每个流只能进行一次终端操作，终端操作结束后流无法再次使用。终端操作会产生一个新的集合或值。</li>\n</ol>\n<p>另外，Stream有几个特性：</p>\n<ol>\n<li>stream不存储数据，而是按照特定的规则对数据进行计算，一般会输出结果。</li>\n<li>stream不会改变数据源，通常情况下会产生一个新的集合或一个值。</li>\n<li>stream具有延迟执行特性，只有调用终端操作时，中间操作才会执行。</li>\n</ol>\n<h2 id=\"Stream的创建\"><a href=\"#Stream的创建\" class=\"headerlink\" title=\"Stream的创建\"></a>Stream的创建</h2><h3 id=\"Stream可以通过集合数组创建。\"><a href=\"#Stream可以通过集合数组创建。\" class=\"headerlink\" title=\"Stream可以通过集合数组创建。\"></a>Stream可以通过集合数组创建。</h3><ol>\n<li>通过 java.util.Collection.stream()方法用集合创建流</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;String&gt; list = Arrays.asList(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;);</span><br><span class=\"line\">// 创建一个顺序流</span><br><span class=\"line\">Stream&lt;String&gt; stream = list.stream();</span><br><span class=\"line\">// 创建一个并行流</span><br><span class=\"line\">Stream&lt;String&gt; parallelStream = list.parallelStream();</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>使用java.util.Arrays.stream(T[] array)方法用数组创建流</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int[] array=&#123;1,3,5,6,8&#125;;</span><br><span class=\"line\">IntStream stream = Arrays.stream(array);</span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li>使用Stream的静态方法：of()、iterate()、generate()</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Stream&lt;Integer&gt; stream = Stream.of(1, 2, 3, 4, 5, 6);</span><br><span class=\"line\"></span><br><span class=\"line\">Stream&lt;Integer&gt; stream2 = Stream.iterate(0, (x) -&gt; x + 3).limit(4);</span><br><span class=\"line\">stream2.forEach(System.out::println);</span><br><span class=\"line\"></span><br><span class=\"line\">Stream&lt;Double&gt; stream3 = Stream.generate(Math::random).limit(3);</span><br><span class=\"line\">stream3.forEach(System.out::println);</span><br></pre></td></tr></table></figure>\n\n<p><strong>stream和parallelStream的简单区分</strong></p>\n<p>stream是顺序流，由主线程按顺序对流执行操作。</p>\n<p>parallelStream是并行流，内部以多线程并行执行的方式对流进行操作，但前提是流中的数据处理没有顺序要求。例如筛选集合中的奇数，两者的处理不同之处：</p>\n<p><img src=\"/images/java-stream-2.png\" alt=\"stream和parallelStream\"></p>\n<p>如果流中的数据量足够大，并行流可以加快处速度。</p>\n<p>除了直接创建并行流，还可以通过parallel()把顺序流转换成并行流：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Optional&lt;Integer&gt; findFirst = list.stream().parallel().filter(x-&gt;x&gt;6).findFirst();</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Stream的使用\"><a href=\"#Stream的使用\" class=\"headerlink\" title=\"Stream的使用\"></a>Stream的使用</h2><p>在使用stream之前，先理解一个概念：Optional。</p>\n<blockquote>\n<p>Optional类是一个可以为null的容器对象。如果值存在则isPresent()方法会返回true，调用get()方法会返回该对象。 更详细说明请见：菜鸟教程Java 8 Optional类</p>\n</blockquote>\n<p>案例使用的员工类</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;Person&gt; personList = new ArrayList&lt;Person&gt;();</span><br><span class=\"line\">personList.add(new Person(&quot;Tom&quot;, 8900, &quot;male&quot;, &quot;New York&quot;));</span><br><span class=\"line\">personList.add(new Person(&quot;Jack&quot;, 7000, &quot;male&quot;, &quot;Washington&quot;));</span><br><span class=\"line\">personList.add(new Person(&quot;Lily&quot;, 7800, &quot;female&quot;, &quot;Washington&quot;));</span><br><span class=\"line\">personList.add(new Person(&quot;Anni&quot;, 8200, &quot;female&quot;, &quot;New York&quot;));</span><br><span class=\"line\">personList.add(new Person(&quot;Owen&quot;, 9500, &quot;male&quot;, &quot;New York&quot;));</span><br><span class=\"line\">personList.add(new Person(&quot;Alisa&quot;, 7900, &quot;female&quot;, &quot;New York&quot;));</span><br><span class=\"line\"></span><br><span class=\"line\">class Person &#123;</span><br><span class=\"line\">    private String name;  // 姓名</span><br><span class=\"line\">    private int salary; // 薪资</span><br><span class=\"line\">    private int age; // 年龄</span><br><span class=\"line\">    private String sex; //性别</span><br><span class=\"line\">    private String area;  // 地区</span><br><span class=\"line\"></span><br><span class=\"line\">    // 构造方法</span><br><span class=\"line\">    public Person(String name, int salary, int age,String sex,String area) &#123;</span><br><span class=\"line\">        this.name = name;</span><br><span class=\"line\">        this.salary = salary;</span><br><span class=\"line\">        this.age = age;</span><br><span class=\"line\">        this.sex = sex;</span><br><span class=\"line\">        this.area = area;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    // 省略了get和set，请自行添加</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"遍历-匹配（foreach-find-match）\"><a href=\"#遍历-匹配（foreach-find-match）\" class=\"headerlink\" title=\"遍历/匹配（foreach/find/match）\"></a>遍历/匹配（foreach/find/match）</h3><p>Stream也是支持类似集合的遍历和匹配元素的，只是Stream中的元素是以Optional类型存在的。Stream的遍历、匹配非常简单。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// import已省略，请自行添加，后面代码亦是</span><br><span class=\"line\">public class StreamTest &#123;</span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        List&lt;Integer&gt; list = Arrays.asList(7, 6, 9, 3, 8, 2, 1);</span><br><span class=\"line\"></span><br><span class=\"line\">        // 遍历输出符合条件的元素</span><br><span class=\"line\">        list.stream().filter(x -&gt; x &gt; 6).forEach(System.out::println);</span><br><span class=\"line\">        // 匹配第一个</span><br><span class=\"line\">        Optional&lt;Integer&gt; findFirst = list.stream().filter(x -&gt; x &gt; 6).findFirst();</span><br><span class=\"line\">        // 匹配任意（适用于并行流）</span><br><span class=\"line\">        Optional&lt;Integer&gt; findAny = list.parallelStream().filter(x -&gt; x &gt; 6).findAny();</span><br><span class=\"line\">        // 是否包含符合特定条件的元素</span><br><span class=\"line\">        boolean anyMatch = list.stream().anyMatch(x -&gt; x &lt; 6);</span><br><span class=\"line\">        System.out.println(&quot;匹配第一个值：&quot; + findFirst.get());</span><br><span class=\"line\">        System.out.println(&quot;匹配任意一个值：&quot; + findAny.get());</span><br><span class=\"line\">        System.out.println(&quot;是否存在大于6的值：&quot; + anyMatch);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"筛选（filter）\"><a href=\"#筛选（filter）\" class=\"headerlink\" title=\"筛选（filter）\"></a>筛选（filter）</h3><p>筛选，是按照一定的规则校验流中的元素，将符合条件的元素提取到新的流中的操作。</p>\n<ul>\n<li><p>案例一：筛选出Integer集合中大于7的元素，并打印出来</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class StreamTest &#123;</span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        List&lt;Integer&gt; list = Arrays.asList(6, 7, 3, 8, 1, 2, 9);</span><br><span class=\"line\">        Stream&lt;Integer&gt; stream = list.stream();</span><br><span class=\"line\">        stream.filter(x -&gt; x &gt; 7).forEach(System.out::println);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>运行结果：</p>\n<blockquote>\n<p>8 9</p>\n</blockquote>\n</li>\n<li><p>案例二： 筛选员工中工资高于8000的人，并形成新的集合。 形成新集合依赖collect（收集），后文有详细介绍。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class StreamTest &#123;</span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        List&lt;Person&gt; personList = new ArrayList&lt;Person&gt;();</span><br><span class=\"line\">        personList.add(new Person(&quot;Tom&quot;, 8900, 23, &quot;male&quot;, &quot;New York&quot;));</span><br><span class=\"line\">        personList.add(new Person(&quot;Jack&quot;, 7000, 25, &quot;male&quot;, &quot;Washington&quot;));</span><br><span class=\"line\">        personList.add(new Person(&quot;Lily&quot;, 7800, 21, &quot;female&quot;, &quot;Washington&quot;));</span><br><span class=\"line\">        personList.add(new Person(&quot;Anni&quot;, 8200, 24, &quot;female&quot;, &quot;New York&quot;));</span><br><span class=\"line\">        personList.add(new Person(&quot;Owen&quot;, 9500, 25, &quot;male&quot;, &quot;New York&quot;));</span><br><span class=\"line\">        personList.add(new Person(&quot;Alisa&quot;, 7900, 26, &quot;female&quot;, &quot;New York&quot;));</span><br><span class=\"line\"></span><br><span class=\"line\">        List&lt;String&gt; fiterList = personList.stream().filter(x -&gt; x.getSalary() &gt; 8000).map(Person::getName)</span><br><span class=\"line\">                .collect(Collectors.toList());</span><br><span class=\"line\">        System.out.print(&quot;高于8000的员工姓名：&quot; + fiterList);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>运行结果：</p>\n<blockquote>\n<p>高于8000的员工姓名：[Tom, Anni, Owen]</p>\n</blockquote>\n</li>\n</ul>\n<h3 id=\"聚合（max-min-count\"><a href=\"#聚合（max-min-count\" class=\"headerlink\" title=\"聚合（max/min/count)\"></a>聚合（max/min/count)</h3><p>max、min、count这些字眼你一定不陌生，没错，在mysql中我们常用它们进行数据统计。Java stream中也引入了这些概念和用法，极大地方便了我们对集合、数组的数据统计工作。</p>\n<ul>\n<li><p>案例一：获取String集合中最长的元素。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class StreamTest &#123;</span><br><span class=\"line\">\tpublic static void main(String[] args) &#123;</span><br><span class=\"line\">\t\tList&lt;String&gt; list = Arrays.asList(&quot;adnm&quot;, &quot;admmt&quot;, &quot;pot&quot;, &quot;xbangd&quot;, &quot;weoujgsd&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tOptional&lt;String&gt; max = list.stream().max(Comparator.comparing(String::length));</span><br><span class=\"line\">\t\tSystem.out.println(&quot;最长的字符串：&quot; + max.get());</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>运行结果：</p>\n<blockquote>\n<p>最长的字符串：weoujgsd</p>\n</blockquote>\n</li>\n<li><p>案例二：获取Integer集合中的最大值。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class StreamTest &#123;</span><br><span class=\"line\">\tpublic static void main(String[] args) &#123;</span><br><span class=\"line\">\t\tList&lt;Integer&gt; list = Arrays.asList(7, 6, 9, 4, 11, 6);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t// 自然排序</span><br><span class=\"line\">\t\tOptional&lt;Integer&gt; max = list.stream().max(Integer::compareTo);</span><br><span class=\"line\">\t\t// 自定义排序</span><br><span class=\"line\">\t\tOptional&lt;Integer&gt; max2 = list.stream().max(new Comparator&lt;Integer&gt;() &#123;</span><br><span class=\"line\">\t\t\t@Override</span><br><span class=\"line\">\t\t\tpublic int compare(Integer o1, Integer o2) &#123;</span><br><span class=\"line\">\t\t\t\treturn o1.compareTo(o2);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;);</span><br><span class=\"line\">\t\tSystem.out.println(&quot;自然排序的最大值：&quot; + max.get());</span><br><span class=\"line\">\t\tSystem.out.println(&quot;自定义排序的最大值：&quot; + max2.get());</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>运行结果：</p>\n<blockquote>\n<p>自然排序的最大值：11</p>\n<p>自定义排序的最大值：11</p>\n</blockquote>\n</li>\n<li><p>案例三：获取员工工资最高的人。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class StreamTest &#123;</span><br><span class=\"line\">\tpublic static void main(String[] args) &#123;</span><br><span class=\"line\">\t\tList&lt;Person&gt; personList = new ArrayList&lt;Person&gt;();</span><br><span class=\"line\">\t\tpersonList.add(new Person(&quot;Tom&quot;, 8900, 23, &quot;male&quot;, &quot;New York&quot;));</span><br><span class=\"line\">\t\tpersonList.add(new Person(&quot;Jack&quot;, 7000, 25, &quot;male&quot;, &quot;Washington&quot;));</span><br><span class=\"line\">\t\tpersonList.add(new Person(&quot;Lily&quot;, 7800, 21, &quot;female&quot;, &quot;Washington&quot;));</span><br><span class=\"line\">\t\tpersonList.add(new Person(&quot;Anni&quot;, 8200, 24, &quot;female&quot;, &quot;New York&quot;));</span><br><span class=\"line\">\t\tpersonList.add(new Person(&quot;Owen&quot;, 9500, 25, &quot;male&quot;, &quot;New York&quot;));</span><br><span class=\"line\">\t\tpersonList.add(new Person(&quot;Alisa&quot;, 7900, 26, &quot;female&quot;, &quot;New York&quot;));</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tOptional&lt;Person&gt; max = personList.stream().max(Comparator.comparingInt(Person::getSalary));</span><br><span class=\"line\">\t\tSystem.out.println(&quot;员工工资最大值：&quot; + max.get().getSalary());</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>运行结果：</p>\n<blockquote>\n<p>员工工资最大值：9500</p>\n</blockquote>\n</li>\n<li><p>案例四：计算Integer集合中大于6的元素的个数。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class StreamTest &#123;</span><br><span class=\"line\">\tpublic static void main(String[] args) &#123;</span><br><span class=\"line\">\t\tList&lt;Integer&gt; list = Arrays.asList(7, 6, 4, 8, 2, 11, 9);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tlong count = list.stream().filter(x -&gt; x &gt; 6).count();</span><br><span class=\"line\">\t\tSystem.out.println(&quot;list中大于6的元素个数：&quot; + count);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>运行结果：</p>\n<blockquote>\n<p>list中大于6的元素个数：4</p>\n</blockquote>\n</li>\n</ul>\n<h3 id=\"映射-map-flatMap\"><a href=\"#映射-map-flatMap\" class=\"headerlink\" title=\"映射(map/flatMap)\"></a>映射(map/flatMap)</h3><p>映射，可以将一个流的元素按照一定的映射规则映射到另一个流中。分为map和flatMap：</p>\n<ol>\n<li>map：接收一个函数作为参数，该函数会被应用到每个元素上，并将其映射成一个新的元素。</li>\n<li>flatMap：接收一个函数作为参数，将流中的每个值都换成另一个流，然后把所有流连接成一个流。</li>\n</ol>\n<ul>\n<li><p>案例一：英文字符串数组的元素全部改为大写。整数数组每个元素+3。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class StreamTest &#123;</span><br><span class=\"line\">\tpublic static void main(String[] args) &#123;</span><br><span class=\"line\">\t\tString[] strArr = &#123; &quot;abcd&quot;, &quot;bcdd&quot;, &quot;defde&quot;, &quot;fTr&quot; &#125;;</span><br><span class=\"line\">\t\tList&lt;String&gt; strList = Arrays.stream(strArr).map(String::toUpperCase).collect(Collectors.toList());</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tList&lt;Integer&gt; intList = Arrays.asList(1, 3, 5, 7, 9, 11);</span><br><span class=\"line\">\t\tList&lt;Integer&gt; intListNew = intList.stream().map(x -&gt; x + 3).collect(Collectors.toList());</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tSystem.out.println(&quot;每个元素大写：&quot; + strList);</span><br><span class=\"line\">\t\tSystem.out.println(&quot;每个元素+3：&quot; + intListNew);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>运行结果：</p>\n<blockquote>\n<p>每个元素大写：[ABCD, BCDD, DEFDE, FTR]</p>\n<p>每个元素+3：[4, 6, 8, 10, 12, 14]</p>\n</blockquote>\n</li>\n<li><p>案例二：将员工的薪资全部增加1000</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class StreamTest &#123;</span><br><span class=\"line\">\tpublic static void main(String[] args) &#123;</span><br><span class=\"line\">\t\tList&lt;Person&gt; personList = new ArrayList&lt;Person&gt;();</span><br><span class=\"line\">\t\tpersonList.add(new Person(&quot;Tom&quot;, 8900, 23, &quot;male&quot;, &quot;New York&quot;));</span><br><span class=\"line\">\t\tpersonList.add(new Person(&quot;Jack&quot;, 7000, 25, &quot;male&quot;, &quot;Washington&quot;));</span><br><span class=\"line\">\t\tpersonList.add(new Person(&quot;Lily&quot;, 7800, 21, &quot;female&quot;, &quot;Washington&quot;));</span><br><span class=\"line\">\t\tpersonList.add(new Person(&quot;Anni&quot;, 8200, 24, &quot;female&quot;, &quot;New York&quot;));</span><br><span class=\"line\">\t\tpersonList.add(new Person(&quot;Owen&quot;, 9500, 25, &quot;male&quot;, &quot;New York&quot;));</span><br><span class=\"line\">\t\tpersonList.add(new Person(&quot;Alisa&quot;, 7900, 26, &quot;female&quot;, &quot;New York&quot;));</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t// 不改变原来员工集合的方式</span><br><span class=\"line\">\t\tList&lt;Person&gt; personListNew = personList.stream().map(person -&gt; &#123;</span><br><span class=\"line\">\t\t\tPerson personNew = new Person(person.getName(), 0, 0, null, null);</span><br><span class=\"line\">\t\t\tpersonNew.setSalary(person.getSalary() + 10000);</span><br><span class=\"line\">\t\t\treturn personNew;</span><br><span class=\"line\">\t\t&#125;).collect(Collectors.toList());</span><br><span class=\"line\">\t\tSystem.out.println(&quot;一次改动前：&quot; + personList.get(0).getName() + &quot;--&gt;&quot; + personList.get(0).getSalary());</span><br><span class=\"line\">\t\tSystem.out.println(&quot;一次改动后：&quot; + personListNew.get(0).getName() + &quot;--&gt;&quot; + personListNew.get(0).getSalary());</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t// 改变原来员工集合的方式</span><br><span class=\"line\">\t\tList&lt;Person&gt; personListNew2 = personList.stream().map(person -&gt; &#123;</span><br><span class=\"line\">\t\t\tperson.setSalary(person.getSalary() + 10000);</span><br><span class=\"line\">\t\t\treturn person;</span><br><span class=\"line\">\t\t&#125;).collect(Collectors.toList());</span><br><span class=\"line\">\t\tSystem.out.println(&quot;二次改动前：&quot; + personList.get(0).getName() + &quot;--&gt;&quot; + personListNew.get(0).getSalary());</span><br><span class=\"line\">\t\tSystem.out.println(&quot;二次改动后：&quot; + personListNew2.get(0).getName() + &quot;--&gt;&quot; + personListNew.get(0).getSalary());</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>运行结果：</p>\n<blockquote>\n<p>一次改动前：Tom–&gt;8900</p>\n<p>一次改动后：Tom–&gt;18900</p>\n<p>二次改动前：Tom–&gt;18900</p>\n<p>二次改动后：Tom–&gt;18900</p>\n</blockquote>\n</li>\n<li><p>案例三：将两个字符数组合并成一个新的字符数组。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class StreamTest &#123;</span><br><span class=\"line\">\tpublic static void main(String[] args) &#123;</span><br><span class=\"line\">\t\tList&lt;String&gt; list = Arrays.asList(&quot;m,k,l,a&quot;, &quot;1,3,5,7&quot;);</span><br><span class=\"line\">\t\tList&lt;String&gt; listNew = list.stream().flatMap(s -&gt; &#123;</span><br><span class=\"line\">\t\t\t// 将每个元素转换成一个stream</span><br><span class=\"line\">\t\t\tString[] split = s.split(&quot;,&quot;);</span><br><span class=\"line\">\t\t\tStream&lt;String&gt; s2 = Arrays.stream(split);</span><br><span class=\"line\">\t\t\treturn s2;</span><br><span class=\"line\">\t\t&#125;).collect(Collectors.toList());</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tSystem.out.println(&quot;处理前的集合：&quot; + list);</span><br><span class=\"line\">\t\tSystem.out.println(&quot;处理后的集合：&quot; + listNew);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>运行结果：</p>\n<blockquote>\n<p>处理前的集合：[m-k-l-a, 1-3-5]</p>\n<p>处理后的集合：[m, k, l, a, 1, 3, 5]</p>\n</blockquote>\n</li>\n</ul>\n<h3 id=\"归约-reduce\"><a href=\"#归约-reduce\" class=\"headerlink\" title=\"归约(reduce)\"></a>归约(reduce)</h3><p>归约，也称缩减，顾名思义，是把一个流缩减成一个值，能实现对集合求和、求乘积和求最值操作。</p>\n<ul>\n<li><p>案例一：求Integer集合的元素之和、乘积和最大值。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class StreamTest &#123;</span><br><span class=\"line\">\tpublic static void main(String[] args) &#123;</span><br><span class=\"line\">\t\tList&lt;Integer&gt; list = Arrays.asList(1, 3, 2, 8, 11, 4);</span><br><span class=\"line\">\t\t// 求和方式1</span><br><span class=\"line\">\t\tOptional&lt;Integer&gt; sum = list.stream().reduce((x, y) -&gt; x + y);</span><br><span class=\"line\">\t\t// 求和方式2</span><br><span class=\"line\">\t\tOptional&lt;Integer&gt; sum2 = list.stream().reduce(Integer::sum);</span><br><span class=\"line\">\t\t// 求和方式3</span><br><span class=\"line\">\t\tInteger sum3 = list.stream().reduce(0, Integer::sum);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t// 求乘积</span><br><span class=\"line\">\t\tOptional&lt;Integer&gt; product = list.stream().reduce((x, y) -&gt; x * y);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t// 求最大值方式1</span><br><span class=\"line\">\t\tOptional&lt;Integer&gt; max = list.stream().reduce((x, y) -&gt; x &gt; y ? x : y);</span><br><span class=\"line\">\t\t// 求最大值写法2</span><br><span class=\"line\">\t\tInteger max2 = list.stream().reduce(1, Integer::max);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tSystem.out.println(&quot;list求和：&quot; + sum.get() + &quot;,&quot; + sum2.get() + &quot;,&quot; + sum3);</span><br><span class=\"line\">\t\tSystem.out.println(&quot;list求积：&quot; + product.get());</span><br><span class=\"line\">\t\tSystem.out.println(&quot;list求和：&quot; + max.get() + &quot;,&quot; + max2);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>运行结果：</p>\n<blockquote>\n<p>list求和：29,29,29</p>\n<p>list求积：2112</p>\n<p>list求和：11,11</p>\n</blockquote>\n</li>\n<li><p>案例二：求所有员工的工资之和和最高工资。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class StreamTest &#123;</span><br><span class=\"line\">\tpublic static void main(String[] args) &#123;</span><br><span class=\"line\">\t\tList&lt;Person&gt; personList = new ArrayList&lt;Person&gt;();</span><br><span class=\"line\">\t\tpersonList.add(new Person(&quot;Tom&quot;, 8900, 23, &quot;male&quot;, &quot;New York&quot;));</span><br><span class=\"line\">\t\tpersonList.add(new Person(&quot;Jack&quot;, 7000, 25, &quot;male&quot;, &quot;Washington&quot;));</span><br><span class=\"line\">\t\tpersonList.add(new Person(&quot;Lily&quot;, 7800, 21, &quot;female&quot;, &quot;Washington&quot;));</span><br><span class=\"line\">\t\tpersonList.add(new Person(&quot;Anni&quot;, 8200, 24, &quot;female&quot;, &quot;New York&quot;));</span><br><span class=\"line\">\t\tpersonList.add(new Person(&quot;Owen&quot;, 9500, 25, &quot;male&quot;, &quot;New York&quot;));</span><br><span class=\"line\">\t\tpersonList.add(new Person(&quot;Alisa&quot;, 7900, 26, &quot;female&quot;, &quot;New York&quot;));</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t// 求工资之和方式1：</span><br><span class=\"line\">\t\tOptional&lt;Integer&gt; sumSalary = personList.stream().map(Person::getSalary).reduce(Integer::sum);</span><br><span class=\"line\">\t\t// 求工资之和方式2：</span><br><span class=\"line\">\t\tInteger sumSalary2 = personList.stream().reduce(0, (sum, p) -&gt; sum += p.getSalary(),</span><br><span class=\"line\">\t\t\t\t(sum1, sum2) -&gt; sum1 + sum2);</span><br><span class=\"line\">\t\t// 求工资之和方式3：</span><br><span class=\"line\">\t\tInteger sumSalary3 = personList.stream().reduce(0, (sum, p) -&gt; sum += p.getSalary(), Integer::sum);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t// 求最高工资方式1：</span><br><span class=\"line\">\t\tInteger maxSalary = personList.stream().reduce(0, (max, p) -&gt; max &gt; p.getSalary() ? max : p.getSalary(),</span><br><span class=\"line\">\t\t\t\tInteger::max);</span><br><span class=\"line\">\t\t// 求最高工资方式2：</span><br><span class=\"line\">\t\tInteger maxSalary2 = personList.stream().reduce(0, (max, p) -&gt; max &gt; p.getSalary() ? max : p.getSalary(),</span><br><span class=\"line\">\t\t\t\t(max1, max2) -&gt; max1 &gt; max2 ? max1 : max2);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tSystem.out.println(&quot;工资之和：&quot; + sumSalary.get() + &quot;,&quot; + sumSalary2 + &quot;,&quot; + sumSalary3);</span><br><span class=\"line\">\t\tSystem.out.println(&quot;最高工资：&quot; + maxSalary + &quot;,&quot; + maxSalary2);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>运行结果：</p>\n<blockquote>\n<p>工资之和：49300,49300,49300</p>\n<p>最高工资：9500,9500</p>\n</blockquote>\n</li>\n</ul>\n<h3 id=\"收集-collect\"><a href=\"#收集-collect\" class=\"headerlink\" title=\"收集(collect)\"></a>收集(collect)</h3><p>collect，收集，可以说是内容最繁多、功能最丰富的部分了。从字面上去理解，就是把一个流收集起来，最终可以是收集成一个值也可以收集成一个新的集合。</p>\n<blockquote>\n<p>collect主要依赖java.util.stream.Collectors类内置的静态方法。</p>\n</blockquote>\n<h4 id=\"归集-toList-toSet-toMap\"><a href=\"#归集-toList-toSet-toMap\" class=\"headerlink\" title=\"归集(toList/toSet/toMap)\"></a>归集(toList/toSet/toMap)</h4><p>因为流不存储数据，那么在流中的数据完成处理后，需要将流中的数据重新归集到新的集合里。toList、toSet和toMap比较常用，另外还有toCollection、toConcurrentMap等复杂一些的用法。</p>\n<p>下面用一个案例演示toList、toSet和toMap：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class StreamTest &#123;</span><br><span class=\"line\">\tpublic static void main(String[] args) &#123;</span><br><span class=\"line\">\t\tList&lt;Integer&gt; list = Arrays.asList(1, 6, 3, 4, 6, 7, 9, 6, 20);</span><br><span class=\"line\">\t\tList&lt;Integer&gt; listNew = list.stream().filter(x -&gt; x % 2 == 0).collect(Collectors.toList());</span><br><span class=\"line\">\t\tSet&lt;Integer&gt; set = list.stream().filter(x -&gt; x % 2 == 0).collect(Collectors.toSet());</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tList&lt;Person&gt; personList = new ArrayList&lt;Person&gt;();</span><br><span class=\"line\">\t\tpersonList.add(new Person(&quot;Tom&quot;, 8900, 23, &quot;male&quot;, &quot;New York&quot;));</span><br><span class=\"line\">\t\tpersonList.add(new Person(&quot;Jack&quot;, 7000, 25, &quot;male&quot;, &quot;Washington&quot;));</span><br><span class=\"line\">\t\tpersonList.add(new Person(&quot;Lily&quot;, 7800, 21, &quot;female&quot;, &quot;Washington&quot;));</span><br><span class=\"line\">\t\tpersonList.add(new Person(&quot;Anni&quot;, 8200, 24, &quot;female&quot;, &quot;New York&quot;));</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tMap&lt;?, Person&gt; map = personList.stream().filter(p -&gt; p.getSalary() &gt; 8000)</span><br><span class=\"line\">\t\t\t\t.collect(Collectors.toMap(Person::getName, p -&gt; p));</span><br><span class=\"line\">\t\tSystem.out.println(&quot;toList:&quot; + listNew);</span><br><span class=\"line\">\t\tSystem.out.println(&quot;toSet:&quot; + set);</span><br><span class=\"line\">\t\tSystem.out.println(&quot;toMap:&quot; + map);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>运行结果：</p>\n<blockquote>\n<p>toList：[6, 4, 6, 6, 20]</p>\n<p>toSet：[4, 20, 6]</p>\n<p>toMap：{Tom=mutest.Person@5fd0d5ae, Anni=mutest.Person@2d98a335}</p>\n</blockquote>\n<h4 id=\"统计-count-averaging\"><a href=\"#统计-count-averaging\" class=\"headerlink\" title=\"统计(count/averaging)\"></a>统计(count/averaging)</h4><p>Collectors提供了一系列用于数据统计的静态方法：</p>\n<ol>\n<li>计数：count</li>\n<li>平均值：averagingInt、averagingLong、averagingDouble</li>\n<li>最值：maxBy、minBy</li>\n<li>求和：summingInt、summingLong、summingDouble</li>\n<li>统计以上所有：summarizingInt、summarizingLong、summarizingDouble</li>\n</ol>\n<p>案例：统计员工人数、平均工资、工资总额、最高工资。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class StreamTest &#123;</span><br><span class=\"line\">\tpublic static void main(String[] args) &#123;</span><br><span class=\"line\">\t\tList&lt;Person&gt; personList = new ArrayList&lt;Person&gt;();</span><br><span class=\"line\">\t\tpersonList.add(new Person(&quot;Tom&quot;, 8900, 23, &quot;male&quot;, &quot;New York&quot;));</span><br><span class=\"line\">\t\tpersonList.add(new Person(&quot;Jack&quot;, 7000, 25, &quot;male&quot;, &quot;Washington&quot;));</span><br><span class=\"line\">\t\tpersonList.add(new Person(&quot;Lily&quot;, 7800, 21, &quot;female&quot;, &quot;Washington&quot;));</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t// 求总数</span><br><span class=\"line\">\t\tLong count = personList.stream().collect(Collectors.counting());</span><br><span class=\"line\">\t\t// 求平均工资</span><br><span class=\"line\">\t\tDouble average = personList.stream().collect(Collectors.averagingDouble(Person::getSalary));</span><br><span class=\"line\">\t\t// 求最高工资</span><br><span class=\"line\">\t\tOptional&lt;Integer&gt; max = personList.stream().map(Person::getSalary).collect(Collectors.maxBy(Integer::compare));</span><br><span class=\"line\">\t\t// 求工资之和</span><br><span class=\"line\">\t\tInteger sum = personList.stream().collect(Collectors.summingInt(Person::getSalary));</span><br><span class=\"line\">\t\t// 一次性统计所有信息</span><br><span class=\"line\">\t\tDoubleSummaryStatistics collect = personList.stream().collect(Collectors.summarizingDouble(Person::getSalary));</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tSystem.out.println(&quot;员工总数：&quot; + count);</span><br><span class=\"line\">\t\tSystem.out.println(&quot;员工平均工资：&quot; + average);</span><br><span class=\"line\">\t\tSystem.out.println(&quot;员工工资总和：&quot; + sum);</span><br><span class=\"line\">\t\tSystem.out.println(&quot;员工工资所有统计：&quot; + collect);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>运行结果：</p>\n<blockquote>\n<p>员工总数：3</p>\n<p>员工平均工资：7900.0</p>\n<p>员工工资总和：23700</p>\n<p>员工工资所有统计：DoubleSummaryStatistics{count=3, sum=23700.000000,min=7000.000000, average=7900.000000, max=8900.000000}</p>\n</blockquote>\n<h4 id=\"分组-partitioningBy-groupingBy\"><a href=\"#分组-partitioningBy-groupingBy\" class=\"headerlink\" title=\"分组(partitioningBy/groupingBy)\"></a>分组(partitioningBy/groupingBy)</h4><ol>\n<li>分区：将stream按条件分为两个Map，比如员工按薪资是否高于8000分为两部分。</li>\n<li>分组：将集合分为多个Map，比如员工按性别分组。有单级分组和多级分组。</li>\n</ol>\n<p>案例：将员工按薪资是否高于8000分为两部分；将员工按性别和地区分组</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class StreamTest &#123;</span><br><span class=\"line\">\tpublic static void main(String[] args) &#123;</span><br><span class=\"line\">\t\tList&lt;Person&gt; personList = new ArrayList&lt;Person&gt;();</span><br><span class=\"line\">\t\tpersonList.add(new Person(&quot;Tom&quot;, 8900, &quot;male&quot;, &quot;New York&quot;));</span><br><span class=\"line\">\t\tpersonList.add(new Person(&quot;Jack&quot;, 7000, &quot;male&quot;, &quot;Washington&quot;));</span><br><span class=\"line\">\t\tpersonList.add(new Person(&quot;Lily&quot;, 7800, &quot;female&quot;, &quot;Washington&quot;));</span><br><span class=\"line\">\t\tpersonList.add(new Person(&quot;Anni&quot;, 8200, &quot;female&quot;, &quot;New York&quot;));</span><br><span class=\"line\">\t\tpersonList.add(new Person(&quot;Owen&quot;, 9500, &quot;male&quot;, &quot;New York&quot;));</span><br><span class=\"line\">\t\tpersonList.add(new Person(&quot;Alisa&quot;, 7900, &quot;female&quot;, &quot;New York&quot;));</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t// 将员工按薪资是否高于8000分组</span><br><span class=\"line\">        Map&lt;Boolean, List&lt;Person&gt;&gt; part = personList.stream().collect(Collectors.partitioningBy(x -&gt; x.getSalary() &gt; 8000));</span><br><span class=\"line\">        // 将员工按性别分组</span><br><span class=\"line\">        Map&lt;String, List&lt;Person&gt;&gt; group = personList.stream().collect(Collectors.groupingBy(Person::getSex));</span><br><span class=\"line\">        // 将员工先按性别分组，再按地区分组</span><br><span class=\"line\">        Map&lt;String, Map&lt;String, List&lt;Person&gt;&gt;&gt; group2 = personList.stream().collect(Collectors.groupingBy(Person::getSex, Collectors.groupingBy(Person::getArea)));</span><br><span class=\"line\">        System.out.println(&quot;员工按薪资是否大于8000分组情况：&quot; + part);</span><br><span class=\"line\">        System.out.println(&quot;员工按性别分组情况：&quot; + group);</span><br><span class=\"line\">        System.out.println(&quot;员工按性别、地区：&quot; + group2);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>运行结果：</p>\n<blockquote>\n<p>员工按薪资是否大于8000分组情况：{false=[mutest.Person@2d98a335, mutest.Person@16b98e56, mutest.Person@7ef20235], true=[mutest.Person@27d6c5e0, mutest.Person@4f3f5b24, mutest.Person@15aeb7ab]}</p>\n<p>员工按性别分组情况：{female=[mutest.Person@16b98e56, mutest.Person@4f3f5b24, mutest.Person@7ef20235], male=[mutest.Person@27d6c5e0, mutest.Person@2d98a335, mutest.Person@15aeb7ab]}</p>\n<p>员工按性别、地区：{female={New York=[mutest.Person@4f3f5b24, mutest.Person@7ef20235], Washington=[mutest.Person@16b98e56]}, male={New York=[mutest.Person@27d6c5e0, mutest.Person@15aeb7ab], Washington=[mutest.Person@2d98a335]}}</p>\n</blockquote>\n<h4 id=\"接合-joining\"><a href=\"#接合-joining\" class=\"headerlink\" title=\"接合(joining)\"></a>接合(joining)</h4><p>joining可以将stream中的元素用特定的连接符（没有的话，则直接连接）连接成一个字符串。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class StreamTest &#123;</span><br><span class=\"line\">\tpublic static void main(String[] args) &#123;</span><br><span class=\"line\">\t\tList&lt;Person&gt; personList = new ArrayList&lt;Person&gt;();</span><br><span class=\"line\">\t\tpersonList.add(new Person(&quot;Tom&quot;, 8900, 23, &quot;male&quot;, &quot;New York&quot;));</span><br><span class=\"line\">\t\tpersonList.add(new Person(&quot;Jack&quot;, 7000, 25, &quot;male&quot;, &quot;Washington&quot;));</span><br><span class=\"line\">\t\tpersonList.add(new Person(&quot;Lily&quot;, 7800, 21, &quot;female&quot;, &quot;Washington&quot;));</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tString names = personList.stream().map(p -&gt; p.getName()).collect(Collectors.joining(&quot;,&quot;));</span><br><span class=\"line\">\t\tSystem.out.println(&quot;所有员工的姓名：&quot; + names);</span><br><span class=\"line\">\t\tList&lt;String&gt; list = Arrays.asList(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;);</span><br><span class=\"line\">\t\tString string = list.stream().collect(Collectors.joining(&quot;-&quot;));</span><br><span class=\"line\">\t\tSystem.out.println(&quot;拼接后的字符串：&quot; + string);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>运行结果：</p>\n<blockquote>\n<p>所有员工的姓名：Tom,Jack,Lily</p>\n<p>拼接后的字符串：A-B-C</p>\n</blockquote>\n<h4 id=\"归约-reducing\"><a href=\"#归约-reducing\" class=\"headerlink\" title=\"归约(reducing)\"></a>归约(reducing)</h4><p>Collectors类提供的reducing方法，相比于stream本身的reduce方法，增加了对自定义归约的支持。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class StreamTest &#123;</span><br><span class=\"line\">\tpublic static void main(String[] args) &#123;</span><br><span class=\"line\">\t\tList&lt;Person&gt; personList = new ArrayList&lt;Person&gt;();</span><br><span class=\"line\">\t\tpersonList.add(new Person(&quot;Tom&quot;, 8900, 23, &quot;male&quot;, &quot;New York&quot;));</span><br><span class=\"line\">\t\tpersonList.add(new Person(&quot;Jack&quot;, 7000, 25, &quot;male&quot;, &quot;Washington&quot;));</span><br><span class=\"line\">\t\tpersonList.add(new Person(&quot;Lily&quot;, 7800, 21, &quot;female&quot;, &quot;Washington&quot;));</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t// 每个员工减去起征点后的薪资之和（这个例子并不严谨，但一时没想到好的例子）</span><br><span class=\"line\">\t\tInteger sum = personList.stream().collect(Collectors.reducing(0, Person::getSalary, (i, j) -&gt; (i + j - 5000)));</span><br><span class=\"line\">\t\tSystem.out.println(&quot;员工扣税薪资总和：&quot; + sum);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t// stream的reduce</span><br><span class=\"line\">\t\tOptional&lt;Integer&gt; sum2 = personList.stream().map(Person::getSalary).reduce(Integer::sum);</span><br><span class=\"line\">\t\tSystem.out.println(&quot;员工薪资总和：&quot; + sum2.get());</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>运行结果：</p>\n<blockquote>\n<p>员工扣税薪资总和：8700</p>\n<p>员工薪资总和：23700</p>\n</blockquote>\n<h3 id=\"排序-sorted\"><a href=\"#排序-sorted\" class=\"headerlink\" title=\"排序(sorted)\"></a>排序(sorted)</h3><p>sorted，中间操作。有两种排序：</p>\n<ol>\n<li>sorted()：自然排序，流中元素需实现Comparable接口</li>\n<li>sorted(Comparator com)：Comparator排序器自定义排序</li>\n</ol>\n<p>案例：将员工按工资由高到低（工资一样则按年龄由大到小）排序</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class StreamTest &#123;</span><br><span class=\"line\">\tpublic static void main(String[] args) &#123;</span><br><span class=\"line\">\t\tList&lt;Person&gt; personList = new ArrayList&lt;Person&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tpersonList.add(new Person(&quot;Sherry&quot;, 9000, 24, &quot;female&quot;, &quot;New York&quot;));</span><br><span class=\"line\">\t\tpersonList.add(new Person(&quot;Tom&quot;, 8900, 22, &quot;male&quot;, &quot;Washington&quot;));</span><br><span class=\"line\">\t\tpersonList.add(new Person(&quot;Jack&quot;, 9000, 25, &quot;male&quot;, &quot;Washington&quot;));</span><br><span class=\"line\">\t\tpersonList.add(new Person(&quot;Lily&quot;, 8800, 26, &quot;male&quot;, &quot;New York&quot;));</span><br><span class=\"line\">\t\tpersonList.add(new Person(&quot;Alisa&quot;, 9000, 26, &quot;female&quot;, &quot;New York&quot;));</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t// 按工资升序排序（自然排序）</span><br><span class=\"line\">\t\tList&lt;String&gt; newList = personList.stream().sorted(Comparator.comparing(Person::getSalary)).map(Person::getName)</span><br><span class=\"line\">\t\t\t\t.collect(Collectors.toList());</span><br><span class=\"line\">\t\t// 按工资倒序排序</span><br><span class=\"line\">\t\tList&lt;String&gt; newList2 = personList.stream().sorted(Comparator.comparing(Person::getSalary).reversed())</span><br><span class=\"line\">\t\t\t\t.map(Person::getName).collect(Collectors.toList());</span><br><span class=\"line\">\t\t// 先按工资再按年龄升序排序</span><br><span class=\"line\">\t\tList&lt;String&gt; newList3 = personList.stream()</span><br><span class=\"line\">\t\t\t\t.sorted(Comparator.comparing(Person::getSalary).thenComparing(Person::getAge)).map(Person::getName)</span><br><span class=\"line\">\t\t\t\t.collect(Collectors.toList());</span><br><span class=\"line\">\t\t// 先按工资再按年龄自定义排序（降序）</span><br><span class=\"line\">\t\tList&lt;String&gt; newList4 = personList.stream().sorted((p1, p2) -&gt; &#123;</span><br><span class=\"line\">\t\t\tif (p1.getSalary() == p2.getSalary()) &#123;</span><br><span class=\"line\">\t\t\t\treturn p2.getAge() - p1.getAge();</span><br><span class=\"line\">\t\t\t&#125; else &#123;</span><br><span class=\"line\">\t\t\t\treturn p2.getSalary() - p1.getSalary();</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;).map(Person::getName).collect(Collectors.toList());</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tSystem.out.println(&quot;按工资升序排序：&quot; + newList);</span><br><span class=\"line\">\t\tSystem.out.println(&quot;按工资降序排序：&quot; + newList2);</span><br><span class=\"line\">\t\tSystem.out.println(&quot;先按工资再按年龄升序排序：&quot; + newList3);</span><br><span class=\"line\">\t\tSystem.out.println(&quot;先按工资再按年龄自定义降序排序：&quot; + newList4);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>运行结果：</p>\n<blockquote>\n<p>按工资升序排序：[Lily, Tom, Sherry, Jack, Alisa]</p>\n<p>按工资降序排序：[Sherry, Jack, Alisa, Tom, Lily]</p>\n<p>先按工资再按年龄升序排序：[Lily, Tom, Sherry, Jack, Alisa]</p>\n<p>先按工资再按年龄自定义降序排序：[Alisa, Jack, Sherry, Tom, Lily]</p>\n</blockquote>\n<h3 id=\"提取-组合\"><a href=\"#提取-组合\" class=\"headerlink\" title=\"提取/组合\"></a>提取/组合</h3><p>流也可以进行合并、去重、限制、跳过等操作。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class StreamTest &#123;</span><br><span class=\"line\">\tpublic static void main(String[] args) &#123;</span><br><span class=\"line\">\t\tString[] arr1 = &#123; &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot; &#125;;</span><br><span class=\"line\">\t\tString[] arr2 = &#123; &quot;d&quot;, &quot;e&quot;, &quot;f&quot;, &quot;g&quot; &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tStream&lt;String&gt; stream1 = Stream.of(arr1);</span><br><span class=\"line\">\t\tStream&lt;String&gt; stream2 = Stream.of(arr2);</span><br><span class=\"line\">\t\t// concat:合并两个流 distinct：去重</span><br><span class=\"line\">\t\tList&lt;String&gt; newList = Stream.concat(stream1, stream2).distinct().collect(Collectors.toList());</span><br><span class=\"line\">\t\t// limit：限制从流中获得前n个数据</span><br><span class=\"line\">\t\tList&lt;Integer&gt; collect = Stream.iterate(1, x -&gt; x + 2).limit(10).collect(Collectors.toList());</span><br><span class=\"line\">\t\t// skip：跳过前n个数据</span><br><span class=\"line\">\t\tList&lt;Integer&gt; collect2 = Stream.iterate(1, x -&gt; x + 2).skip(1).limit(5).collect(Collectors.toList());</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tSystem.out.println(&quot;流合并：&quot; + newList);</span><br><span class=\"line\">\t\tSystem.out.println(&quot;limit：&quot; + collect);</span><br><span class=\"line\">\t\tSystem.out.println(&quot;skip：&quot; + collect2);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>运行结果：</p>\n<blockquote>\n<p>流合并：[a, b, c, d, e, f, g]</p>\n<p>limit：[1, 3, 5, 7, 9, 11, 13, 15, 17, 19]</p>\n<p>skip：[3, 5, 7, 9, 11]</p>\n</blockquote>\n<hr>\n<p>转载自 <a href=\"https://blog.csdn.net/mu_wind/article/details/109516995\">https://blog.csdn.net/mu_wind/article/details/109516995</a></p>\n<p><em>观点仅代表自己，期待你的留言。</em></p>\n"}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"cku52dyl70001bbin8ydgclb6","tag_id":"cku52dyli0003bbin628f2mn2","_id":"cku52dylw0008bbinekiug0sf"},{"post_id":"cku52dyll0006bbin4qrp6zam","tag_id":"cku52dyli0003bbin628f2mn2","_id":"cku52dylx000abbin60x5by1b"},{"post_id":"cku52dylw0009bbincqkw2dcc","tag_id":"cku52dyli0003bbin628f2mn2","_id":"cku52dym0000dbbin7zkcgn7y"},{"post_id":"cku52dylx000bbbin1qm6b8j8","tag_id":"cku52dyli0003bbin628f2mn2","_id":"cku52dym2000fbbin1klb6dc1"},{"post_id":"cku52dym1000ebbingxa842qa","tag_id":"cku52dyli0003bbin628f2mn2","_id":"cku52dym3000ibbin60r4g437"},{"post_id":"cku52dylg0002bbin5frm82zd","tag_id":"cku52dyli0003bbin628f2mn2","_id":"cku52dym4000kbbin1han8a8c"},{"post_id":"cku52dylg0002bbin5frm82zd","tag_id":"cku52dym0000cbbin4jwb0rmi","_id":"cku52dym6000nbbingl059vy3"},{"post_id":"cku52dym2000gbbin2w4j6yql","tag_id":"cku52dyli0003bbin628f2mn2","_id":"cku52dym9000pbbin8eru6iif"},{"post_id":"cku52dylj0004bbinb4g81nkn","tag_id":"cku52dyli0003bbin628f2mn2","_id":"cku52dymb000sbbin3fs9c665"},{"post_id":"cku52dym4000lbbin7nat5qlb","tag_id":"cku52dym0000cbbin4jwb0rmi","_id":"cku52dymc000ubbin2kqdbowq"},{"post_id":"cku52dym6000obbinb177a6k4","tag_id":"cku52dyli0003bbin628f2mn2","_id":"cku52dyme000wbbin2ymzgpbd"},{"post_id":"cku52dylk0005bbineygdhgkv","tag_id":"cku52dyli0003bbin628f2mn2","_id":"cku52dymf000zbbinfaudb4w1"},{"post_id":"cku52dylk0005bbineygdhgkv","tag_id":"cku52dym5000mbbincj6a4lqi","_id":"cku52dymf0011bbin60b21iwa"},{"post_id":"cku52dym9000qbbinew9rh8pk","tag_id":"cku52dyli0003bbin628f2mn2","_id":"cku52dymg0013bbin92w721dd"},{"post_id":"cku52dymb000tbbin6u3b5rlq","tag_id":"cku52dyli0003bbin628f2mn2","_id":"cku52dymh0016bbinflvr77su"},{"post_id":"cku52dymb000tbbin6u3b5rlq","tag_id":"cku52dym5000mbbincj6a4lqi","_id":"cku52dymi0018bbin2xmheo6q"},{"post_id":"cku52dym3000jbbin0842aban","tag_id":"cku52dyli0003bbin628f2mn2","_id":"cku52dymj001bbbin0q067zgh"},{"post_id":"cku52dym3000jbbin0842aban","tag_id":"cku52dyma000rbbinh68g434s","_id":"cku52dymu001dbbin6h80bmkj"},{"post_id":"cku52dymc000vbbin6qde15v7","tag_id":"cku52dyli0003bbin628f2mn2","_id":"cku52dymv001gbbin8n1u8kh0"},{"post_id":"cku52dymc000vbbin6qde15v7","tag_id":"cku52dyme000ybbin5rpu3uit","_id":"cku52dymw001ibbin27c83vze"},{"post_id":"cku52dyme000xbbinah0e3b17","tag_id":"cku52dymh0015bbinad4r31xd","_id":"cku52dymx001lbbin7hkch6u4"},{"post_id":"cku52dyme000xbbinah0e3b17","tag_id":"cku52dyli0003bbin628f2mn2","_id":"cku52dymy001nbbincijybvy7"},{"post_id":"cku52dymi0019bbin0b566tcv","tag_id":"cku52dyli0003bbin628f2mn2","_id":"cku52dymz001qbbin49pjb1h8"},{"post_id":"cku52dymf0010bbin7egu9vff","tag_id":"cku52dymh0015bbinad4r31xd","_id":"cku52dyn0001sbbinat812ede"},{"post_id":"cku52dymf0010bbin7egu9vff","tag_id":"cku52dyli0003bbin628f2mn2","_id":"cku52dyn1001vbbinbvc66lsb"},{"post_id":"cku52dymu001ebbinbogecn5q","tag_id":"cku52dyli0003bbin628f2mn2","_id":"cku52dyn2001xbbindrcggya1"},{"post_id":"cku52dymv001hbbin1c0v1am6","tag_id":"cku52dyli0003bbin628f2mn2","_id":"cku52dyn60020bbinbhb1erby"},{"post_id":"cku52dymg0012bbineyb9fp1o","tag_id":"cku52dymh0015bbinad4r31xd","_id":"cku52dyn80022bbin88p803ln"},{"post_id":"cku52dymg0012bbineyb9fp1o","tag_id":"cku52dym0000cbbin4jwb0rmi","_id":"cku52dyna0024bbincf597ikz"},{"post_id":"cku52dymx001mbbincihz0n73","tag_id":"cku52dyli0003bbin628f2mn2","_id":"cku52dynb0027bbinekgk1mom"},{"post_id":"cku52dymg0014bbinea6nhs91","tag_id":"cku52dymh0015bbinad4r31xd","_id":"cku52dynb0029bbin5h9h45iy"},{"post_id":"cku52dymg0014bbinea6nhs91","tag_id":"cku52dyli0003bbin628f2mn2","_id":"cku52dync002cbbinfjk6d4ye"},{"post_id":"cku52dymh0017bbin00au8z3q","tag_id":"cku52dyli0003bbin628f2mn2","_id":"cku52dynd002ebbin1505d6om"},{"post_id":"cku52dymh0017bbin00au8z3q","tag_id":"cku52dymz001pbbinbb8y1p18","_id":"cku52dynf002hbbinfe3aauw8"},{"post_id":"cku52dymj001cbbin023qh89d","tag_id":"cku52dyli0003bbin628f2mn2","_id":"cku52dyng002jbbindjpw5yv3"},{"post_id":"cku52dymj001cbbin023qh89d","tag_id":"cku52dyn1001ubbin6adv3m7c","_id":"cku52dynh002mbbinbdrv14u5"},{"post_id":"cku52dymj001cbbin023qh89d","tag_id":"cku52dyn3001zbbinbfq9eth8","_id":"cku52dyni002obbinah9l58j6"},{"post_id":"cku52dynb0028bbin3ue92lfm","tag_id":"cku52dyli0003bbin628f2mn2","_id":"cku52dynj002rbbin4wae8kpe"},{"post_id":"cku52dymw001jbbinec2hhiyy","tag_id":"cku52dyli0003bbin628f2mn2","_id":"cku52dyno002tbbingd858cst"},{"post_id":"cku52dymw001jbbinec2hhiyy","tag_id":"cku52dyna0026bbin36627r8b","_id":"cku52dynq002wbbin7x64cz4o"},{"post_id":"cku52dync002abbin1dd1gu6e","tag_id":"cku52dyli0003bbin628f2mn2","_id":"cku52dynr002ybbindbcs84q4"},{"post_id":"cku52dynd002dbbinhxvwa8t3","tag_id":"cku52dyli0003bbin628f2mn2","_id":"cku52dyns0031bbin6ygy55yz"},{"post_id":"cku52dymy001obbinchauftf3","tag_id":"cku52dync002bbbin1zqw5eom","_id":"cku52dynt0033bbinci8dc69e"},{"post_id":"cku52dymy001obbinchauftf3","tag_id":"cku52dym0000cbbin4jwb0rmi","_id":"cku52dynu0036bbin6d9u3ob1"},{"post_id":"cku52dyne002fbbin0dtsa54v","tag_id":"cku52dyli0003bbin628f2mn2","_id":"cku52dynv0038bbin5lhwf2fy"},{"post_id":"cku52dynf002ibbin13le2gxg","tag_id":"cku52dyli0003bbin628f2mn2","_id":"cku52dynw003bbbina5gwemet"},{"post_id":"cku52dymz001rbbin4dy7hnxr","tag_id":"cku52dync002bbbin1zqw5eom","_id":"cku52dynx003dbbin3hju6y9n"},{"post_id":"cku52dymz001rbbin4dy7hnxr","tag_id":"cku52dym0000cbbin4jwb0rmi","_id":"cku52dyny003gbbin6etf9hqo"},{"post_id":"cku52dyng002kbbin5ot7cm8m","tag_id":"cku52dyli0003bbin628f2mn2","_id":"cku52dyny003ibbin7i312e60"},{"post_id":"cku52dynh002nbbinevo17tyc","tag_id":"cku52dyli0003bbin628f2mn2","_id":"cku52dynz003lbbina60x5g5u"},{"post_id":"cku52dyn0001tbbinb5ygdqqw","tag_id":"cku52dync002bbbin1zqw5eom","_id":"cku52dyo0003nbbinh4utf6qe"},{"post_id":"cku52dyn0001tbbinb5ygdqqw","tag_id":"cku52dym0000cbbin4jwb0rmi","_id":"cku52dyo1003pbbin6xfgfpb4"},{"post_id":"cku52dyn2001wbbin7kpw3gq6","tag_id":"cku52dync002bbbin1zqw5eom","_id":"cku52dyo5003sbbin4vtddq4j"},{"post_id":"cku52dyn2001wbbin7kpw3gq6","tag_id":"cku52dyli0003bbin628f2mn2","_id":"cku52dyo6003ubbin0yy26bds"},{"post_id":"cku52dynq002xbbin1b2ob86i","tag_id":"cku52dyli0003bbin628f2mn2","_id":"cku52dyo7003xbbin1np6f5jh"},{"post_id":"cku52dyn2001ybbinecmo8zbi","tag_id":"cku52dync002bbbin1zqw5eom","_id":"cku52dyo8003zbbin7sf6df4q"},{"post_id":"cku52dyn2001ybbinecmo8zbi","tag_id":"cku52dym0000cbbin4jwb0rmi","_id":"cku52dyo90042bbin3ehb539z"},{"post_id":"cku52dyns0032bbinci9ba9fs","tag_id":"cku52dym0000cbbin4jwb0rmi","_id":"cku52dyoa0044bbin1yks6go7"},{"post_id":"cku52dyn60021bbin215i7cr9","tag_id":"cku52dync002bbbin1zqw5eom","_id":"cku52dyob0047bbinfp6whasm"},{"post_id":"cku52dyn60021bbin215i7cr9","tag_id":"cku52dym0000cbbin4jwb0rmi","_id":"cku52dyob0049bbina7201t2c"},{"post_id":"cku52dynt0034bbin0f32da75","tag_id":"cku52dym0000cbbin4jwb0rmi","_id":"cku52dyoc004cbbin3d0s6s5b"},{"post_id":"cku52dyn80023bbing3wp3z7r","tag_id":"cku52dync002bbbin1zqw5eom","_id":"cku52dyod004ebbin8vobewc7"},{"post_id":"cku52dyn80023bbing3wp3z7r","tag_id":"cku52dyli0003bbin628f2mn2","_id":"cku52dyoe004gbbin8f868vvg"},{"post_id":"cku52dynw003cbbin6lc8hzzu","tag_id":"cku52dyli0003bbin628f2mn2","_id":"cku52dyog004jbbin0cn9bae6"},{"post_id":"cku52dyna0025bbind91ka78h","tag_id":"cku52dync002bbbin1zqw5eom","_id":"cku52dyom004lbbinag10bcfe"},{"post_id":"cku52dyna0025bbind91ka78h","tag_id":"cku52dym0000cbbin4jwb0rmi","_id":"cku52dyor004obbin05qk303p"},{"post_id":"cku52dynx003ebbinab7l26eq","tag_id":"cku52dyli0003bbin628f2mn2","_id":"cku52dyou004qbbin1tnj5as6"},{"post_id":"cku52dyni002pbbin778pe3ev","tag_id":"cku52dym0000cbbin4jwb0rmi","_id":"cku52dyp9004tbbin3uzb2s1i"},{"post_id":"cku52dyni002pbbin778pe3ev","tag_id":"cku52dynx003fbbin9py0azld","_id":"cku52dypa004vbbin1avv5eql"},{"post_id":"cku52dynj002sbbin9xho56ph","tag_id":"cku52dyli0003bbin628f2mn2","_id":"cku52dypd004ybbin71ahh1jv"},{"post_id":"cku52dynj002sbbin9xho56ph","tag_id":"cku52dynz003kbbin5h19f9w2","_id":"cku52dypi0050bbin2jky5cv0"},{"post_id":"cku52dyno002ubbinhupu3bqp","tag_id":"cku52dyli0003bbin628f2mn2","_id":"cku52dypk0053bbincp876tvb"},{"post_id":"cku52dyno002ubbinhupu3bqp","tag_id":"cku52dynz003kbbin5h19f9w2","_id":"cku52dypl0055bbinai1g4vv4"},{"post_id":"cku52dynr002zbbindeylda27","tag_id":"cku52dyli0003bbin628f2mn2","_id":"cku52dypm0058bbindp50g9f8"},{"post_id":"cku52dynr002zbbindeylda27","tag_id":"cku52dyo7003wbbin38gx2ap4","_id":"cku52dypn005abbin2nnmbpxj"},{"post_id":"cku52dyob0048bbin4oo5eama","tag_id":"cku52dyli0003bbin628f2mn2","_id":"cku52dypn005dbbin1iup4ymh"},{"post_id":"cku52dyoc004abbin0ran30m8","tag_id":"cku52dyli0003bbin628f2mn2","_id":"cku52dypo005fbbin6i4vd7n4"},{"post_id":"cku52dyoc004abbin0ran30m8","tag_id":"cku52dyme000ybbin5rpu3uit","_id":"cku52dypp005hbbin3bp9e7n1"},{"post_id":"cku52dyod004fbbin00ny6yu6","tag_id":"cku52dyli0003bbin628f2mn2","_id":"cku52dypq005kbbingao89bku"},{"post_id":"cku52dynu0037bbinejvk3e4l","tag_id":"cku52dyli0003bbin628f2mn2","_id":"cku52dypq005mbbin0u0z43zu"},{"post_id":"cku52dynu0037bbinejvk3e4l","tag_id":"cku52dyo90041bbin1cwe311u","_id":"cku52dypr005pbbinhlj41758"},{"post_id":"cku52dynu0037bbinejvk3e4l","tag_id":"cku52dyob0046bbindp8i5e67","_id":"cku52dyps005rbbin4666ff6t"},{"post_id":"cku52dynu0037bbinejvk3e4l","tag_id":"cku52dyoc004bbbin5y014dae","_id":"cku52dyps005tbbin8mc76pik"},{"post_id":"cku52dyog004kbbin3pambq7m","tag_id":"cku52dyli0003bbin628f2mn2","_id":"cku52dyps005ubbin9j9rdzfp"},{"post_id":"cku52dynv0039bbin0w1qba0x","tag_id":"cku52dyli0003bbin628f2mn2","_id":"cku52dypu005wbbinedh199a2"},{"post_id":"cku52dynv0039bbin0w1qba0x","tag_id":"cku52dyog004ibbin2vfug77e","_id":"cku52dypu005xbbin6qz66zyp"},{"post_id":"cku52dyom004mbbin1o848hjm","tag_id":"cku52dyli0003bbin628f2mn2","_id":"cku52dypu005zbbinhdot9vlm"},{"post_id":"cku52dyos004pbbing5zz0sol","tag_id":"cku52dyli0003bbin628f2mn2","_id":"cku52dypu0060bbin9q9m0xzi"},{"post_id":"cku52dyny003hbbinhxwddl0m","tag_id":"cku52dyli0003bbin628f2mn2","_id":"cku52dypv0062bbin0vm03xmg"},{"post_id":"cku52dyny003hbbinhxwddl0m","tag_id":"cku52dyog004ibbin2vfug77e","_id":"cku52dypv0063bbin5e2ja6ta"},{"post_id":"cku52dyov004rbbinh9gp2nn7","tag_id":"cku52dyli0003bbin628f2mn2","_id":"cku52dypv0064bbin74rg8mty"},{"post_id":"cku52dyp9004ubbin6hpm7vkc","tag_id":"cku52dyli0003bbin628f2mn2","_id":"cku52dypw0066bbin5xlnfq66"},{"post_id":"cku52dyny003jbbin6woo3i8s","tag_id":"cku52dyli0003bbin628f2mn2","_id":"cku52dypw0067bbin3zo7dq0a"},{"post_id":"cku52dyny003jbbin6woo3i8s","tag_id":"cku52dyp8004sbbin536f3nhl","_id":"cku52dypw0069bbin5tazfe8u"},{"post_id":"cku52dypa004wbbin2q4r14y4","tag_id":"cku52dyli0003bbin628f2mn2","_id":"cku52dypx006abbin5gdhaa14"},{"post_id":"cku52dype004zbbin57mpesr9","tag_id":"cku52dyli0003bbin628f2mn2","_id":"cku52dypz006cbbineczohdlf"},{"post_id":"cku52dynz003mbbinebw2akjc","tag_id":"cku52dyli0003bbin628f2mn2","_id":"cku52dypz006dbbin21othzyz"},{"post_id":"cku52dynz003mbbinebw2akjc","tag_id":"cku52dyog004ibbin2vfug77e","_id":"cku52dyq1006fbbin7c35fi6j"},{"post_id":"cku52dyo0003obbin5xi5ed44","tag_id":"cku52dyli0003bbin628f2mn2","_id":"cku52dyq1006gbbin2ncehfvj"},{"post_id":"cku52dyo0003obbin5xi5ed44","tag_id":"cku52dyog004ibbin2vfug77e","_id":"cku52dyq2006ibbinbvj6bpjw"},{"post_id":"cku52dypl0056bbing4hg6av5","tag_id":"cku52dyli0003bbin628f2mn2","_id":"cku52dyq2006jbbin7tnrhgho"},{"post_id":"cku52dypn005bbbinfc25b2sh","tag_id":"cku52dyli0003bbin628f2mn2","_id":"cku52dyq2006lbbin8te03e6l"},{"post_id":"cku52dypo005ebbinahirbpp9","tag_id":"cku52dyli0003bbin628f2mn2","_id":"cku52dyq3006mbbindkdy5p71"},{"post_id":"cku52dyo1003qbbin24pf98nx","tag_id":"cku52dyli0003bbin628f2mn2","_id":"cku52dyq3006nbbin4j104fnb"},{"post_id":"cku52dyo1003qbbin24pf98nx","tag_id":"cku52dypm0057bbingfzrei5v","_id":"cku52dyq3006pbbinc5cv2chx"},{"post_id":"cku52dyo1003qbbin24pf98nx","tag_id":"cku52dypn005cbbin2mde1ltr","_id":"cku52dyq3006qbbinfp1l2u6y"},{"post_id":"cku52dyo5003tbbin1iq031tr","tag_id":"cku52dyli0003bbin628f2mn2","_id":"cku52dyq3006sbbine46l5n7h"},{"post_id":"cku52dyo5003tbbin1iq031tr","tag_id":"cku52dypp005jbbin1daxgj8j","_id":"cku52dyq3006tbbinbp6t9cko"},{"post_id":"cku52dypq005nbbin8gpbhlzd","tag_id":"cku52dyli0003bbin628f2mn2","_id":"cku52dyq4006vbbin66be48vx"},{"post_id":"cku52dyo6003vbbingebwduhn","tag_id":"cku52dym0000cbbin4jwb0rmi","_id":"cku52dyq4006wbbinb9rl5fez"},{"post_id":"cku52dyo6003vbbingebwduhn","tag_id":"cku52dypr005obbincaal4c0y","_id":"cku52dyq4006ybbinbri8cifz"},{"post_id":"cku52dyo6003vbbingebwduhn","tag_id":"cku52dyog004ibbin2vfug77e","_id":"cku52dyq4006zbbin1cld5t5n"},{"post_id":"cku52dyo7003ybbina83ufnaz","tag_id":"cku52dyli0003bbin628f2mn2","_id":"cku52dyq40070bbina2ixafg6"},{"post_id":"cku52dyo7003ybbina83ufnaz","tag_id":"cku52dypt005vbbin4m0v0hqp","_id":"cku52dyq50072bbin1l1s7qia"},{"post_id":"cku52dyo80040bbin90hl3fzu","tag_id":"cku52dyli0003bbin628f2mn2","_id":"cku52dyq50073bbin11vd7tl0"},{"post_id":"cku52dyo80040bbin90hl3fzu","tag_id":"cku52dypt005vbbin4m0v0hqp","_id":"cku52dyq50074bbinc1wo0xbg"},{"post_id":"cku52dyo90043bbindj6o87kh","tag_id":"cku52dyli0003bbin628f2mn2","_id":"cku52dyq50075bbindcf4bm5l"},{"post_id":"cku52dyo90043bbindj6o87kh","tag_id":"cku52dypv0061bbinf8w4hy3f","_id":"cku52dyq50076bbincjd2du5v"},{"post_id":"cku52dyoa0045bbindsum40go","tag_id":"cku52dyli0003bbin628f2mn2","_id":"cku52dyq50077bbin8two3q25"},{"post_id":"cku52dyoa0045bbindsum40go","tag_id":"cku52dypv0061bbinf8w4hy3f","_id":"cku52dyq50078bbinbpq36e7t"},{"post_id":"cku52dyoc004dbbin12ru4e1a","tag_id":"cku52dyli0003bbin628f2mn2","_id":"cku52dyq50079bbindar63zjr"},{"post_id":"cku52dyoc004dbbin12ru4e1a","tag_id":"cku52dypw0068bbin9jw98jma","_id":"cku52dyq5007abbin5eg65tgn"},{"post_id":"cku52dyoe004hbbin0f3t46pp","tag_id":"cku52dyli0003bbin628f2mn2","_id":"cku52dyq5007bbbin8mxw5drg"},{"post_id":"cku52dyoe004hbbin0f3t46pp","tag_id":"cku52dypw0068bbin9jw98jma","_id":"cku52dyq5007cbbin9bh2c2k4"},{"post_id":"cku52dypj0051bbin8j3a72t6","tag_id":"cku52dyli0003bbin628f2mn2","_id":"cku52dyq5007dbbinhcuvb915"},{"post_id":"cku52dypj0051bbin8j3a72t6","tag_id":"cku52dypz006ebbin480x34pv","_id":"cku52dyq5007ebbin276r2bep"},{"post_id":"cku52dypk0054bbinfzfja2te","tag_id":"cku52dyq1006hbbin1cc10wyy","_id":"cku52dyq5007fbbindjt51nij"},{"post_id":"cku52dypm0059bbinarolgi5e","tag_id":"cku52dyq2006kbbingqupfnk3","_id":"cku52dyq5007gbbin34v41clw"},{"post_id":"cku52dypm0059bbinarolgi5e","tag_id":"cku52dyli0003bbin628f2mn2","_id":"cku52dyq5007hbbin90d040ux"},{"post_id":"cku52dypo005gbbingtx80prm","tag_id":"cku52dyq3006obbindp3o64bv","_id":"cku52dyq5007ibbin8tq3fvjs"},{"post_id":"cku52dypp005ibbin89mwdoqj","tag_id":"cku52dyli0003bbin628f2mn2","_id":"cku52dyq6007jbbing30p6dls"},{"post_id":"cku52dypp005ibbin89mwdoqj","tag_id":"cku52dyog004ibbin2vfug77e","_id":"cku52dyq6007kbbin78w4elyf"},{"post_id":"cku52dypp005ibbin89mwdoqj","tag_id":"cku52dyq3006rbbin2k93e32j","_id":"cku52dyq6007lbbinf5838e6j"},{"post_id":"cku52dypp005ibbin89mwdoqj","tag_id":"cku52dyq3006ubbinb5n54p7l","_id":"cku52dyq6007mbbinfndo8ry0"},{"post_id":"cku52dypq005lbbinf2cs7jzh","tag_id":"cku52dyli0003bbin628f2mn2","_id":"cku52dyq6007nbbineqz0eytn"},{"post_id":"cku52dypq005lbbinf2cs7jzh","tag_id":"cku52dyq4006xbbin7v9a23i3","_id":"cku52dyq7007obbin0ud9gtob"},{"post_id":"cku52dypr005qbbingsvrcjyn","tag_id":"cku52dyli0003bbin628f2mn2","_id":"cku52dyq7007pbbin80wadm5a"},{"post_id":"cku52dypr005qbbingsvrcjyn","tag_id":"cku52dyq40071bbin720laucu","_id":"cku52dyq7007qbbinhs5jf7ij"},{"post_id":"cku52dypr005qbbingsvrcjyn","tag_id":"cku52dypm0057bbingfzrei5v","_id":"cku52dyq7007rbbinamfc0huf"},{"post_id":"cku52dyqh007tbbin8bzdagce","tag_id":"cku52dync002bbbin1zqw5eom","_id":"cku52dyqk007wbbin7looa1yr"},{"post_id":"cku52dyqh007tbbin8bzdagce","tag_id":"cku52dym0000cbbin4jwb0rmi","_id":"cku52dyqk007xbbin4xdtepeh"},{"post_id":"cku52dyqj007vbbinci10c030","tag_id":"cku52dym0000cbbin4jwb0rmi","_id":"cku52dyql007ybbinbaye1kmo"},{"post_id":"cku52dyqg007sbbin8sd8614f","tag_id":"cku52dyqj007ubbin5v8u6lpr","_id":"cku52dyql007zbbinfoh6gd6n"}],"Tag":[{"name":"原创","_id":"cku52dyli0003bbin628f2mn2"},{"name":"转载","_id":"cku52dym0000cbbin4jwb0rmi"},{"name":"大数据","_id":"cku52dym5000mbbincj6a4lqi"},{"name":"cdt","_id":"cku52dyma000rbbinh68g434s"},{"name":"Redis","_id":"cku52dyme000ybbin5rpu3uit"},{"name":"Docker","_id":"cku52dymh0015bbinad4r31xd"},{"name":"分布式事务","_id":"cku52dymz001pbbinbb8y1p18"},{"name":"电商","_id":"cku52dyn1001ubbin6adv3m7c"},{"name":"架构","_id":"cku52dyn3001zbbinbfq9eth8"},{"name":"https","_id":"cku52dyna0026bbin36627r8b"},{"name":"iOS","_id":"cku52dync002bbbin1zqw5eom"},{"name":"linux","_id":"cku52dynx003fbbin9py0azld"},{"name":"Maven","_id":"cku52dynz003kbbin5h19f9w2"},{"name":"rocketmq","_id":"cku52dyo7003wbbin38gx2ap4"},{"name":"分布式","_id":"cku52dyo90041bbin1cwe311u"},{"name":"多进程","_id":"cku52dyob0046bbindp8i5e67"},{"name":"并发","_id":"cku52dyoc004bbbin5y014dae"},{"name":"Nginx","_id":"cku52dyog004ibbin2vfug77e"},{"name":"nginx + obs","_id":"cku52dyp8004sbbin536f3nhl"},{"name":"spring","_id":"cku52dypm0057bbingfzrei5v"},{"name":"transaction","_id":"cku52dypn005cbbin2mde1ltr"},{"name":"操作系统","_id":"cku52dypp005jbbin1daxgj8j"},{"name":"php-fpm","_id":"cku52dypr005obbincaal4c0y"},{"name":"podman","_id":"cku52dypt005vbbin4m0v0hqp"},{"name":"Podman","_id":"cku52dypv0061bbinf8w4hy3f"},{"name":"shiro","_id":"cku52dypw0068bbin9jw98jma"},{"name":"springcloud","_id":"cku52dypz006ebbin480x34pv"},{"name":"随笔","_id":"cku52dyq1006hbbin1cc10wyy"},{"name":"Java","_id":"cku52dyq2006kbbingqupfnk3"},{"name":"笔记","_id":"cku52dyq3006obbindp3o64bv"},{"name":"tomcat","_id":"cku52dyq3006rbbin2k93e32j"},{"name":"redis","_id":"cku52dyq3006ubbinb5n54p7l"},{"name":"总结","_id":"cku52dyq4006xbbin7v9a23i3"},{"name":"Transaction","_id":"cku52dyq40071bbin720laucu"},{"name":"关键笔记","_id":"cku52dyqj007ubbin5v8u6lpr"}]}}